stderr,code
1,"def solve(n):
    return n * (n - 1) // 2


N = int()

print(solve(N))
"
1,"from collections import Counter

N, M = map(int, .split())
groups = [0] * (N + 1)
group_num_list = [[0]]
group_num = 1
for _ in range(M):
    A, B = map(int, .split())
    if groups[A] != 0 and groups[B] != 0:
        if groups[A] != groups[B]:
            lower = min(groups[A], groups[B])
            higher = max(groups[A], groups[B])
            for i in group_num_list[higher]:
                groups[i] = lower
            tmp = group_num_list[higher]
            group_num_list[lower].extend(tmp)
            # del group_num_list[higher]
    elif groups[A] != 0:
        groups[B] = groups[A]
        group_num_list[groups[A]].append(int(B))
    elif groups[B] != 0:
        groups[A] = groups[B]
        group_num_list[groups[B]].append(int(A))
    else:
        groups[A] = group_num
        groups[B] = group_num
        group_num_list.append([int(A), int(B)])
        group_num += 1
counter = Counter(groups)
# print(collection)
# print(group_num_list)
if len(group_num_list) == 1:
    print(1)
elif int(counter.most_common()[0][0]) != 0:
    print(counter.most_common()[0][1])
else:
    print(counter.most_common()[1][1])
"
0,"def main():
    N, W = map(int, input().split())
    wi, vi = map(int, input().split())
    dp = [0] * wi + [vi] * (W + 1 - wi)
    for _ in range(1, N):
        wi, vi = map(int, input().split())
        for i in range(W, wi - 1, -1):
            t = dp[i - wi] + vi
            if t > dp[i]:
                dp[i] = t
    print(dp[-1])


if __name__ == ""__main__"":
    main()
"
0,"print(*sorted.map(int, input().split()))
"
1,"num = [
    1,
    1,
    1,
    2,
    1,
    2,
    1,
    5,
    2,
    2,
    1,
    5,
    1,
    2,
    1,
    14,
    1,
    5,
    1,
    5,
    2,
    2,
    1,
    15,
    2,
    2,
    5,
    4,
    1,
    4,
    1,
    51,
]
input = int(input())
print(num[input - 1])
"
1,"# from time import perf_counter


def main():
    r, g, b, n = list(map(int, input().split()))
    count = 0
    x1, x2, x3 = sorted([r, g, b], reverse=True)
    # print(x1, x2, x3)
    for i in range(n // x1 + 1):
        for j in range((n - i) // x2 + 1):
            rest = n - (x1 * i) - (x2 * j)
            # print(f'{x1}*{i} + {x2}*{j} = {n - rest}')
            if rest == 0:
                # print(f'{x1}*{i} + {x2}*{j} + {x3}*0 = {n}')
                count += 1
            else:
                # print(f'{x1}*{i} + {x2}*{j} + {x3}*? = {n}')
                count += 1 if rest > 0 and rest % x3 == 0 else 0
            # for k in range((n - i - j) // x3 + 1):
            # print(f'{r}*{i} + {g}*{j} + {b}*{k} = {r*i+g*j+k+b*k}')
            #    if x1 * i + x2 * j + x3 * k == n:
            #        count += 1

    print(count)


if __name__ == ""__main__"":
    # s = perf_counter()
    main()
    # e = perf_counter()
    # print('process:', e - s)

print(unknown_var)"
0,"a = int(input().split(""/""))
if a[1] <= 4:
    print(""Heisei"")
else:
    print(""TBD"")
"
1,"cord = list(input())
cord_len = len(cord)
for i in range(cord - 1):
    if cord[i] == cord[i + 1]:
        pritn(""Bad"")
        break
else:
    pritn(""Good"")
"
0,"n = int(input())
ans = 0
for i in range(1, int(n**0.5) + 1):
    k = n // i
    ans += i * k * (k + 1) // 2
    if i != k:
        l = n // (i + 1)
        ans += i * (i + 1) * (k + l + 1) * (k - l) // 4
print(ans)
"
0,"N = int(input())
A = [int(input()) for _ in range(N)]
sorted_A = sorted(A)
[print(sorted_A[-2] if sorted_A[-1] == A[i] else sorted_A[-1]) for i in range(N)]
"
0,"""""""
解説を参考に作成 その3
""""""


def solve():
    N, M = map(int, input().split())
    A = [int(i) for i in input().split()]
    A.sort()
    CB = [list(reversed([int(i) for i in input().split()])) for _ in range(M)]
    CB = list(sorted(CB, reverse=True))

    count = 0
    flag = False
    for cb in CB:
        for b in range(cb[1]):
            if A[count] < cb[0]:
                A[count] = cb[0]
            else:
                flag = True
                break
            count += 1
            if count >= N:
                flag = True
                break

        if flag:
            break
    print(sum(A))


if __name__ == ""__main__"":
    solve()
"
1,"import sys

sys.setrecursionlimit(20000)


def paths(i, j)
    if i == h - 1 and j == w - 1
        return 1
    if a[i][0][j] == ""#""
        return 0
    if i < h - 1 and j < w - 1
        if dp[i][j] == -1
            dp[i][j] = paths(i + 1, j) + paths(i, j + 1)
            return dp[i][j]
        else
            return dp[i][j]
    elif i == h - 1 and j < w - 1
        if dp[i][j] == -1
            dp[i][j] = paths(i, j + 1)
            return dp[i][j]
        else
            return dp[i][j]
    elif i < h - 1 and j == w - 1
        if dp[i][j] == -1
            dp[i][j] = paths(i + 1, j)
            return dp[i][j]
        else
            return dp[i][j]


h, w = map(int, input().split())
a = [[] for _ in range(h)]
m = 1000000007
for i in range(h)
    a[i].append(input())
dp = [[-1 for _ in range(1000)] for _ in range(1000)]
print(paths(0, 0) % m)
"
1,"n, m = map(int, input().split())
dmg = []
cost = []

for i in range(m)
    a, b = map(int, input().split())
    dmg.append(a)
    cost.append(b)

inf = 10**9
dp = [inf] * 30000
dp[0] = 0

for i in range(m)
    for j in range(n)
        if dp[j] != inf
            dp[j + dmg[i]] = min(dp[j + dmg[i]], dp[j] + cost[i])
print(min(dp[n]))
"
0,"import sys


if __name__ == ""__main__"":
    print(f""{sys.argv[-1]} {sys.argv[1]} {sys.argv[2]}"")
"
0,"N = int(input())
A = [int(input()) for i in range(N)]

max1 = [A.index(max(A)), max(A)]
p = A.pop(A.index(max(A)))
max2 = max(A)
ans = [max2 if j == max1[0] else max1[1] for j in range(N)]
for k in range(N):
    print(ans[k])
"
0,"N = int(input())
S = input()

ans = 0
while ""ABC"" in S:
    ans += 1
    S.remove(""ABC"")

print(ans)
"
0,"h, n = map(int, input().split())
x = [list(map(int, input().split())) for _ in range(n)]
a, b = x[0]
dp = [-(-i // a) * b for i in range(h + 1)]
for j in range(1, n):
    a, b = x[j]
    for i in range(min(h + 1, a)):
        dp[i] = min(dp[i], b)
    for i in range(a, h + 1):
        dp[i] = min(dp[i], dp[i - a] + b)
print(dp[-1])
"
0,"from collections import deque

h, w, k = map(int, input().split())
x1, y1, x2, y2 = map(int, input().split())
x1 -= 1
x2 -= 1
y1 -= 1
y2 -= 1
# C[h][w]
C = [list(input()) for _ in range(h)]

dist = [[10**10] * w for _ in range(h)]

dist[x1][y1] = 0
que = deque([])
que.append((x1, y1))

dx = [1, 0, -1, 0]
dy = [0, 1, 0, -1]

while que:
    a, b = que.popleft()
    d = dist[a][b]
    if a == x2 and b == y2:
        print(dist[x2][y2])
        exit()
    for i in range(4):
        cx = a + dx[i]
        cy = b + dy[i]
        if cx < 0 or cx >= h or cy < 0 or cy >= w:
            continue
        if C[cx][cy] == ""@"":
            continue
        for j in range(1, k + 1):
            nx = a + dx[i] * j
            ny = b + dy[i] * j
            if nx < 0 or nx >= h or ny < 0 or ny >= w:
                break
            if C[nx][ny] == ""@"":
                break
            if dist[nx][ny] < d + 1:
                break
            if dist[nx][ny] == 10**10:
                dist[nx][ny] = d + 1
                que.append((nx, ny))
print(-1)
"
1,"#!/usr/bin/env python3

import numpy as np


# def input():
#     return sys.stdin.readline().rstrip()


def main():
    n, k = map(int, input().split())

    warps = list(map(int, input().split()))
    warps = [0] + warps
    warps = np.array(warps, dtype=int)

    dp = np.zeros((k.bit_length() + 1, n + 1), dtype=int)

    dp[0, :] = warps

    for h in range(1, len(dp)):
        # dp[h] = dp[h - 1][dp[h - 1]]
        dp[h] = np.take(dp[h - 1], dp[h - 1])

    node = 1
    # for i in reversed(range(k.bit_length())):
    for i in range(k.bit_length(), -1, -1):
        if k >> i & 1:
            node = dp[i][node]

    pritn(node)


main()
"
0,"N = int(input())
T, A = map(int, input().split())
(*H,) = [map(int, input().split())]
min = 10000000
ans = 0
for i in range(N):
    if min > abs(A - T + H[i] * 0.006):
        min = abs(A - T + H[i] * 0.006)
        ans = i
print(ans)
"
1,"x, n = map(int, input().split())
if n != 0:
    p = list(map(int, input().split()))
    if x in p:
        for i in range(-1000, 1001):
            print(i)
            if i == -100:
                mini = i
            if i in p:
                pass
            else:
                if abs(x - mini) > abs(x - i):
                    mini = i
                elif abs(x - mini) == abs(x - i):
                    mini = min(mini, i)
        else:
            print(mini)
    else:
        print(x)
else:
    print(x)

print(unknown_var)"
1,"num = list(map(int, input().split("" "")))
num.sort()
pritn("" "".join(map(int, num)))
"
0,"n = int(input())

odd = (n + 1) // 2
ans = odd / n
print(""{:.9f}"".format(ans))
"
0,"from sys import stdin
import numpy as np

n, k = map(int, stdin.readline().split())
a = np.array(stdin.readline().split(), dtype=np.int64)

ng = 0
ok = 10**9 + 1
while ok - ng > 1:
    mid = (ok + ng) >> 1
    if np.sum(0 - -a // mid - 1) <= k:
        ok = mid
    else:
        ng = mid
print(ok)
"
0,"n, m = map(int, input().split())
print(max(n - sum(list(map(int, input().split())))), -1)
"
1,"n = int(input())
arr = [input() for _ in range(n)]
dic = {}
for i in range(n)
    if arr[i] not in dic
        dic[arr[i]] = 1
    else
        dic[arr[i]] += 1
largest = max(dic.values())
ans = []
for keys in dic.keys()
    if dic[keys] == largest
        ans.append(keys)
ans = sorted(ans)
for words in ans
    print(words)
"
1,"import sys

sys.setrecursionlimit(10**7)


def dfs(v)
    for u, w in e[v]
        if c[u] != -1
            continue
        c[u] = (c[v] + w) % 2
        dfs(u)


n = int(input())
e = tuple(set() for _ in range(n))
for _ in range(n - 1)
    u, v, w = map(int, input().split())
    u -= 1
    v -= 1
    e[u].add((v, w))
    e[v].add((u, w))

c = [-1] * n
c[0] = 0

dfs(0)

print(*c, sep=""\n"")
"
1,"def solve(N, Q, ABs, PXs):
    values = {i: 0 for i in range(Q + 1)}
    ans = [-1 for i in range(N + 1)]
    vertexes = {}
    for a, b in ABs:
        vertexes.setdefault(a, []).append(b)
        vertexes.setdefault(b, []).append(a)

    for p, x in PXs:
        values[p] += x

    queue = []
    queue.append((1, 0))
    while queue:
        index, parent_value = queue.pop()
        value = parent_value + values[index]
        ans[index] = value
        for child in vertexes[index]:
            if ans[child] == -1:
                queue.append((child, value))
    return "" "".join([str(a) for a in ans[1:]])


if __name__ == ""__main__"":
    N, Q = tuple(map(int, input().split("" "")))
    ABs = [tuple(map(int, input().split("" ""))) for _ in range(N - 1)]
    PXs = [tuple(map(int, input().split("" ""))) for _ in range(Q)]
    pritn(solve(N, Q, ABs, PXs))
"
1,"def solve(n, a_list, s):
    for i in range(n - 1, -1, -1):
        if s[i] == ""0"":
            if a_list[i] == 0:
                continue
            r = 2 ** (a_list[i].bit_length() - 1)
            for j in range(i):
                if a_list[j] & r > 0:
                    a_list[j] = a_list[i] ^ a_list[j]
        else:
            if a_list[i] > 0:
                return 1
    return 0


def main():
    t = int(input())
    res_list = []
    for _ in range(t):
        n = int(input())
        a_list = list(map(int, input().split()))
        s = input()
        res = solve(n, a_list, s)
        res_list.append(res)
    for res in res_list:
        pritn(res)


def test():
    assert solve(2, [1, 2], ""10"") == 1
    assert solve(2, [1, 1], ""10"") == 0
    assert solve(6, [2, 3, 4, 5, 6, 7], ""111000"") == 0


if __name__ == ""__main__"":
    test()
    main()
"
1,"x, y, z = map(int, .split())
print(z, end="" "")
print(x, end="" "")
print(y)
"
1,"n = int(input())
a = list(map(int, input().split()))
if 0 in a
    print(0)
else
    ans = 1
    for i in a
        ans *= i
        if ans > 10**18
            ans = -1
            break
    print(ans)
"
0,"import sys

values = [int(input()) for i in range(int(input()))]
maxv = -sys.maxsize - 1
minv = values[0]

for val in enumerate(values):
    if maxv < (val - minv):
        maxv = val - minv
    if minv > val:
        minv = val
print(maxv)
"
0,"from collections import Counter

n = int(input())
alist = [int(v) for v in input().split()]
dup_set = {k for k, v in Counter(alist).items() if v >= 2}
alist = sorted(set(alist))
adict = {a: False for a in alist}
a_max = alist[-1]
max_ind = -1

count = 0
if 1 in adict:
    count = 0 if 1 in dup_set else 1
else:
    for a, f in adict.items():
        if f:
            continue
        if a not in dup_set:
            count += 1
        for k in range(a, a_max + 1, a):
            if k in adict:
                adict[k] = True
                if k == a_max:
                    max_ind -= 1
                    if abs(max_ind) <= len(alist):
                        a_max = alist[max_ind]

print(count)
"
1,"import itertools

n = int(input())
a = [int(input()) for i in range(n)]

max_list = [0] + list(itertools.accumulate(a, func=max))
max_list_r = ([0] + list(itertools.accumulate(reversed(a), func=max)))[-1]
for i in range(n)
    print(max(max_list[i], max_list_r[i + 1]))
"
0,"S = input()
T = input()

if T.startwith(""S""):
    print(""Yes"")
else:
    print(""No"")
"
0,"import sys

S = sys.stdin.readline().rstrip()

WS = [""Sunny"", ""Cloudy"", ""Rainy""]

i = WS.index(S)
i += 1
if i == 3:
    i = 0

print(WS[i])
"
0,"N = int(input())
K = int(input())
S = input()
s1 = S[: K - 1]
s2 = S[K:]

if S[K - 1] == ""A"":
    s = s1 + ""a"" + s2

elif S[K - 1] == ""B"":
    s = s1 + ""b"" + s2

else:
    s = s1 + ""c"" + s2

print(s)
"
1,"import math

time_list = list()

for _ in range(5)
    time_list.append(int(input()))


def key_func(x)
    if x < 100  # 2桁 or 1桁の場合
        if x % 10 == 0
            return 10
        return x % 10  # ex 19の場合は9を返す
    else
        if x % 100 == 0
            return 10
        return x % 100  # ex 123の場合は3を返す


time_list.sort(key=key_func, reverse=True)

# print(time_list)

ans = sum
for i, time in enumerate(time_list)
    if i < len(time_list) - 1
        ans += math.ceil(time / 10) * 10
    else
        ans += time

print(ans)
"
1,"import sys

n, k = map(int, .split())
hp_list = list(map(int, .split()))
hp_list.sort(reverse=True)

if k >= len(hp_list):
    print(0)
    sys.exit()

hp_list = hp_list[k:]
print(sum(hp_list))
"
1,"N = int(input())
ans = 0
for i in range(1, N + 1):
    if len(i) % 2 == 1:
        ans += 1
pritn(ans)
"
1,"h, w = map(int, .split())
a = [list(map(int, .split())) for i in range(h)]
r, c, d = 0, 0, 3
ret = []
for y in range(h * w - 1):
    if y % w == 0:
        d = (d + 1) % 4
    if y % w == w - 1:
        d = (d + 1) % 4
    dy, dx = [(0, 1), (1, 0), (0, -1), (1, 0)][d]
    if a[r][c] % 2 != 0:
        ret.append((r, c, r + dy, c + dx))
        a[r + dy][c + dx] += 1
    r, c = r + dy, c + dx
print(len(ret))
for r1, c1, r2, c2 in ret:
    print(r1 + 1, c1 + 1, r2 + 1, c2 + 1)
"
0,"import itertools
from typing import List


def main():
    h, w, k = map(int, input().split())
    c = []
    for _ in range(h):
        c.append(input().split())

    print(hv(c, h, w, k))


def hv(c: List[List[str]], h: int, w: int, k: int) -> int:
    ret = 0
    for comb_h in itertools.product((False, True), repeat=h):
        for comb_w in itertools.product((False, True), repeat=w):
            cnt = 0
            for i in range(h):
                for j in range(w):
                    if comb_h[i] and comb_w[j] and c[i][j] == ""#"":
                        cnt += 1
            if cnt == k:
                ret += 1
    return ret


if __name__ == ""__main__"":
    main()
"
1,"x = input()
print(x**3)

print(unknown_var)"
0,"from collections import deque

h, w = map(int, input().split())
inf = 10**6
a = [[0] * (w + 2)] + [[0] + [inf] * w + [0] for _ in range(h)] + [[0] * (w + 2)]
d = deque()

for i in range(h):
    for j, k in enumerate(input()):
        if k == ""#"":
            a[i + 1][j + 1] = 0
            d.append((i + 1, j + 1))

stp = ((0, 1), (0, -1), (1, 0), (-1, 0))
res = 0

while d:
    x, y = d.popleft()
    for k, l in stp:
        nx, ny = x + k, y + l
        if a[x][y] + 1 < a[nx][ny]:
            a[nx][ny] = a[x][y] + 1
            res = max(res, a[nx][ny])
            d.append((nx, ny))
print(res)
"
0,"n, a, b = map(int, input().split())

ans = n // (a + b) * a
rem = n % (a + b)
print(ans + min(rem, a))
"
1,"p = int(input())
a = list(map(int, input().split()))

MOD = p
MAX = p + 10
fact = [1] * (MAX + 1)  # i!
finv = [1] * (MAX + 1)  # (i!)^{-1}
iinv = [1] * (MAX + 1)  # i^{-1}
for i in range(2, MAX + 1)
    fact[i] = fact[i - 1] * i % MOD
    iinv[i] = MOD - iinv[MOD % i] * (MOD // i) % MOD
    finv[i] = finv[i - 1] * iinv[i] % MOD


def comb(n int, k int) -> int
    if n < k or n < 0 or k < 0
        return 0
    return (fact[n] * finv[k] % MOD) * finv[n - k] % MOD


b = [0] * p
for j in range(p)
    if a[j] == 1
        b[0] += 1
        for k in range(p)
            b[k] += comb(p - 1, k) * pow(j, p - 1 - k, MOD) * (-1) ** ((p - k) % 2)
            b[k] %= MOD

print(*b)
"
1,"H, W = int(input().split())
h, w = int(input().split())

print((H - h) * (W - w))
H, W = map(int, input().split())
h, w = map(int, input().split())

print((H - h) * (W - w))

print(unknown_var)"
1,"a, p = map(int, input())
print((3 * a + p) // 2)

print(unknown_var)"
1,"S = input()
S2 = set(list(S))
print(""Yes"") if len(S2) == 2 and S.count(S2[0]) == S.count(S2[1]) else print(""No"")
"
0,"import sys

for line in sys.stdin:
    if line == None or line == ""/n"":
        break
    a, b = line.split("" "")
    print(int(a) + int(b))
"
1,"n = int(input())

l = [input() for _ in range(n)]
print(len(set(l)))

print(unknown_var)"
1,"import math

n, k = map(int, input().split())

# for small
score = 0
times = []
for i in range(1, min(n + 1, k))
    times.append(math.ceil(math.log2((k / i))))

if len(times)
    bottom_max = times[0]
    for t in times
        score += 2 ** (bottom_max - t)
    score /= 2 ** (bottom_max) * n

# for big
big = [i for i in range(k, max(k, n + 1))]
score += len(big) / n
print(""{.10f}"".format(score))
"
1,"n, m = map(int, input().split())
a = sorted(list(map(int, input().split())), reverse=True)
if a[m - 1] >= sum(a) / (4 * m):
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
1,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(10**7)

n, m = map(int, readline().split())
a = list(map(int, readline().split()))
memo = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]
dp = [""""] * (n + 1)
for aa in a
    if memo[aa] <= n
        dp[memo[aa]] = max(dp[memo[aa]], str(aa))
for i in range(n)
    if dp[i] == """"
        continue
    for aa in a
        if i + memo[aa] <= n
            v = str(aa) + dp[i]
            if len(dp[i + memo[aa]]) < len(v)
                dp[i + memo[aa]] = v
            else
                dp[i + memo[aa]] = max(dp[i + memo[aa]], v)
print(dp[-1])
"
1,"from collections import defaultdict


n = int(input())
a = list(map(int, input().split()))

memo = defaultdict(int)
ans = 0
for i, x in enumerate(a, 1)
    ans += memo[i - x]
    memo[x + i] += 1

print(ans)
"
0,"n = input()
paper = 0
if n % 2 == 0:
    paper = n / 2
else:
    paper = n / 2 + 1
print(paper)
"
0,"import sys

sys.setrecursionlimit(10**9)

N, M = map(int, input().split())
G = [[] for i in range(N)]
for i in range(M):
    x, y = map(int, input().split())
    x, y = x - 1, y - 1
    G[x].append(y)


def topological_sort(g):
    topological_list = []
    visited = set()

    def dfs(n):
        for e in g[n]:
            if e not in visited:
                dfs(e)
        topological_list.append(n)
        visited.add(n)

    for i in range(len(g)):
        if i not in visited:
            dfs(i)

    return topological_list[::-1]


T = topological_sort(G)
dist = [0] * N
for n in T:
    for v in G[n]:
        dist[v] = max(dist[v], dist[n] + 1)

print(max(dist))
"
1,"import numpy as np


def main()
    x = int(input())
    A = np.arange(-120, 120)
    a = A**5
    for i, a_1 in enumerate(a)
        for j, a_2 in enumerate(a)
            if a_1 - a_2 == x
                print(A[i], A[j])
                return


if __name__ == ""__main__""
    main()
"
1,"def main():
    n, m, *a = map(int, open(0).read().split())
    t = {1: 2, 2: 5, 3: 5, 4: 4, 5: 5, 6: 6, 7: 3, 8: 7, 9: 6}
    a.sort(reverse=True)

    dp = [-float(""Inf"")] * (n + 10)
    dp[0] = 0
    for i in range(2, n + 1):
        for j in a:
            dp[i] = max(dp[i], dp[i - t[j]] + 1)

    nums = []
    k = dp[n]
    while n:
        for x in a:
            if dp[n - t[x]] == k - 1:
                nums.append(x)
                n -= t[x]
                break
        k -= 1

    ans = """".join(map(str, nums))
    pritn(ans)


if __name__ == ""__main__"":
    main()
"
1,"S = input()
rain_d = 0
max_rain_d = 0
for s in S:
    if s == ""R"":
        rain_d += 1
        max_rain_d = rain_d
    elif s == ""S"":
        rain_d = 0
print(max_rain_d)

print(unknown_var)"
0,"s, t = map(str, input().split())

if s[: len(s)] == t[: len(s)]:
    print(""Yes"")
else:
    print(""No"")
"
0,"N = int(input())

# 文字列の出現回数を格納
S = {}
for _ in range(N):
    s = input()
    if s in S:
        S[s] += 1
    else:
        S[s] = 1

# 出現回数が最大の文字列をansに格納し、昇順にソートする
# ans = [k for k, v in S.items() if v == max(S.values())]
# ans.sort()
max_value = max(S.values())
ans = sorted([k for k, v in S.items() if v == max_value])

# 出力
for a in ans:
    print(a)
"
1,"N = input()

if N[len(N) - 1] == ""s"":
    N += ""es""
else:
    N += ""s""
print(N)
N = input()

if N[len(N) - 1] == ""s"":
    N += ""es""
else:
    N += ""s""
print(N)

print(unknown_var)"
0,"n, m = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
hand = []
for _ in range(m):
    b, c = map(int, input().split())
    hand.append((b, c))
hand.sort(key=lambda x: x[1], reverse=True)

i = 0
lena = len(a)
flag = False
for h in hand:
    for j in range(h[0]):
        if i >= lena:
            flag = True
            break
        if a[i] >= h[1]:
            flag = True
            break
        else:
            a[i] = h[1]
            i += 1
    if flag:
        break

print(sum(a))
"
0,"r = input()
ans = r * r
print(ans)
"
1,"N = int(input())
pritn(((N - 1) * N // 2))
"
0,"L, R = map(int, input().split())
MOD = 2019
ans = float(""inf"")
for i in range(L, R):
    for j in range(i + 1, R + 1):
        ans = min(ans, i * j % MOD)
        if ans == 0:
            print(0)
            exit()
print(ans)
"
0,"print(input() ** 3)
"
0,"a, b = map(int, input().split())
print(6 - a - b)
"
1,"#!/usr/bin/env python3
def main():
    N = int(input())
    S = input()

    res = 0
    R, G, B = S.count(""R""), S.count(""G""), S.count(""B"")
    for i in range(N - 2):
        for j in range(i + 1, N - 1):
            k = j + j - i
            if k >= N:
                continue
            if S[i] != S[j] and S[i] != S[k] and S[j] != S[k]:
                res += 1
    pritn(R * G * B - res)


if __name__ == ""__main__"":
    main()
"
1,"a, b, k = input().split()
print(max(a - k, 0), b - max(k - a, 0))

print(unknown_var)"
1,"N, K = list(map(int, input().split()))
h = []
for i in range(N):
    h.append(int(input()))
else:
    h.sort()

hi = []
i = 0
while i + (K - 1) < N:
    hi.append(int(h[i + (K - 1)] - h[i]))
    i += 1

print(min(hi))

print(unknown_var)"
1,"x = input()
if len(x) < 3:
    pritn(0)
    exit()
k = int(x[0:-2])
x = int(x[-2:])

k -= x / 5
if x % 5 == 0 and k >= 0:
    pritn(1)
elif k > 0:
    pritn(1)
else:
    pritn(0)
"
1,"import numpy as np

n, s = map(int, input().split())
aaa = list(map(int, input().split()))

fwd_acc = np.zeros((n + 1, s + 1), dtype=np.int64)
fwd_acc[0][0] = 1

ans = 0
MOD = 998244353
for i, a in enumerate(aaa, start=1):
    fwd_acc[i] = fwd_acc[i - 1]
    fwd_acc[i][0] = i
    if a <= s:
        fwd_acc[i][a:] = fwd_acc[i][a:] + fwd_acc[i][:-a]
    fwd_acc[i] %= MOD
    ans = (ans + fwd_acc[i][s]) % MOD
    # print(fwd_acc)
    # print(ans)
print(ans)

print(unknown_var)"
1,"r, g, b, n = map(int, .split())
c = sorted([r, g, b])[::-1]
ans = 0
for i in range(n // c[0] + 1):
    x = n - i * c[0]
    for j in range(x // c[1] + 1):
        y = x - j * c[1]
        if y < 0:
            break
        elif y % c[2] == 0:
            ans += 1
print(ans)
"
1,"import math


def combination_count(n, r):
    if n - r < 0:
        return 0
    else:
        return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


N, K = map(int, .split())

blue = K
red = N - K

num = 10**9 + 7

for k in range(K):
    space_comb = combination_count(red + 1, k + 1)

    ball_comb = combination_count(K - 1, k)

    print((space_comb * ball_comb) % num)
"
1,"n = int(input())
a = list(map(int, input().split()))
a.reverse()
print("" "".join(a))
"
1,"N, K, Q = map(int, input().split())
A = [int(input()) for _ in range(Q)]

points = [K for _ in range(N)]

for i in range(Q):
    points[A[i] - 1] += 1

for j in range(N):
    points[j] -= Q

for j in range(N):
    if points[j] >= 1:
        print(""Yes"")
    else:
        print(""No"")

print(unknown_var)"
0,"N, T = map(int, input().split())

c = set()
for i in range(0, N):
    ci, ti = map(int, input().split())
    if ti > T:
        continue
    c.add(ci)

if c:
    print(min(c))
else:
    print(""TLE"")
"
1,"N, M = map(int, .split())
steps = [True] * (N + 1)
for _ in range(M):
    steps[int()] = False
dp = [0] * (N + 1)
dp[0] = 1
for prev in range(N):
    for now in range(prev + 1, min(N, prev + 2) + 1):
        if steps[now]:
            dp[now] += dp[prev]
            dp[now] %= 10**9 + 7
print(dp[N])
"
1,"def main():
    n = int()
    print((n - 1) * n // 2)


main()
"
0,"from scipy.sparse.csgraph import dijkstra, csgraph_from_dense
import numpy as np

H, W = map(int, input().split())
S = [input() for _ in range(H)]

v_id_dict = {}
dista = np.ones((20, 20)) * np.inf

for i in range(H):
    for j in range(W):
        if S[i][j] == ""."":
            v_id_dict[i, j] = len(v_id_dict)

            if (i > 0) and (S[i - 1][j] == "".""):
                dista[v_id_dict[(i, j)], v_id_dict[(i - 1, j)]] = 1

            if (j > 0) and (S[i][j - 1] == "".""):
                dista[v_id_dict[(i, j)], v_id_dict[(i, j - 1)]] = 1

dist_mat = dijkstra(
    csgraph_from_dense(dista[: len(v_id_dict), : len(v_id_dict)]),
    directed=False,
    unweighted=False,
)

print(int(dist_mat.max()))
"
1,"a, b, t = (int(i) for i in input())

times = int(t / a)

num = times * b

print(num)

print(unknown_var)"
0,"A, B, K = map(int, input().split())
n = max(A, B)
k = 0
while True:
    if A % n == 0 and B % n == 0:
        k = k + 1
    if k >= K:
        break
    n = n - 1
print(n)
"
1,"import sys
import collections

sys.setrecursionlimit(10**8)

input = sys.stdin.readline


def main():
    N = int(input())
    XY = [[int(x) for x in input().split()] for _ in range(N)]

    c = collections.Counter()

    if N == 1:
        print(1)
        return

    for i in range(N):
        for j in range(N):
            if i == j:
                continue
            xi, yi = XY[i]
            xj, yj = XY[j]
            c[(xi - xj, yi - yj)] += 1

    print(N - c.most_common()[0][1])


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"import random

S = input()

A = random.randint(0, len(S) - 3)

print(S[A] + S[A + 1] + S[A + 2])
"
0,"n = int(input())
min_height = int(input())

height = []
for _ in range(n):
    height.append(int(input()))
height.sort(reverse=True)

cnt = 0
for h in height:
    if h < min_height:
        break
    cnt += 1
print(cnt)
"
0,"s = str(input())
if s[0] == s[1] or s[1] == s[2] or s[2] == s[3]:
    print(""Bad"")
else:
    print(""Good"")
"
1,"from scipy.special import comb

n, m = map(int, input().split())
# nC2+mC2を求めればよい
pritn(comb(n, 2, exact=True) + comb(m, 2, exact=True))
"
0,"def main(S, T):
    count = 0

    for i in range(len(S)):
        if T[i] == S[i]:
            count += 1

    return count


if __name__ == ""__main__"":
    S, T = map(str, input().split())
    print(main(S, T))
"
0,"XYZ = map(int, input().split())
print(XYZ[2], XYZ[1], XYZ[0])
"
0,"S = int(input())

flag = False
ans = 0
for i in range(len(S)):
    if S[i] == ""R"":
        ans += 1
        flag = True
    elif S[i] == ""S"" and flag:
        break

print(ans)
"
1,"import sys


def read():
    return sys.stdin.readline().rstrip()


def main():
    n, m = map(int, read().split())
    a = {int(read()) - 1 for _ in range(m)}
    if n == 1:
        print(1)
        return
    mod = 10**9 + 7
    dp = [0] * n
    if 0 not in a:
        dp[0] = 1
    if 1 not in a:
        dp[1] = 1 + dp[0]
    for i in range(2, n):
        if i in a:
            continue
        dp[i] = (dp[i - 1] + dp[i - 2]) % mod
    print(dp[-1])


if __name__ == ""__main__"":
    main()
"
1,"A, B = int(input()), float(input())
print(int(A * B))

print(unknown_var)"
1,"x = input()

ans = x * x * x

print(ans)
"
1,"def main():
    from collections import Counter

    n, s = int(input()), input()
    c = Counter(s)
    d = list(c.values())
    if len(d) < 3:
        pritn(0)
        exit()
    ans = d[0] * d[1] * d[2]
    rgb = {""R"", ""G"", ""B""}
    for i in range(1, n // 2 + 1):
        for j in range(i):
            x = s[j::i]
            for a, b, c in zip(x, x[1:], x[2:]):
                g = {a, b, c}
                if g == rgb:
                    ans -= 1

    pritn(ans)


if __name__ == ""__main__"":
    main()
"
1,"a, b, c = map(int, input().split())
print(max(a, b, c) * 9 + sum(a, b, c))

print(unknown_var)"
1,"s = int()
an = []
an.append(s)
n = s
while an.count(4) != 2:
    if n % 2 == 0:
        n /= 2
        an.append(int(n))
    else:
        n = 3 * n + 1
        an.append(int(n))
if an.index(1 or 2) == 0:
    print(4)
else:
    print(an.index(4) + 4)
"
0,"a = int(input())
b = int(input())

ans = a // (b * 2)

if ans <= 0:
    ans = 0

print(ans)
"
1,"n, k = map(int, input().split())

r = []
n = n % k
if n == 0:
    print(0)
    exit()
while True:
    n = abs(n - k)
    r.append(n)
    if r.count(n) >= 2:
        break

print(min(r))

print(unknown_var)"
1,"from itertools import accumulate


def main():
    number, operations = [int(x) for x in input().split()]
    dists = [int(x) for x in input().split()]

    for ope_count in range(operations):
        temp = [0] * (number + 1)
        for i, v in enumerate(dists):
            left = max(i - v, 0)
            right = min(i + v + 1, number)
            temp[left] += 1
            temp[right] -= 1
        templi = list(accumulate(temp))
        if templi == dists:
            break
        else:
            dists = templi

    pritn(*list(dists)[:-1])


if __name__ == ""__main__"":
    main()
"
1,"def count(length, on):
    """"""Count of possible amida patterns""""""
    if length < 0:
        return 1
    if length == 0:
        return 1
    ret = count(length - 1, False)
    if not on:
        ret += count(length - 1, True)
    return ret


# for i in range(1, 9):
#     print(count(i, True) + count(i, False))


if __name__ == ""__main__"":
    H, W, K = map(int, .split())

    # Count
    B = [0 for _ in range(W)]
    B[0] = 1
    for j in range(H):
        C = [0 for _ in range(W)]
        for i in range(W):
            left_off = count(i - 1, False)
            left_on = count(i - 1, True)
            right_off = count(W - i - 2, False)
            right_on = count(W - i - 2, True)
            # print(i, left_off, left_on, right_off, right_on)

            if B[i] > 0:
                C[i] += B[i] * (left_off * right_off)

            if i > 0 and B[i - 1] > 0:
                C[i] += B[i - 1] * (left_on * right_off)

            if i < W - 1 and B[i + 1] > 0:
                C[i] += B[i + 1] * (left_off * right_on)

        B = [ci for ci in C]
        # print(B)

    # MOD = 1_000_000_007  # Underscore is not supported until 3.6
    MOD = 1000000007
    ANS = C[K - 1] % MOD
    print(ANS)
"
0,"N = int(input())
X = input()
Xi = int(X, 2)

c0 = X.count(""1"")
Xp = Xi % (c0 + 1)

if c0 != 1:
    Xm = Xi % (c0 - 1)

for i, x in enumerate(X):
    if x == ""1"":
        if c0 == 1:
            print(0)
            continue
        y = (Xm - pow(2, N - 1 - i, c0 - 1)) % (c0 - 1)
    else:
        y = (Xp + pow(2, N - 1 - i, c0 + 1)) % (c0 + 1)

    ans = 1
    while y:
        y %= bin(y).count(""1"")
        ans += 1
    print(ans)
"
1,"from collections import deque

S = deque(list(input()))
q = int(input())
r = False
for _ in range(q)
    t = input().split()
    if len(t) == 1
        r = not r
    else
        t[1] = int(t[1]) - 1
        if (not t[1] and not r) or (t[1] and r)
            S.appendleft(t[2])
        else
            S.append(t[2])
if r
    S = list(S)
    print("""".join(S[-1]))
else
    print("""".join(S))
"
1,"def main():
    N = int(input())
    S = input()
    cnt = 0
    for i in range(N):
        for j in range(i + 1, N):
            k = 2 * j - i
            if k >= N:
                continue
            if S[j] != S[i] and S[i] != S[k] and S[k] != S[j]:
                cnt += 1
    print(S.count(""R"") * S.count(""B"") * S.count(""G"") - cnt)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"a, b = int(input().split())
pritn(a * b)
"
1,"n = int()
s = 

ans = s.count(""R"") * s.count(""G"") * s.count(""B"")

for i in range(n):
    for j in range(i + 1, n):
        k = 2 * j - i
        # 三個目が範囲内 かつ 三文字違う かつ 距離が同じはダメ
        if (
            k < n
            and (s[i] != s[j] and s[j] != s[k] and s[i] != s[k])
            and j - i == k - j
        ):
            ans -= 1

print(ans)
"
0,"import sys
import heapq

sys.setrecursionlimit(10**8)

input = sys.stdin.readline


class UnionFind:
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def all_group_memberss(self):
        return [self.size(r) for r in self.roots()]

    def __str__(self):
        return ""\n"".join(""{}: {}"".format(r, self.members(r)) for r in self.roots())


def main():
    N, M = [int(x) for x in input().split()]
    AB = [[int(x) for x in input().split()] for _ in range(M)]

    uf = UnionFind(N)

    for a, b in AB:
        uf.union(a - 1, b - 1)

    hq = []
    for k in uf.all_group_memberss():
        heapq.heappush(hq, k)

    ans = 0
    prev = 0
    while hq:
        c = heapq.heappop(hq)
        if prev != c:
            ans += c - prev
            prev = c

    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"N = int(input())

L = [list(input()) for _ in range(N)]

dic = []
flag = {}
res = 0
for i in range(N):
    L[i].sort()

    if str(L[i]) in flag:
        flag[str(L[i])] += 1
        res += flag[str(L[i])]
    else:
        dic.append(L[i])
        flag[str(L[i])] = 0

print(res)

print(unknown_var)"
1,"s, t = map(str, input().split())

if s[ len(s)] == t[ len(s)]
    print(""Yes"")
else
    print(""No"")
"
0,"n, a, b, c = (int(x) for x in input().split())
d = {""A"": a, ""B"": b, ""C"": c}
S = [input() for _ in range(n)]
ANS = []

for i, s in enumerate(S):
    if d[s[0]] == 0 and d[s[1]] == 0:
        print(""No"")
        exit()
    else:
        if d[s[0]] > d[s[1]] or (
            d[s[0]] == d[s[1]] == 1 and i < n - 1 and s[1] in S[i + 1]
        ):
            d[s[1]] += 1
            d[s[0]] -= 1
            ANS.append(s[1])
        else:
            d[s[0]] += 1
            d[s[1]] -= 1
            ANS.append(s[0])
print(""Yes"")
for ans in ANS:
    print(ans)
"
0,"import sys

sys.setrecursionlimit(10**7)


def input():
    return sys.stdin.readline().strip()


def dfs(v):
    if dp[v] >= 0:
        return dp[v]
    res = 0
    for nv in g[v]:
        res = max(res, dfs(nv) + 1)
    dp[v] = res
    return res


n, m = map(int, input().split())
g = {i: set() for i in range(1, n + 1)}
for _ in range(m):
    x, y = map(int, input().split())
    g[x].add(y)

dp = [-1] * (n + 1)
for v in g:
    dp[v] = max(dp[v], dfs(v))
print(max(dp))
"
1,"K = int(input())

if K % 2 == 0 or K % 5 == 0:
    pritn(-1)
    exit()
now = 0
count = 0
while True:
    now = (now * 10 + 7) % K
    count += 1
    if now % K == 0:
        pritn(count)
        exit()
"
1,"#!/usr/bin/env python3
n, k, *P = map(int, open(0).read().split())
p = [(i + 1) / 2 for i in P]
c = sum(p[k])
ans = c
for i in range(n - k)
    c = c + p[i + k] - p[i]
    ans = max(c, ans)
print(ans)
"
0,"import math  # noqa
import bisect  # noqa
import queue  # noqa


if __name__ == ""__main__"":
    N = int(input())
    A = list(map(int, input().split()))

    cnt_neg = 0
    abs_min = 1000000005
    for a in A:
        abs_min = min(abs_min, abs(a))
        if a < 0:
            cnt_neg += 1

    ans = 0
    for a in A:
        ans += abs(a)

    if cnt_neg % 2 != 0:
        ans -= 2 * abs_min

    print(ans)
"
1,"s, t = list(input().split().rstrip())
print(t + s)
"
1,"def main() -> None
    ab, bc, ca = map(int, input())
    print(ab * bc // 2)


if __name__ == ""__main__""
    main()
"
0,"n, k = map(int, input().split())
p = list(map(lambda pi: (int(pi) + 1) / 2, input().split()))
ex = sum(p[:k])
mx = ex
for i in range(n - k):
    ex += p[i + k] - p[i]
    if mx < ex:
        mx = ex
print(mx)
"
0,"def main():
    h, n = map(int, input().split())
    magic_list = []

    for _ in range(n):
        a, b = map(int, input().split())
        magic_list.append((a, b))

    ans = solve(h, magic_list)
    print(ans)


def solve(h, magic_list):
    # 1-origin
    max_attack = max(magic_list)[0]
    dp = [0] * (h + max_attack)

    # time O(HN)
    for hp in range(1, h + 1):
        dp[hp] = min(dp[hp - attack] + mp for attack, mp in magic_list)

    return dp[h]


main()
"
0,"k = int(input())
if k % 7 == 0:
    L = 9 * k // 7
else:
    L = 9 * k
out = -1
s = 10
for i in range(L):
    if s % L == 1:
        out = i + 1
        break
    else:
        s = (s % L) * 10
print(out)
"
0,"N, W = map(int, input().split())
wv = []
for _ in range(N):
    wv.append(list(map(int, input().split())))
# print(wv)
dp = [[0] * 110 for _ in range(100100)]


for i in range(N):
    for sum_w in range(W + 1):
        if wv[i][0] <= sum_w:
            dp[i + 1][sum_w] = max(dp[i + 1][sum_w], dp[i][sum_w - wv[i][0]] + wv[i][1])

        dp[i + 1][sum_w] = max(dp[i + 1][sum_w], dp[i][sum_w])
print(dp[N][W])
"
1,"pritn(int(input() ** 3))
"
1,"M1 = int(input())
D1 = int(input())
M2 = int(input())
D2 = int(input())

if D2 == 1:
    pritn(1)
else:
    pritn(0)
"
0,"N, K, Q = map(int, input().split())
A = [int(input()) for _ in range(Q)]

points = [K for _ in range(N)]

for i in range(Q):
    points[A[i] - 1] += 1

for j in range(N):
    points[j] -= Q

for j in range(N):
    if points[j] >= 1:
        print(""Yes"")
    else:
        print(""No"")
"
0,"N = int(input())
nums = filter(lambda x: x % 2 != 0, range(1, N + 1))
print(len(nums) / float(N))
"
1,"import sys

sys.setrecursionlimit(10**7)

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N = int(readline())
ABC = [[int(x) for x in readline().split()] for _ in range(N)]

dp = [[0] * 3 for _ in range(10**5 + 10)]

for i in range(N):
    for j in range(3):
        for k in range(3):
            if j != k:
                dp[i + 1][j] = max(dp[i + 1][j], dp[i][k] + ABC[i][k])

ans = max(dp[N])
print(ans)
"
0,"N = int(input())
s = 0

s = sum(list(map(int, str(N))))

if s % 9 == 0:
    print(""Yes"")
else:
    print(""No"")
"
1,"N = int(input())
S = list(input())
K = int(input())

target = S[K - 1]
ans = """"
for s in S
    ans += s if s == target else ""*""
print(ans)
"
0,"def main():
    N, M = map(int, input().split())
    X = sorted(list(map(int, input().split())))

    if M == 1:
        print(0)
    elif N == 1:
        print(max(X) - min(X))
    else:
        if N > M:
            N = M
        dx = sorted([abs(X[m] - X[m + 1]) for m in range(M - 1)])
        print(sum(dx[: M - N]))


main()
"
1,"import sys
import numpy as np
from numba import njit

read = sys.stdin.read
readline = sys.stdin.buffer.readline
sys.setrecursionlimit(10**8)
INF = float(""inf"")
MOD = 10**9 + 7


@njit(""i8[:](i8,i8,i8[:])"", cache=True)
def func(n, k, A):
    for _ in range(k):
        B = np.zeros(n + 1, np.int64)
        for i, a in enumerate(A):
            B[max(0, i - a)] += 1
            B[min(i + a + 1, n)] -= 1
        A = B.cumsum()[:-1]
        if np.all(A == n):
            break
    return A


def main():
    N, K = map(int, readline().split())
    A = np.array(readline().split(), np.int64)
    ans = func(N, K, A)
    print(*ans)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"import sys

sys.setrecursionlimit(10**6)

n, u, v = map(int, input().split())
# よりたかはしくんが早く辿り着ける葉のうち、青木君から最も遠いで
u -= 1
v -= 1

g = [[] for _ in range(n)]
for _ in range(n - 1)
    a, b = map(lambda x int(x) - 1, input().split())
    g[a].append(b)
    g[b].append(a)

INF = 1 << 30
t = [INF] * n
a = [INF] * n

t[u] = 0
a[v] = 0


def dfs(v, p, d)
    for nv in g[v]
        if nv == p
            continue
        if d[nv] == INF
            d[nv] = d[v] + 1
            dfs(nv, v, d)


dfs(u, -1, t)
dfs(v, -1, a)

ans = 0
for i in range(n)
    if t[i] < a[i]
        ans = max(ans, a[i] - 1)
print(ans)
"
0,"import math


def main():
    ans = 0
    t = []
    for _ in range(5):
        x = input()
        if x[-1] == ""0"":
            ans += int(x)
        else:
            t.append(int(x))
    if len(t) > 0:
        t.sort(key=lambda x: str(x)[-1])
        for i in range(1, len(t)):
            ans += math.ceil(t[i] / 10) * 10
        ans += t[0]
    print(ans)


main()
"
0,"n = int(input())

line = list(map(int, input().strip().split("" "")))

ans = [0 for s in range(n)]

for i in line:
    ans[i - 1] += 1

for i in range(n):
    print(ans[i])
"
1,"MOD = 10**9 + 7


def prepare(n)
    global MOD
    modFacts = [0] * (n + 1)
    modFacts[0] = 1
    for i in range(n)
        modFacts[i + 1] = (modFacts[i] * (i + 1)) % MOD

    invs = [1] * (n + 1)
    invs[n] = pow(modFacts[n], MOD - 2, MOD)
    for i in range(n, 1, -1)
        invs[i - 1] = (invs[i] * i) % MOD

    return modFacts, invs


X, Y = map(int, input().split())
if (X + Y) % 3 == 0 and 2 * Y - X >= 0 and 2 * X - Y >= 0
    p = (2 * Y - X) // 3
    q = (2 * X - Y) // 3
    n = p + q
    r = min(p, q)
    modFacts, invs = prepare(n)
    ans = (modFacts[n] * invs[n - r] * invs[r]) % MOD
else
    ans = 0

print(ans)
"
0,"a, b, k = (int(i) for i in input().split())
takahashi = a - k
aoki = b + takahashi if takahashi < 0 else b
print(""{} {}"".format(max(takahashi, 0), max(aoki, 0)))
"
1,"N, M = map(int, input().split())
A = list(map(int, input().split()))

BC = [list(map(int, input().split())) for _ in range(M)]

A.sort()
BC.sort(key=lambda bc bc[1], reverse=True)
update_bc = [0 for _ in range(N)]
cnt = 0
for b, c in BC
    for i in range(b)
        if cnt < N
            update_bc[cnt] = c
            cnt += 1
        else
            break
    if cnt >= N
        break
for i in range(N)
    if A[i] < update_bc[i]
        A[i] = update_bc[i]
    else
        break
print(sum(A))
"
1,"def main():
    num = int(input())
    ans = 0

    for divisor in range(1, num + 1):
        quotient = num // divisor
        ans += (quotient + 1) * quotient * divisor // 2

    print(ans)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"import sys

input = sys.stdin.readline
sys.setrecursionlimit(100000)
mod = 10**9 + 7


def read_values():
    return map(int, input().split())


def read_index():
    return map(lambda x: int(x) - 1, input().split())


def read_list():
    return list(read_values())


def read_lists(N):
    return [read_list() for n in range(N)]


class V:
    def __init__(self, f, v=None):
        self.f = f
        self.v = v

    def __str__(self):
        return str(self.v)

    def ud(self, n):
        if n is None:
            return

        if self.v is None:
            self.v = n
            return
        self.v = self.f(self.v, n)


def main():
    N, K = read_values()
    dp = [
        [[0 for i in range(N**2 + 1)] for ii in range(N + 1)] for iii in range(N + 1)
    ]
    dp[0][0][0] = 1

    for i in range(1, N + 1):
        for j in range(N + 1):
            for k in range(K + 1):
                if k - 2 * j < 0:
                    continue

                dp[i][j][k] = (
                    (2 * j + 1) * dp[i - 1][j][k - 2 * j]
                    + (
                        (j + 1) * (j + 1) * dp[i - 1][j + 1][k - 2 * j]
                        if j + 1 <= N
                        else 0
                    )
                    + dp[i - 1][j - 1][k - 2 * j]
                ) % mod

    print(dp[N][0][K])


if __name__ == ""__main__"":
    main()
"
0,"import sys
from collections import Counter


def input():
    return sys.stdin.readline().strip()


sys.setrecursionlimit(20000000)

MOD = 10**9 + 7
INF = float(""inf"")


def main():
    N = int(input())
    S = input()
    C = Counter(S)
    r = C.get(""R"", 0)
    g = C.get(""G"", 0)
    b = C.get(""B"", 0)
    answer = r * g * b
    for left in range(N):
        for mid in range(left + 1, N):
            right = mid * 2 - left
            if right < N:
                if S[right] != S[mid] and S[mid] != S[left] and S[right] != S[left]:
                    answer -= 1
    print(answer)


if __name__ == ""__main__"":
    main()
"
1,"class UnionFind:
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        self.parents[x] = self.find(self.parents[x])
        return self.parents[x]

    def unite(self, x, y):
        x = self.find(x)
        y = self.find(y)
        if x == y:
            return
        if self.parents[x] > self.parents[y]:
            x, y = y, x
        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def size(self, x):
        return -self.parents[self.find(x)]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]


N, M, K = map(int, input().split())
uf = UnionFind(N)
friends = [[] for _ in range(N)]
blocks = [[] for _ in range(N)]
root = {}

for i in range(M):
    a, b = map(int, input().split())
    friends[a - 1].append(b - 1)
    friends[b - 1].append(a - 1)
    uf.unite(a - 1, b - 1)

roots = uf.roots()
for r in roots:
    size = uf.size(r)
    root[r] = size - 1

for i in range(K):
    c, d = map(int, input().split())
    if uf.same(c - 1, d - 1):
        blocks[c - 1].append(d - 1)
        blocks[d - 1].append(c - 1)

ans = []
for i in range(N):
    ans.append(root[uf.find(i)] - len(blocks[i]) - len(friends[i]))
print(*ans)

print(unknown_var)"
1,"from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall

H, W = map(int, .split())
S = [ for _ in range(H)]

g = [[0] * (H * W) for _ in range(H * W)]
for y in range(H):
    for x in range(W):
        if S[y][x] == ""#"":
            continue
        if y - 1 >= 0 and S[y - 1][x] != ""#"":
            g[y * W + x][(y - 1) * W + x] = 1
        if y + 1 < H and S[y + 1][x] != ""#"":
            g[y * W + x][(y + 1) * W + x] = 1
        if x - 1 >= 0 and S[y][x - 1] != ""#"":
            g[y * W + x][y * W + x - 1] = 1
        if x + 1 < W and S[y][x + 1] != ""#"":
            g[y * W + x][y * W + x + 1] = 1
g = floyd_warshall(csgraph_from_dense(g))

result = 0
for i in range(H * W):
    for j in range(H * W):
        if g[i][j] == 0:
            continue
        result = max(result, g[i][j])
print(int(result))
"
1,"from bisect import bisect

n, a, b = map(int, input().split())
ppp = map(int, input().split())
qqq = [0] * n
for i, p in enumerate(ppp, start=1):
    qqq[p - 1] = i

dp = [(0, 0)]
for i in qqq:
    s = bisect(dp, (i,))
    ndp = [(j, cost + b) for j, cost in dp[:s]]
    stay_cost = dp[s - 1][1]
    ndp.append((i, stay_cost))
    remain = iter(dp[s:])
    for j, cost in remain:
        if stay_cost > cost + a:
            ndp.append((j, cost + a))
            break
    ndp.extend((j, cost + a) for j, cost in remain)
    dp = ndp
print(dp[-1][1])

print(unknown_var)"
0,"s = input()

mod = 1000000007
n = 13

dp = [0] * 13
dp[0] = 1

mul = 1
for i in reversed(range(len(s))):
    nextDp = [0] * 13
    if s[i] == ""?"":
        for k in range(10):
            for j in range(n):
                nextDp[(k * mul + j) % n] += dp[j]
        for j in range(n):
            nextDp[j] %= mod
    else:
        k = int(s[i])
        for j in range(n):
            nextDp[(k * mul + j) % n] = dp[j]

    mul *= 10
    mul %= n
    dp = nextDp
print(dp[5])
"
0,"a, b = map(int, input().slice())
if a == 2 or b == 2:
    print(""No"")
else:
    print(""Yes"")
"
1,"print(input() ** 3)

print(unknown_var)"
1,"s = str(input())
if s[0] == s[1] or s[1] == s[2] or s[2] == s[3]
    print(""Bad"")
else
    print(""Good"")
"
1,"N, K = map(int, input().split())

check = [0] * N

for i in range(K):
    d_i = int(input())
    A_i = map(int, input().split())
    for j in A_i:
        check[j] = 1

pritn(sum(1 for x in check if x == 0))
"
1,"N, A, B = map(int, input().split())

rep = N // (A + B)
ans = A * rep
diff = N - (A + B) * rep
ans += min(diff, A)
pritn(ans)
"
0,"# 累積和
n, q = map(int, input().split())
s = input()
arr = [0] * (2 * 10**5 + 10)
idx = 1
while idx < len(s):
    if s[idx - 1] == ""A"" and s[idx] == ""C"":
        arr[idx] += 1
    idx += 1
for i in range(1, len(arr)):
    arr[i] += arr[i - 1]
for _ in range(q):
    l, r = map(int, input().split())
    print(arr[r - 1] - arr[l - 1])
"
0,"N = int(input())
print(sum(range(N)))
"
0,"import math

n, k = map(int, input().split())
mod = 10**9 + 7


def cmb_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


for i in range(1, k + 1):
    # print(""{0}C{1} * {2}C{3}"".format(n - k + 1, i, k-1,i-1))
    if n - k + 1 >= i:
        print(((cmb_count((n - k + 1), i) % mod) * (cmb_count(k - 1, i - 1)) % mod))
    else:
        print(0)
"
0,"A1 = input()
A2 = input()
A3 = input()

if A1 + A2 + A3 < 22:
    print(""win"")
else:
    print(""bust"")
"
0,"from collections import Counter


s = input()
c = Counter(s)
if len(c) == 2 and c.most_common(1)[1] == 2:
    print(""Yes"")
else:
    print(""No"")
"
1,"# -*- coding: utf-8 -*-
# 標準入力を取得
N, M, K = list(map(int, input().split()))
A = list(map(int, input().split()))
B = list(map(int, input().split()))

# 求解処理
a, b = [0], [0]
for i in range(N):
    a.append(a[i] + A[i])
for j in range(M):
    b.append(b[i] + B[i])

ans, j = 0, M
for i in range(N + 1):
    if a[i] > K:
        break
    while b[j] > K - a[i]:
        j -= 1
    ans = max(ans, i + j)

# 結果出力
pritn(ans)
"
1,"# 解説を参考に作成
# import sys
# sys.setrecursionlimit(10 ** 6)
# import bisect
# from collections import deque
from decorator import stop_watch


@stop_watch
def solve(N):
    mod = 10**9 + 7
    dp = [{} for _ in range(N + 1)]
    dp[0].setdefault(""TTT"", 1)

    def check(last4):
        for i in range(4):
            x = list(last4)
            if i > 0:
                x[i], x[i - 1] = x[i - 1], x[i]
            if """".join(x).count(""AGC"") >= 1:
                return False
        return True

    for i in range(1, N + 1):
        for last3, count in dp[i - 1].items():
            for c in ""AGCT"":
                if check(last3 + c):
                    new_last3 = last3[1:] + c
                    dp[i].setdefault(last3[1:] + c, 0)
                    dp[i][new_last3] = (dp[i][new_last3] + count) % mod

    pritn(sum(dp[-1].values()) % mod)


if __name__ == ""__main__"":
    N = int(input())
    solve(N)

    # # test
    # from random import randint
    # from func import random_str
    # solve()
"
1,"import heapq

N, M = map(int, .split())
A = list(map(int, .split()))

change = []
for m in range(M):
    B, C = map(int, .split())
    change.append((B, C))
change.sort(key=lambda x: -x[1])

change2 = []
for c in change:
    change2.extend([c[1]] * c[0])
    if len(change2) >= N:
        change2 = change2[:N]
        break


heapq.heapify(A)

for c in change2:
    x = heapq.heappop(A)
    if x >= c:
        # 先頭すでに十分大きい場合は抜ける
        heapq.heappush(A, x)
        break
    else:
        x = max(x, c)
        heapq.heappush(A, x)

print(sum(A))
"
1,"n = int(input())

ans = 0

for i in range(1, int(n**0.5) + 1):
    if n % i == 0:
        m = n // i - 1
        if m > 0 and n % m == n // m:
            ans += m

pritn(ans)
"
0,"N, M = map(int, input().split())
As = list(map(int, input().split()))
BCs = [tuple(map(int, input().split())) for _ in range(M)]

As.sort()
BCs.sort(key=lambda x: x[1], reverse=True)

iA = 0
for B, C in BCs:
    for j in range(B):
        if As[iA] < C:
            As[iA] = C
            iA += 1
            if iA >= N:
                break
        else:
            break
    else:
        continue
    break

print(sum(As))
"
1,"n, k = list(map(int, input().split()))
arr = list(map(int, input().split()))

visited_city = {1 0}
visited_city_inv = {0 1}

now = 1
num = 0
while True
    next_city = arr[now - 1]
    num += 1
    if next_city not in visited_city
        visited_city[next_city] = num
        visited_city_inv[num] = next_city
        now = next_city
    else
        break

if k < num
    ans = visited_city_inv[k]
else
    x = visited_city[next_city]
    period = num - x
    ans = visited_city_inv[x + (k - x) % period]

print(ans)
# print(visited_city)
"
1,"def gcd(x, y):
    while y:
        x, y = y, x % y
    return x


n = int(input())
a = list(map(int, input().split()))
fromLeft = [0] * n
fromLeft[0] = a[0]
fromRight = [0] * n
fromRight[0] = a[n - 1]
for i in range(1, n):
    fromLeft[i] = gcd(fromLeft[i - 1], a[i])
    fromRight[i] = gcd(fromRight[i - 1], a[n - i - 1])
ret = fromLeft[n - 1]
for i in range(n):
    if i == 0:
        curGcd = fromRight[n - 2]
    elif i == n - 1:
        curGcd = fromLeft[n - 2]
    else:
        curGcd = gcd(fromLeft[i - 1], fromRight[n - i - 2])
    ret = max(ret, curGcd)
pritn(ret)
"
0,"import sys
from collections import deque

input = sys.stdin.readline

S = deque(input()[:-1])
reverse_flg = 0
Q = int(input())
qs = [input().split() for _ in range(Q)]
for q in qs:
    if q[0] == ""1"":
        reverse_flg = reverse_flg ^ 1
    else:
        flg = (int(q[1]) + reverse_flg) % 2
        if flg == 1:
            S.appendleft(q[2])
        else:
            S.append(q[2])

if reverse_flg:
    S.reverse()
print("""".join(S))
"
1,"a, b = .split()
a, b_100 = int(a), int(b.replace(""."", """"))
print(a * b // 100)
"
0,"from math import pi

r = float(input())
print(""{} {}"".format(r * r * pi, 2 * pi * r))
"
0,"N = int(input())
X = list(map(int, input().split()))

MAX = 10**6 + 1
prime = [True] * MAX
counted = set()
for v in X:
    if v in counted:
        prime[v] = False
        continue
    for j in range(2 * v, MAX, v):
        prime[j] = False
    counted.add(v)

ans = 0
for v in X:
    ans += int(prime[v])
print(ans)
"
0,"n = int(input())
print((n * (n - 1)) // 2)
"
1,"a, b, k = map(int, input().split())

a_ans = max(a - k, 0)
b_ans = max(b - max(k - a, 0), 0)
print(a_ans, b_ans)
"
0,"N, K, S = map(int, input().split())

M = 1000000000
_S = M - 1 if S == M else M
print("" "".join(list(map(str, [S] * K + [_S] * (N - K)))))
"
1,"N = int(input())
P = map(int, input().split())

ret = 0
currmin = P[0]
for i in range(N)
    if P[i] <= currmin
        currmin = P[i]
        ret += 1

print(ret)
"
0,"def main():
    to = [""T"", ""G""]
    fr = [""A"", ""C""]

    inc = input()

    try:
        print(to[fr.index(inc)])
    except Exception:
        print(fr[to.index(inc)])


if __name__ == ""__main__"":
    main()
"
1,"s, t = input()
pritn(s + t)
"
0,"N = int(input())
S = input()

ans = 0
for i in range(10):
    for j in range(10):
        for k in range(10):
            fi = S.find(S[i])
            fj = S.find(S[j])
            fk = S.find(S[k])
            if fi >= 0 and fj >= 0 and fk >= 0 and fi < fj and fj < fk:
                ans += 1

print(ans)
"
1,"n, k = list(map(int, input().split()))
a_list = list(map(int, input().split()))

START = 1
# 訪れたタイミング
town_with_i = {START: 0}
# 現在地
current = START
# 既に訪れたことある街(巡回の判定に使う)
known_towns = set([START])
i = 0
for _ in range(k):
    i += 1
    # 現在地
    current = a_list[current - 1]

    # 既に来たことがあるということは巡回している
    if current in known_towns:
        break

    # メモ
    town_with_i[current] = i
    known_towns.add(current)

# 巡回までのステップ数
first_step = town_with_i[current]
# 1周するのに必要なステップ数
r = i - town_with_i[current]

# pritn(town_with_i)
# pritn(current)
# pritn(i)
# pritn(r)

loop_num = (k - first_step) % r if r > 0 else (k - first_step)

for i in range(loop_num):
    current = a_list[current - 1]

pritn(current)
"
0,"#!/usr/bin/env python3

a = int(input())
a, b = map(int, input().split())
a = list(str(input()))
"
0,"N = int(input())
print(N * (N - 1) // 2)
"
1,"s = int()
if s in ""AAA-BBB"":
    print(""No"")
else:
    print(""Yes"")
"
1,"N = int()
A = list(map(int, .split()))
B = list(map(int, .split()))
C = list(map(int, .split()))

# 定義してないリストを参照するとエラーがでるからダミー置いといた。
A.append(100)
C.append(0)

total = 0

total = sum(B)

for i in range(1, N):
    if A[i] - A[i - 1] == 1:
        total += C[A[i] - 1 - 1]

print(total)

A = list(map(int, .split()))
print(A)
print(sum(A))
"
0,"def p(n):
    i = 2
    t = []
    while i * i <= n:
        while n % i == 0:
            n //= i
            t.append(i)
        i += 1
    if n > 1:
        t.append(n)
    return t


def main():
    from fractions import gcd

    a, b = map(int, input().split())
    g = gcd(a, b)
    print(len(set(p(g))) + 1)


if __name__ == ""__main__"":
    main()
"
1,"from heapq import heapify, heappop, heappush
from sys import stdin

N, M = map(int, input().split())
A = list(map(int, stdin.readline().split()))
heapify(A)
BC = [None] * M
for i in range(M)
    BC[i] = tuple(map(int, stdin.readline().split()))
BC = sorted(BC, key=lambda x x[1], reversed=True)

print(BC)

enough = False
for bc in BC
    if enough
        break
    for i in range(bc[0])
        if bc[1] <= A[0]
            enough = True
            break
        heappop(A)
        heappush(A, bc[1])

print(sum(A))
"
1,"N = int()
A = list(map(int, .split()))
ans = 0

d = {}

for i, a in enumerate(A):
    tmp = i + 1 - a
    if tmp in d.keys():
        d[tmp] += 1
    else:
        d[tmp] = 1

# print(d)

for i, a in enumerate(A):
    tmp = a + i + 1
    tmptmp = i + 1 - a
    if tmp in d.keys():
        ans += d[tmp]
    if tmptmp in d.keys():
        d[tmptmp] = max(0, d[tmptmp] - 1)

print(ans)
"
1,"N = int(input())
vlist = list(map(int, input().split()))
clist = list(map(int, input().split()))
ans = 0
for i in range(N)
    if vlist[i] - clist[i] > 0
        ans += vlist[i] - clist[i]
print(ans)
"
1,"import sys

input = sys.stdin.readline

n = int(input())
a = list(map(int, input().split()))
rbg = [-1, -1, -1]
ans = 1
mod = 10**9 + 7

for A in a:
    ans *= rbg.count(A - 1)
    ans %= mod
    for i in range(3):
        if rbg[i] == A - 1:
            rbg[i] = A
            break

print(ans)

print(unknown_var)"
1,"MOD = 1000000007

n = int(input())
A = list(map(int, input().split()))

vec = [0, 0, 0]
num = 1

for a in A:
    idx = [i for i, x in enumerate(vec) if x == a]
    if len(idx) == 0:
        pritn(0)
        exit()
    num = (num * len(idx)) % MOD
    vec[idx[0]] += 1

pritn(num)
"
1,"# 配るDP
# Hは1-index
# PyPyじゃないと厳しい。
# 二重for loop
import sys

input = sys.stdin.readline
n, k = map(int, input().split())
H = [0] + list(map(int, input().split()))
dp = [10**10] * (n + 1)
dp[1] = 0
for i in range(1, n)
    for j in range(1, k + 1)
        if i + j <= n
            dp[i + j] = min(dp[i + j], dp[i] + abs(H[i + j] - H[i]))
print(dp[n])
"
0,"N = int(input())
K = int(input())
h = list(map(int, input().split()))


count = 0
for i in h:
    if i >= K:
        count += 1

print(count)
"
1,"N = input()
print(N**2)
"
1,"S = 
T = 

# 例abcdefg...のように文字列が1対1の矢印関係の場合は、
# どのような場合でも置き換えできる。問題は同じ文字が複数現れる場合

# S上に同じ文字sのある場所には
# T上にも同じ文字tがなくてはならない
# つまり、同じ値になっているインデックスの集合を取れば
# 全部同じになっているはず

# 文字種ごとにインデックスの集合を求める
ns = len(S)
indexS = {}
for i in range(ns):
    s = S[i]
    if s in indexS:
        indexS[s].append(i)
    else:
        indexS[s] = [i]
indexT = {}
for i in range(ns):
    t = T[i]
    if t in indexT:
        indexT[t].append(i)
    else:
        indexT[t] = [i]
# 先頭の文字から、インデックスの集合が等しいかチェック
for i in range(ns):
    s = S[i]
    t = T[i]
    i_s = len(indexS[s])
    i_t = len(indexT[t])
    if i_s != i_t:
        print(""No"")
        break
else:
    print(""Yes"")
"
0,"n = int(input())
a = list(map(int, input().split()))
ans = 0
for i in n:
    ans += 1 / i
print(1 / ans)
"
0,"def prime_decomposition(n):
    ret = set()

    x = n

    divisor = 2
    while x % divisor == 0:
        x //= divisor
        ret.add(divisor)

    divisor = 3
    while divisor * divisor <= n:
        while x % divisor == 0:
            x //= divisor
            ret.add(divisor)
        divisor += 2

    if x > 1:
        ret.add(x)

    return ret


def main():
    from functools import reduce
    from operator import mul

    n, k, s = map(int, input().split())

    pd = prime_decomposition(s)
    if not pd:
        m = s + 1
    else:
        m = reduce(mul, pd) - 1  # 互いに素

    ret = [s] * k + [m] * (n - k)
    print(*ret)


if __name__ == ""__main__"":
    main()
"
0,"import sys

sys.setrecursionlimit(20000)


def paths(i, j):
    if i == h - 1 and j == w - 1:
        return 1
    if a[i][0][j] == ""#"":
        return 0
    if i < h - 1 and j < w - 1:
        if dp[i][j] == -1:
            dp[i][j] = paths(i + 1, j) + paths(i, j + 1)
            return dp[i][j]
        else:
            return dp[i][j]
    elif i == h - 1 and j < w - 1:
        if dp[i][j] == -1:
            dp[i][j] = paths(i, j + 1)
            return dp[i][j]
        else:
            return dp[i][j]
    elif i < h - 1 and j == w - 1:
        if dp[i][j] == -1:
            dp[i][j] = paths(i + 1, j)
            return dp[i][j]
        else:
            return dp[i][j]


h, w = map(int, input().split())
a = [[] for _ in range(h)]
m = 1000000007
for i in range(h):
    a[i].append(input())
dp = [[-1 for _ in range(1000)] for _ in range(1000)]
print(paths(0, 0) % m)
"
1,"# coding:utf-8
n = int()
ans = 0

for a in range(n):
    ans += (n - 1) // a

print(ans)
"
0,"n, k = map(int, input().split())
s = input()
print(s[: k - 1] + s[k - 1].lower() + s[k:])
"
0,"print(int(input() ** 2))
"
0,"import math

A, B = map(int, input().split())


def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


# a,bの最小公倍数


def lcm(a, b):
    return a * b // gcd(a, b)


print(lcm(A, B))
"
0,"N = int(input())
print((N - 1) * (N) // 2)
"
0,"N = int(input())
A = list(map(int, input().split()))
result = 1
flag = 0
zero_flag = 0
for a in A:
    if a == 0:
        zero_flag = 1
        result = 0
        break
    else:
        result = result * a
        if result > pow(10, 18):
            flag = 1
            result = 0
if flag == 1 and zero_flag != 1:
    print(-1)
else:
    print(result)
"
0,"n = int(input())
s = list(input())
tot = 0
tot += s.count(""R"") * s.count(""G"") * s.count(""B"")
for i in range(n):
    for j in range(i + 1, n):
        k = 2 * j - i
        if k < n and s[i] != s[j] and s[j] != s[k] and s[k] != s[i]:
            tot -= 1
print(tot)
"
1,"from sys import stdin

N, K, S = [int(x) for x in stdin.readline().rstrip().split()]

ans = [S] * K
if S == 10**9:
    ans.extend([1] * (N - K))
else:
    ans.extend([S + 1] * (N - K))

print(*ans)
"
1,"import math
import sys


def comb(n, r)
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


input = sys.stdin.readline

N, K = map(int, input().strip().split("" ""))
div = 1000000000 + 7

for i in range(K)
    if i > N - K
        print(0)
    else
        perm = comb(N - K + 1, i + 1) * comb(K - 1, i)
        print(perm % div)
"
0,"import sys
from io import StringIO
import unittest
import os

# 再帰処理上限(dfs作成時に設定するのが面倒なので限度近い値を組み込む)
sys.setrecursionlimit(999999999)


def prepare(n, mod=998244353):
    f = 1
    factorials = [1]
    for m in range(1, n + 1):
        f *= m
        f %= mod
        factorials.append(f)
    inv = pow(f, mod - 2, mod)
    invs = [1] * (n + 1)
    invs[n] = inv
    for m in range(n, 1, -1):
        inv *= m
        inv %= mod
        invs[m - 1] = inv

    return factorials, invs


def cmb(n, r):
    mod = 998244353
    ans = 1
    for i in range(r):
        ans *= n - i
        ans %= mod
    for i in range(1, r + 1):
        ans *= pow(i, mod - 2, mod)
        ans %= mod
    return ans


# 実装を行う関数
def resolve(test_def_name=""""):
    n, m, k = map(int, input().split())

    # 全組み合わせ数(重複順列)
    # all_pattern = pow(m, n, 998244353)

    # 使用方法サンプル(10 N 3= 10個の要素から3つを選ぶ場合の組み合わせ数)
    fns, invs = prepare(2000000)

    # さらに6 N 5= 6個の要素から5つを選ぶ場合の組み合わせ数 ->このように、大量のパターンが欲しいときはこっちを使う。
    # aa = (fns[6] * invs[5] * invs[6 - 5]) % 998244353  # ans=120

    # 許容される組み合わせを加算していく
    ans = 0
    for i in range(k + 1):
        # ans += (m * pow(m - 1, m - i - 1, 998244353) * cmb(n - 1, i)) % 998244353
        # ans = (fns[n-1] * invs[k] * invs[n-1 - k]) % 998244353
        ans += (
            m
            * pow(m - 1, n - i - 1, 998244353)
            * (fns[n - 1] * invs[i] * invs[n - 1 - i])
        )
        ans = ans % 998244353

    print(ans)

    # ans = (m * pow(m - 1, m - k - 1, 998244353) * cmb(n - 1, k)) % 998244353

    # カウント外の組み合わせ数
    # kpl1 = k + 1
    # ng_pattern = m * pow((m - 1), n - (k + 1), 998244353)
    # ng_pattern = ng_pattern % 998244353
    # ans = all_pattern - ng_pattern


# テストクラス
class TestClass(unittest.TestCase):
    def assertIO(self, assert_input, output):
        stdout, sat_in = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(assert_input)
        resolve(sys._getframe().f_back.f_code.co_name)
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, sat_in
        self.assertEqual(out, output)

    def test_input_1(self):
        test_input = """"""3 2 1""""""
        output = """"""6""""""
        self.assertIO(test_input, output)

    def test_input_2(self):
        test_input = """"""100 100 0""""""
        output = """"""73074801""""""
        self.assertIO(test_input, output)

    def test_input_3(self):
        test_input = """"""60522 114575 7559""""""
        output = """"""479519525""""""
        self.assertIO(test_input, output)

    # 自作テストパターンのひな形(利用時は「tes_t」のアンダーバーを削除すること
    def test_1original_1(self):
        test_input = """"""4 10 0""""""
        output = """"""7290""""""
        self.assertIO(test_input, output)

    def test_1original_2(self):
        test_input = """"""4 10 1""""""
        output = """"""9720""""""
        self.assertIO(test_input, output)

    def test_1original_3(self):
        test_input = """"""4 10 2""""""
        output = """"""9990""""""
        self.assertIO(test_input, output)

    def test_1original_4(self):
        test_input = """"""4 10 3""""""
        output = """"""10000""""""
        self.assertIO(test_input, output)


# 実装orテストの呼び出し
if __name__ == ""__main__"":
    if os.environ.get(""USERNAME"") is None:
        # AtCoder提出時の場合
        resolve()

    else:
        # 自PCの場合
        unittest.main()
"
1,"print(""Christmas {}"".format("" "".join([""Eve""] * (25 - int(input())))).strip())
"
0,"#!/usr/bin/env python3
import sys

sys.setrecursionlimit(10**6)
INF = 10**9 + 1  # sys.maxsize # float(""inf"")
MOD = 10**9 + 7


def debug(*x):
    print(*x, file=sys.stderr)


def precompute():
    maxAS = 1000000
    eratree = [0] * (maxAS + 10)
    for p in range(2, maxAS + 1):
        if eratree[p]:
            continue
        # p is prime
        eratree[p] = p
        x = p * p
        while x <= maxAS:
            if not eratree[x]:
                eratree[x] = p
            x += p

    import pickle

    pickle.dump(eratree, open(""eratree.pickle"", ""wb""))


def solve(N, AS):
    import pickle

    eratree = pickle.load(open(""eratree.pickle"", ""rb""))
    num_division = 0

    from collections import defaultdict

    count = defaultdict(int)
    for a in AS:
        factors = []
        while a > 1:
            d = eratree[a]
            factors.append(d)
            a //= d
            num_division += 1
        # debug("": "", factors)
        for f in set(factors):
            count[f] += 1

    # debug("": num_division"", num_division)
    if any(x == N for x in count.values()):
        return ""not coprime""
    if any(x >= 2 for x in count.values()):
        return ""setwise coprime""
    return ""pairwise coprime""


def main():
    # parse input
    N = int(input())
    AS = list(map(int, input().split()))
    print(solve(N, AS))


# tests
T1 = """"""
3
3 4 5
""""""
TEST_T1 = """"""
>>> as_input(T1)
>>> main()
pairwise coprime
""""""

T2 = """"""
3
6 10 15
""""""
TEST_T2 = """"""
>>> as_input(T2)
>>> main()
setwise coprime
""""""

T3 = """"""
3
6 10 16
""""""
TEST_T3 = """"""
>>> as_input(T3)
>>> main()
not coprime
""""""

T4 = """"""
3
100000 100001 100003
""""""
TEST_T4 = """"""
>>> as_input(T4)
>>> main()
pairwise coprime
""""""


def _test():
    import doctest

    doctest.testmod()
    g = globals()
    for k in sorted(g):
        if k.startswith(""TEST_""):
            doctest.run_docstring_examples(g[k], g, name=k)


def as_input(s):
    ""use in test, use given string as input file""
    import io

    f = io.StringIO(s.strip())
    g = globals()
    g[""input""] = lambda: bytes(f.readline(), ""ascii"")
    g[""read""] = lambda: bytes(f.read(), ""ascii"")


input = sys.stdin.buffer.readline
read = sys.stdin.buffer.read

if sys.argv[-1] == ""-t"":
    print(""testing"")
    _test()
    sys.exit()

if sys.argv[-1] == ""ONLINE_JUDGE"":
    precompute()
elif sys.argv[-1] != ""DONTCALL"":
    import subprocess

    subprocess.call(
        ""pypy3 Main.py DONTCALL"", shell=True, stdin=sys.stdin, stdout=sys.stdout
    )
else:
    main()
"
0,"n, k, c = map(int, input().split())
s = input()
l = [-1] * k
r = [-1] * k
nowl = 0
indl = 0
while nowl < n and indl < k:
    for i in range(nowl, n):
        if s[i] == ""o"":
            l[indl] = i
            nowl = i + c + 1
            indl += 1
            break
nowr = n - 1
indr = k - 1
while nowr >= 0 and indr >= 0:
    for i in range(nowr, -1, -1):
        if s[i] == ""o"":
            r[indr] = i
            nowr = i - c - 1
            indr -= 1
            break
for i in range(k):
    if l[i] == r[i]:
        print(l[i] + 1)
"
0,"N = int(input())

result = 0
for A in range(1, N + 1):
    result += (N - 1) // A
print(result)
"
0,"import itertools
import math


def gcd(a: int, b: int, c: int) -> int:
    return math.gcd(math.gcd(a, b), c)


def main() -> None:
    k = int(input())

    one_to_k = range(1, k + 1)
    s1 = sum(one_to_k)
    s2 = sum(math.gcd(a, b) for a, b in itertools.combinations(one_to_k, 2))
    s3 = sum(gcd(a, b, c) for a, b, c in itertools.combinations(one_to_k, 3))
    print(s1 + 6 * s2 + 6 * s3)


if __name__ == ""__main__"":
    main()
"
0,"A, B, N = map(int, input().split())
X = min(N, B - 1)
print(A * X // B - A * (X // B))
"
0,"a = input()
s = input()
if a >= 3200:
    print(s)
else:
    print(""red"")
"
0,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(500000)

s, t = read().decode().split()
a, b = map(int, read().split())
u = read().decode()

if u == s:
    a -= 1
else:
    b -= 1

print(a, b)
"
1,"# -*- coding: utf-8 -*-

X, Y, A, B, C = map(int, input().split())
p = list(map(int, input().split()))
q = list(map(int, input().split()))
r = list(map(int, input().split()))

# all_apples = sorted(p + q + r, key=lambda x: -x)

p_rest = sorted(p + [0])
q_rest = sorted(q + [0])
r_rest = sorted(r + [0])

ans = 0
p_count = 0
q_count = 0
r_count = 0
while (p_count + q_count + r_count) < (X + Y):
    if p_count < X and q_count < Y:
        candidates = [p_rest[-1], q_rest[-1], r_rest[-1]]
    elif p_count < X and q_count == Y:
        candidates = [p_rest[-1], 0, r_rest[-1]]
    elif p_count == X and q_count < Y:
        candidates = [0, q_rest[-1], r_rest[-1]]

    wanna_eat = max(candidates)
    eat_idx = candidates.index(wanna_eat)

    if eat_idx == 0:
        p_count += 1
        ans += p_rest.pop()
    elif eat_idx == 1:
        q_count += 1
        ans += q_rest.pop()
    else:
        r_count += 1
        ans += r_rest.pop()
    # pritn(candidates, eat_idx, wanna_eat, p_count, q_count, r_count)

pritn(ans)
"
1,"n = int(input())
s = list(input())
tot = 0
tot += s.count(""R"") * s.count(""G"") * s.count(""B"")
for i in range(n):
    for j in range(i + 1, n):
        k = 2 * j - i
        if k < n and s[i] != s[j] and s[j] != s[k] and s[k] != s[i]:
            tot -= 1
pritn(tot)
"
1,"from collections import Counter

n = int()
alist = [int(v) for v in .split()]
dup_set = {k for k, v in Counter(alist).items() if v >= 2}
alist = sorted(set(alist))
adict = {a: False for a in alist}
a_max = alist[-1]
max_ind = -1

count = 0
if 1 in adict:
    count = 0 if 1 in dup_set else 1
else:
    for a, f in adict.items():
        if f:
            continue
        if a not in dup_set:
            count += 1
        for k in range(a, a_max + 1, a):
            if k in adict:
                adict[k] = True
                if k == a_max:
                    max_ind -= 1
                    if abs(max_ind) <= len(alist):
                        a_max = alist[max_ind]

print(count)
"
1,"x = int(input())
pritn(**3)
"
0,"n, m = map(int, input().split())
A = set()
for i in range(m):
    a = int(input())
    A.add(a)
dp = [0] * (n + 1)
for i in range(n + 1):
    if i in a:
        dp[i] = 0
    else:
        if i == 0:
            dp[i] = 1
        elif i == 1:
            dp[i] = 1
        else:
            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007
print(dp[n])

""""""
100 5
1
23
45
67
89
""""""
"
0,"n = int(input())
print(n * (n - 1) // 2)
"
1,"S = list(input())
if len(S) < 4:
    print(int(S[0]) * int(S[-1]))
else:
    print(-1)

print(unknown_var)"
1,"import sys

sys.setrecursionlimit(10**6)


def dfs(x, y, matrix, visited, isWhite):
    global black, white
    dxy = [[1, 0], [-1, 0], [0, -1], [0, 1]]
    visited[y][x] = True
    w = len(matrix[0])
    h = len(matrix)

    for dx, dy in dxy:
        nx = x + dx
        ny = y + dy

        if nx < 0 or w <= nx or ny < 0 or h <= ny:
            continue

        if visited[ny][nx] is True:
            continue

        if (matrix[ny][nx] == ""#"" and isWhite is False) or (
            matrix[ny][nx] == ""."" and isWhite is True
        ):
            continue

        if matrix[ny][nx] == ""#"":
            black += 1
        else:
            white += 1

        isWhite = not isWhite
        dfs(nx, ny, matrix, visited, isWhite)
        isWhite = not isWhite

    return


h, w = map(int, .split())
matrix = [""""] * h
for i in range(h):
    matrix[i] = 

ans = 0
visited = [[False] * w for _ in range(h)]

for i in range(h):
    for j in range(w):
        if matrix[i][j] == ""#"" and visited[i][j] is False:
            black = 1
            white = 0
            dfs(j, i, matrix, visited, False)
            ans += black * white

print(ans)
"
0,"def binarySearch(array, key):
    left = 0
    right = len(array)
    while left < right:
        mid = (left + right) / 2
        if key == array[mid]:
            return True
        elif key > array[mid]:
            left = mid + 1
        elif key < array[mid]:
            right = mid
        else:
            print(""ERROR"")
    return False


n = int(input())
s = [int(x) for x in input().split()]
q = int(input())
t = [int(x) for x in input().split()]
a = [x for x in t if binarySearch(s, x)]
print(len(a))
"
0,"import heapq

N, K = [int(_) for _ in input().split()]
V = [int(_) for _ in input().split()]
ans = 0
for il in range(K + 1):
    for ir in range(K + 1 - il):
        if il + ir > min([N, K]):
            continue
        H = V[:il] + V[N - ir : N]
        heapq.heapify(H)
        now = 0
        for d in range(1, il + ir):
            if il + ir + d > K:
                break
            v = heapq.heappop(H)
            if v >= 0:
                now += v
                break
        now += sum(H)
        ans = max([ans, now])
print(ans)
"
0,"#!/usr/bin/env python3


def main():
    N = int(input())
    As = [int(input()) for _ in range(N)]
    max1 = max(As)
    max_idx = As.index(max1)
    As.remove(max1)
    max2 = max(As)
    max_list = [max1] * N
    max_list[max_idx] = max2
    for m in max_list:
        print(m)


if __name__ == ""__main__"":
    main()
"
0,"S = input()

R = []
r = 0
for s in S:
    if s == ""R"":
        r += 1
    if s == ""S"":
        R.append(r)
        r = 0
    R.append(r)

print(max(R))
"
0,"n = int(input())
s = input()

dp = [[0] * (n + 1) for _ in range(n + 1)]

res = 0
for i in range(n - 1, -1, -1):
    for j in range(n - 1, i, -1):
        if s[i] == s[j]:
            dp[i][j] = dp[i + 1][j + 1] + 1
            # dp[i][j] = max(dp[i][j], dp[i + 1][j + 1] + 1)
        res = max(res, min(dp[i][j], j - i))
print(res)
"
0,"X, Y, Z = map(int, input())
print(Z, X, Y)
"
1,"N, M = map(int, .split())
a = set([int() for i in range(M)])
MOD = 10**9 + 7
dp = [1]
if 1 in a:
    dp.append(0)
else:
    dp.append(1)
for ith_stair in range(2, N + 1):
    if ith_stair in a:
        dp.append(0)
    else:
        dp.append((dp[ith_stair - 1] + dp[ith_stair - 2]) % MOD)
print(dp[N] % MOD)
"
1,"import heapq

N, M, init_silver = map(int, input().split())
MAX_COST = 2500
init_silver = min(init_silver, MAX_COST)

G = [[] for _ in range(N)]
for i in range(M):
    u, v, silver_cost, time_cost = map(int, input().split())
    u, v = u - 1, v - 1
    G[u].append([v, silver_cost, time_cost])
    G[v].append([u, silver_cost, time_cost])

change_rate, change_cost = [], []
for i in range(N):
    rate, cost = map(int, input().split())
    change_rate.append(rate)
    change_cost.append(cost)


# dp[i][silver] := 頂点iにいて銀貨をsilver枚持っているような状況を作るために必要な最小時間
dp = [[float(""inf"")] * (MAX_COST + 1) for _ in range(N)]
dp[0][init_silver] = 0

# 優先度付きキュー: (time, node, silver)
hq = [(0, 0, init_silver)]
while hq:
    time, node, silver = heapq.heappop(hq)

    self_loop_silver = min(silver + change_rate[node], MAX_COST)
    self_loop_cost = time + change_cost[node]
    if self_loop_cost < dp[node][self_loop_silver]:
        dp[node][self_loop_silver] = self_loop_cost
        heapq.heappush(hq, (time + change_cost[node], node, self_loop_silver))

    for to, silver_cost, time_cost in G[node]:
        remain_silver = min(silver - silver_cost, MAX_COST)
        if remain_silver < 0:
            continue

        dp_next_value = time + time_cost
        if dp[to][remain_silver] <= dp_next_value:
            continue

        dp[to][remain_silver] = dp_next_value
        heapq.heappush(hq, (dp_next_value, to, remain_silver))

pritn(*[min(d) for d in dp[1:]], sep=""\n"")
"
1,"S = input()

print(""Yes"" if all(S.count(s) == 2 for s in input()) else ""No"")

print(unknown_var)"
0,"def main():
    n, m, *a = map(int, open(0).read().split())
    t = {1: 2, 2: 5, 3: 5, 4: 4, 5: 5, 6: 6, 7: 3, 8: 7, 9: 6}
    a.sort(reverse=True)

    dp = [-float(""Inf"")] * (n + 10)
    dp[0] = 0
    for i in range(2, n + 1):
        for j in a:
            dp[i] = max(dp[i], dp[i - t[j]] + 1)

    nums = []
    k = dp[n]
    while n:
        for x in a:
            if dp[n - t[x]] == k - 1:
                nums.append(x)
                n -= t[x]
                break
        k -= 1

    ans = """".join(map(str, nums))
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"import heapq

n, m = map(int, input().split())
lis = []
for i in range(n + 1):
    lis.append([])

for i in range(n):
    a, b = map(int, input().split())
    if a <= m:
        lis[a].append(-b)

cnd = []
heapq.heapify(cnd)
res = 0

for j in range(1, m + 1):
    for e in lis[j]:
        heapq.heappush(cnd, e)
    if cnd:
        res += -heapq.heappop(cnd)
pritn(res)
"
0,"N, K = map(int, input().split())
K = 2
(*h,) = map(int, input().split())
a = [abs(h[0] - h[k]) for k in range(K)]
for n in range(N - K):
    a = a[1:] + [min([a[k] + abs(h[n + k] - h[n + K]) for k in range(K)])]
print(a[K - 1])
"
0,"x = input()

print(x**3)
"
0,"K = int(input())

ans = 1
a = 7
i = K
while i > 0:
    m = a % K
    if m == 0:
        print(ans)
        break
    else:
        ans += 1
        a = m * 10 + 7
        i -= 1
if m != 0:
    print(-1)
"
1,"n, k = map(int, input().split("" ""))
pp = list(map(int, input().split("" "")))

pp_ex = list(map(lambda p (p + 1) / 2, pp))

max_ex = 0
for i in range(k)
    max_ex += pp_ex[i]
bef_ex = max_ex
for i in range(1, n - k + 1)
    ex = bef_ex - pp_ex[i - 1] + pp_ex[i + k - 1]
    bef_ex = ex
    if max_ex < ex
        max_ex = ex

print(max_ex)
"
1,"print(int(input) ** 3)

print(unknown_var)"
1,"n = int(input())
a = [int(i) for i in input().split()]
answer = 1
for i in range(len(a)):
    answer = answer * a[i]
    if answer > 10**18:
        if 0 in a:
            print(0)
        else:
            print(-1)
        break
else:
    print(answer)

print(unknown_var)"
0,"N, W = [int(_) for _ in input().split()]
WV = [[int(_) for _ in input().split()] for _ in range(N)]
dp = {}
dp[0] = 0
for w, v in WV:
    dp_o = dp.copy()
    for k in dp_o:
        if k + w <= W:
            dp[k + w] = max(dp_o.get(k + w, 0), dp_o[k] + v)
print(max([v for k, v in dp.items()]))
"
0,"s = input()
ans = 0
cntA = 0
for i in range(0, len(s) - 1):
    if s[i] == ""A"":
        cntA += 1
    elif s[i : i + 2] == ""BC"":
        ans += cntA
    elif i > 0 and s[i - 1 : i + 1] == ""BC"":
        continue
    else:
        cntA = 0
print(ans)
# print(*data, sep='\n')
"
1,"n = int()
s = 
ans = ""No""
if n % 2 == 0:
    ans = ""Yes""
    for i in range(n / 2):
        if s[i] != s[n / 2 + i]:
            ans = ""No""
            break
print(ans)
"
1,"inputted = input().split()
S = inputted[0]
T = inputted[1]
inputted = list(map(int, input().split()))
A = inputted[0]
B = inputted[1]
U = input()

A2 = A - 1 if U == S else A
B2 = B - 1 if U == T else B

output = A2 + "" "" + B2

pritn(output)
"
1,"from itertools import product, chain

x, y, z, k = list(map(int, .split("" "")))
a = sorted(list(map(int, .split("" ""))))
b = sorted(list(map(int, .split("" ""))))
c = sorted(list(map(int, .split("" ""))))

apb_sorted = sorted([a + b for a, b in product(a, b)])[-k:]
ans_list = sorted(
    list(chain.from_iterable([[_c + ab for ab in apb_sorted] for _c in c[:k]]))
)
it = reversed(ans_list)
for _ in range(k):
    print(next(it))
"
1,"N, T = map(int, .split())

c = set()
for i in range(0, N):
    ci, ti = map(int, .split())
    if ti > T:
        continue
    c.add(ci)

if c:
    print(min(c))
else:
    print(""TLE"")
"
0,"N, M = map(int, input().split())

A = []

for _ in range(M):
    A[int(input())] = True

step = [0] * (N + 1)

step[0] = 1

for s in range(1, N + 1):
    if A[s]:
        step[s] = 0
        continue
    if s == 1:
        step[s] = 1
        continue
    else:
        step[s] = step[s - 1] + step[s - 2]
        step[s] %= 1000000007

print(step[N])
"
1,"N, M = map(int, input().split())
ceil = M // N
for i in range(1, ceil + 1)[-1]
    tmp = M - i * (N - 1)
    if tmp > 0 and tmp % i == 0
        print(i)
        break
"
0,"import os
import sys

import numpy as np

if os.getenv(""LOCAL""):
    sys.stdin = open(""_in.txt"", ""r"")

sys.setrecursionlimit(2147483647)
INF = float(""inf"")


def bisect_right_callable(fn, x, lo, hi):
    """"""
    lo から hi-1 のうち、fn の結果が x 以下となる、最も右の値 + 1
    bisect.bisect_right と同じ
    https://docs.python.org/ja/3/library/bisect.html
    :param callable fn:
    :param x:
    :param int lo: 最小値
    :param int hi: 最大値 + 1
    :return: lo <= ret <= hi
    """"""
    while lo < hi:
        mid = (lo + hi) // 2
        if x < fn(mid):
            hi = mid
        else:
            lo = mid + 1
    return lo


N, X = list(map(int, sys.stdin.readline().split()))
B, L, U = list(zip(*[map(int, sys.stdin.readline().split()) for _ in range(N)]))

B = np.array(B, dtype=int)
L = np.array(L, dtype=int)
U = np.array(U, dtype=int)

# 全部 L で B 点とると仮定する
target = (B * L).sum()

# こうすれば target と比較できる
scores = B * L + (X - B) * U
scores_i = scores.argsort()

scores = scores[scores_i]
scores_cumsum = np.concatenate((scores[::-1].cumsum()[::-1], [0]))
B = B[scores_i]
L = L[scores_i]
U = U[scores_i]


def get_max_score(x):
    # x 点とったときの最大のスコア

    # 満点の数
    perfects = x // X
    # 途中まで頑張るやつは何点取ればいいか
    half_x = x % X

    border = N - perfects
    ret = []
    if len(B[:border]) > 0:
        # 途中まで頑張るやつを 0 点エリアから選択
        ret.append(
            max(
                scores_cumsum[border]
                + np.minimum(half_x, B[:border]) * L[:border]
                + np.maximum(0, half_x - B[:border]) * U[:border]
            )
        )
    if len(B[border:]) > 0:
        # 途中まで頑張るやつを満点エリアから選択
        ret.append(
            max(
                scores_cumsum[border - 1]
                - scores[border:]
                + np.minimum(half_x, B[border:]) * L[border:]
                + np.maximum(0, half_x - B[border:]) * U[border:]
            )
        )
    return max(0, *ret)


ans = bisect_right_callable(get_max_score, target - 1, 0, B.sum())
print(ans)
"
0,"import sys


def input():
    return sys.stdin.readline().strip()


sys.setrecursionlimit(20000000)

MOD = 10**9 + 7
INF = float(""inf"")


class Combination:
    """"""
    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる
    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)
    使用例：
    comb = Combination(1000000)
    print(comb(5, 3))  # 10
    """"""

    def __init__(self, n_max, mod=10**9 + 7):
        self.mod = mod
        self.modinv = self.make_modinv_list(n_max)
        self.fac, self.facinv = self.make_factorial_list(n_max)

    def __call__(self, n, r):
        if n < r:
            return 0
        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod

    def make_factorial_list(self, n):
        # 階乗のリストと階乗のmod逆元のリストを返す O(n)
        # self.make_modinv_list()が先に実行されている必要がある
        fac = [1]
        facinv = [1]
        for i in range(1, n + 1):
            fac.append(fac[i - 1] * i % self.mod)
            facinv.append(facinv[i - 1] * self.modinv[i] % self.mod)
        return fac, facinv

    def make_modinv_list(self, n):
        # 0からnまでのmod逆元のリストを返す O(n)
        modinv = [0] * (n + 1)
        modinv[1] = 1
        for i in range(2, n + 1):
            modinv[i] = self.mod - self.mod // i * modinv[self.mod % i] % self.mod
        return modinv


def main():
    X, Y = map(int, input().split())
    if (X + Y) % 3 != 0:
        print(0)
        return
    a = (X + Y) // 3
    two = X - a
    if two < 0:
        print(0)
        return
    if two == 0:
        print(1)
        return
    cmb = Combination(a + 1)
    print(cmb(a, two))


if __name__ == ""__main__"":
    main()
"
1,"import math


def main()
    N = int(input())

    if N == 0 or N == 1
        ans = 0

    elif N % 2 == 0
        B = N // 2
        n = math.floor(math.log(B) / math.log(5))

        ans = 0
        for i in range(1, n + 1)
            ans += B // (5**i)

    else
        ans = 0

    print(int(ans))


main()
"
1,"from collections import deque


def solve(string):
    n, q, *abpx = map(int, string.split())
    ab, px = abpx[: 2 * n - 2], abpx[2 * n - 2 :]
    check = [True] * (n + 1)
    t = {i: [] for i in range(n + 1)}
    c = [0] * (n + 1)
    d = deque([1])
    for a, b in zip(*[iter(ab)] * 2):
        t[a].append(b)
        t[b].append(a)
    for p, x in zip(*[iter(px)] * 2):
        c[p] += x
    while len(d) > 0:
        curr = d.pop()
        check[curr] = False
        next_ = [i for i in t[curr] if check[i]]
        for n_ in next_:
            c[n_] += c[curr]
        d.extend(next_)
    return "" "".join([str(_c) for _c in c[1:]])


if __name__ == ""__main__"":
    n, m = map(int, input().split())
    pritn(solve(""{} {}\n"".format(n, m) + ""\n"".join([input() for _ in range(n + m)])))
"
1,"import math

a, b, c = map(int, input().split())

result = math.sqrt(a) + math.sqrt(b) < math.sqrt(c)

if result:
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
0,"import sys
from collections import Counter

m = Counter(sys.stdin.read.lower())
for i in ""abcdefghijklmnopqrstuvwxyz"":
    print(i, "":"", m[i])
"
0,"def main():
    import sys

    input = sys.stdin.readline

    x, y, z, k = map(int, input().split())
    A = sorted(map(int, input().split()), reverse=True)
    B = sorted(map(int, input().split()), reverse=True)
    C = sorted(map(int, input().split()), reverse=True)

    ret = []
    for p, a in enumerate(A):
        for q, b in enumerate(B):
            if p * q > k:
                break
            for r, c in enumerate(C):
                if p * q * r > k:
                    break
                ret.append(a + b + c)
    ret.sort(reverse=True)
    print(*ret[:k], sep=""\n"")


main()

# O(Klog^3K)
# https://img.atcoder.jp/abc123/editorial.pdf
"
1,"import sys

sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input():
    return sys.stdin.readline().strip()


def main():
    N, W = map(int, input().split())
    item = []
    for _ in range(N):
        w, v = map(int, input().split())
        item.append((w, v))

    dp = [0] * (W + 1)
    for w, v in item:
        for i in range(w, W + 1)[::-1]:
            tmp = dp[i - w] + v
            if tmp > dp[i]:
                dp[i] = tmp

    print(max(dp))


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"n, m = map(int, input().split())

a = set()
for i in range(m)
    a_tmp = int(input())
    a.add(a_tmp)

# a = [int(input()) for i in range(m)]

dp = [0] * (n + 1)
for i in range(n + 1)
    if i in a
        dp[i] = 0
    else
        if i == 0
            dp[i] = 1
        elif i == 1
            dp[i] = 1
        else
            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007
print(dp[n])
"
1,"n = int(input())
a = list(map(int, input().split()))
x = 0
y = sum(a)
ans = 2020202020
for i in range(n - 1)
    x += a[i]
    y -= a[i]
    ans = min(ans, abs(x - y))
print(ans)
"
0,"N, M = [int(_) for _ in input().split()]
bridge = [[int(_) for _ in input().split()] for _ in range(M)]

bridge.reverse()
bridge = bridge[:-1]

inconvenience = N * (N - 1) // 2
inconvenience_history = [inconvenience]


class UnionFind:
    def __init__(self, N):
        self.par = [i for i in range(N + 1)]
        self.rank = [0] * (N + 1)
        self._number = [1] * (N + 1)

    def root(self, i):
        if self.par[i] == i:
            return i
        self.par[i] = self.root(self.par[i])
        return self.par[i]

    def tree_rank(self, i):
        return self.rank[self.root(i)]

    def number(self, i):
        return self._number[self.root(i)]

    def union(self, i, j):
        _root_i = self.root(i)
        _root_j = self.root(j)
        if _root_i == _root_j:
            return
        else:
            if self.tree_rank(i) < self.tree_rank(j):
                self.par[_root_i] = _root_j
                self._number[_root_j] += self._number[_root_i]
            else:
                self.par[_root_j] = _root_i
                self._number[_root_i] += self._number[_root_j]
                if self.tree_rank(i) == self.tree_rank(j):
                    self.rank[_root_i] += 1


islands = UnionFind(N)

for A_i, B_i in bridge:
    islands.pri()

    root_A = islands.root(A_i)
    root_B = islands.root(B_i)

    if root_A == root_B:
        inconvenience_history.append(inconvenience)
        continue
    else:
        improvement = islands.number(A_i) * islands.number(B_i)
        islands.union(A_i, B_i)

        inconvenience -= improvement
        if inconvenience == 0:
            inconvenience_history += [0] * (M - len(inconvenience_history))
            break
        inconvenience_history.append(inconvenience)

print(*inconvenience_history[::-1], sep=""\n"")
"
1,"from math import ceil


def main(N, A, B, C, D, E):
    loads = [A, B, C, D, E]
    min_val = min(loads)
    min_index = loads.index(min_val)

    res = min_index + ceil(N / min_val) + (5 - (min_index + 1))

    return res


if __name__ == ""__main__"":
    N = input()
    A = input()
    B = input()
    C = input()
    D = input()
    E = input()
    print(main(N, A, B, C, D, E))

print(unknown_var)"
0,"print(int(input() ** 3))
"
0,"def main():
    # from math import gcd

    def gcd(a, b):
        return a if b == 0 else gcd(b, a % b)

    A, B, K = map(int, input().split())

    g = gcd(A, B)
    rt = int(pow(g, 0.5))

    divisors = set()
    for d in range(1, rt + 1):
        if g % d == 0:
            divisors.add(d)
            divisors.add(g // d)

    ans = sorted(divisors, reverse=True)[K - 1]
    print(ans)


if __name__ == ""__main__"":
    main()

# import sys
#
# sys.setrecursionlimit(10 ** 7)
#
# input = sys.stdin.readline
# rstrip()
# int(input())
# map(int, input().split())
"
1,"N = int(input())
A = list(map(int, input().split()))
ans = 1
if 0 in A:
    pritn(0)
else:
    for a in A:
        ans *= a
        if ans > 10**18:
            ans = -1
            break
    pritn(ans)
"
1,"from collections import defaultdict, deque

N, M, P = map(int, .split())
G = defaultdict(lambda: defaultdict(lambda: 10000000))
G_rev = defaultdict(lambda: defaultdict(lambda: 10000000))

for i in range(1, N + 1):
    G[i] = dict()
    G_rev[i] = dict()

for _ in range(M):
    A, B, C = map(int, .split())
    G[A][B] = min(G[A][B], P - C)
    G_rev[B][A] = 1

reachable_N = [0] * (N + 1)
reachable_N[N] = 1
queue = deque([N])

while len(queue) > 0:
    p = queue.popleft()
    for q in G_rev[p].keys():
        if reachable_N[q] == 0:
            reachable_N[q] = 1
            queue.append(q)

reachable_1 = [0] * (N + 1)
reachable_1[1] = 1
queue = deque([1])

while len(queue) > 0:
    p = queue.popleft()
    for q in G[p].keys():
        if reachable_1[q] == 0:
            reachable_1[q] = 1
            queue.append(q)

reachable = [reachable_1[i] * reachable_N[i] for i in range(N + 1)]

dist = [10000000000 for i in range(N + 1)]
res = 0
dist[1] = 0
queue = deque([1])
cnt = 0

update = True

while update:
    update = False
    for p in range(1, N + 1):
        if reachable[p] == 0:
            continue
        for q in G[p].keys():
            if reachable[q] == 0:
                pass
            elif dist[p] + G[p][q] < dist[q]:
                dist[q] = dist[p] + G[p][q]
                update = True
    cnt += 1
    if cnt > N:
        res = -1
        break

if res == -1:
    print(res)
else:
    print(max(0, -dist[N]))
"
1,"N = int(input())
b_list = list(map(int, input().split()))

generate_seq = []


def is_ok(b):
    len_b = len(b)
    if len_b == 1 and b[0] == 1:
        generate_seq.append(1)
        return True

    for idx, val in enumerate(b):
        if idx + 1 < val:
            return False

    processing = []
    for idx in range(len_b):
        if b[idx] != idx + 1:
            processing.append(False)
        else:
            b_tmp = b[:]
            del b_tmp[idx]
            tmp = is_ok(b_tmp)
            if tmp:
                generate_seq.append(idx + 1)
                return True
    return False


result = is_ok(b_list)
if result:
    print(""\n"".join(list(map(str, generate_seq))))
else:
    print(-1)

print(unknown_var)"
0,"a = list(map(int, input().split()))
[print(*i) for i in a.sort()]
"
1,"number = input(int())
print(number**3)

print(unknown_var)"
0,"MOD = 10**9 + 7
K = int(input())
S = input()
N = len(S)


class Combination:
    """"""
    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる
    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)
    使用例：
    comb = Combination(1000000)
    print(comb(5, 3))  # 10
    """"""

    def __init__(self, n_max, mod=10**9 + 7):
        self.mod = mod
        self.modinv = self.make_modinv_list(n_max)
        self.fac, self.facinv = self.make_factorial_list(n_max)

    def __call__(self, n, r):
        if n < r or n < 0 or r < 0:
            return 0
        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod

    def make_factorial_list(self, n):
        # 階乗のリストと階乗のmod逆元のリストを返す O(n)
        # self.make_modinv_list()が先に実行されている必要がある
        fac = [1]
        facinv = [1]
        for i in range(1, n + 1):
            fac.append(fac[i - 1] * i % self.mod)
            facinv.append(facinv[i - 1] * self.modinv[i] % self.mod)
        return fac, facinv

    def make_modinv_list(self, n):
        # 0からnまでのmod逆元のリストを返す O(n)
        modinv = [0] * (n + 1)
        modinv[1] = 1
        for i in range(2, n + 1):
            modinv[i] = self.mod - self.mod // i * modinv[self.mod % i] % self.mod
        return modinv


comb = Combination(1000000)
ans = 0
for i in range(K + 1):
    temp = comb(N + K - i - 1, N - 1)
    temp %= MOD
    temp *= pow(26, i, MOD)
    temp %= MOD
    temp *= pow(25, K - i, MOD)
    temp %= MOD
    ans += temp
    ans %= MOD
print(ans)
"
0,"A = int(input())
B = int(input())
C = int(input())
if A == B and B == C:
    print(""Yes"")
else:
    print(""No"")
"
1,"N = int(input())
P = list(map(int, input().split()))
Q = []
m = 10**17
for p in P
    m = min(m, p)
    Q.append(m)
c = 0
for x, y in zip(P, Q)
    if x <= y
        c += 1
print(c)
"
1,"import sys
from collections import deque

input = sys.stdin.readline

S = deque([:-1])
reverse_flg = 0
Q = int()
qs = [.split() for _ in range(Q)]
for q in qs:
    if q[0] == ""1"":
        reverse_flg = reverse_flg ^ 1
    else:
        flg = (int(q[1]) + reverse_flg) % 2
        if flg == 1:
            S.appendleft(q[2])
        else:
            S.append(q[2])

if reverse_flg:
    S.reverse()
print("""".join(S))
"
0,"from fractions import gcd

n = int(input())
aaa = list(map(int, input().split()))
MOD = 10**9 + 7
lcm = aaa[0]
for a in aaa[1:]:
    lcm = lcm * a // gcd(lcm, a)

ans = sum(lcm // a for a in aaa) % MOD
print(ans)
"
0,"N = int(input())
b_list = list(map(int, input().split()))

generate_seq = []


def is_ok(b):
    len_b = len(b)
    if len_b == 1 and b[0] == 1:
        generate_seq.append(1)
        return True

    for idx, val in enumerate(b):
        if idx + 1 < val:
            return False

    processing = []
    for idx in range(len_b):
        if b[idx] != idx + 1:
            processing.append(False)
        else:
            b_tmp = b[:]
            del b_tmp[idx]
            tmp = is_ok(b_tmp)
            if tmp:
                generate_seq.append(idx + 1)
                return True
    return False


result = is_ok(b_list)
if result:
    print(""\n"".join(list(map(str, generate_seq))))
else:
    print(-1)
"
0,"from math import gcd


def eratosthenes(n):
    prime = []
    data = [i for i in range(n - 1)]
    while True:
        p = data[0]
        if n <= p**2:
            return prime + data
        prime.append(p)
        data = [e for e in data if e % p != 0]
    return data


def factorize(N):  # 素因数分解
    prime = set()
    for p in prime_list:
        if p * p > N:
            break
        while N % p == 0:
            N //= p
            prime.add(p)
    if N > 1:
        prime.add(N)
    return prime


n = int(input())
a = list(map(int, input().split()))

ans = 0
for ai in a:
    ans = gcd(ans, ai)
if ans != 1:
    print(""not coprime"")
    exit()

prime_list = eratosthenes(10**6)
num = set()
for ai in a:
    prime = factorize(ai)
    if len(prime & num) > 0:
        print(""setwise coprime"")
        break
    num |= prime
else:
    print(""pairwise coprime"")
"
1,"def solve(string):
    n, *ab = map(int, string.split())
    a, b = ab[: n + 1], ab[n + 1 :]
    _sum = sum(a)
    for i, _b in enumerate(b[::-1]):
        if a[n - i] < _b:
            _b -= a[n - i]
            a[n - i] = 0
            a[n - i - 1] = max(0, a[n - i - 1] - _b)
        else:
            a[n - i] -= _b
    return str(_sum - sum(a))


if __name__ == ""__main__"":
    n = int(input())
    print(solve(""{}\n"".format(n) + ""\n"".join([input() for _ in range(2)])))

print(unknown_var)"
0,"x = input()
print(x**3)
"
1,"N, K = map(int, .split())
P = list(map(int, .split())).sort()
print(sum(P[:K]))
"
0,"n = int(input())
A = list(map(int, input().split()))
ans = 1000
for i in range(n - 1):
    if A[i] < A[i + 1]:
        ans += ans // A[i] * (A[i + 1] - A[i])
print(ans)
"
0,"import sys
from collections import defaultdict

sys.setrecursionlimit(10**6)


def dfs(v, p, ccc, links, ans):
    ret_colors = defaultdict(int)
    ret_count = 1
    cv = ccc[v]
    for u in links[v]:
        if u == p:
            continue
        sub_colors, sub_count = dfs(u, v, ccc, links, ans)
        cc = sub_count - sub_colors[cv]
        ans[cv] -= cc * (cc + 1) // 2
        ret_count += sub_count

        if len(ret_colors) < len(sub_colors):
            ret_colors, sub_colors = sub_colors, ret_colors

        for c, cnt in sub_colors.items():
            ret_colors[c] += cnt

    ret_colors[cv] = ret_count

    return ret_colors, ret_count


def solve(n, ccc, links):
    if n == 1:
        return [1]

    all_pair = n * (n + 1) // 2
    ans = [all_pair] * (n + 1)

    colors, count = dfs(0, -1, ccc, links, ans)
    assert count == n

    for c in range(1, n + 1):
        cc = n - colors[c]
        ans[c] -= cc * (cc + 1) // 2

    return ans[1:]


n, *cab = map(int, sys.stdin.buffer.read().split())
ccc = cab[:n]
links = [set() for _ in range(n)]

for a, b in zip(cab[n + 0 :: 2], cab[n + 1 :: 2]):
    a -= 1
    b -= 1
    links[a].add(b)
    links[b].add(a)

print(""\n"".join(map(str, solve(n, ccc, links))))
"
0,"x = input()
print(x**3)
"
1,"x1, y1, x2, y2 = map(float, input().split())
pritn(""%.8f"" % (((x2 - x1) ** 2 + (y2 - y1) ** 2)) ** 0.5)
"
0,"def solve():
    n, k = map(int, input().split())
    h = sorted(list(int(input()) for _ in range(n)))
    return min(h[i + k - 1] - h[i] for i in range(n - k + 1))


if __name__ == ""__main__"":
    print(solve())
"
0,"a, b, c = 7, 4, 2
k = int(input())

while a >= b and k > 0:
    b *= 2
    k -= 1

while b >= c and k > 0:
    c *= 2
    k -= 1

if a < b < c:
    print(""Yes"")
else:
    print(""No"")
"
0,"N, K = map(int, input().split())
H = map(int, input().split())

H.sort(reverse=True)

if K >= N:
    print(0)
else:
    print(sum(H[K:]))
"
1,"from fractions import gcd

N, X = map(int, input().split())
X_list = list(map(int, input().split()))

dX = [abs(X - x) for x in X_list]
if len(dX) == 1:
    pritn(dX[0])
    exit(0)

D = [abs(X_list[i] - X_list[i + 1]) for i in range(0, N - 1)]
res = gcd(D[0], D[1])
for x in D[2:]:
    res = gcd(res, x)

ans = 0
for d in dX:
    ans = max(gcd(res, d), ans)
pritn(ans)
"
0,"s = input()
zom = min(s.count(""1""), s.count(""0""))
if len(set(list(s))) == 1:
    zom = 0
print(zom * 2)
"
1,"n = int(input())
str_dic = {}
for _ in range(n):
    inp = input()
    if inp in str_dic:
        str_dic[inp] += 1
    else:
        str_dic[inp] = 1

max_num = max(str_dic.values())

max_str = [s[0] for s in str_dic.items() if s[1] == max_num]

for s in sorted(max_str):
    pritn(s)
"
0,"import bisect

N = int(input())
L = [int(i) for i in input().split()]

SL = sorted(L)
ans = 0
for i in range(N - 2):
    for j in range(i + 1, N - 1):
        right = bisect.bisect_left(SL, SL[i] + SL[j])
        left = j + 1
        ans += max(right - left)

print(ans)
"
0,"n = int(input())

print((n * (n - 1)) // 2)
"
0,"N, A, B, C = map(int, input().split())
opts = []
for _ in range(N):
    opt = input()
    opts.append((ord(opt[0]) - ord(""A""), ord(opt[1]) - ord(""A"")))

choices = []
nums = [A, B, C]
for i, opt in enumerate(opts):
    if nums[opt[0]] == 0 and nums[opt[1]] == 0:
        print(""No"")
        break
    if nums[opt[0]] == 1 and nums[opt[1]] == 1:
        if i < N - 1 and opt != opts[i + 1]:
            choice = (set(opt) & set(opts[i + 1])).pop()
            nums[choice] += 1
            nums[choice ^ opt[0] ^ opt[1]] -= 1
            choices.append(choice)
            continue
    if nums[opt[0]] >= nums[opt[1]]:
        choices.append(opt[1])
        nums[opt[1]] += 1
        nums[opt[0]] -= 1
    else:
        choices.append(opt[0])
        nums[opt[0]] += 1
        nums[opt[1]] -= 1
else:
    print(""Yes"")
    for c in choices:
        print(chr(c + ord(""A"")))
"
0,"from fractions import gcd

# from math import gcd
from functools import reduce

N, M = map(int, input().split())
nums = set([num // 2 for num in list(map(int, input().split()))])
# 1<=X<=Mの範囲で、半公倍数の数を求める。
# 但し、Xは、num*(p+0.5)でなければならない
# Mが10**9なので、全部やるのは無理。
# n.5倍なので、numsのあたいは全て偶数になっている。

# nums一つ一つ、答えになりうるXの配列を作って、重複したものを残せばそれが答えになる。
# Nが10**5なので、どうだろう


def half_multiple(x, y):
    return (x * y) // gcd(x, y)


def run():
    half_multiple_num = reduce(half_multiple, nums, 1)

    # print(half_multiple_num)
    for num in nums:
        if (half_multiple_num // num) % 2 == 0:
            print(0)
            return

    pmax = M // half_multiple_num
    pmax = pmax - 1 if pmax % 2 == 0 else pmax

    print((pmax + 1) // 2)


run()
"
0,"s = input()
a = s.count(""0"")
b = s.count(""1"")
print(min(a, b) * 2)
"
0,"def main():
    n = int(input())
    words = {}
    for _ in range(n):
        a = input()
        if a in words:
            words[a] += 1
        else:
            words[a] = 1

    max_val = max(words.values())
    # words_sorted = sorted(words.items(), key=lambda x: x[0])
    for key, value in sorted(words):
        if value != max_val:
            continue
        else:
            print(key)
            # key valueを両方printするとき
            # print('{}:{}'.format(key, value))


if __name__ == ""__main__"":
    main()
"
1,"s = input()

ans = 0

s_0 = s.replace(""0"", """")
n_0 = len(s) - len(s_0)
s_1 = s.replace(""1"", """")
n_1 = len(s) - len(s_1)

print(2 * min(n_0, n_1))
"
0,"H, N = map(int, input().split())
total_A = sum(list(map(int, input.split())))

if H <= total_A:
    print(""Yes"")
else:
    print(""No"")
"
1,"N = int(input())
X_list = list(map(int, input().split()))

hp_list = []
for p in range(int(min(X_list)), int(max(X_list))):
    hp = 0
    for x in X_list:
        hp += abs(x - p) ** 2
    hp_list.append(hp)

print(min(hp_list) if len(hp_list) > 0 else 0)

print(unknown_var)"
1,"S = input()
T = input()

dic = {}
dic_rev = {}


def solve():
    for s, t in zip(S, T):
        if t in dic.keys():
            if s != dic[t]:
                pritn(""No"")
                return
        else:
            dic[t] = s
    for s, t in zip(S, T):
        if t in dic_rev.keys():
            if t != dic_rev[s]:
                pritn(""No"")
                return
        else:
            dic_rev[s] = t
    pritn(""Yes"")
    return


solve()
"
0,"#!/usr/bin/python3

import os
import sys


def main():
    N = read_int()
    A = read_ints()
    print(solve(N, A))


MOD = 1000000007


def solve(N, A):
    c = 1
    nums = [0, 0, 0]

    for a in A:
        z = nums.count(a)
        if z == 0:
            return 0
        c *= z
        c %= MOD
        nums[nums.index(a)] = a + 1

    return c


###############################################################################

DEBUG = ""DEBUG"" in os.environ


def inp():
    return sys.stdin.readline().rstrip()


def read_int():
    return int(inp())


def read_ints():
    return [int(e) for e in inp().split()]


def dprint(*value, sep="" "", end=""\n""):
    if DEBUG:
        print(*value, sep=sep, end=end)


if __name__ == ""__main__"":
    main()
"
1,"def solve(string):
    from collections import deque

    n, m, *ab = map(int, string.split())
    p = [[] for _ in range(n)]
    for a, b in zip(*[iter(ab)] * 2):
        p[a - 1].append(b - 1)
        p[b - 1].append(a - 1)
    s, ans, d = deque([0]), [0] * n, [0] + [n] * (n - 1)
    while s:
        c = s.popleft()
        for t in p[c]:
            if d[c] + 1 < d[t]:
                d[t] = d[c] + 1
                ans[t] = c + 1
                s.append(t)
    return ""Yes\n"" + ""\n"".join(map(str, ans[1:]))


if __name__ == ""__main__"":
    import sys

    print(solve(sys.stdin.read().strip()))

print(unknown_var)"
1,"a, b = map(int, .split())
print(6 - a - b)
"
0,"m1, d1 = map(int, input().split())
m2, d2 = map(int, input().split())

if m1 != m2:
    print(""1"")
else:
    print(""0"")
"
1,"k = int(input())
if k % 7 == 0
    L = 9 * k // 7
else
    L = 9 * k
out = -1
s = 10
for i in range(L)
    if s % L == 1
        out = i + 1
        break
    else
        s = (s % L) * 10
print(out)
"
0,"n = int(input())
a = list(map(int, input().split("" "")))

b = [j - i for i, j in enumerate(a, start=1)]
# c = [-j - i for i, j in enumerate(a, start=1)]
count = {}
for i, j in enumerate(a, start=1):
    num = -i - j
    if num not in count:
        count[num] = 0
    count[num] += 1
result = sum([count.get(i, 0) for i in b])
print(result)
"
0,"answer = 1
lens = int(input())
arrs = [int(x) for x in input().split()]
if 0 in arrs:
    answer = 0
else:
    for x in arrs:
        answer *= x
        if answer > int(10**18):
            answer = -1
            break
print(answer)
"
0,"H, W = map(int, input().split())
M = (H + W) * 80

A = [tuple(map(int, input().split())) for _ in range(H)]
B = [tuple(map(int, input().split())) for _ in range(H)]

dp = [[0] * W for _ in range(H)]
dp[0][0] = 1 << (M - abs(A[0][0] - B[0][0]))

for h in range(H):
    for w, (a, b) in enumerate(zip(A[h], B[h])):
        d = abs(a - b)
        mask = 0
        if h > 0:
            mask |= dp[h - 1][w] << d
            mask |= dp[h - 1][w] >> d
        if w > 0:
            mask |= dp[h][w - 1] << d
            mask |= dp[h][w - 1] >> d
        dp[h][w] |= mask

state = dp[-1][-1]
nums = []
for digit, b in enumerate(bin(state)[2:][::-1]):
    if b == ""1"":
        nums.append(digit - M)
ans = min(abs(n) for n in nums)
print(ans)
"
1,"def solve():
    N, M = map(int, .split())
    A = []
    if M != 0:
        A = [int() for _ in range(M)]
    A.sort(reverse=True)
    mm = 10**9 + 7
    dp = [0] * (N + 1)
    dp[0] = 1  # 0段目に行くパターンは1とする
    tag = -1
    if len(A) != 0:
        tag = A.pop()
    # 1段目のパターンを設定
    if tag == 1:
        dp[1] = 0
        if len(A) == 0:
            tag = -1
        else:
            tag = A.pop()
    else:
        dp[1] = 1
    for i in range(2, N + 1):
        if i == tag:
            if len(A) == 0:
                tag = -1
            else:
                tag = A.pop()
            continue
        dp[i] = (dp[i - 1] + dp[i - 2]) % mm
    print(dp[N])


if __name__ == ""__main__"":
    solve()
"
1,"N = int(input())
A = list(map(int, input().split()))
result = 1
flag = 0
zero_flag = 0
for a in A:
    if a == 0:
        zero_flag = 1
        result = 0
        break
    else:
        result = result * a
        if result > pow(10, 18):
            flag = 1
            result = 0
if flag == 1 and zero_flag != 1:
    pritn(-1)
else:
    pritn(result)
"
0,"A = input()
B = input()

A = int(A)
B = int(B)

if A > B:
    X = A
    A = A - 1

else:
    X = B
    B = B - 1

if A > B:
    X = X + A
else:
    X = X + B

print(X)
"
0,"#!/usr/bin/env python3
(n,), *r = [[*map(int, i.split())] for i in open(0)]
s = sorted([[x + l, x - l] for x, l in r])
c = 1
p = s[0][0]
for i in s[1:]:
    if i[1] >= p:
        c += 1
        p = i[0]
print(c)
"
1,"x = input()

pritn(x * x * x)
"
1,"def solve(s):
    k = 10**9
    if s <= k:
        return 0, 0, 1, 0, 0, s
    X = k
    while True:
        Y = (s - 1) // X + 1
        while Y <= k:
            xy = X * Y - s
            if xy == 0:
                return 0, 0, X, 0, 0, Y
            lim = min(Y, int(xy**0.5))
            for y in range(1, lim + 1):
                x, m = divmod(xy, y)
                if x <= X and m == 0:
                    return 0, 0, X, y, x, Y
            Y += 1
        X -= 1


s = int(input())
print(*solve(s))

print(unknown_var)"
0,"a, b, c, k = map(int, input().split())

ans = 0

if a > k:
    ans += 1 * k
    k = 0
else:
    ans += 1 * a
    k -= a

if b > k:
    ans += 0 * k
    k = 0
else:
    ans += 0 * b
    k -= b

if c > k:
    ans += -1 * k
    k = 0
else:
    ans += -1 * c
    k -= c


print(ans)
"
0,"import os
import sys

import numpy as np


def solve(inp):
    def bitree_sum(bit, t, i):
        s = 0
        while i > 0:
            s += bit[t, i]
            i ^= i & -i
        return s

    def bitree_add(bit, n, t, i, x):
        while i <= n:
            bit[t, i] += x
            i += i & -i

    def bitree_lower_bound(bit, n, d, t, x):
        sum_ = 0
        pos = 0
        for i in range(d, -1, -1):
            k = pos + (1 << i)
            if k <= n and sum_ + bit[t, k] < x:
                sum_ += bit[t, k]
                pos += 1 << i
        return pos + 1

    def initial_score(d, ccc, sss, ttt):
        bit_n = d + 3
        bit = np.zeros((26, bit_n), dtype=np.int64)
        INF = 10**18
        for t in range(26):
            bitree_add(bit, bit_n, t, bit_n - 1, INF)

        last = np.full(26, -1, dtype=np.int64)
        score = 0

        for i in range(d):
            t = ttt[i]
            score += sss[i, t]
            for u in range(26):
                if u == t:
                    continue
                score -= ccc[u] * (i - last[u])
            last[t] = i
            bitree_add(bit, bit_n, t, i + 2, 1)

        return bit, score

    def update_score(bit, bit_n, bit_d, ccc, sss, ttt, d, q):
        diff = 0
        t = ttt[d]
        k = bitree_sum(bit, t, d + 2)
        c = bitree_lower_bound(bit, bit_n, bit_d, t, k - 1) - 2
        e = bitree_lower_bound(bit, bit_n, bit_d, t, k + 1) - 2
        b = ccc[t]
        diff -= b * (d - c) * (e - d)
        diff -= sss[d, t]

        k = bitree_sum(bit, q, d + 2)
        c = bitree_lower_bound(bit, bit_n, bit_d, q, k) - 2
        e = bitree_lower_bound(bit, bit_n, bit_d, q, k + 1) - 2
        b = ccc[q]
        diff += b * (d - c) * (e - d)
        diff += sss[d, q]

        return diff

    d = inp[0]
    ccc = inp[1:27]
    sss = np.zeros((d, 26), dtype=np.int64)
    for r in range(d):
        sss[r] = inp[27 + r * 26 : 27 + (r + 1) * 26]

    ttt = np.random.choice(26, d)

    bit, score = initial_score(d, ccc, sss, ttt)
    bit_n = d + 3
    bit_d = int(np.log2(bit_n))

    for _ in range(5 * 10**6):
        cd = np.random.randint(0, d)
        ct = np.random.randint(0, 26)
        diff = update_score(bit, bit_n, bit_d, ccc, sss, ttt, cd, ct)
        if diff > 0:
            score += diff
            bitree_add(bit, bit_n, ttt[cd], cd + 2, -1)
            bitree_add(bit, bit_n, ct, cd + 2, 1)
            ttt[cd] = ct

    return ttt + 1


if sys.argv[-1] == ""ONLINE_JUDGE"":
    from numba.pycc import CC

    cc = CC(""my_module"")
    cc.export(""solve"", ""(i8[:],)"")(solve)
    cc.compile()
    exit()

if os.name == ""posix"":
    # noinspection PyUnresolvedReferences
    from my_module import solve
else:
    from numba import njit

    solve = njit(""(i8[:],)"", cache=True)(solve)
    print(""compiled"", file=sys.stderr)

inp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep="" "")
ans = solve(inp)
print(""\n"".join(map(str, ans)))
"
1,"n, m = map(int, input().split())
res = [0] * m

for i in range(n)
    o = list(map(int, input().split()))
    for j, x in enumerate(o)
        if j != 0
            res[x - 1] += 1

ans = sum(1 for x in res if x == n)

print(ans)
"
1,"n = int(input())
nlist = list(map(int, input().split()))
W = [0 for i in range(n)]


def M(l, r)  ##l~r-1 까지의 리스트.
    if l + 1 >= r
        return 0
    elif l + 2 == r
        if nlist[l] <= nlist[l + 1]
            return 0
        else
            nlist[l], nlist[l + 1] = nlist[l + 1], nlist[l]
            return 1
    ##위의 if문으로 (r-l)가 2이하일 경우는 해놓음
    m = (l + r) // 2
    i = l
    j = m
    k = l
    cl = M(l, m)
    cr = M(m, r)
    c = 0
    while i < m and j < r
        if nlist[i] <= nlist[j]
            W[k] = nlist[i]  ##l부터 r까지 W에 크기순으로 대입해나감
            k += 1
            i += 1
        else
            W[k] = nlist[j]  ##일단 W[k]에는 더 작은쪽을 저장하는듯
            k += 1
            j += 1
            c += m - i  ##만약 nlist[i] > nlist[j]라면 i~m-1 까지 반전 하고있기 때문
            ##그러고 더 작은 nlist[j]를 안에 넣는것.
    while i < m  ##i번째쪽에 더 큰것들이 남았을 경우 (j=r 이 되있는 상황이기에 더 반전수를 늘리지는 않음)
        W[k] = nlist[i]
        k += 1
        i += 1
    while j < r  ##j쪽에 큰게 남아있는경우도 동일
        W[k] = nlist[j]
        k += 1
        j += 1
    for i in range(l, r)
        nlist[i] = W[i]
    return cl + cr + c


print(M(0, n))
"
0,"import sys

sys.setrecursionlimit(10**9)


def rec(edges, nodes, cp, cdistance, visited):
    if not visited[cp]:
        visited[cp] = True
        nodes[cp] = cdistance % 2 == 0
        if edges[cp]:
            for v, w in edges[cp]:
                rec(edges, nodes, v, cdistance + w, visited)


def main():
    N = int(input())
    nodes = [False] * N
    visited = [False] * N
    edges = [[] for _ in range(N)]

    for _ in range(N - 1):
        u, v, w = map(int, input().split())
        edges[u - 1].append((v - 1, w))
        edges[v - 1].append((u - 1, w))

    rec(edges, nodes, 0, 0, visited)

    for n in nodes:
        print(0 if n else 1)


if __name__ == ""__main__"":
    main()
"
0,"N, M = map(int, input().split())
sc = [tuple(map(int, input().split())) for _ in range(M)]

for i in range(1000):
    t = str(i)
    if len(t) != N:
        continue
    ok = True
    for s, c in sc:
        if int(t[s - 1]) != c:
            ok = False
            break
    if ok:
        print(i)
        exit()
print(-1)
"
0,"A, B, M = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

s = []
s.append(min(a) + min(b))

for i in range(M):
    x_i, y_i, c_i = map(int, input().split())
    minus = a[x_i - 1] + b[y_i - 1] - c_i
    s.append(minus)

print(min(s))
"
0,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(10**7)

n, m = map(int, readline().split())
if m == 0:
    if n == 1:
        print(0)
    else:
        print(""1"" + ""0"" * (n - 1))
    exit()
sc = [list(map(int, readline().split())) for i in range(m)]
sc.sort()
memo = sc[0]
if sc[0] == [1, 0] and n != 1:
    print(-1)
    exit()
for i in range(1, m):
    if memo[0] == sc[i][0]:
        if memo[1] != sc[i][1]:
            print(-1)
            exit()
    else:
        memo = sc[i]
ans = """"
for i in range(n):
    for j in range(m):
        if i + 1 == sc[j][0]:
            ans += str(sc[j][1])
            break
    if len(ans) != i + 1:
        if len(ans) == 0:
            ans += ""1""
        else:
            ans += ""0""
print(ans)
"
1,"s = map(int, input().split(""/""))
print(""Heisei"" if s <= 20190430 else ""TBD"")

print(unknown_var)"
0,"a = map(int, input().split())
s = list(map(int, input().split()))

print(len(set(s)))
"
0,"def solve(string):
    n, *a = map(int, string.split())
    a = (""{:060b}"".format(_a) for _a in a)
    m = 10**9 + 7
    ans = 0
    for s in map(str.count(""1""), zip(*a)):
        ans <<= 1
        ans += s * (n - s)
        ans %= m
    return str(ans)


if __name__ == ""__main__"":
    import sys

    print(solve(sys.stdin.read().strip()))
"
0,"ht, st, ha, sa = list(map(int, input().split("" "")))
bool_player = True  # Takashi
while ht > 0 and ha > 0:
    if bool_player:
        ha -= st
        bool_player = False
    else:
        ht -= sa
        bool_player = True

if ht <= 0:
    print(""No"")
else:
    print(""Yes"")
"
1,"A, B, N = map(int, input().split())
X = min(N, B - 1)
pritn(A * X // B - A * (X // B))
"
0,"N = int(input())
A = list(map(int, input().split("" "")))
Q = int(input())
BC = [list(map(int, list(input().split("" "")))) for i in range(Q)]

count = [0] * 10**5 + 5
for i in range(N):
    count[A[i]] += 1

s = sum(A)
for i in range(Q):
    s = s - BC[i][0] * count[BC[i][0]] + BC[i][1] * count[BC[i][0]]
    count[BC[i][1]] += count[BC[i][0]]
    count[BC[i][0]] = 0
    print(s)
"
1,"N = int(input())
A = [int(input()) for _ in range(N)]
sorted_A = sorted(A)
[pritn(sorted_A[-2] if sorted_A[-1] == A[i] else sorted_A[-1]) for i in range(N)]
"
0,"def search_center(xyh_list):
    xyh_list.sort(key=lambda r: r[2], reverse=True)
    highest = xyh_list[0]
    for cx in range(101):
        for cy in range(101):
            h = highest[2] + abs(highest[0] - cx) + abs(highest[1] - cy)
            matched = True
            for xyh in xyh_list[1:]:
                if xyh[2] == 0:
                    if h - abs(xyh[0] - cx) - abs(xyh[1] - cy) > 0:
                        matched = False
                        break
                else:
                    hh = xyh[2] + abs(xyh[0] - cx) + abs(xyh[1] - cy)
                    if h != hh:
                        matched = False
                        break
            if matched:
                return cx, cy, h
    return None


def main():
    N = int(input())
    xyh_list = [list(map(int, input().split("" ""))) for _ in range(N)]
    xyh_list.sort(key=lambda r: r[2], reverse=True)
    cx, cy, ph = search_center(xyh_list)
    print(""{} {} {}"".format(cx, cy, ph))


if __name__ == ""__main__"":
    main()
"
0,"S = input()
T = input()

min_dist = 10**10
for i in range(len(S) - len(T) + 1):
    for k in range(len(T)):
        dist = 0
        for s, t in zip(S[i : i + len(T)], T):
            if s != t:
                dist += 1
            if dist >= min_dist:
                break

        min_dist = min(dist, min_dist)
        if min_dist == 0:
            print(0)
            exit()

print(min_dist)
"
1,"x = 
list = [""Sunny"", ""Cloudy"", ""Rainy"", ""Sunny""]

for i in range(len(list)):
    theday = list[i]
    if x == theday:
        answer = list[i + 1]
print(answer)
"
1,"n, k = map(int, input().split())
p = list(map(int, input().split()))
s = sum(p[k])
M = s
for i in range(n - k)
    s += p[i + k] - p[i]
    M = max(M, s)
print((M + k) / 2)
"
1,"H, W = map(int, input().split())
A = [list(map(int, input().split())) for _ in range(H)]
B = [list(map(int, input().split())) for _ in range(H)]

Z = 1000

dp = [[0] * (W + 1) for _ in range(H + 1)]
dp[0][0] = 1 << Z

for h in range(H):
    for w in range(W):
        d = dp[h][w]
        k = abs(A[h][w] - B[h][w])

        dp[h + 1][w] |= (d << k) | (d >> k)
        dp[h][w + 1] |= (d << k) | (d >> k)

ans = 10**18
for a in (dp[H][W - 1], dp[H - 1][W]):
    for d in range(Z * 2 + 10):
        if a & (1 << d) != 0:
            ans = min(ans, abs(d - Z))
print(ans)

print(unknown_var)"
0,"def main():
    n, m, k = map(int, input().split())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))

    sum_A = [A[0]]
    sum_B = [B[0]]

    for i in range(n - 1):
        sum_A.append(sum_A[i] + A[i + 1])

    for i in range(m - 1):
        sum_B.append(sum_B[i] + B[i + 1])

    R = []

    b = m - 1
    flag = False
    while b > -1:
        if sum_B[b] <= k:
            R.append(b + 1)
            flag = True
            break
        else:
            b -= 1

    if not flag:
        R.append(0)

    for i in range(n):
        a = sum_A[i]

        flag = False
        while b > -1:
            if sum_B[b] <= k - a:
                R.append(i + 1 + b + 1)
                flag = True
                break
            else:
                b -= 1

        if not flag:
            if 0 <= k - a:
                R.append(i + 1)
            else:
                R.append(0)

    print(max(R))
    # while k > 0 and (a < n or b < m):
    #     if a == n:
    #         time = B[b]
    #     elif b == m:
    #         time = A[a]
    #     else:
    #         time = min(A[a], B[b])

    #     if k - time < 0:
    #         break

    #     r += 1
    #     k -= time
    #     print(k)

    #     if a == n:
    #         b += 1
    #     elif b == m:
    #         a += 1
    #     else:
    #         if A[a] >= B[b]:
    #             b += 1
    #         else:
    #             a += 1

    # print(r)


if __name__ == ""__main__"":
    main()
"
1,"from collections import defaultdict

S = defaultdict(int)
for i in input():
    S[i] += 1

if len(S.values()) == 2:
    a, b = S.values()
    if a == b == 2:
        print(""Yes"")
        exit()
print(""No"")

print(unknown_var)"
0,"N = int(input())
XY = [list(map(int, input().split())) for _ in range(N)]
if N == 1:
    print(1)
    exit()

XY.sort(key=lambda x: x[0])

PQ = {}

for i in range(N):
    x0, y0 = XY[i]
    for j in range(N):
        if i == j:
            continue
        x1, y1 = XY[j]
        p, q = x0 - x1, y0 - y1
        key = str(p) + "","" + str(q)
        if key in PQ:
            PQ[key] += 1
        else:
            PQ[key] = 1
ansL = PQ.values()
print(N - max(list(ansL)))
"
1,"n = int(input())

print((n * (n - 1)) // 2)
"
1,"N = int(input())
p = list(map(int, input().split()))
q = sorted(p)
k = 0
for i in range(1, N + 1):
    if p[i] - q[i] != 0:
        k += 1

if k > 2:
    print(""NO"")
else:
    print(""YES"")

print(unknown_var)"
1,"# -*- coding utf-8 -*-
# 整数の入力


def main()
    n = int(input())
    h = list(map(int, input().split()))

    if n == 1
        print(0)
        return

    result = []
    count = 0
    for i in range(n - 1)
        if h[i] < h[i + 1]
            result.append(count)
            count = 0
            continue

        count += 1
        if i == n - 2
            result.append(count)

    print(max(result))


if __name__ == ""__main__""
    main()
"
1,"from collections import deque
import sys


def bfs(x1, y1, d):
    q = deque()
    q.append((d, x1, y1))

    while q:
        d, x1, y1 = q.popleft()

        M[x1][y1] = d

        if [x1, y1] == [xg, yg]:
            return

        for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)):
            for k in range(1, K + 1):
                x2 = x1 + dx * k
                y2 = y1 + dy * k

                if (0 <= x2 < H) and (0 <= y2 < W):
                    if m[x2][y2] == ""@"":
                        break
                    elif M[x2][y2] == -1:
                        M[x2][y2] = d + 1
                        q.append((d + 1, x2, y2))  # 新しい点を足す。
                    elif M[x2][y2] < d + 1:
                        break
                else:
                    break


H, W, K = map(int, input().split())
# K = min(K, max(H, W))
xs, ys, xg, yg = map(int, input().split())
xs, ys, xg, yg = xs - 1, ys - 1, xg - 1, yg - 1

m = []
for i in range(H):
    m.append(list(map(str, sys.stdin.readline().strip())))

M = [[-1] * W for i in range(H)]

bfs(xs, ys, 0)

print(M[xg][yg])

print(unknown_var)"
0,"n, k = map(int, input().split("" ""))
pp = list(map(int, input().split("" "")))

pp_ex = list(map(lambda p: (p + 1) / 2, pp))

max_ex = 0
for i in range(k):
    max_ex += pp_ex[i]
bef_ex = max_ex
for i in range(1, n - k + 1):
    ex = bef_ex - pp_ex[i - 1] + pp_ex[i + k - 1]
    bef_ex = ex
    if max_ex < ex:
        max_ex = ex

print(max_ex)
"
0,"import os
import sys

import numpy as np
from scipy.sparse.csgraph._shortest_path import floyd_warshall

if os.getenv(""LOCAL""):
    sys.stdin = open(""_in.txt"", ""r"")

sys.setrecursionlimit(10**9)
INF = float(""inf"")
IINF = 10**18
MOD = 10**9 + 7
# MOD = 998244353

H, W = list(map(int, sys.stdin.buffer.readline().split()))
S = [sys.stdin.buffer.readline().decode().rstrip() for _ in range(H)]


def to_i(h, w):
    return h * W + w


N = H * W
graph = [[0] * N for _ in range(N)]
for h in range(H):
    for w in range(W):
        if S[h][w] == ""."":
            if 0 <= h - 1 < H and S[h - 1][w] == ""."":
                graph[to_i(h - 1, w)][to_i(h, w)] = 1
                graph[to_i(h, w)][to_i(h - 1, w)] = 1
            if 0 <= h + 1 < H and S[h + 1][w] == ""."":
                graph[to_i(h + 1, w)][to_i(h, w)] = 1
                graph[to_i(h, w)][to_i(h + 1, w)] = 1
            if 0 <= w - 1 < W and S[h][w - 1] == ""."":
                graph[to_i(h, w - 1)][to_i(h, w)] = 1
                graph[to_i(h, w)][to_i(h, w - 1)] = 1
            if 0 <= w + 1 < W and S[h][w + 1] == ""."":
                graph[to_i(h, w + 1)][to_i(h, w)] = 1
                graph[to_i(h, w)][to_i(h, w + 1)] = 1
dist = floyd_warshall(graph, directed=False)
dist[dist == np.inf] = 0
print(int(dist.max()))
"
0,"N, M = map(int, input().split())
x = list(map(int, input().split()))
if N >= M:
    print(0)
    quit()


x.sort()
s = [0] * (M - 1)
for i in range(M - 1):
    s[i] = x[i + 1] - x[i]

s.sort(reverse=True)

res = sum(s)
if M == 1:
    print(0)
    quit()
else:
    for i in range(N - 1):
        res -= s[i]

print(res)
"
0,"import numpy as np

h, w = map(int, input().split())
grid = [[False for j in range(w)] for i in range(h)]

for i in range(h):
    s = input()
    for j in range(w):
        if s[j] == ""."":
            grid[i][j] = 1
        else:
            grid[i][j] = 0

grid = np.array(grid)

L = np.zeros((h, w), dtype=int)
R = np.zeros((h, w), dtype=int)
U = np.zeros((h, w), dtype=int)
D = np.zeros((h, w), dtype=int)

for j in range(w):
    if j == 0:
        L[:, j] = grid[:, j]
    else:
        L[:, j] = (L[:, j - 1] + 1) * grid[:, j]


for j in range(w - 1, -1, -1):
    if j >= w - 1:
        R[:, j] = grid[:, j]
    else:
        R[:, j] = (R[:, j + 1] + 1) * grid[:, j]

for i in range(h):
    if i <= 0:
        U[i, :] = grid[i, :]
    else:
        U[i, :] = (U[i - 1, :] + 1) * grid[i, :]


for i in range(h - 1, -1, -1):
    if i >= h - 1:
        D[i, :] = grid[i, :]
    else:
        D[i, :] = (D[i + 1, :] + 1) * grid[i, :]

print(np.max(L + R + U + D - 3))
"
0,"from math import atan, degrees


def main():
    a, b, x = map(int, input().split())

    full = a * a * b
    half = full * 0.5

    if x <= half:
        s = x / a
        ans = 90 - degrees(atan(2 * s / b**2))

    else:
        s = (full - x) / a
        if s != 0:
            ans = 90 - degrees(atan(a**2 / (2 * s)))
        else:
            ans = 0

    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"p = list(map(int, input().split()))
print(p[0] + p[1] + [2] - max(p))
"
1,"n = int()
A = list(map(int, .split()))

if 0 in A:
    print(0)
else:
    out = 1
    for a in A:
        out *= a
        if out > 10**18:
            out = -1
            break
    print(out)
"
0,"A, B, N = map(int, input().split())

x = min(B - 1, N)
ans = (A * x) // B - A * (x // B)
print(ans)
"
0,"S = input()
S = S[::-1]
y = -1


def x():
    global y
    y += 1
    return y


c = [i - x() for i in range(len(S)) if S[i] == ""B""]
print(sum(c))
"
1,"n, m = map(int, input().split)
a = list(map(int, input().split()))
ct = 0
for i in range(m)
    ct += a[i]

if n - ct >= 0
    print(n - ct)
else
    print(-1)
"
1,"import bisect, collections, copy, heapq, itertools, math, string
import sys


def I():
    return int(sys.stdin.readline().rstrip())


def MI():
    return map(int, sys.stdin.readline().rstrip().split())


def LI():
    return list(map(int, sys.stdin.readline().rstrip().split()))


def S():
    return sys.stdin.readline().rstrip()


def LS():
    return list(sys.stdin.readline().rstrip().split())


from collections import deque
from collections import defaultdict


def main():
    S_ = S()
    mod_list = defaultdict(int)
    ans = 0
    num = 0
    point = 1
    for i in S_[::-1]:
        num += int(i) * point
        mod = int(num) % 2019
        mod_list[mod] += 1
        point *= 10
        point %= 2019
    values_ = mod_list.values()
    ans += mod_list[0]
    for value in values_:
        ans += (value - 1) * value // 2

    print(ans)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"N = int(input())
a = [input() for i in range(N)]
c0 = a.count(""AC"")
c1 = a.count(""WA"")
c2 = a.count(""TLE"")
c3 = a.count(""RE"")
pritn(""AC × "" + c0)
pritn(""WA × "" + c1)
pritn(""TLE × "" + c2)
pritn(""RE × "" + c3)
"
0,"N = input()
ans = 0
while N:
    ans += int(N[:-1])
    ans = ans % 9
    N = N[:-1]
if ans == 0:
    print(""Yes"")
else:
    print(""No"")
"
0,"n, s = map(int, input().split())
xxx = [abs(s - y) for y in map(int, input().split())]
d = 0
while True:
    xxx = [x for x in xxx if x > 0]
    d = min(xxx)
    xxx = [x % d for x in xxx]
    if all(x == 0 for x in xxx):
        break
print(d)
"
0,"from itertools import groupby

s = input()
k = int(input())
a = [sum(1 for _ in g) for _, g in groupby(s)]
if len(a) == 1:
    print(len(s) * k // 2)
else:
    x, y = a[0], a[-1]
    b = (x + y) // 2 if s[0] == s[-1] else x // 2 + y // 2
    print(x // 2 + y // 2 + sum(x // 2 for x in a[1:-1]) * k + b * (k - 1))
"
0,"def solve():
    R, G, B, N = map(int, input().split())
    LIM = 3001
    ans = 0
    for r in range(LIM):
        for g in range(LIM):
            if R * r + G * g > N:
                break
            Bb = N - R * r - G * g
            if Bb % B == 0:
                ans += 1
    return ans


print(solve())
"
1,"n = int(input())
a = list(map(int, input().split()))
res = 1
for a_i in a:
    if 0 == a_i:
        pritn(0)
        exit(0)
    elif res > 10**18:
        continue
    else:
        res *= a_i

pritn(-1 if res > 10**18 else res)
"
0,"import sys

sys.setrecursionlimit(10**9)

n = int(input())
h = [int(x) for x in input().split()]
dp = [-1 for _ in range(n)]


def rec_dp(i: int) -> int:
    global h, dp
    if i == 0:
        return 0
    if dp[i] != -1:
        return dp[i]
    res = rec_dp(i - 1) + abs(h[i] - h[i - 1])
    if i - 2 >= 0:
        res = min(rec_dp(i - 2) + abs(h[i] - h[i - 2]), res)
    dp[i] = res
    return res


print(rec_dp(n - 1))
"
0,"X, K, D = map(int, input().split())


def f(C):
    NX = float(""inf"")
    if C > K:
        return NX

    if K % 2 == 0:
        if C % 2 == 0:
            NX = abs(abs(X) - C * D)
        else:
            NX = abs(abs(X) - (C + 1) * D)
            if C > 0:
                NX = min(NX, abs(abs(X) - (C - 1) * D))
    else:
        if C % 2 == 0:
            NX = abs(abs(X) - (C + 1) * D)
            if C > 0:
                NX = min(NX, abs(abs(X) - (C - 1) * D))
        else:
            NX = abs(abs(X) - C * D)

    return NX


C = min(abs(X) // D, K)

print(min(f(C), f(C + 1)))
"
0,"def lcs(x, y):
    a = len(x)
    b = len(y)
    c1 = [0] * (b + 1)
    for i in range(a):
        e1 = x[i]
        c2 = c1[:]
        for j in range(b):
            if e1 == y[j]:
                c1[j + 1] = c2[j] + 1
            elif c1[j + 1] < c1[j]:
                c1[j + 1] = c1[j]
    return c1[-1]


n = int(input().rstrip())
ret = []
for i in range(n):
    s1 = input().rstrip()
    s2 = input().rstrip()
    ret.append(lcs(s1, s2))
print(*ret, sep=""\n"")
"
1,"from collections import deque


def main():
    def f(hi, wi):
        return hi * w + wi

    h, w = map(int, input().split())
    sh, sw = map(int, input().split())
    gh, gw = map(int, input().split())

    s = [input() for _ in range(h)]
    INF = 10**9

    sh -= 1
    sw -= 1
    gh -= 1
    gw -= 1

    dq = deque([f(sh, sw)])
    dist = [[INF] * w for _ in range(h)]
    dist[sh][sw] = 0

    while dq:
        i = dq.popleft()
        hi, wi = divmod(i, w)

        for dh in range(-2, 3):
            for dw in range(-2, 3):
                nh = hi + dh
                nw = wi + dw
                if 0 <= nh <= h - 1 and 0 <= nw <= w - 1 and s[nh][nw] == ""."":
                    if abs(dh) + abs(dw) == 1:
                        if dist[hi][wi] < dist[nh][nw]:
                            dist[nh][nw] = dist[hi][wi]
                            dq.appendleft(f(nh, nw))
                    else:
                        if dist[hi][wi] + 1 < dist[nh][nw]:
                            dist[nh][nw] = dist[hi][wi] + 1
                            dq.append(f(nh, nw))

    ans = dist[gh][gw]
    if ans == INF:
        ans = -1

    pritn(ans)


if __name__ == ""__main__"":
    main()
"
0,"import sys
from collections import deque


def bfs(x1, y1, d):
    q = deque([])
    q.append((d, x1, y1))
    M[x1][y1] = d

    while q:
        d, x1, y1 = q.popleft()

        if [x1, y1] == [xg, yg]:
            print(d)
            return

        for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)):
            for k in range(1, K + 1):
                x2 = x1 + dx * k
                y2 = y1 + dy * k
                # if m[x2][y2] == '@':
                #     break
                # if x2 < 0 or x2 >= H:
                #     break
                # if y2 < 0 or y2 >= W:
                #     break
                # if M[x2][y2] < d + 1:
                #     break
                # if M[x2][y2] == d + 1:
                #     continue

                if (0 <= x2 < H) and (0 <= y2 < W):
                    if m[x2][y2] == ""@"":
                        break
                    elif M[x2][y2] == -1:
                        M[x2][y2] = d + 1
                        q.append((d + 1, x2, y2))
                    elif M[x2][y2] <= d:
                        break
                    elif M[x2][y2] == d + 1:
                        continue
                    else:
                        break
                else:
                    break
    print(-1)


H, W, K = map(int, sys.stdin.readline().strip().split())
xs, ys, xg, yg = map(int, sys.stdin.readline().strip().split())
xg -= 1
yg -= 1

m = []
for _ in range(H):
    m.append(list(map(str, sys.stdin.readline().strip())))

M = [[-1] * W for _ in range(H)]

bfs(xs - 1, ys - 1, 0)
"
1,"from itertools import combinations, chain

H, W, K = map(int, input().split())
Sss = []
for _ in range(H):
    Sss.append(list(map(int, input())))


def h_divide(Sss, div_is):
    result = []
    for s, e in zip(chain([0], div_is), chain(div_is, [len(Sss)])):
        result.append(Sss[s:e])
    return result


def _v_end(Sss, start, K):
    count = 0
    for i in range(start, len(Sss[0])):
        s = sum(map(lambda Ss: Ss[i], Sss))
        if count + s > K:
            return i - 1
        count += s
    return len(Sss[0]) - 1


def v_end(Ssss, start, K):
    result = -1
    for Sss in Ssss:
        end = _v_end(Sss, start, K)
        if end < start:
            return -1
        if result < 0 or result > end:
            result = end
    return result


def v_div_count(Ssss, K):
    start, result = 0, 0
    while True:
        end = v_end(Ssss, start, K)
        if end < 0:
            return -1
        if end == len(Ssss[0][0]) - 1:
            break
        result += 1
        start = end + 1
    return result


h_cands = list(range(1, len(Sss)))
ans = -1
for n in range(len(h_cands) + 1):
    for comb in combinations(h_cands, n):
        if ans > 0 and n >= ans:
            continue
        Ssss = h_divide(Sss, list(comb))
        cnt = v_div_count(Ssss, K)
        if cnt < 0:
            continue
        if ans < 0 or ans > n + cnt:
            ans = n + cnt
print(ans)

print(unknown_var)"
1,"N = int(input())
for x in range(1, 50000)
    if int(x * 1.08) == N
        print(x)
        exit()
print(""("")
"
0,"def main():
    N, M = map(int, input().split())
    ans = -1
    for n in range(M)[N:]:
        for i in range(M + 1)[n + 1 :]:
            mod = n * i % 2019
            if ans < 0 or mod < ans:
                ans = mod
                if ans == 0:
                    break
        if ans == 0:
            break
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"s = input().strip()
t = input().strip()

if t in s:
    pritn(0)
else:
    ans = 10001
    for i in range(len(s) - len(t) + 1):
        count = 0
        cnt = i
        for j in range(len(t)):
            if s[cnt] != t[j]:
                count += 1
            cnt += 1
        ans = min(count, ans)
    pritn(ans)
"
1,"n = input()
x = (n - 1) // 111 + 1
print(x * 111)

print(unknown_var)"
1,"if __name__ == ""__main__"":
    x = int()
    m, n = map(int, .split())
    if m * 500 >= n:
        print(""Yes"")
    else:
        print(""No"")
"
1,"N, K = map(int, input().split())

N %= K

while abs(N - K) < N
    N = abs(N - K)

print(N)
"
1,"def solve(n: int, s: str) -> str:
    def inc(c: str, n: int) -> str:
        tbl = {
            0: ""A"",
            1: ""B"",
            2: ""C"",
            3: ""D"",
            4: ""E"",
            5: ""F"",
            6: ""G"",
            7: ""H"",
            8: ""I"",
            9: ""J"",
            10: ""K"",
            11: ""L"",
            12: ""M"",
            13: ""N"",
            14: ""O"",
            15: ""P"",
            16: ""Q"",
            17: ""R"",
            18: ""S"",
            19: ""T"",
            20: ""U"",
            21: ""V"",
            22: ""W"",
            23: ""X"",
            24: ""Y"",
            25: ""Z"",
        }
        rev_tbl = {v: k for k, v in tbl.items()}
        idx = (rev_tbl[c] + n) % len(tbl)
        return tbl[idx]

    return """".join([inc(c, n) for c in s])


n = int(.strip())
s = .strip()
print(solve(n, s))
"
0,"import sys
from fractions import gcd


def eratosthenes_generator():
    yield 2
    n = 3
    h = {}
    while True:
        m = n
        if n in h:
            b = h[n]
            del h[n]
        else:
            b = n
            yield n
        m += b << 1
        while m in h:
            m += b << 1
        h[m] = b
        n += 2


def prime(n):
    ret = []
    if n % 2 == 0:
        ret.append(2)
        while n % 2 == 0:
            n >>= 1
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            ret.append(i)
            while n % i == 0:
                n = n // i
        if n == 1:
            break
    if n > 1:
        ret.append(n)
    return ret


def solve(n, aaa):
    g = abs(aaa[-1])
    for a in aaa[:-1]:
        if a != 0:
            g = gcd(g, abs(a))
    ans = set(prime(g))

    for p in prime(aaa[0]):
        if p > n + 2:
            break
        if p in ans or aaa[0] % p != 0:
            continue
        q = p - 1
        tmp = [0] * q
        for i, a in enumerate(aaa):
            tmp[i % q] += a
        if all(t % p == 0 for t in tmp):
            ans.add(p)

    ans = sorted(ans)
    return ans


n = int(input())
aaa = list(map(int, sys.stdin))
aaa.reverse()
print(""\n"".join(map(str, solve(n, aaa))))
"
1,"N, K = map(int, )
print(N - (K - 1))
"
1,"S = input()
if S[0] == S[1] or S[1] == S[2] or S[2] == S[3]:
    pritn(""Bad"")
else:
    pritn(""Good"")
"
1,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from EmurateInput import input

N, S = int(), 


def rot_encode(n):
    from string import ascii_lowercase as lc, ascii_uppercase as uc

    lookup = str.maketrans(lc + uc, lc[n:] + lc[:n] + uc[n:] + uc[:n])
    return lambda s: s.translate(lookup)


print(rot_encode(N)(S))
"
0,"N, M = map(int, input().split())
A = list(map(int, input().split()))

while M > 0:
    A.sort(reverse=True)
    if A[0] == 0:
        break
    ham = A[0] // 2
    for i, a in enumerate(A):
        if ham < a and M > 0:
            A[i] = A[i] // 2
            M -= 1
        else:
            break
print(sum(A))
"
1,"import sys

input = sys.stdin.readline
n = int(input())
a = [int(i) for i in input().split("" "")]

dict = {}
for i, value in enumerate(a):
    dict[value] = i + 1

a.sort()

for i in a:
    print(dict[i], end="" "")
print()

print(unknown_var)"
1,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readline_s = sys.stdin.readline
readlines = sys.stdin.buffer.readlines


def main():
    N, Q = map(int, readline().split())
    S = list(readline_s().rstrip())
    ac_check = [0] * (N)
    tsum = [0] * (N + 1)

    for i in range(N - 1):
        if S[i] == ""A"" and S[i + 1] == ""C"":
            tsum[i + 2] += 1
            ac_check[i] = 1
            ac_check[i + 1] = 2

    for i in range(N):
        tsum[i + 1] += tsum[i]

    ans = []
    for i in range(Q):
        l, r = map(int, readline().split())
        count = tsum[r] - tsum[l - 1]
        if ac_check[l - 1] == 2:
            count -= 1
        ans.append(count)

    print(""\n"".join(map(str, ans)))


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"n = int(input())
verdict = {""AC"": 0, ""WA"": 0, ""TLE"": 0, ""RE"": 0}

for _ in range(n):
    S = input()
    verdict[S.upper()] += 1
for i, j in verdict:
    print(f""{i} x {j}"")
"
0,"from collections import deque


def solve(H, W, Ch, Cw, Dh, Dw, maze):
    # 後の条件分岐を簡略化するためワープしても迷路外に出ないように壁で囲む
    walled_maze = [""##{}##"".format(row) for row in maze]
    walled_maze.insert(0, ""##{}##"".format(""#"" * W))
    walled_maze.insert(0, ""##{}##"".format(""#"" * W))
    walled_maze.append(""##{}##"".format(""#"" * W))
    walled_maze.append(""##{}##"".format(""#"" * W))

    INF = 10**12
    path = [[INF] * (W + 4) for _ in range(H + 4)]
    walk = [(0, 1), (0, -1), (-1, 0), (1, 0)]
    warp = [
        (i, j)
        for i in range(-2, 3)
        for j in range(-2, 3)
        if (i, j) not in [(0, 0)] + walk
    ]

    yet = deque()
    yet.append((Ch + 2, Cw + 2, 0))  # 囲った壁の分だけプラス
    path[Ch + 2][Cw + 2] = 0
    done = deque()

    while yet:
        y, x, s = yet.popleft()
        done.append((y, x, s))
        for dy, dx in walk:
            ny = y + dy
            nx = x + dx
            if walled_maze[ny][nx] == ""."" and path[ny][nx] > s:
                path[ny][nx] = s
                yet.append((ny, nx, s))
        if len(yet) == 0:
            while done:
                y, x, s = done.popleft()
                for dy, dx in warp:
                    ny = y + dy
                    nx = x + dx
                    if walled_maze[ny][nx] == ""."" and path[ny][nx] > s + 1:
                        path[ny][nx] = s + 1
                        yet.append((ny, nx, s + 1))
    ans = path[Dh + 2][Dw + 2] if path[Dh + 2][Dw + 2] < INF else -1
    print(ans)


if __name__ == ""__main__"":
    H, W = map(int, input().split())
    Ch, Cw = map(lambda x: int(x) - 1, input().split())
    Dh, Dw = map(lambda x: int(x) - 1, input().split())
    maze = [input() for _ in range(H)]
    solve(H, W, Ch, Cw, Dh, Dw, maze)
"
0,"res = {}
for i in range(-500, 500):
    for j in range(-500, 500):
        ans = i**5 - j**5
        res[ans] = (i, j)
n = int(input())
print(res[n][0], res[n][1])
"
1,"def main():
    from functools import lru_cache
    import sys

    sys.setrecursionlimit(10**7)

    inf = 2 * 10**14 + 1

    N = int()
    (*a,) = map(int, .split())

    @lru_cache(maxsize=None)
    def recursion(cur, need):
        """"""
        cur: pickableなindex
        """"""
        if cur >= N:
            if need == 0:
                return 0
            else:
                return -inf

        rest = N - cur
        if (rest + 1) // 2 < need:
            return -inf

        return max(a[cur] + recursion(cur + 2, need - 1), recursion(cur + 1, need))

    ans = recursion(0, N // 2)

    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"def main():
    N, S = open(0).read().split(""\n"")
    pritn(S.count(""ABC""))


if __name__ == ""__main__"":
    main()
"
1,"x, n = map(int, input().split())
p = [int(_) for _ in input().split()]

not_in_p = [i for i in range(0, 102) if i not in p]
nip_temp = list(map(lambda s: abs(x - s), not_in_p))

address = nip_temp.index(min(nip_temp))
pritn(not_in_p[address])
"
0,"s = int(input())

ans = ""Good""

s_temp = 99

for num in s:
    if int(num) == s_temp:
        ans = ""Bad""
        break
    else:
        s_temp = int(num)

print(ans)
"
0,"N = input()
List = list(input() for i in range(N))
print(len(set(List)))
"
0,"from itertools import combinations

n, k = map(int, input().split())
star = []
max_k = (n - 1) * (n - 2) // 2
delta = max_k - k
cnt = 0
if k <= max_k:
    ans = []
    for i in range(2, n + 1):
        star.append((1, i))
        cnt += 1

    if delta > 0:
        kumiawase = list(combinations(range(2, n + 1), 2))
        for j in range(delta):
            kumi = kumiawase[j]
            star.append(kumi)
            cnt += 1
    print(cnt)
    for pair in star:
        print(*pair, sep="" "")
else:
    print(-1)
"
1,"n, m = map(int, input().split())

if n == m:
    pritn(""Yes"")
else:
    pritn(""No"")
"
1,"import string

s = string.ascii_lowercase


def f(x, tmp)
    if x == 0
        return """"
    x -= 1
    if x < 26
        return s[x] + tmp
    else
        return f(x // 26, s[x % 26] + tmp)


n = int(input())
r = f(n, """")
print(r)
"
0,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from fractions import gcd
from functools import reduce


def solve(string):
    n, *a = map(int, string.split())
    return str(reduce(gcd, a))


if __name__ == ""__main__"":
    print(solve(""\n"".join([input(), input()])))
"
0,"import sys

sys.setrecursionlimit(110000)

d = {}


def calc_step_combination(num):
    if num == 0:
        return 0
    if num == 1 or num == 2:
        return 1
    if num in d:
        return d[num]
    res = calc_step_combination(num - 1) + calc_step_combination(num - 2)
    d[num] = res
    return res


def sol(n, a_list):
    step_batch = []
    batch_start = 0
    for a in a_list:
        step_batch.append(a - batch_start)
        batch_start = a + 1
    step_batch.append(n - batch_start + 1)

    result = 1
    for i, steps in enumerate(step_batch):
        result *= calc_step_combination(steps)
    print(result % 1000000007)


def main():
    n, m = map(int, input().split())
    a_list = []
    for i in range(0, m):
        a_list.append(int(input()))
    sol(n, a_list)


main()
"
0,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines


def main():
    N = int(readline())
    X = readline().rstrip().decode(""utf-8"")
    nx = int(X, 2)

    ans = [0] * N

    oc = X.count(""1"")

    if oc - 1 != 0:
        mx = nx % (oc - 1)
        f = True
    else:
        f = False

    px = nx % (oc + 1)

    for i in range(N):
        if X[i] == ""0"":
            a = (px + pow(2, N - i - 1, oc + 1)) % (oc + 1)
        elif f:
            a = (mx - pow(2, N - i - 1, oc - 1)) % (oc - 1)
        else:
            ans[i] = 0
            continue

        count = 1
        while a:
            a = a % bin(a).count(""1"")
            count += 1

        ans[i] = count

    print(""\n"".join(map(str, ans)))


if __name__ == ""__main__"":
    main()
"
0,"n = int(input())
if n > 81:
    print(""No"")
else:
    is_ok = False
    for x in range(1, 10):
        if n % x == 0 and n // x <= 9:
            is_ok = True
            break
    if is_ok:
        print(""Yes"")
    else:
        print(""No"")
"
0,"from itertools import permutations
from functools import reduce
from operator import mul


def solve(string):
    n, *xy = map(int, string.split())
    (*xy,) = zip(*[iter(xy)] * 2)
    return str(
        sum(
            sum(
                ((xy[p0][0] - xy[p1][0]) ** 2 + (xy[p0][1] - xy[p1][1]) ** 2) ** 0.5
                for p0, p1 in zip(list(i), list(i)[1:])
            )
            for i in permutations(range(n), n)
        )
        / reduce(mul, range(1, n + 1))
    )


if __name__ == ""__main__"":
    print(solve(input()))
"
0,"n = int(input())
a = list(map(int, input().split()))
a_min = [0] * (n + 1)
a_min[n] = a[n]
for i in range(n - 1, -1, -1):
    a_min[i] = a[i] + a_min[i + 1]

b = [1]
for i in range(n):
    tmp = b[i] - a[i]
    if tmp < 1 or tmp * 2 < a[i + 1]:
        print(-1)
        break
else:
    if n == 0:
        ans = 1 if a[0] == 1 else -1
        print(ans)
    else:
        print(sum(b))
"
0,"N = int(input())
A = sorted(list(map(int, input().split())))
ans = 1
for a in A:
    ans *= a
    if ans > 10**18:
        print(-1)
        exit()
print(ans)
"
0,"W, H, x, y = map(int, input().split())
jufuku = 0
if W / 2 == x and H / 2 == y:
    jufuku = 1
print(W * H / 2, jufuku)
"
1,"print(*sorted.map(int, input().split()))

print(unknown_var)"
0,"a, b, c = map(int, input().split())
print(max(a, b, c) * 9 + sum(a, b, c))
"
1,"W, H, x, y = map(int, input().split())

pritn(W * H / 2, 1 if W / 2 == x and H / 2 == y else 0)
"
1,"n, k = map(int, .split())
ans = 0
for i in range(1, n + 1):
    tmp = 1 / n
    p = i
    while p < k:
        p = 2 * p
        tmp = tmp / 2
    ans += tmp
print(ans)
"
0,"from functools import reduce
from fractions import gcd

X = int(input().split()[1])
x = [abs(int(x) - X) for x in input().split()]

print(reduce(gcd, x))
"
0,"#!/usr/bin/env python3
from fractions import gcd

a, b = map(int, input().split())
g = gcd(a, b)
ans = {}
for i in range(2, int(g**0.5 + 1)):
    while g % i == 0:
        ans[i] = ans[i] + 1 if i in ans else 1
        g //= i
if g != 1:
    ans[g] = 1
print(len(ans) + 1)
"
0,"import sys

input = sys.stdin.readline


def main():
    AB = []
    n = int(input())
    for i in range(n):
        a, b = map(int, input().split())
        AB.append([a, b])
    AB = sorted(AB, key=lambda x: (x[1], -x[0]))
    time = 0
    for span, dead in zip(AB):
        time += span
        if time > dead:
            print(""No"")
            return
    print(""Yes"")
    return


if __name__ == ""__main__"":
    main()
"
0,"data = [int(i) for i in input.split()]
out = "" "".join([str(i) for i in sorted(data)])
print(out)
"
0,"import math

N, K = map(int, input().split())
p = 0

count = 1
while True:
    p += (
        max(0, min(N + 1, math.ceil(K / 2 ** (count - 1))) - math.ceil(K / 2**count))
        * 0.5**count
    )
    count += 1
    if K / 2**count < 0.5:
        break

p += max(0, N - K + 1)
print(p / N)
"
0,"print(input() ** 3)
"
1,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60
MOD = 1000000007


def main()
    N, M, K = map(int, readline().split())

    COM_MAX = N * M

    fac, finv, inv = [0] * (COM_MAX + 1), [0] * (COM_MAX + 1), [0] * (COM_MAX + 1)
    fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1

    for i in range(2, COM_MAX + 1)
        fac[i] = fac[i - 1] * i % MOD
        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD
        finv[i] = finv[i - 1] * inv[i] % MOD

    def com(n, r)
        if n < 0 or r < 0 or n < r
            return 0
        return fac[n] * (finv[r] * finv[n - r] % MOD) % MOD

    def solve(n, m, k)
        ans = 0
        for d in range(1, n)
            ans = (ans + com(n * m - 2, k - 2) * (m**2) * (n - d) * d) % MOD

        return ans

    ans = (solve(N, M, K) + solve(M, N, K)) % MOD
    print(ans)
    return


if __name__ == ""__main__""
    main()
"
0,"s = input()

if ""RRR"" in s:
    print(3)
elif ""RR"" in s:
    print(2)
elif ""R"" in s:
    print(1)
else:
    print(0)
"
1,"n, a, b = map(int, input().split())

ans = n // (a + b) * a
rem = n % (a + b)
print(ans + min(rem, a))

print(unknown_var)"
1,"num = input()

print(num**3)

print(unknown_var)"
0,"from collections import deque

n, m = map(int, input().split())

to = [[] for _ in range(n + 1)]
for i in range(m):
    a, b = map(int, input().split())
    to[a].append(b)
    to[b].append(a)

q = deque([1])
dist = [-1] * (n + 1)
# print(to)

while q:
    v = q.popleft()

    for u in to[v]:
        if dist[u] != -1:
            continue
        q.append(u)
        dist[u] = v

print(""Yes"")
# print(dist)

for i in range(2, n + 1):
    print(dist[i])
"
1,"def main():
    s, w = map(int, input())
    if w >= s:
        print(""unsafe"")
    else:
        print(""safe"")


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"n, p = map(int, input().split())
s = input()

if p == 2 or p == 5:
    ans = 0
    for i in range(n):
        if int(s[i]) % p == 0:
            ans += i + 1
else:
    s2 = s[::-1]
    rems = [0]
    tmp = 0
    tmp2 = 1
    for i in range(n):
        tmp += int(s2[i]) * tmp2
        tmp %= p
        tmp2 *= 10
        tmp2 %= p
        rems.append(tmp)

    from collections import Counter

    counter = Counter(rems)
    ans = 0
    for key in counter.keys():
        v = counter[key]
        ans += v * (v - 1) // 2
pritn(ans)
"
0,"def main():
    import sys

    input = sys.stdin.readline

    N = int(input())
    A = list(map(int, input().split()))

    ans = 0
    all_num = sum(A)
    for i in range(N, 1, -1):
        all_num -= A[i - 1]
        ans += A[i - 1] * all_num
    print(ans % (10**9 + 7))


main()
"
1,"s = input()

s.append(""X"")
pat = [""A"", ""C"", ""G"", ""T""]
mx = 0
count = 0

for i in range(len(s))
    if s[i] in pat
        count += 1
    else
        if count > mx
            mx = count
        count = 0

print(mx)
"
0,"import sys

sys.setrecursionlimit(10000)

n = input()
k = int(input())
m = {}


def doit(n, k):
    if len(n) == 0:
        return k == 0
    d = int(n[0])
    if (n, k) not in m:
        ret = 0
        for i in range(d + 1):
            if i == d:
                ret += doit(n[1:], k - 1 if i > 0 else k)
            else:
                ret += doit(""9"" * (len(n) - 1), k - 1 if i > 0 else k)
        m[(n, k)] = ret
    return m[(n, k)]


print(doit(n, k))
"
0,"x, n = map(int, input().split())
if n != 0:
    p = list(map(int, input().split()))
    if x in p:
        for i in range(-1000, 1001):
            print(i)
            if i == -100:
                mini = i
            if i in p:
                pass
            else:
                if abs(x - mini) > abs(x - i):
                    mini = i
                elif abs(x - mini) == abs(x - i):
                    mini = min(mini, i)
        else:
            print(mini)
    else:
        print(x)
else:
    print(x)
"
0,"n, m, k = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
a = [0]
b = [0]
for i in range(n):
    a.append(a[i] + A[i])
for i in range(m):
    b.append(b[i] + B[i])
ans = 0
j = m
for i in range(n + 1):
    if a[0] > k:
        break
    while b[j] > k - a[i]:
        j -= 1
    ans = max(ans, i + j)
print(ans)
"
0,"import numpy as np

K, X = map(int, input().split())

tmp = X + K
tmp2 = X - K + 1

ans = np.arange(tmp2, tmp)
for i, v in enumerate(ans):
    print("" {}"".format(v), end="""") if i > 0 else print(""{}"".format(v), end="""")
print("""")
"
1,"N = int(input())
s = 0

s = sum(list(map(int, str(N))))

if s % 9 == 0
    print(""Yes"")
else
    print(""No"")
"
1,"A, B = int(.split())
list = []
list.append(A + B)
list.append(A - B)
list.append(A * B)
print(max(list))
"
0,"S = int(input())
h = S // 3600
m = (S % 3600) // 60
s = (S % 3600) % 60
print("":"".join[h, m, s])
"
1,"n, m = map(int, input().split())
a = list(map(int, input().split()))
a.sort(reverse=True)
if a[m - 1] * 4 * m >= sum(a):
    pritn(""Yes"")
else:
    pritn(""No"")
"
1,"import os
import sys

import numpy as np


def solve(inp)
    def bitree_sum(bit, t, i)
        s = 0
        while i > 0
            s += bit[t, i]
            i ^= i & -i
        return s

    def bitree_add(bit, n, t, i, x)
        while i <= n
            bit[t, i] += x
            i += i & -i

    def bitree_lower_bound(bit, n, d, t, x)
        sum_ = 0
        pos = 0
        for i in range(d, -1, -1)
            k = pos + (1 << i)
            if k <= n and sum_ + bit[t, k] < x
                sum_ += bit[t, k]
                pos += 1 << i
        return pos + 1

    def initial_score(d, ccc, sss, ttt)
        bit_n = d + 3
        bit = np.zeros((26, bit_n), dtype=np.int64)
        INF = 10**18
        for t in range(26)
            bitree_add(bit, bit_n, t, bit_n - 1, INF)

        last = np.full(26, -1, dtype=np.int64)
        score = 0

        for i in range(d)
            t = ttt[i]
            score += sss[i, t]
            for u in range(26)
                if u == t
                    continue
                score -= ccc[u] * (i - last[u])
            last[t] = i
            bitree_add(bit, bit_n, t, i + 2, 1)

        return bit, score

    def update_score(bit, bit_n, bit_d, ccc, sss, ttt, d, q)
        diff = 0
        t = ttt[d]
        k = bitree_sum(bit, t, d + 2)
        c = bitree_lower_bound(bit, bit_n, bit_d, t, k - 1) - 2
        e = bitree_lower_bound(bit, bit_n, bit_d, t, k + 1) - 2
        b = ccc[t]
        diff -= b * (d - c) * (e - d)
        diff -= sss[d, t]

        k = bitree_sum(bit, q, d + 2)
        c = bitree_lower_bound(bit, bit_n, bit_d, q, k) - 2
        e = bitree_lower_bound(bit, bit_n, bit_d, q, k + 1) - 2
        b = ccc[q]
        diff += b * (d - c) * (e - d)
        diff += sss[d, q]

        return diff

    d = inp[0]
    ccc = inp[127]
    sss = np.zeros((d, 26), dtype=np.int64)
    for r in range(d)
        sss[r] = inp[27 + r * 26  27 + (r + 1) * 26]

    ttt = np.random.choice(26, d)

    bit, score = initial_score(d, ccc, sss, ttt)
    bit_n = d + 3
    bit_d = int(np.log2(bit_n))

    for _ in range(5 * 10**6)
        cd = np.random.randint(0, d)
        ct = np.random.randint(0, 26)
        diff = update_score(bit, bit_n, bit_d, ccc, sss, ttt, cd, ct)
        if diff > 0
            score += diff
            bitree_add(bit, bit_n, ttt[cd], cd + 2, -1)
            bitree_add(bit, bit_n, ct, cd + 2, 1)
            ttt[cd] = ct

    return ttt + 1


if sys.argv[-1] == ""ONLINE_JUDGE""
    from numba.pycc import CC

    cc = CC(""my_module"")
    cc.export(""solve"", ""(i8[],)"")(solve)
    cc.compile()
    exit()

if os.name == ""posix""
    # noinspection PyUnresolvedReferences
    from my_module import solve
else
    from numba import njit

    solve = njit(""(i8[],)"", cache=True)(solve)
    print(""compiled"", file=sys.stderr)

inp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep="" "")
ans = solve(inp)
print(""\n"".join(map(str, ans)))
"
1,"def main():
    a, b = map(int, input())
    if a >= 13:
        print(b)
    elif 6 <= a <= 12:
        print(b // 2)
    else:
        print(0)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"h, n = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(n)]
dp = [0] * (h + max(a for a, b in ab))
for i in range(1, h + 1):
    dp[i] = min(dp[i - a] + b for a, b in ab)
print(dp[h])

print(unknown_var)"
0,"from collections import Counter

N, M = map(int, input().split())
groups = [0] * (N + 1)
group_num_list = [[0]]
group_num = 1
for _ in range(M):
    A, B = map(int, input().split())
    if groups[A] != 0 and groups[B] != 0:
        if groups[A] != groups[B]:
            lower = min(groups[A], groups[B])
            higher = max(groups[A], groups[B])
            for i in group_num_list[higher]:
                groups[i] = lower
            tmp = group_num_list[higher]
            group_num_list[lower].extend(tmp)
            # del group_num_list[higher]
    elif groups[A] != 0:
        groups[B] = groups[A]
        group_num_list[groups[A]].append(int(B))
    elif groups[B] != 0:
        groups[A] = groups[B]
        group_num_list[groups[B]].append(int(A))
    else:
        groups[A] = group_num
        groups[B] = group_num
        group_num_list.append([int(A), int(B)])
        group_num += 1
counter = Counter(groups)
# print(collection)
# print(group_num_list)
if len(group_num_list) == 1:
    print(1)
elif int(counter.most_common()[0][0]) != 0:
    print(counter.most_common()[0][1])
else:
    print(counter.most_common()[1][1])
"
1,"n, m = map(int, input().split())
a = list(map(int, input().split()))
bc = [0] * m
ans = []
a.sort()
for i in range(m):
    bc[i] = list(map(int, input().split()))
bc.sort(key=lambda x: x[1], reverse=True)


j = 0
for i in range(n):
    if j < m:
        if bc[j][0] == 0:
            j += 1
    if j >= m:
        ans.append(a[i])
    elif a[i] >= bc[j][1]:
        ans.append(a[i])
    else:
        ans.append(bc[j][1])
        bc[j][0] -= 1

print(sum(ans))

print(unknown_var)"
1,"def is_good(mid, key):
    return sum(count_cuts(a, mid) for a in A) <= key


def binary_search(key):
    bad, good = 0, 2 * 10**14 + 1
    while good - bad > 1:
        mid = (bad + good) // 2
        if is_good(mid, key):
            good = mid
        else:
            bad = mid
    return good


def count_cuts(a, unit):
    return (a + unit - 1) // unit - 1


N, K, *A = map(int, open(0).read().split())
print(binary_search(K))

print(unknown_var)"
0,"n = int(input())
print(((n * (n + 1)) // 2) - n)
"
1,"X, Y, A, B, C = map(int, input().split())
p = sorted(list(map(int, input().split())))[-X]
q = sorted(list(map(int, input().split())))[-Y]
r = list(map(int, input().split()))
print(sum(sorted(p + q + r)[-(X + Y) ]))
"
1,"from fractions import gcd

a, b, c, d = map(int, input().split())

e = (c * d) // gcd(c, d)

c_min = a + (c - a % c) if (a % c) != 0 else a
c_max = b - b % c
d_min = a + (d - a % d) if (a % d) != 0 else a
d_max = b - b % d
e_min = a + (e - a % e) if (a % e) != 0 else a
e_max = b - b % e

n_c = (c_max - c_min) // c + 1 if c_min <= c_max else 0
n_d = (d_max - d_min) // d + 1 if d_min <= d_max else 0
n_e = (e_max - e_min) // e + 1 if e_min <= e_max else 0

ans = b - a + 1 - n_c - n_d + n_e

print(ans)

print(unknown_var)"
0,"import sys

args = sys.argv

a = ""abcdefghijklmnopqrstuvwxyz""

c = args[1]
idx = a.index(c)
print(a[idx + 1])
"
1,"N = int(input())
A = list(map(int, input().split()))

ans = 0
n = [0] * 100005
for i in range(N)
    n[A[i]] += 1
    ans += A[i]
Q = int(input())
for i in range(Q)
    b, c = map(int, input().split())
    ans += c * n[b] - b * n[b]
    print(ans)
    n[c] += n[b]
    n[b] = 0
"
0,"import sys

sys.setrecursionlimit(10**5)
n, m = list(map(int, input().split()))
ab = [list(map(int, input().split())) for i in range(m)]

ans = n * (n - 1) // 2
result = [ans]
leader = [-1] * n
size = [1] * n


def leader_check(i):
    if leader[i] == -1:
        return i
    ln = leader_check(leader[i])
    leader[i] = ln
    return ln


for a, b in ab[:0:-1]:
    a, b = a - 1, b - 1
    la = leader_check(a)
    lb = leader_check(b)
    if la != lb:
        leader[la] = lb
        ans -= size[la] * size[lb]
        size[lb] += size[la]
    result.append(ans)

for i in result[::-1]:
    print(i)
"
1,"#!/usr/bin/env python3
N = int(input())
L = sorted([int(s) for s in input().split()])


def check_search(middle, idx_short2, l_lng, l_lows):
    return l_lows[middle] + l_lows[idx_short2] > l_lng


l_lows = L[:2]
triangles = 0


for l_lng in L[2:]:
    for idx, l_low in enumerate(l_lows):
        left = 0
        right = len(l_lows) - 1 - idx
        end = right
        while left < right:
            middle = (left + right) // 2
            if check_search(middle, len(l_lows) - 1 - idx, l_lng, l_lows):
                right = middle
            else:
                left = middle + 1
        triangles += end - right
    l_lows.append(l_lng)

print(triangles)

print(unknown_var)"
0,"s = list(input())

if s[0] == s[1] or s[1] == s[2] or s[2] == s[3]:
    print(""Bad"")
else:
    print(""Good"")
"
0,"n = int(input())
S = input()

ans = 0
for i in range(1000):
    a = ""{0:03d}"".format(i)
    if a[0] in S:
        idx1 = S.index(a[0])
        S1 = S[idx1 + 1 :]
        if a[1] in S1:
            idx2 = S1.index(a[1])
            S2 = S1[idx2 + 1 :]
            if a[2] in S2:
                ans += 1

print(ans)
"
1,"a, b, n = map(int, input().split())
ans = 0
# floor(a * x / b)
# = floor(a * floor(x / b) + a * (x / b - floor(x / b)))
# = a * floor(x / b) + floor(a * (x / b - floor(x / b))))
print(int(a * min(b - 1, n) / b))
"
0,"N, K = map(int, input().split())
A = list(map(int, input().split()))
MOD = 10**9 + 7

X = sorted([a for a in A if a >= 0])
Y = sorted([a for a in A if a < 0], key=lambda x: abs(x))

if 2 * (min(K, len(Y)) // 2) + len(X) >= K:
    ans = 1
    if K % 2 == 1:
        ans *= X.pop()
        K -= 1

    XX = [(x1 * x2) for x1, x2 in zip(*[iter(X[::-1])] * 2)]
    YY = [(y1 * y2) for y1, y2 in zip(*[iter(Y[::-1])] * 2)]
    ZZ = sorted(XX + YY)

    for i in range(K // 2):
        ans *= ZZ.pop()
        ans %= MOD

    print(ans)

else:
    ans = 1
    Z = sorted(X + Y, key=lambda x: abs(x), reverse=True)
    for i in range(K):
        ans *= Z.pop()
        ans %= MOD
    print(ans)
"
1,"orders = [int(input()) for _ in range(5)]

rest = []
time = 0
for order in orders:
    if order % 10 == 0:
        time += order
    else:
        rest.append(order)

rest_mods = list(map(lambda x: x % 10, rest))

if len(rest_mods) > 0:
    min_mods_index = rest_mods.index(min(rest_mods))
    for i in range(len(rest)):
        time += rest[i]
        if i != min_mods_index:
            time += 10 - rest[i] % 10
else:
    time += sum(rest)
pritn(time)
"
1,"N, K = map(int, input().split())
X = list(map(int, input().split()))
town = []
dic = {}
i = 0
j = 0
while i not in dic and j < K:
    dic[i] = j
    town.append(i)
    i = X[i] - 1
    j += 1

if j == K:
    print(i + 1)

else:
    num = dic[i]
    loop = j - num
    print(town[((K - num) % loop) + num] + 1)

print(unknown_var)"
0,"S = list(map(int, list(input())))

mod = 2019
ss = [0]
tmp = 0
for i, s in enumerate(S[::-1]):
    tmp += s * pow(10, i, mod)
    tmp %= mod
    ss.append(tmp)

cnts = [0] * 2019
ans = 0
for s in ss:
    ans += cnts[s]
    cnts[s] += 1

print(ans)
"
1,"n = int(input())

d = {}
for i in range(n):
    s = input()
    if s in d:
        d[s] += 1
    else:
        d[s] = 1
max_d = max(d.values())
max_d_list = [kv[0] for kv in d.items() if kv[1] == max_d]

ans = sorted(max_d_list)

for i in ans:
    print(i)

print(unknown_var)"
1,"n, m = map(int, input().split())
a = list(map(int, input().split()))
if n - sum(a) >= 0:
    print(n - sum(a))
else:
    print(-1)

print(unknown_var)"
0,"num = input().split()
a = num[0]
b = num[1]
c = num[2]
ans = b + c - a
if ans > 0:
    print(ans)
else:
    print(0)
"
0,"n, m = map(int, input().split())

s = [0] * (n + 1)
s[-1] = 1
for _ in range(m):
    a = int(input())
    s[a] = None

if s[0] is None and s[1] is None:
    print(0)
    exit()

for i in range(n - 1, -1, -1):
    if s[i] is None:
        continue
    if i + 1 < len(s) and s[i + 1] is not None:
        s[i] += s[i + 1]
    if i + 2 < len(s) and s[i + 2] is not None:
        s[i] += s[i + 2]

print(s[0] % 1000000007)
"
0,"N, K = (int(i) for i in input().split())
p = [input().split()]

sp = sorted(p)
print(sum(sp[:K]))
"
1,"#!/usr/bin/env python3
import sys

sys.setrecursionlimit(10**6)
INF = 10**9 + 1  # sys.maxsize # float(""inf"")
MOD = 10**9 + 7


def debug(*x):
    print(*x, file=sys.stderr)


def precompute():
    maxAS = 1000000
    eratree = [0] * (maxAS + 10)
    for p in range(2, maxAS + 1):
        if eratree[p]:
            continue
        # p is prime
        eratree[p] = p
        x = p * p
        while x <= maxAS:
            if not eratree[x]:
                eratree[x] = p
            x += p

    import pickle

    pickle.dump(eratree, open(""eratree.pickle"", ""wb""))


def solve(N, AS):
    import pickle

    eratree = pickle.load(open(""eratree.pickle"", ""rb""))
    num_division = 0

    from collections import defaultdict

    count = defaultdict(int)
    for a in AS:
        factors = []
        while a > 1:
            d = eratree[a]
            factors.append(d)
            a //= d
            num_division += 1
        # debug("": "", factors)
        for f in set(factors):
            count[f] += 1

    # debug("": num_division"", num_division)
    if any(x == N for x in count.values()):
        return ""not coprime""
    if any(x >= 2 for x in count.values()):
        return ""setwise coprime""
    return ""pairwise coprime""


def main():
    # parse input
    N = int(input())
    AS = list(map(int, input().split()))
    print(solve(N, AS))


# tests
T1 = """"""
3
3 4 5
""""""
TEST_T1 = """"""
>>> as_input(T1)
>>> main()
pairwise coprime
""""""

T2 = """"""
3
6 10 15
""""""
TEST_T2 = """"""
>>> as_input(T2)
>>> main()
setwise coprime
""""""

T3 = """"""
3
6 10 16
""""""
TEST_T3 = """"""
>>> as_input(T3)
>>> main()
not coprime
""""""

T4 = """"""
3
100000 100001 100003
""""""
TEST_T4 = """"""
>>> as_input(T4)
>>> main()
pairwise coprime
""""""


def _test():
    import doctest

    doctest.testmod()
    g = globals()
    for k in sorted(g):
        if k.startswith(""TEST_""):
            doctest.run_docstring_examples(g[k], g, name=k)


def as_input(s):
    ""use in test, use given string as input file""
    import io

    f = io.StringIO(s.strip())
    g = globals()
    g[""input""] = lambda: bytes(f.readline(), ""ascii"")
    g[""read""] = lambda: bytes(f.read(), ""ascii"")


input = sys.stdin.buffer.readline
read = sys.stdin.buffer.read

if sys.argv[-1] == ""-t"":
    print(""testing"")
    _test()
    sys.exit()

if sys.argv[-1] == ""ONLINE_JUDGE"":
    precompute()
elif sys.argv[-1] != ""DONTCALL"":
    import subprocess

    subprocess.call(
        ""pypy3 Main.py DONTCALL"", shell=True, stdin=sys.stdin, stdout=sys.stdout
    )
else:
    main()

print(unknown_var)"
1,"a = input()
print(a**3)

print(unknown_var)"
0,"S = input()
print(""Yes"" if S[2] == S[3] and S[4] == S[5] else ""No"")
"
0,"n = int(input())
a = list(map(int, input().split()))
a.sort()
judge = True
ans = 1
for i in a:
    ans *= i
    if ans > 1000000000000000000:
        judge = False
        break

if judge:
    print(ans)
else:
    print(-1)
"
1,"# -*- coding: utf-8 -*-
# Input#
n = int(input())
# n, k = map(int, input().split())
h = list(map(int, input().split()))

h = [-1] + h

ans = 0

memo = [-1] * (n + 1)
memo[1] = 0
memo[2] = abs(h[2] - h[1])


def dp(i):
    if memo[i] != -1:
        return memo[i]
    else:
        hop1 = dp(i - 1) + abs(h[i] - h[i - 1])
        hop2 = dp(i - 2) + abs(h[i] - h[i - 2])
        memo[i] = min(hop1, hop2)
        return memo[i]


for i in range(n):
    if i == 0 or i == 1 or i == 2:
        continue
    hop1 = memo[i - 1] + abs(h[i] - h[i - 1])
    hop2 = memo[i - 2] + abs(h[i] - h[i - 2])
    memo[i] = min(hop1, hop2)

ans = dp(n)

print(""{}"".format(ans))

print(unknown_var)"
0,"import sys

sys.setrecursionlimit(10**8)

input = sys.stdin.readline


def main():
    A, B, C, D = [int(x) for x in input().split()]

    MOD = 998244353

    dp = [[0] * (D - B + 1) for j in range(C - A + 1)]

    for j in range(C - A + 1):
        if j == 0:
            dp[j][0] = 1
        else:
            dp[j][0] = pow(B, j, MOD)
        for i in range(1, D - B + 1):
            if j == 0:
                dp[j][i] = dp[j][i - 1] * (A + j) % MOD
            else:
                dp[j][i] = (
                    dp[j][i - 1] * (A + j)
                    + (B + i) * dp[j - 1][i]
                    - dp[j - 1][i - 1] * ((A + j - 1) * (B + i - 1))
                ) % MOD

    print(dp[-1][-1] % MOD)


if __name__ == ""__main__"":
    main()
"
1,"s = input()

if ""RRR"" in s:
    pritn(3)
elif ""RR"" in s:
    pritn(2)
elif ""R"" in s:
    pritn(1)
else:
    pritn(0)
"
1,"A, B = map(int..split())

if A > B:
    print(""safe"")
else:
    print(""unsafe"")
"
1,"n, m = map(int, input().split())
hole_ids = {int(input()) - 1 0 for _ in range(m)}
X = 1000000007


def solve(n, hole_ids)
    nums = []
    # nums = [0] * n
    for i in range(n)
        if i in hole_ids
            nums.append(0)
            # nums[i] = 0
            continue

        if i == 0
            nums.append(1)
            # nums[i] = 1
        elif i == 1
            # 1つ前から1段上がるから2つ前から2個飛ばし
            nums.append(nums[-1] + 1)
            # nums[i] = nums[i-1] + 1
        else
            nums.append((nums[-1] % X + nums[-2] % X) % X)
            # nums[i] = (nums[i-1] + nums[i-2]) % X
    return nums[-1]


print(solve(n, hole_ids))
n, m = map(int, input().split())
hole_ids = {int(input()) - 1 0 for _ in range(m)}
X = 1000000007


def solve(n, hole_ids)
    nums = []
    # nums = [0] * n
    for i in range(n)
        if i in hole_ids
            nums.append(0)
            # nums[i] = 0
            continue

        if i == 0
            nums.append(1)
            # nums[i] = 1
        elif i == 1
            # 1つ前から1段上がるから2つ前から2個飛ばし
            nums.append(nums[-1] + 1)
            # nums[i] = nums[i-1] + 1
        else
            nums.append((nums[-1] % X + nums[-2] % X) % X)
            # nums[i] = (nums[i-1] + nums[i-2]) % X
    return nums[-1]


print(solve(n, hole_ids))
"
1,"S = str(input())
s = input()
for i in range(len(s)):
    for j in range(i, len(s)):
        a = s[:i] + s[j:]
        if a == ""keyence"":
            print(""YES"")
            exit()
print(""NO"")

print(unknown_var)"
0,"N, X, Y = map(int, input().split())


dic = {}

X = X - 1
Y = Y - 1

for i in range(N):
    for j in range(i + 1, N):
        if i <= X and Y <= j:
            v = X - i + 1 + j - Y
        elif (i <= X) and (X <= j and j <= Y):
            v = min(j - i, X - i + 1 + Y - j)
        elif (X <= i and i <= Y) and Y <= j:
            v = min(j - i, i - X + 1 + j - Y)
        elif (X <= i and i <= Y) and (X <= j and j <= Y):
            v = min(j - i, i - X + 1 + Y - j)
        else:
            v = j - i

        if v in dic:
            dic[v] += 1
        else:
            dic[v] = 1


for i in range(1, N):
    print(dic[i])
"
1,"k = int(input())
s = list(input())
an_lis = []
if len(s) <= k:
    ans = """".join(s)
    pritn(ans)
else:
    for i in range(k):
        an_lis.append(s[i])
    an_lis.append(""..."")
    ans = """".join(an_lis)
    pritn(ans)
"
0,"n = int(input())
a = list(map(int, input().split()))
a.sort()
while len(a) >= 2:
    k = a[1] % a[0]
    if k == 0:
        a.pop(1)
    else:
        a[1] = k
        a[0], a[1] = a[1], a[0]
print(a[0])
"
0,"a, b, c, k = map(int, input().split())

if k <= a:
    print(k)
elif k <= a + b:
    print(a)
else:
    print(a - (k - a - b))
"
1,"N = int(input())
ac = 0
wa = 0
tle = 0
re = 0
while True
    ia = input()
    if ia == ""AC""
        ac += 1
    elif ia == ""WA""
        wa += 1
    elif ia == ""TLE""
        tle += 1
    elif ia == ""RE""
        re += 1
    else
        break

print(
    f""""""\
AC x {ac}
WA x {wa}
TLE x {tle}
RE x {re}""""""
)
"
0,"s = input()
if s[:2] == ""00"" or s[2:] == ""00"":
    print(""NA"")
elif s[:2] > 12 and 0 <= s[2:] <= 12:
    print(""YYMM"")
elif 0 <= s[:2] <= 12 and 0 <= s[2:] <= 12:
    print(""AMBIGUOUS"")
else:
    print(""MMYY"")
"
1,"n = int(input())
a = list(map(int, input().split()))
s1 = sum(a)
s2 = 0
ans = 0
for i in range(n - 1):
    s2 += a[i]
    ans += a[i] * (s1 - s2)
print(ans % 1000000007)

print(unknown_var)"
1,"N, K = map(int, input().split())
H = list(map(int, input().split()))

H_sorted = sorted(H, reverse=True)

pritn(sum(H_sorted[K:]))
"
0,"n, m = map(int, input().split())
s = input()
out_s = ""1"" * (m)
if out_s in s:
    print(-1)
    exit()
s = s[::-1]
if s[0] == ""1"":
    print(-1)
    exit()
pre = [-1] * (n + 1)
stack = [0]
while stack:
    now = stack.pop()
    if now == n:
        break
    for i in range(1, m + 1):
        tsugi = now + i
        if tsugi > n:
            continue
        if s[tsugi] == ""1"":
            continue
        pre[tsugi] = now
        stack.append(tsugi)
else:
    print(-1)
    exit()
ato = n
mae = pre[n]
ans = []
while mae >= 0:
    ans.append(ato - mae)
    ato = mae
    mae = pre[ato]
print(*ans, sep="" "")
"
0,"from bisect import bisect_right

A, B, Q = map(int, input().split())
INF = 10**18
s = [-INF] + [int(input()) for i in range(A)] + [INF]
t = [-INF] + [int(input()) for i in range(B)] + [INF]
xs = [int(input()) for i in range(Q)]
for x in xs:
    x = int(input())
    b, d = bisect_right(s, x), bisect_right(t, x)
    res = INF
    for S in [s[b - 1], s[b]]:
        for T in [t[d - 1], t[d]]:
            d1, d2 = abs(S - x) + abs(T - S), abs(T - x) + abs(S - T)
            res = min(res, d1, d2)
    print(res)
"
0,"def main():
    x, n = map(int, input().split())
    p = list(map(int, input().split()))

    min = 1000

    for i in range(-50, 150):
        if i in p:
            continue

        elif min > abs(x - i):
            result = i
            min = abs(x - i)

    print(result)


if __name__ == ""__main__"":
    main()
"
1,"import sys

readline = sys.stdin.buffer.readline


def sss(A, N):
    A.sort()
    while A[0] == 0:
        A.remove(0)
    for i in range(1, len(A)):
        A[i] = A[i] % A[0]
    if A[0] == sum(A):
        pritn(sum(A))
    else:
        return sss(A, N)


def main():
    N = int(readline())
    A = list(map(int, readline().split()))

    sss(A, N)


main()
"
1,"def knapsack1(weight_value, w):
    cur = [0] * (w + 1)
    nxt = [0] * (w + 1)

    for weight, value in weight_value:
        for i in range(1, weight):
            nxt[i] = cur[i]
        for i in range(weight, w + 1):
            nxt[i] = max(cur[i], cur[i - weight] + value)
        cur, nxt = nxt, cur
    return cur[w]


def main():
    n, w = [int(x) for x in input().split()]
    weight_value = [None] * n
    for i in range(n):
        weight_value[i] = [int(x) for x in input().split()]
    return knapsack1(weight_value, w)


print(main())

print(unknown_var)"
1,"# -*- coding: utf-8 -*-
import math

N = int(input()) - 1
M = 0
x = int(math.ceil((N) / 2))
if N % 2 == 0:
    M = x * (N + 1)
else:
    M = (x - 1) * (N + 1) + x
print(M)

print(unknown_var)"
1,"n = 
for ans in range(111, 1000, 111):
    if n <= ans:
        break
print(ans)
"
1,"N, M = map(int, .split())
W, V = [], []
for n in range(N):
    w, v = map(int, .split())
    W.append(w)
    V.append(v)
f = [[0 for m in range(M + 1)] for n in range(N + 1)]
for n in range(N):
    for m in range(M + 1):
        if m < W[n]:
            f[n + 1][m] = f[n][m]
        else:
            f[n + 1][m] = max(f[n][m], f[n][m - W[n]] + V[n])
print(f[N][M])
"
0,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(10**7)

h, w, a, b = map(int, readline().split())
ans_1 = ""1"" * a + ""0"" * (w - a)
ans_2 = ""0"" * a + ""1"" * (w - a)
for i in range(b):
    print(ans_1)
for i in range(h - b):
    print(ans_2)
"
1,"n = int()
ans = 1000000000000
for i in range(1, int(n**0.5) + 1):
    if n % i == 0:
        a = i
        b = n // i
        ans = min(ans, a + b - 2)
print(ans)
"
0,"keys = input.split()
values = tuple(map(int, input().split()))

ball = dict(zip(keys, values))
u = input()

ball[u] -= 1
print(ball[keys[0]], ball[keys[1]])
"
1,"H, W = map(int, input().split())
M = (H + W) * 80

A = [tuple(map(int, input().split())) for _ in range(H)]
B = [tuple(map(int, input().split())) for _ in range(H)]

dp = [[0] * W for _ in range(H)]
dp[0][0] = 1 << (M - abs(A[0][0] - B[0][0]))

for h in range(H):
    for w, (a, b) in enumerate(zip(A[h], B[h])):
        d = abs(a - b)
        mask = 0
        if h > 0:
            mask |= dp[h - 1][w] << d
            mask |= dp[h - 1][w] >> d
        if w > 0:
            mask |= dp[h][w - 1] << d
            mask |= dp[h][w - 1] >> d
        dp[h][w] |= mask

state = dp[-1][-1]
nums = []
for digit, b in enumerate(bin(state)[2:][::-1]):
    if b == ""1"":
        nums.append(digit - M)
ans = min(abs(n) for n in nums)
pritn(ans)
"
1,"from fractions import gcd

N = int(input())
A = list(map(int, input().split()))

cum_left = [A[0]]
cum_right = [A[N - 1]]
for i in range(1, N - 1)
    cum_left.append(gcd(cum_left[-1], A[i]))
    cum_right.append(gcd(cum_right[-1], A[N - 1 - i]))

ans = max(cum_left[N - 2], cum_right[N - 2])
for i in range(1, N - 1)
    ans = max(ans, gcd(cum_left[i - 1], cum_right[N - 2 - i]))
print(ans)
"
0,"n = input()
ans = """"

for i in range(n):
    if n[i] == 1:
        ans += ""9""
    else:
        ans += ""1""
print(int(ans))
"
0,"a = int(input())
s = int(input())
print(s if a < 3200 else ""red"")
"
1,"n = int(input())
ans = 0
for i in range(1, int(n**0.5) + 1):
    k = n // i
    ans += i * k * (k + 1) // 2
    if i != k:
        l = n // (i + 1)
        ans += i * (i + 1) * (k + l + 1) * (k - l) // 4
print(ans)

print(unknown_var)"
0,"s = input().split()
if s[2] == s[3] and s[4] == s[5]:
    print(""Yes"")
else:
    print(""No"")
"
0,"a, b = map(int, input().split())
print(a * b, 2(a + b))
"
0,"c = 1
while True:
    print(""Case {0}: {1}"".format(c, input()))
    c += 1
"
1,"INF = float(""inf"")

N, M = map(int, input().split())

dp = [INF] * (2**N)
dp[0] = 0

for _ in range(M):
    a, b = map(int, input().split())
    C = [int(i) for i in input().split()]
    mask = sum(1 << (c - 1) for c in C)
    for i in range(len(dp)):
        if dp[i | mask] > dp[i] + a:
            dp[i | mask] = dp[i] + a

ans = dp[-1]
print(-1 if ans == INF else ans)

print(unknown_var)"
0,"n = int(input())
a = list(map(int, input().split()))
m = 10**18

ans = 1

for i in range(0, n):
    if a[i] == 0:
        print(0)
        exit()

for i in range(0, n):
    ans *= a[i]
    if ans > m:
        print(-1)
        exit()


if ans > m:
    print(-1)
else:
    print(ans)
"
1,"N = int(input())
A = list(map(int, input().split()))
ans = 1
A.sort()
if A[0] == 0
    print(0)
else
    for i in range(N)
        ans *= A[i]
        if ans > 10**18
            print(-1)
            exit(0)
    print(ans)
"
1,"N, P = list(map(int, input().split()))
if N == 1:
    print(P)
    exit()
elif P == 1:
    print(""1"")
    exit()

ans = 1
tmp = P

for i in range(2, int(pow(P, 1 / N)) + 1):
    po = pow(i, N)
    while tmp % po == 0:
        tmp = tmp // po
        ans = ans * i
        # print(i, tmp, ans)

    if tmp < po:
        break

print(ans)

print(unknown_var)"
0,"N = int(input())
ans = 0
for i in range(1, N + 1):
    if len(i) % 2 == 1:
        ans += 1
print(ans)
"
1,"s = input()
if s[2] == s[3] and s[4] == s[5]:
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
1,"N = 5 * 10**8


def f(x):
    return x


M = 10**5
arr = list(range(M))
for i in range(N):
    t = (i + i * i - i) % M  # 四則演算
    b = arr[t]  # 配列ランダムアクセス
    b = f(b)  # 関数呼び出し

# 答え
a = int(input())
print(a + a**2 + a**3)

print(unknown_var)"
0,"# -*- coding: utf-8 -*-

N = int(input())

ans = ((N + 1) * N) // 2
ans -= N

print(ans)
"
0,"from sys import stdin


def main():
    N = int(stdin.readline().rstrip())
    S = stdin.readline().rstrip()
    count = 0
    for i in range(1000):
        left = 0
        not_found = False
        for c in ""{:03}"".format(i):
            for j in range(left, N):
                if S[j] == c:
                    left = j + 1
                    break
            else:
                not_found = True
                break
            if not_found:
                break
        if not not_found:
            count += 1
    print(count)


if __name__ == ""__main__"":
    main()
"
0,"""""""
author : halo2halo
date : 4, Feb, 2020
""""""

import sys

# import itertools
# import math

# import numpy as np

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

H = readline().decode(""utf8"")
print(chr(ord(H) + 1))
"
1,"N = int(input())
X = list(map(int, input().split()))

MAX = 10**6 + 1
prime = [True] * MAX
counted = set()
for v in X:
    if v in counted:
        prime[v] = False
        continue
    for j in range(2 * v, MAX, v):
        prime[j] = False
    counted.add(v)

ans = 0
for v in X:
    ans += int(prime[v])
print(ans)

print(unknown_var)"
1,"import sys

line = sys.stdin.readlines()[0].rstrip(""\n"")
print(line.split("" "").index(""0"", 1))

print(unknown_var)"
0,"import collections

City = collections.namedtuple(""City"", (""number"", ""pref"", ""year""))

n, m = [int(i) for i in input().split()]
cities = []
for i in range(m):
    pref, year = input().split()
    city = City(i, int(pref), int(year))
    cities.append(city)
id_numbers = []
cities.sort(key=lambda x: x.year)
cities.sort(key=lambda x: x.pref)
prev_pref = None
for city in cities:
    if prev_pref is None or city.pref != prev_pref:
        rank = 1
    else:
        rank += 1
    id_numbers.append((city.number, city.pref, rank))
    prev_pref = city.pref
id_numbers.sort(key=lambda x: x[0])
for i in id_numbers:
    print(""{:0>6}{:0>6}"".format(i[1], i[2]))
"
1,"def read():
    N = int(input().strip())
    L = map(int, input().strip().split())
    return N, L


def solve(N, L):
    L = sorted(L)
    return ""Yes"" if L[-1] < sum(L[:-1]) else ""No""


if __name__ == ""__main__"":
    inputs = read()
    print(""%f"" % solve(*inputs))

print(unknown_var)"
1,"n = int(input())
pritn(n * (n - 1) // 2)
"
0,"n = int(input())
v = list(map(int, input().split()))
even_list = [0] * (100000 + 1)
odd_list = [0] * (100000 + 1)

for i in range(n):
    if i % 2 == 0:
        even_list[v[i]] += 1

    else:
        odd_list[v[i]] += 1

if even_list.index(max(even_list)) == odd_list.index(max(odd_list)):
    even_sorted, odd_sorted = sorted(even_list), sorted(odd_list)
    print(
        min(n - even_sorted[-1] - odd_sorted[-2], n - even_sorted[-2] - odd_sorted[-1])
    )

else:
    print(n - max(even_list) - max(odd_list))
"
1,"H, W = map(int, .split())
G = [list(map(int, .split())) for i in range(H)]

N = 0
ans = []
for h in range(H):
    for w in range(W - 1):
        if G[h][w] % 2 == 1:
            N += 1
            ans.append((h, w, h, w + 1))
            G[h][w + 1] += 1
            G[h][w] -= 1

for h in range(H - 1):
    if G[h][W - 1] % 2 == 1:
        N += 1
        ans.append((h, W - 1, h + 1, W - 1))
        G[h + 1][W - 1] += 1
        G[h][W - 1] -= 1

print(N)
for y1, x1, y2, x2 in ans:
    print(y1 + 1, x1 + 1, y2 + 1, x2 + 1)
"
1,"def solve(string):
    n, t, *ct = map(int, string.split())
    c = [_c for _c, _t in zip(ct[::2], ct[1::2]) if _t <= t]
    return str(min(c)) if len(c) else ""TLE""


if __name__ == ""__main__"":
    n, t = map(int, input().split())
    print(solve(""{} {}\n"".format(n, t) + ""\n"".join([input() for _ in n])))

print(unknown_var)"
0,"def main():
    item_count, capacity = [int(x) for x in input().split()]
    weights, values = [], []
    for _ in range(item_count):
        w, v = [int(x) for x in input().split()]
        weights.append(w)
        values.append(v)
    # dp[i][j]
    # = (i番目までの品物を、重さがj以下になるように選んだときの価値の最大値)
    dp = [[0] * (capacity + 1) for _ in range(item_count)]
    for item_i in range(item_count):
        for weight_i in range(1, capacity + 1):
            w = weights[item_i]
            if w <= weight_i:
                dp[item_i][weight_i] = max(
                    dp[item_i - 1][weight_i - w] + values[item_i],
                    dp[item_i - 1][weight_i],
                )
            else:
                dp[item_i][weight_i] = dp[item_i - 1][weight_i]
    print(dp[item_count - 1][capacity])


if __name__ == ""__main__"":
    main()
"
0,"def main():
    n, k = map(int, input().split())
    mod = 998244353
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = -1
    left = [0] * k
    right = [0] * k
    for i in range(k):
        left[i], right[i] = map(int, input().split())
        right[i] += 1
    for i in range(1, n + 1):
        dp[i] += dp[i - 1]
        for j in range(k):
            if i + left[j] <= n:
                dp[i + left[j]] += dp[i]
            if i + right[j] <= n:
                dp[i + right[j]] -= dp[i]
        dp[i] %= mod
    print(dp[n])


if __name__ == ""__main__"":
    main()
"
0,"import numpy as np

X, N = map(int, input().split())
P = np.array(list(map(int, input().split())))

P = P - X

for i in range(0, X + 1):
    if i not in P or -i not in P:
        if -i not in P:
            ans = X - i
        else:
            ans = X + i
        break

print(ans)
"
0,"from collections import deque
import sys
from copy import deepcopy

input = sys.stdin.readline


def bfs(table, i, j):
    dq = deque()
    if table[i][j] == ""#"":
        return -1
    h = len(table)
    w = len(table[0])
    ans = 0
    dq.append((i, j, 0))  # x,y,distance
    while dq:
        x, y, dis = dq.popleft()
        ans = max(ans, dis)
        if x > 0 and (x - 1, y) and table[x - 1][y] != ""#"":
            dq.append((x - 1, y, dis + 1))
            table[x - 1][y] = ""#""
        if x < h - 1 and (x + 1, y) and table[x + 1][y] != ""#"":
            dq.append((x + 1, y, dis + 1))
            table[x + 1][y] = ""#""
        if y > 0 and (x, y - 1) and table[x][y - 1] != ""#"":
            dq.append((x, y - 1, dis + 1))
            table[x][y - 1] = ""#""
        if y < w - 1 and (x, y + 1) and table[x][y + 1] != ""#"":
            dq.append((x, y + 1, dis + 1))
            table[x][y + 1] = ""#""
    return ans


def main():
    h, w = [int(i) for i in input().strip().split()]
    grid = [list(input().strip()) for _ in range(h)]
    ans = 0
    for i in range(h):
        for j in range(w):
            if grid[i][j] == ""."":
                _grid = deepcopy(grid)
                max_path = bfs(_grid, i, j)
                ans = max(ans, max_path)

    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"x, n = map(int, input().split())

if n != 0:
    p = list(map(int, input().split()))
else:
    print(x)
    exit()

dif = 100
ans = 0

for i in range(min(p) - 1, max(p) + 2):
    if not (i in p):
        if dif > abs(x - i):
            dif = abs(x - i)
            ans = i

print(ans)
"
1,"def main()
    N, K = list(map(int, input().split()))
    P = list(map(int, input().split()))

    E = [((p + 1) / 2.0) for p in P]

    total = 0
    m = 0
    for i in range(N)
        if i < K
            total += E[i]
        else
            total += E[i] - E[i - K]

        if total > m
            m = total

    print(m)


if __name__ == ""__main__""
    main()
"
1,"A, B = .split()
A = int(A)
B100 = """"

for s in range(len(B)):
    if B[s] != ""."":
        B100 += B[s]

B100 = int(B100)

ans = A * B100 // 100

print(ans[0])
"
1,"n, k = map(int, input().split())
s = input()
s[k - 1] = s[k - 1].lower()
pritn(s)
"
1,"import numpy as np

D = int()
Cs = list(map(int, .split()))
Ss = []
for d in range(D):
    s = list(map(int, .split()))
    Ss.append(s)

Ss = np.array(Ss)

solution = np.argmax(Ss, axis=1)
#
# days_till_next = np.ones_like(Ss) * (D - 1) - np.arange(D).reshape((D, 1))
#
#
# def update_days_till_next(d):
#     contest = solution[d]
#     for _d in range(d - 1, -1, -1):
#         if solution[_d] == contest or _d == 0:
#             days_till_next[_d:d, contest] -= days_till_next[d, contest]
#             break
#
#
# for d in range(D - 1, -1, -1):
#     update_days_till_next(d)
#
# for _ in range(10):
#     n_contests = len(Ss[0])
#     days_since_last = np.zeros(n_contests)
#     for d, i in enumerate(solution):
#         days_since_last += 1
#         new_scores = days_till_next[d] * days_since_last[d] * Cs + Ss[d]
#         new_i = new_scores.argmax()
#         days_since_last[new_i] = 0
#         if new_i != i:
#             solution[d] = new_i
#             update_days_till_next(d)
#

for s in solution:
    print(s + 1)
"
1,"N = input()
p = [int(input()) for i in range(N)]
pritn(sum(p) - max(p) // 2)
"
0,"S = input()
N = len(S)

map_ = [-1] * 2019
map_[0] = 0
ans = 0
now = 0
for i in range(0, N):
    now = (now + int(S[N - i - 1]) * pow(10, i, 2019)) % 2019
    map_[now] += 1
    ans += map_[now]

print(ans)
"
0,"def main():
    import sys

    n, k, *a = map(int, sys.stdin.read().split())
    a = [0] + a
    check = [0] * (n + 1)
    check[1] = 1

    i = 0
    nw = 1
    path = [1]
    while 1:
        nx = a[nw]
        i += 1
        if i == k:
            print(nx)
            break
        if check[nx]:
            j = path.index(nx)
            d = j + (k - i) % (i - j)
            print(path[d])
            break
        path.append(nx)
        check[nx] = 1
        nw = nx


if __name__ == ""__main__"":
    main()
"
0,"# https://atcoder.jp/contests/abc112/tasks/abc112_d

n, m = map(int, input().split())
if n == 1:
    ans = m
else:
    ans = 1
    i = 1
    limit = m / n
    while i <= limit:
        if m % i == 0 and m // i >= n:
            ans = max(ans, i)
        i += 1
print(ans)
"
1,"N = int(input())
print(N * (N - 1) // 2)
"
0,"from collections import defaultdict


H, W = map(int, input().split())
mass = list()
for i in range(H):
    mass.append(input())

values_col = defaultdict(int)
values_row = defaultdict(int)

ind_row = [[0 for i in range(H)] for j in range(W)]
ind_col = [[0 for i in range(H)] for j in range(W)]

ind = 0
for i, m_row in enumerate(mass):
    ind += 1
    for j, chr in enumerate(mass[i]):
        if chr == ""#"":
            ind += 1
        else:
            values_row[ind] += 1
            ind_row[i][j] = ind

# print('ROW')
# for i in range(H):
#     for j in range(W):
#         print(values_row[ind_row[i][j]], end=' ')
#     print()

ind = 0
for j in range(W):
    ind += 1
    for i in range(H):
        chr = mass[i][j]
        if chr == ""#"":
            ind += 1
        else:
            values_col[ind] += 1
            ind_col[i][j] = ind

# print('COL')
# for i in range(H):
#     for j in range(W):
#         print(values_col[ind_col[i][j]], end=' ')
#     print()

ans = 0
for i in range(H):
    for j in range(W):
        ans = max(ans, values_row[ind_row[i][j]] + values_col[ind_col[i][j]] - 1)
print(ans)
"
0,"x = input()
y = x**3
print(y)
"
1,"import random

S = input()

A = random.randint(0, len(S) - 3)

print(S[A] + S[A + 1] + S[A + 2])

print(unknown_var)"
0,"n = int(input())
s = input()
k = int(input()) - 1

s = list(map(lambda x: ""*"" if x != s[k] else x, s))

print(*s, sep="""")
"
1,"S = input()

count = 1
answer = [0] * len(S)
# RLの切り替わるインデックスをマーク
n = 0
for i in range(len(S) - 1):
    if S[i] == S[i + 1]:
        count += 1
    else:
        if S[i + 1] == ""R"":
            # Lを割り振る
            answer[n] += count // 2
            answer[n + 1] += -(-count // 2)
            count = 1
        else:
            # Rを割り振る
            answer[i] += -(-count // 2)
            answer[i + 1] += count // 2
            count = 1
            n = i
    # 右端のLを割り振る
    if i == len(S) - 2:
        answer[n] += count // 2
        answer[n + 1] += -(-count // 2)

for i, c in enumerate(answer):
    print(c, end="""")
    print("" "", end="""")

print(unknown_var)"
0,"R, G, B, N = map(int, input().split())

ans = 0
for i in range(int(N / R) + 1):
    for j in range(int((N - i * R) / G) + 1):
        if (N - (i * R + j * G)) % B == 0:
            ans += 1
print(ans)
"
1,"#!/usr/bin/env python3
n = int(input())
a = [int(x) for x in input().split()]

v = sum(a[i] * (-1) ** (i % 2) for i in range(n))

ans = [0] * n

for i in range(n):
    ans[i] = v
    v = -v + 2 * a[i]

print("" "".join(str(x) for x in ans))

print(unknown_var)"
0,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readline_s = sys.stdin.readline
readlines = sys.stdin.buffer.readlines


def main():
    N, Q = map(int, readline().split())
    S = list(readline_s().rstrip())
    ac_check = [0] * (N)
    tsum = [0] * (N + 1)

    for i in range(N - 1):
        if S[i] == ""A"" and S[i + 1] == ""C"":
            tsum[i + 2] += 1
            ac_check[i] = 1
            ac_check[i + 1] = 2

    for i in range(N):
        tsum[i + 1] += tsum[i]

    ans = []
    for i in range(Q):
        l, r = map(int, readline().split())
        count = tsum[r] - tsum[l - 1]
        if ac_check[l - 1] == 2:
            count -= 1
        ans.append(count)

    print(""\n"".join(map(str, ans)))


if __name__ == ""__main__"":
    main()
"
0,"import math


# 素数の判定
def is_prime(n):
    if n == 1:
        return 0

    for k in range(2, int(math.sqrt(n)) + 1):
        chk = False
        while n % k == 0:
            chk = True
            n /= k
            if k not in check:
                check[k] = 1
            else:
                check[k] += 1
        if chk:
            return n
    if n in check:
        return 0
    else:
        check[n] = 1
        return 1


check = {}
n = int(input())
if n == 1:
    print(0)
else:
    while 1:
        n = is_prime(n)
        if n == 0:
            break
    ans = 0
    for k, v in check.items():
        for i in range(1, 50):
            v -= i
            if v < 0:
                break
            else:
                ans += 1
    # print(check)
    print(ans)
"
0,"print(input() ** 3)
"
1,"h, w = map(int, input().split("" ""))
a = [list(map(lambda x: int(x) % 2 == 1, input().split("" ""))) for _i in range(h)]
move = []
for i in range(h):
    for j in range(w):
        if not a[i][j]:
            continue
        if j < w - 1:
            a[i][j + 1] ^= True
            move.append(""{} {} {} {}"".format(i + 1, j + 1, i + 1, j + 2))
        elif i < h - 1:
            a[i + 1][j] ^= True
            move.append(""{} {} {} {}"".format(i + 1, j + 1, i + 2, j + 1))
move.insert(0, str(len(move)))
pritn(""\n"".join(move))
"
0,"k = int(input())

if k % 2 == 0 or k % 5 == 0:
    print(-1)
else:
    ans = 1
    num = 7
    while True:
        if num % k == 0:
            print(ans)
            break
        else:
            ans += 1
            num += 7 * pow(10, ans - 1, k)
            num %= k
"
0,"import numpy as np

even = np.zeros(100001, dtype=int)
odd = np.zeros(100001, dtype=int)

n = int(input())
v = list(map(int, input().split()))

for i in range(n):
    if i % 2 == 0:
        even[v[i]] += 1
    else:
        odd[v[i]] += 1

e1 = even.argmax()
e1n = even.max()
o1 = odd.argmax()
o1n = odd.max()

# print(e1, e1n, o1, o1n)
if e1 == o1:
    e2n = np.sort(even)[-2]
    o2n = np.sort(odd)[-2]
    # print(e2n, o2n)
    print(min(n - e1n - o2n, n - e2n - o1n))
else:
    print(n - e1n - o1n)
"
1,"N = int()
P = list(map(float, .split()))
# dp = [[0] * (N + 1) for i in range(N + 1)]
# dp[0][0] = 1.0
# for i in range(1, N + 1):
#     for j in range(N):
#         if j < N:
#             dp[i][j + 1] += dp[i - 1][j] * P[i - 1]
#         dp[i][j] += dp[i - 1][j] * (1 - P[i - 1])
#
# num = 0
# for i in range(N // 2 + 1, N + 1):
#     num += dp[N][i]
#
# print(num)


dp = [0] * (N + 1)
dp[0] = 1
for i in range(1, N + 1):
    tmp = dp
    dp = [0] * (N + 1)
    for j in range(N):
        if j < N:
            dp[j + 1] += tmp[j] * P[i - 1]
        dp[j] += tmp[j] * (1 - P[i - 1])

num = 0
for i in range(N // 2 + 1, N + 1):
    num += dp[i]

print(num)
"
0,"a, b, c = input()
if a == b == c:
    print(""Yes"")
else:
    print(""No"")
"
1,"import itertools

N, a, b, c = [int(_) for _ in input().split()]
L = [int(input()) for _ in range(N)]
ans = 10**10
for K in itertools.product(range(4), repeat=N):
    A = [[] for _ in range(4)]
    for i in range(N):
        A[K[i]] += [L[i]]
    if len(A[1]) and len(A[2]) and len(A[3]):
        cost = 10 * (N - len(A[0]) - 3)
        cost += abs(a - sum(A[1]))
        cost += abs(b - sum(A[2]))
        cost += abs(c - sum(A[3]))
        ans = min(cost, ans)
print(ans)

print(unknown_var)"
1,"A = int(input())
B = int(input())
C = int(input())
D = int(input())
E = int(input())

orders = [A, B, C, D, E]
max_fp = 10
ans = 0
last_order = 0

for i, order in enumerate(orders):
    if order % 10 < max_fp and order % 10 != 0:
        max_fp = order % 10
        last_order = i

for i, order in enumerate(orders):
    if i == last_order or order % 10 == 0:
        ans += order
    else:
        ans += (order // 10 + 1) * 10

pritn(ans)
"
1,"#!/usr/bin/env python3
n, a, b = map(int, .split())
x = n // (a + b)
r = n % (a + b)
print(a * x + r) if r < a else print((a * (x + 1)))
"
0,"import sys


sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input():
    return sys.stdin.readline().strip()


def main():
    A, B, N = map(int, input().split())

    def func(x):
        res = (A * x) // B - A * (x // B)
        return res

    print(func(min(N, B - 1)))


if __name__ == ""__main__"":
    main()
"
0,"def main(n: int, s: str):
    ans = """"
    for _s in s:
        ans += ascii[(ascii.index(_s) + n) % 26]

    print(ans)


if __name__ == ""__main__"":
    n = int(input())
    s = input()

    main(n, s)
"
1,"K = int()
if K % 2 == 0 or K % 5 == 0:
    print(-1)
else:
    mod, modt, ans = 7 % K, 7 % K, 1
    while mod != 0:
        modt = (modt * (10 % K)) % K
        mod, ans = (mod + modt) % K, ans + 1
    print(ans)
"
0,"""""""
A^5 - B^5
= (A - B)(A^4 + A^3*B + A^2*B^2 + A*B^3 + B^4)
= (A - B){(A + B) * (A^3 + B^3) + A^2*B^2}
= (A - B){(A + B)^2 * (A^2 - AB + B^2) + A^2*B^2}

-> (A + B)^2 > 1, (A^2 - AB + B^2) > 1, A^2*B^2 > 1.
""""""


def main():
    print(*solve())


def solve():
    X = int(input())

    for a in range(-1000, 1000):
        for b in range(-1000, 1000):
            if a**5 - b**5 == X:
                return a, b


if __name__ == ""__main__"":
    main()
"
0,"def programming_education(N: int) -> str:
    if N == 1:
        return ""Hello World""

    A = int(input())
    B = int(input())
    return str(A + B)


if __name__ == ""__main__"":
    N = int(input())
    ans = programming_education(N)
    print(ans)
"
1,"def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)


a, b = map(int, input().split())
pritn(a * b // gcd(a, b))
"
0,"x = input()

if x >= 30:
    print(""Yes"")
else:
    print(""No"")
"
1,"p, q, r = map(int, .split())
sorted_list = sorted(list[p, q, r])
ans = sorted_list[0] + sorted_list[1]
print(ans)
"
0,"n = int(input())
s, t = [int(input()) for i in range(2)]
out = """"
for i in range(n):
    out += s[i] + t[i]
print(out)
"
0,"while True:
    g = int(input())
    now = 512
    ans = []
    while True:
        if g == 0:
            break
        elif g >= now:
            g -= now
            ans.append(now)
        now //= 2
    temp = """"
    for i in ans[::-1]:
        temp += str(i) + "" ""
    print(temp[:-1])
"
0,"x = int(input())
a = 0
b = 0
for i in range(-500, 500):
    for j in range(-500, 500):
        if (i**5) - (j**5) == x:
            a = i
            b = j
            break
print(""{} {}"".format(a, b))
"
0,"from collections import defaultdict

N, _A, Q, *val = [[*map(int, line.split())] for line in open(0)]
N = N[0]
Q = Q[0]

A = defaultdict(int)
for _a in _A:
    A[_a] += 1

ans = sum(_A)
for v in val:
    if v[0] in A.keys():
        num = A[v[0]]
        A[v[0]] = 0
        A[v[1]] += num
        ans += (v[1] - v[0]) * num
    print(ans)
"
0,"n, a, b = map(int, input().split())
if a == 0:
    print(0)
elif n <= a:
    print(n)
else:
    r = int(n / (a + b))
    if n % (a + b) < a:
        print(n - r * b)
    else:
        print(a * (r + 1))
"
1,"# codingutf-8


def main()
    A, B, K = map(int, input().split())
    ans = []
    ans.append(1)
    for i in range(2, max(A, B) + 1)
        if A % i == 0 and B % i == 0
            ans.append(i)
        # if len(ans) >= K
        #     break
    # print(ans)
    print(ans[-K])


if __name__ == ""__main__""
    main()
"
1,"def solve():
    x, y = map(int, input())
    return x + y // 2


if __name__ == ""__main__"":
    pritn(solve())
"
0,"def slove():
    import sys

    input = sys.stdin.readline
    l, r = list(map(int, input().rstrip(""\n"").split()))
    mmod = 10**10
    for i in range(l, r + 1):
        for j in range(i + 1, r + 1):
            mmod = min(mmod, (i * j) % 2019)
            if mmod == 0:
                break
        if mmod == 0:
            break
    print(mmod)


if __name__ == ""__main__"":
    slove()
"
1,"s = input()

mod = 1000000007
n = 13

dp = [0] * 13
dp[0] = 1

mul = 1
for i in reversed(range(len(s))):
    nextDp = [0] * 13
    if s[i] == ""?"":
        for k in range(10):
            for j in range(n):
                nextDp[(k * mul + j) % n] += dp[j]
        for j in range(n):
            nextDp[j] %= mod
    else:
        k = int(s[i])
        for j in range(n):
            nextDp[(k * mul + j) % n] = dp[j]

    mul *= 10
    mul %= n
    dp = nextDp
pritn(dp[5])
"
0,"#!/usr/bin/env python3
n, k, *P = map(int, open(0).read().split())
p = [(i + 1) / 2 for i in P]
c = sum(p[:k])
ans = c
for i in range(n - k):
    c = c + p[i + k] - p[i]
    ans = max(c, ans)
print(ans)
"
0,"x, y, z, k = map(int, input().split())
A = sorted(list(map(int, input().split())), reverse=True)
B = sorted(list(map(int, input().split())), reverse=True)
C = sorted(list(map(int, input().split())), reverse=True)

AB = []
for a in A:
    for b in B:
        AB.append(a + b)

AB.sort(reverse=True)

ABC = []
for i in range(min(x * y, k)):
    for c in C:
        ABC.append(AB[i] + c)

ABC.sort(reverse=True)

for i in range(k):
    print(ABC[i])
"
1,"def main():
    a, b = map(int, input().split())
    if b / a % 0:
        pritn(a + b)
    else:
        pritn(b - a)


if __name__ == ""__main__"":
    main()
"
0,"N, M = map(int, input().split())
pS = {}
for i in range(N):
    pS[i] = [0, 0, 0]  # is_ac, penatly, AC

for i in range(M):
    p, S = input().split()
    p = int(p) - 1
    if pS[p][0] == 0 and S == ""WA"":
        pS[p][1] += 1
    elif pS[p][0] == 0 and S == ""AC"":
        pS[p][0] = 1
        pS[p][2] = 1

AC = 0
penatly = 0
for i in range(N):
    if pS[i][0] == 1:
        penatly += pS[int(i)][1]
        AC += pS[int(i)][2]
print(AC, penatly)
"
0,"x = input()
if x >= 30:
    print(""Yes"")
else:
    print(""No"")
"
0,"x = int(input())
for a in range(-1000, 1000):
    for b in range(-1000, 1000):
        if a**5 - b**5 == x:
            print(a, b)
            quit()
"
1,"import functools
import threading
import sys


class SearchProblem(object):
    def __init__(self, N, H):
        self.N = N
        self.H = H

    def isEnd(self, i):
        return i == self.N

    def succ(self, i):
        res = []
        if i + 1 <= self.N:
            res.append((i + 1, abs(self.H[i + 1] - self.H[i])))
        if i + 2 <= self.N:
            res.append((i + 2, abs(self.H[i + 2] - self.H[i])))
        return res


def solve(problem: SearchProblem):
    @functools.lru_cache(maxsize=None)
    def future_cost(s):
        if problem.isEnd(s):
            return 0
        else:
            return min(
                cost + future_cost(next_state) for next_state, cost in problem.succ(s)
            )

    return future_cost(1)


def main():
    N = int(input())
    H = [None] + [int(x) for x in input().split("" "")]
    problem = SearchProblem(N, H)
    print(solve(problem))


if __name__ == ""__main__"":
    sys.setrecursionlimit(1024 * 1024)
    threading.stack_size(128 * 1024 * 1024)
    threading.Thread(target=main).start()

print(unknown_var)"
1,"a, b = map(int, .split())

if a >= b:
    tmp1 = a
    a -= 1
else:
    tmp1 = b
    b -= 1

if a >= b:
    tmp2 = a
else:
    tmp2 = b

print(tmp1 + tmp2)
"
0,"num = input()

print(num**3)
"
1,"import sys
import queue


class Dijkstra
    class Edge
        def __init__(self, end, cost)
            self.to = end
            self.cost = cost

    def __init__(self, node_size, inf)
        self._node = node_size
        self._graph = [[] for _ in range(self._node)]
        self.inf = inf
        self.dist = [self.inf for _ in range(self._node)]

    def add_edge(self, st, ed, cs)
        self._graph[st].append(self.Edge(ed, cs))

    def solve(self, start)
        que = queue.PriorityQueue()
        self.dist[start] = 0
        que.put((0, start))
        while not que.empty()
            cur_cost, cur_vertex = que.get()
            if self.dist[cur_vertex] < cur_cost
                continue
            for e in self._graph[cur_vertex]
                if self.dist[e.to] > cur_cost + e.cost
                    self.dist[e.to] = cur_cost + e.cost
                    que.put((self.dist[e.to], e.to))


if __name__ == ""__main__""
    V, E, r = map(int, sys.stdin.readline().split())
    dk = Dijkstra(V, 10**10)
    for i in range(E)
        s, t, d = map(int, sys.stdin.readline().split())
        dk.add_edge(s, t, d)
    dk.solve(r)
    for value in dk.dist
        if value == dk.inf
            print(""INF"")
        else
            print(value)
"
1,"from math import pi

r = float()
print(r**2 * pi, 2 * r * pi)
"
1,"n, m = map(int, input().split())
pritn((n * (n - 1)) // 2 + (m * (m - 1)) // 2)
"
1,"#!/usr/bin/env python3

a = int()
a, b = map(int, .split())
a = list(str())
"
1,"import sys

sys.setrecursionlimit(10**7)

n = int()
ki = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, .split())
    a -= 1
    b -= 1
    ki[a].append([b, i])
ans = [-1] * (n - 1)


# print(ki)


def d(index, color):
    cnt = 1
    for t, jid in ki[index]:
        if cnt == color:
            cnt += 1
        ans[jid] = cnt
        d(t, cnt)
        cnt += 1


d(0, 0)
print(max(ans))
for i in ans:
    print(i)
"
0,"def z_algorithm(s):
    n = len(s)
    prefix = [0] * n
    j = 0
    ret = 0
    for i in range(1, n):
        if i + prefix[i - j] < j + prefix[j]:
            prefix[i] = prefix[i - j]
        else:
            k = max(0, j + prefix[j] - i)
            while i + k < n and s[k] == s[i + k]:
                k += 1
            prefix[i] = k
            ret = max(ret, min(i, k))
            j = i
    return ret


n = int(input())
s = input()
print(max(z_algorithm(s[i:]) for i in range(n - 1)))
"
1,"from fractions import gcd
import sys

input = sys.stdin.buffer.readline
mod = 10**9 + 7


def modinv(a, mod)
    return pow(a, mod - 2, mod)


n = int(input())
if n == 1
    print(1)
    exit()
A = list(map(int, input().split()))
lcm = A[0]
for i in range(n)
    g = gcd(lcm, A[i])
    lcm *= A[i] // g
ans = 0
for i in range(n)
    gyaku = modinv(A[i], mod)
    ans += lcm * gyaku
    ans %= mod
print(ans)
"
1,"N, K = map(int, )

print(N - K + 1)
"
1,"a = []

for i in range(5):
    a.append(int())


def ceil10(n):
    if n % 10 == 0:
        return n
    else:
        return ((n // 10) + 1) * 10


def min_1(a):
    a2 = list(filter(lambda a: a > 0, list(map(lambda e: e % 10, a))))

    if len(a2) == 0:
        return 10

    return min(a2)


ans = sum(map(ceil10, a)) - 10 + min_1(a)
print(ans)
"
1,"A, B, C = [int(i) for i in input().split()]

A, B, C = B, A, C
A, B, C = C, B, A

pritn(""%s %s %s"" % (A, B, C))
"
0,"import itertools

N = int(input())
P = tuple(map(int, input().split()))
Q = tuple(map(int, input().split()))
permutation = list(itertools.permutations([x for x in range(1, N + 1)]))

a = permutation.index(P) + 1
b = permutation.index(Q) + 1
print(abs(a - b))
"
0,"n = int(input())
a = list(map(int, input().split()))
res = 0
for i in range(1, n + 1, 2):
    if a[i] % 2 != 0:
        res += 1

print(res)
"
0,"n = int(input())
a = [int(i) for i in input().split()]
b = [int(i) for i in input().split()]
c = [int(i) for i in input().split()]
ans = b[a[0] - 1]
for i in range(1, n):
    ans += b[a[i] - 1]
    if a[i] == a[i - 1] + 1:
        ans += c[a[i - 1] - 1]
print(ans)
"
0,"#!/usr/bin/env python3

import sys

sys.setrecursionlimit(1000000)

n, m = [int(x) for x in input().split()]
edges = []
g = [[] for _ in range(n)]
for _ in range(m):
    a, b = [int(x) for x in input().split()]
    a -= 1
    b -= 1
    e = len(edges)
    g[a].append(e)
    g[b].append(e)
    edges.append((a, b))

if m % 2 == 1:
    print(-1)
    sys.exit(0)


visited = [False] * n
visitede = [False] * m


def build_stree(i):
    cts = []
    for e in g[i]:
        j = edges[e][1 if edges[e][0] == i else 0]
        if visited[j]:
            continue
        visitede[e] = True
        visited[j] = True
        cts.append((e, build_stree(j)))
    return i, cts


visited[0] = True
st = build_stree(0)

rev_e = [None if v else False for v in visitede]


def pos(t):
    i, cts = t
    for _, ct in cts:
        pos(ct)
    es = [e for e in g[i] if rev_e[e] is None]
    assert len(es) <= 1
    if not es:
        return
    f = es[0]
    rev_e[f] = (sum((edges[e][0] == i) ^ rev_e[e] for e in g[i] if e != f) % 2 != 0) ^ (
        edges[f][0] == i
    )


pos(st)

for ed, re in zip(edges, rev_e):
    if re:
        b, a = ed
    else:
        a, b = ed
    print(a + 1, b + 1)
"
0,"a, b, t = (int(i) for i in input())

times = int(t / a)

num = times * b

print(num)
"
1,"W, H, x, y = map(int, .split())
print(W * H / 2, 1 if x != 0 and y != 0 and W / x == 2 and H / y == 2 else 0)
"
0,"def gcd(x, y):
    while y:
        x, y = y, x % y
    return x


n = int(input())
a = list(map(int, input().split()))
fromLeft = [0] * n
fromLeft[0] = a[0]
fromRight = [0] * n
fromRight[0] = a[n - 1]
for i in range(1, n):
    fromLeft[i] = gcd(fromLeft[i - 1], a[i])
    fromRight[i] = gcd(fromRight[i - 1], a[n - i - 1])
ret = fromLeft[n - 1]
for i in range(n):
    if i == 0:
        curGcd = fromRight[n - 2]
    elif i == n - 1:
        curGcd = fromLeft[n - 2]
    else:
        curGcd = gcd(fromLeft[i - 1], fromRight[n - i - 2])
    ret = max(ret, curGcd)
print(ret)
"
0,"n = input()
for ans in range(111, 1000, 111):
    if n <= ans:
        break
print(ans)
"
1,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60
MOD = 1000000007


def main():
    N, K, *A = map(int, read().split())

    ng = 0
    ok = 10**9
    while ok - ng > 1:
        mid = (ok + ng) // 2
        res = 0
        for a in A:
            res += (a + mid - 1) // mid - 1
        if res <= K:
            ok = mid
        else:
            ng = mid

    pritn(ok)
    return


if __name__ == ""__main__"":
    main()
"
0,"h, n = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(n)]
dp = [0] * (h + max(a for a, b in ab))
for i in range(1, h + 1):
    dp[i] = min(dp[i - a] + b for a, b in ab)
print(dp[h])
"
0,"pi = 3.14159265359
r = float(input())

print(f""{r*r*pi:.6f} {2*r*pi:.6f}"")
"
0,"N = 10**6


def f(x):
    return x


M = 10**5
arr = list(range(M))
for i in range(N):
    t = (i + i * i - i) % M  # 四則演算
    b = arr[t]  # 配列ランダムアクセス
    b = f(b)  # 関数呼び出し

# 答え
a = int(input())
print(a + a**2 + a**3)
"
0,"import numpy as np

N = int(input())
a = np.fromstring(input(), sep="" "", dtype=np.int64)
b = np.bitwise_xor.reduce(a)
c = np.bitwise_xor(a, b)
print(*c, sep="" "")
"
1,"input = input()
print(input**3)

print(unknown_var)"
1,"from typing import List


class DSU:
    def __init__(self, n: int) -> None:
        self._n = n
        self.parent_or_size = [-1] * n

    def merge(self, a: int, b: int) -> int:
        assert 0 <= a <= self._n
        assert 0 <= b <= self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self.parent_or_size[y] = x
        return x

    def same(self, a: int, b: int) -> bool:
        assert 0 <= a <= self._n
        assert 0 <= b <= self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a: int) -> int:
        assert 0 <= a < self._n
        stack = []
        while self.parent_or_size[a] >= 0:
            stack.append(a)
            a = self.parent_or_size[a]
        for i in stack:
            self.parent_or_size[i] = a
        return a

    def size(self, a: int) -> int:
        assert 0 <= a <= self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self) -> List[List[int]]:
        leader_buf = [self.leader(i) for i in range(self._n)]
        group_size = [0] * self._n
        for i in leader_buf:
            group_size[i] += 1
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        result = [i for i in result if i]
        return result


n, q = map(int, input().split())
dsu = DSU(n)

for _ in range(q):
    t, u, v = map(int, input().split())
    if t == 0:
        dsu.merge(u, v)
    else:
        pritn(1 if dsu.same(u, v) else 0)
"
1,"n = int()
(*A,) = map(int, .split())
m = max(A)
C = [0 for a in range(m + 1)]
for a in A:
    C[a] += 1
s = 0
for a in range(2, m + 1):
    s = max(s, sum(C[a::a]))
if s < 2:
    print(""pairwise coprime"")
elif s < n:
    print(""setwise coprime"")
else:
    print(""not coprime"")
"
1,"import sys

N = int(input())
X = [int(_) for _ in input().split()]
ans_list = []
if N == 1:
    pritn(""0"")
    sys.exit()
for i in range(min(X), max(X) + 1):
    ans = 0
    for j in X:
        ans += (j - i) ** 2
    ans_list.append(ans)

pritn(min(ans_list))
"
1,"import sys

input = sys.stdin.readline


def main():
    AB = []
    n = int()
    for i in range(n):
        a, b = map(int, .split())
        AB.append([a, b])
    AB = sorted(AB, key=lambda x: (x[1], -x[0]))
    time = 0
    for span, dead in zip(AB):
        time += span
        if time > dead:
            print(""No"")
            return
    print(""Yes"")
    return


if __name__ == ""__main__"":
    main()
"
1,"def input_li():
    return list(map(int, input().split()))


def input_int():
    return int(input())


def prime_factorization(n):
    table = []
    for x in range(2, int(n**0.5) + 1):
        while n % x == 0:
            table.append(x)
            n //= x
    if n > 1:
        table.append(n)
    return table


A, B = input_li()
A_LI = [x[0] for x in prime_factorization(A)]
B_LI = [x[0] for x in prime_factorization(B)]
print(len(set(A_LI) & set(B_LI)) + 1)

print(unknown_var)"
1,"# -*- coding utf-8 -*-
a, b, c, d, e = map(int, input().split())

suuji_list = ["""", a, b, c, d, e]

print(list.index(0))
"
1,"N = int(input())

print(N * (N - 1) // 2)
"
1,"S, T = map(str, .split())
print(T + S).split("""")
"
0,"# -*- coding:utf-8 -*-

import math

N = int(input())

type_dict = {}
for _ in range(N):
    s = input()
    counts = (
        s.count(""a""),
        s.count(""b""),
        s.count(""c""),
        s.count(""d""),
        s.count(""e""),
        s.count(""f""),
        s.count(""g""),
        s.count(""h""),
        s.count(""i""),
        s.count(""j""),
        s.count(""k""),
        s.count(""l""),
        s.count(""m""),
        s.count(""n""),
        s.count(""o""),
        s.count(""p""),
        s.count(""q""),
        s.count(""r""),
        s.count(""s""),
        s.count(""t""),
        s.count(""u""),
        s.count(""v""),
        s.count(""w""),
        s.count(""x""),
        s.count(""y""),
        s.count(""z""),
    )
    if counts in type_dict:
        type_dict[counts] = type_dict[counts] + 1
    else:
        type_dict[counts] = 1


def combinations_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


print(sum([combinations_count(x, 2) for x in type_dict.items() if x > 1]))
"
0,"def solve():
    N, M = map(int, input().split())
    A = []
    if M != 0:
        A = [int(input()) for _ in range(M)]
    A.sort(reverse=True)
    mm = 10**9 + 7
    dp = [0] * (N + 1)
    dp[0] = 1  # 0段目に行くパターンは1とする
    tag = -1
    if len(A) != 0:
        tag = A.pop()
    # 1段目のパターンを設定
    if tag == 1:
        dp[1] = 0
        if len(A) == 0:
            tag = -1
        else:
            tag = A.pop()
    else:
        dp[1] = 1
    for i in range(2, N + 1):
        if i == tag:
            if len(A) == 0:
                tag = -1
            else:
                tag = A.pop()
            continue
        dp[i] = (dp[i - 1] + dp[i - 2]) % mm
    print(dp[N])


if __name__ == ""__main__"":
    solve()
"
1,"w = input()
weather = [""Sunny"", ""Cloudy"", ""Rainy""]

index = weather.index(w)
index += 1
if index == 3
    index = 0

print(weather[index])
"
1,"def main():
    N, M = map(int, .split())
    A = sorted(list(map(int, .split())))
    BC = []
    for _ in range(M):
        B, C = map(int, .split())
        BC.append((B, C))
    BC = sorted(BC, key=lambda x: x[1], reverse=True)
    i = 0
    for b, c in BC:
        for _ in range(b):
            if i >= len(A) or A[i] >= c:
                break
            A[i] = c
            i += 1
    print(sum(A))


main()
"
1,"def kukan(n, a):
    dp = [[0] * n for _ in range(n)]
    for i in range(n):
        dp[i][i] = a[i]
    for i in range(n - 2, -1, -1):
        for j in range(i + 1, n):
            L = a[i] - dp[i + 1][j]
            R = a[j] - dp[i][j - 1]
            dp[i][j] = L if L > R else R
    return dp[0][n - 1]


n = int()
a = list(map(int, .split()))
print(kukan(n, a))
"
1,"N = int()
A = list(map(int, .split()))

if 0 in A:
    print(0)

else:
    total = 1
    for i in range(N):
        total *= A[i]
        if total > 10**18:
            total = -1
            break
    print(total)
"
0,"import sys
import collections


def solve():
    readline = sys.stdin.buffer.readline
    h, w = list(map(int, readline().split()))
    a = [[True] * w for _ in range(h)]
    ql = []
    ql = collections.deque(ql)
    for i in range(h):
        s = str(readline().rstrip().decode(""utf-8""))
        for j in range(w):
            if s[j] == ""#"":
                a[i][j] = False
                ql.append([0, i, j])

    mt = 0
    while True:
        if len(ql) != 0:
            cost, x, y = ql.popleft()
            mt = max(mt, cost)
            for xv, yv in [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]]:
                if 0 <= xv < h and 0 <= yv < w:
                    if a[xv][yv]:
                        ql.append([cost + 1, xv, yv])
                        a[xv][yv] = False
        else:
            break
    print(mt)


if __name__ == ""__main__"":
    solve()
"
0,"# from math import gcd
from fraction import gcd
import sys

N, M = map(int, input().split())
S = input()
T = input()

d = gcd(N, M)
m = N * M // d

for i in range(d):
    if S[i * (N // d)] != T[i * (M // d)]:
        print(-1)
        sys.exit()

print(m)
"
1,"# ABC153
# B Common Raccoon VS Monster
h, n = map(int, .split())
a = list(map(int, .split()))
s = sum(a)
if a <= s:
    print(""Yes"")
else:
    print(""No"")
"
0,"def main() -> None:
    num = [int(input()) for _ in range(5)]
    ans = 0
    m = [0]
    for i in num:
        if i % 10:
            ans += i + 10 - i % 10
            m.append(10 - i % 10)
        else:
            ans += i
    print(ans - max(m))


if __name__ == ""__main__"":
    main()
"
1,"k = int()

if k % 2 == 0 or k % 5 == 0:
    print(-1)
else:
    ans = 1
    num = 7 % k
    temp = 7 % k
    while True:
        if num % k == 0:
            print(ans)
            break
        else:
            ans += 1
            temp = temp * 10 % k
            num += temp % k
            num %= k
"
0,"A, B, C, K = map(int, input.split("" ""))
if K <= A:
    print(K)
else:
    K = K - A
    if K <= B:
        print(A)
    else:
        K = K - B
        print(A - K)
"
0,"import math

a, b, x = map(int, input().split())

b_1 = x / (a**2)
area_1 = a * b_1
area_2 = (a * b) / 2

if b_1 == b:
    ans = 90
elif area_2 > area_1:
    # 三角形
    h = (a * b_1 * 2) / b
    ans = math.degrees(math.atan(h / b))
else:
    # 梯形
    upside_len = b_1 * 2 - b
    ans = math.degrees(math.atan(a / (b - upside_len)))

print(90 - ans)
"
1,"def main():
    import sys

    input = sys.stdin.readline

    x, y, z, k = map(int, .split())
    A = sorted(map(int, .split()), reverse=True)
    B = sorted(map(int, .split()), reverse=True)
    C = sorted(map(int, .split()), reverse=True)

    ret = []
    for p, a in enumerate(A):
        for q, b in enumerate(B):
            if p * q > k:
                break
            for r, c in enumerate(C):
                if p * q * r > k:
                    break
                ret.append(a + b + c)
    ret.sort(reverse=True)
    print(*ret[:k], sep=""\n"")


main()

# O(Klog^3K)
# https://img.atcoder.jp/abc123/editorial.pdf
"
0,"# input
N, M = map(int, input().split())
a = []
a_append = a.append

for n in range(M):
    a_append(int(input()))

mod = 1000000007

# check
check = [True] * (N + 1)
for i in a:
    check[i] = False

dp = {0: 1}
if check[1] is True:
    dp[1] = 1
else:
    dp[1] = 0

for n in range(2, N + 1):
    dp[n] = 0
    if check[n - 1] is True:
        dp[n] += dp[n - 1]
    if check[n - 2] is True:
        dp[n] += dp[n - 2]
    dp[n] %= mod

print(dp[N])
"
0,"import heapq

N, M = map(int, input().split())
dic = {}
for i in range(N):
    A, B = map(int, input().split())
    if A not in dic:
        dic[A] = [-B]
    else:
        dic[A].append(-B)
# print(dic, sorted(dic.keys()))

ans = 0
heap = []

for i in range(M):
    # print(i)
    if i + 1 in dic:
        for j in dic[i + 1]:
            heapq.heappush(heap, j)
    # print(heap)
    if heap:
        ans = ans - heapq.heappop(heap)

print(ans)
"
0,"import collections
import sys

input = sys.stdin.readline

q = int(input())
a = [input().rstrip() for _ in range(q)]

dic = collections.Counter(a)

ma = max(dic.values())
keys = [k for k, v in dic.items() if v == ma]
keys_s = sorted(keys)
for i in keys_s:
    print(i)
"
0,"from heapq import heappop, heapify, heappush


def main():
    n, m = map(int, input().split())
    work = [[] for _ in range(10**5 + 1)]
    for _ in range(n):
        a, b = map(int, input().split())
        work[a].append(b)
    ans = 0
    q = []
    heapify(q)
    for i in range(1, m + 1):
        for w in work[i]:
            heappush(q, -w)
        if len(q) == 0:
            continue
        ans += heappop(q)
    ans *= -1
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"from collections import deque


H, W = map(int, input().split())
A = [list(""#"" * (W + 2))]
q = deque()
A_append = A.append
q_append = q.append
for _ in range(H):
    a = input()
    A_append(list(""#"" + a + ""#""))
A.append(list(""#"" * (W + 2)))
dx = [-1, 0, 1, 0]
dy = [0, -1, 0, 1]

for i in range(1, H + 1):
    for j in range(1, W + 1):
        if A[i][j] == ""#"":
            q_append([i, j, 0])

ans = 0

while len(q) != 0:
    p = q.popleft()
    for k in range(4):
        y = p[0] + dy[k]
        x = p[1] + dx[k]
        c = p[2]
        ans = max(ans, c)
        if A[y][x] == ""."":
            A[y][x] = ""#""
            q_append([y, x, c + 1])

pritn(ans)
"
0,"import collections

N = int(input())
A = [int(_) for _ in input().split()]


class Prime:
    @staticmethod
    def trial_division(x):
        if x % 2 == 0:
            return True
        for p in range(3, int(x**0.5 + 1), 2):
            if x % p == 0:
                return False
        return True

    @staticmethod
    def factorization(n):
        a = set()
        while n % 2 == 0:
            a.add(2)
            n //= 2
        f = 3
        while f * f <= n:
            if n % f == 0:
                a.add(f)
                n //= f
            else:
                f += 2
        if n != 1:
            a.add(n)
        return a

    @staticmethod
    def miller_rabin(n):
        def suspect(a, t, n):
            x = pow(a, t, n)
            n1 = n - 1
            while t != n1 and x != 1 and x != n1:
                x = pow(x, 2, n)
                t <<= 1
            return t & 1 or x == n1

        if n == 2:
            return True
        if n < 2 or n % 2 == 0:
            return False
        d = (n - 1) >> 1
        while d & 1 == 0:
            d >>= 1

        if n < 2**32:
            check_list = (2, 7, 61)
        elif n < 2**48:
            check_list = (2, 3, 5, 7, 11, 13, 17, 19, 23)
        else:
            check_list = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37)

        for i in check_list:
            if i >= n:
                break
            if not suspect(i, d, n):
                return False
        return True


c = collections.defaultdict(int)
for a in A:
    for p in Prime.factorization(a):
        c[p] += 1
ans = ""pairwise coprime""
if c:
    x = max(c.values())
    if x == 1:
        ans = ""pairwise coprime""
    elif x == N:
        ans = ""not coprime""
    else:
        ans = ""setwise coprime""
print(ans)
"
0,"MOD = 10**9 + 7
N = int(input())
A = list(map(int, input().split()))

ans = 0
m = 1
for i in range(60):
    bits = sum((a & m for a in A))
    bits //= m
    ans += bits * (N - bits) * m
    ans %= MOD
    m <<= 1
print(ans % MOD)
"
0,"import math

time_list = list()

for _ in range(5):
    time_list.append(int(input()))


def key_func(x):
    if x < 100:  # 2桁 or 1桁の場合
        if x % 10 == 0:
            return 10
        return x % 10  # ex: 19の場合は9を返す
    else:
        if x % 100 == 0:
            return 10
        return x % 100  # ex: 123の場合は3を返す


time_list.sort(key=key_func, reverse=True)

# print(time_list)

ans = sum
for i, time in enumerate(time_list):
    if i < len(time_list) - 1:
        ans += math.ceil(time / 10) * 10
    else:
        ans += time

print(ans)
"
1,"A, B, K = map(int, .split())
a = max(0, A - K)
b = B
if K - A > 0:
    b = max(0, B - K + A)
print(a, b)
"
0,"n, m = map(int, input().split())
a = [[None] * n]
b = [None] * m
for i in range(n):
    a[i] = list(map(int, input().split()))
for i in range(m):
    b[i] = int(input())
for i in range(n):
    c = 0
    for j in range(m):
        c += a[i][j] * b[j]
    print(c)
"
0,"N = int(input())

if N == 1:
    print(""Hello World"")
elif N == 2:
    A = int(input())
    B = int(input())
    print(A + B)
"
1,"import sys
import operator

n, m = map(int, input().split())

a = [int(x) for x in sys.stdin.readline().rstrip().split()]
a.sort()

cards = [[int(x) for x in sys.stdin.readline().rstrip().split()] for _ in range(m)]
cards.sort(key=operator.itemgetter(1), reverse=True)

a_idx = 0
a_len = len(a)

for b, c in cards:
    if a_idx == a_len:
        break
    for b_idx in range(b):
        if a_idx == a_len or c <= a[a_idx]:
            break
        else:
            a[a_idx] = c
            a_idx += 1

print(sum(a))

print(unknown_var)"
0,"N, *s = map(open(0).read().split())
for v in (""AC"", ""WA"", ""TLE"", ""RE""):
    print(""{} x {}"".format(v, s.count(v)))
"
0,"# -*- coding: utf-8 -*-
import math

N = int(input()) - 1
M = 0
x = int(math.ceil((N) / 2))
if N % 2 == 0:
    M = x * (N + 1)
else:
    M = (x - 1) * (N + 1) + x
print(M)
"
1,"N = int(input())
print(N * (N - 1) // 2)

print(unknown_var)"
0,"import math


def run(N):
    if N == 0:
        return 0
    ans = 0
    if N % 2 == 0:
        for i in range(int(math.log(N, 5))):
            ans += N // (10 * (5**i))
    return ans


def main():
    N = int(input())
    print(run(N))


if __name__ == ""__main__"":
    main()
"
1,"import numpy as np
from numba import njit


@njit(""(f8[,,],i4,i4,i4,i4,)"")
def solve(dp, N, n1, n2, n3)
    if dp[n1][n2][n3] >= 0.0
        return dp[n1][n2][n3]
    if n1 == n2 == n3 == 0
        return 0.0

    cnt = n1 + n2 + n3
    ret = 0
    if n3 >= 1
        ret += solve(dp, N, n1, n2 + 1, n3 - 1) * n3
    if n2 >= 1
        ret += solve(dp, N, n1 + 1, n2 - 1, n3) * n2
    if n1 >= 1
        ret += solve(dp, N, n1 - 1, n2, n3) * n1

    ret = (ret + N) / cnt
    dp[n1][n2][n3] = ret
    return ret


def main()
    N = int(input())
    A = list(map(int, input().split()))

    dp = np.full((N + 1, N + 1, N + 1), -1, dtype=np.float64)

    a1, a2, a3 = 0, 0, 0
    for i in range(N)
        if A[i] == 1
            a1 += 1
        elif A[i] == 2
            a2 += 1
        elif A[i] == 3
            a3 += 1

    print(solve(dp, N, a1, a2, a3))


if __name__ == ""__main__""
    main()
"
1,"N, W = [int(_) for _ in .split()]
WV = [[int(_) for _ in .split()] for _ in range(N)]
dp = {}
dp[0] = 0
for w, v in WV:
    dp_o = dp.copy()
    for k in dp_o:
        if k + w <= W:
            dp[k + w] = max(dp_o.get(k + w, 0), dp_o[k] + v)
print(max([v for k, v in dp.items()]))
"
1,"from fractions import gcd

A, B, C, D = map(int, input().split())
G = gcd(C, D)
L = C * D // G
ca = (A - 1) // C
cb = B // C
da = (A - 1) // D
db = B // D
la = (A - 1) // L
lb = B // L
div = cb + db - (ca + da) - (lb - la)
pritn(B - (A - 1) - div)
"
1,"s = input()
ans = 0
cntA = 0
for i in range(0, len(s) - 1):
    if s[i] == ""A"":
        cntA += 1
    elif s[i : i + 2] == ""BC"":
        ans += cntA
    elif i > 0 and s[i - 1 : i + 1] == ""BC"":
        continue
    else:
        cntA = 0
pritn(ans)
# pritn(*data, sep='\n')
"
1,"def main():
    A = input()[::-1]
    A = ""0"" + A
    # lis_num = [int(s) for s in A]

    # print(lis_num)

    # S = [0] * len(lis_num)
    S = [0] * len(A)
    cnt = [0] * 2019
    cnt[0] = 1

    for i in range(len(A) - 1):
        S[i + 1] = (S[i] + int(A[i + 1]) * pow(10, i, 2019)) % 2019
        cnt[S[i + 1] % 2019] += 1

    # print(S)

    # for i in S:
    #     cnt[i % 2019] += 1

    ans = 0

    for i in cnt:
        ans += i * (i - 1) // 2

    print(ans)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"import sys

input = sys.stdin.readline


alphabets = ""abcdefghijklmnopqrstuvwxyz""

c = input()
i = alphabets.index(c)

answer = alphabets[i + 1]
print(answer)
"
1,"n = int(input())

ans = 0
for a in range(1, n + 1):
    num = n // a
    ans += num * (num + 1) // 2 * a
print(ans)

print(unknown_var)"
1,"import sys

sys.setrecursionlimit(10**7)

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

S = list(input())
L = len(S)

c = 0
t = 0
md = [0] * 2019
md[0] += 1
for i in range(L - 1, -1, -1):
    t += int(S[i]) * pow(10, c, 2019)
    c += 1
    md[t % 2019] += 1

ans = 0
for i in range(2019):
    m = md[i]

    if m == 0:
        continue

    ans += m * (m - 1) // 2

pritn(ans)
"
1,"import heapq

N, M = map(int, input().split())
A_LIST = list(map(int, input().split()))
BC_LIST = []
heapq.heapify(A_LIST)
for i in range(M):
    b, c = map(int, input().split())
    BC_LIST.append([b, c])
BC_LIST.sort(reverse=True, key=lambda x: x[1])  # C降順にソート
for b, c in BC_LIST:
    for _ in range(b):
        tmp = heapq.heappop(A_LIST)
        if tmp < c:
            heapq.heappush(A_LIST, c)
        else:
            heapq.heappush(A_LIST, tmp)
            break
print(sum(A_LIST))

print(unknown_var)"
0,"N, K = map(int, input().split())
A = list(map(int, input().split()))

for _ in range(min(K, 50)):
    lamp = [0 for i in range(N + 1)]
    for i in range(N):
        lamp[max(0, i - A[i])] += 1
        lamp[min(N, i + A[i] + 1)] -= 1

    for i in range(1, N + 1):
        lamp[i] += lamp[i - 1]
    A = lamp

[print(A[i], end="" "") for i in range(N)]
print()
"
0,"n = int(input())
print(n * (n - 1) // 2)
"
1,"N, K = map(int, .split())

if K > (N - 1)(N - 2) // 2:
    print(-1)
else:
    M = N * (N - 1) // 2 - K
    cnt = 0
    ans = []
    for i in range(N - 1):
        for j in range(i + 1, N):
            ans.append((i + 1, j + 1))
            cnt += 1
            if M == cnt:
                break
        else:
            continue
        break
    print(M)
    for edge in ans:
        print(*edge)
"
1,"N = int(input())
arr = list(map(int, input().split()))
first = 0
second = sum(arr)
min_delta = second - first
for i in range(N):
    first += arr[i]
    second -= arr[i]
    min_delta = min(abs(second - first), min_delta)

print(min_delta)

print(unknown_var)"
1,"a, b = map(int, .splot())
print(str(a * b) + str(2 * a + 2 * b))
"
1,"def solve(string):
    n, k, *v = map(int, string.split())
    ans = 0
    for i in range(k + 1):
        for j in range(k - i + 1):
            base = sorted(v[:i] + v[max(n - k + i + j, i) :])
            ans = max(ans, sum([b for l, b in enumerate(base) if b >= 0 or j <= l]))
    return str(ans)


if __name__ == ""__main__"":
    print(solve(""\n"".join([, ])))
"
0,"# https://atcoder.jp/contests/m-solutions2019/submissions/5741430
from operator import mul
import sys

input = sys.stdin.readline

MOD = 10**6 + 3


def inv(n):
    return pow(n, MOD - 2, MOD)


def mod_mul(x, y):
    return mul(x, y) % MOD


fact = [1]
for n in range(1, MOD):
    fact.append(mod_mul(fact[-1], n))
    # d>1 の数列を d=1 となる数列に変換する
    # MODの倍数を含む数列の積は0になるので,
    # MODの倍数を含まない区間の積が計算できればよい
    # そのような区間の右端はMOD-1であり,fact[MOD-1]が計算できればよい

Q = int(input())
for _ in range(Q):
    x, d, n = map(int, input().split())

    if x == 0:
        print(0)
        continue

    if d == 0:
        print(pow(x, n, MOD))
        continue

    xd = mod_mul(x, inv(d))
    if MOD - xd < n:
        print(0)
        continue

    dn = pow(d, n, MOD)
    print(mod_mul(mod_mul(fact[xd + n - 1], inv(fact[xd - 1])), dn))
"
1,"N = int(input())
A = list(map(int, input().split()))

if 0 in A
    print(0)
else
    ans = 1
    for i in range(A)
        ans += A[i]
        if ans > 10**18
            print(-1)
            exit()
    print(ans)
"
1,"n, x = map(int, input().split())
li = list(map(int, input().split()))
t = []
for i in li:
    t.append(abs(i - x))
divisors = []
for i in range(1, int(min(t) ** 0.5) + 1):
    if min(t) % i == 0:
        divisors.append(i)
        if i != min(t) // i:
            divisors.append(min(t) // i)
divisors.sort()
divisors = divisors[::-1]
for j in divisors:
    if all(k % j == 0 for k in t):
        pritn(j)
        exit()
"
1,"# 0-index segment tree


class SegmentTree:
    """"""
    init(init_val, ide_ele): 配列init_valで初期化  O(N)
    update(k, x): k番目の値をxに更新                O(logN)
    query(l, r): 区間[l, r)をsegfuncしたものを返す   O(logN)
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        init_val: 配列の初期値
        segfunc: 区間にしたい操作
        ide_ele: 単位元
        n: 要素数
        num: n以上の最小の2のべき乗
        tree: セグメント木(0-index)
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # 配列の値を葉にセット
        for i in range(n):
            self.tree[self.num - 1 + i] = init_val[i]
        # 構築していく
        for i in range(self.num - 2, -1, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i + 1], self.tree[2 * i + 2])

    def update(self, k, x):
        """"""
        k番目の値をxに更新
        k: index(0-index)
        x: update value
        """"""
        k += self.num - 1
        # self.tree[k]  = x   <- when updated
        # self.tree[k] += x  <- when added
        self.tree[k] = x
        while k > 0:
            k = (k - 1) // 2
            self.tree[k] = self.segfunc(self.tree[2 * k + 1], self.tree[2 * k + 2])

    def query(self, left, right):
        if left >= right:
            print(""left must be smaller than right"")
            exit(0)

        if right > self.num:
            print(""right must be smaller than self.num"")
            exit(0)

        """"""
        [l, r)のsegfuncしたものを得る
        l: index(0-index)
        r: index(0-index)
        """"""
        res = self.ide_ele

        left += self.num - 1
        right += self.num - 1
        while left < right:
            if left & 1 == 0:
                res = self.segfunc(res, self.tree[left])
            if right & 1 == 0:
                right -= 1
                res = self.segfunc(res, self.tree[right])
            left >>= 1
            right >>= 1
        return res


MAX_NUM = 300000
n, k = map(int, input().split())

a = []
for i in range(n):
    a.append(int(input()))

dp = [0] * (MAX_NUM + 5)

segfunc = max
ide_ele = -float(""inf"")

st = SegmentTree(dp, segfunc, ide_ele)

for num in a:
    left = max(0, num - k)
    right = min(MAX_NUM, num + k) + 1

    st.update(num, st.query(left, right) + 1)

print(st.query(0, MAX_NUM + 1))

print(unknown_var)"
0,"n, m = map(int, input().split())
a = list(map(int, input().split()))

dp = dict.fromkeys(range(n + 1))  # dp[n]: n本使うときの桁数
dp[0] = 0

num = {1: 2, 2: 5, 3: 5, 4: 4, 5: 5, 6: 6, 7: 3, 8: 7, 9: 6}
anum = sorted(
    dict(filter(lambda e: e[0] in a, num.items())).items(), reverse=True
)  # 後の計算用にsortしておく

for i in range(n):
    dp[i + 1] = -float(""inf"")
    for e in anum:
        if i + 1 - e[1] >= 0:
            dp[i + 1] = max(dp[i + 1], dp[i + 1 - e[1]] + 1)

ans = """"
while dp[n] > 1:
    for e in anum:  # anum は降順sortされているので, 大きい順に確認
        if n - e[1] >= 0:
            if dp[n - e[1]] == dp[n] - 1:
                ans += str(e[0])
                n -= e[1]
                break

# 末尾桁は n =0(ちょうど使い切るように決定)
ans += str(list(filter(lambda e: e[1] == n, anum))[0][0])

print(ans)
"
1,"times = []
ones = [10]
for i in range(5):
    t = int(input())
    times.append((t + 9) // 10 * 10)
    ones.append(t % 10)
ones.sort()
print(sum(times) - 10 + min(filter(lambda x: x, ones)))

print(unknown_var)"
1,"k = int()

if k % 2 == 0 or k % 5 == 0:
    print(-1)
else:
    ans = 1
    num = 7
    while True:
        if num % k == 0:
            print(ans)
            break
        else:
            ans += 1
            num += 7 * pow(10, ans - 1, k)
            num %= k
"
1,"import itertools

N, K = map(int, .split())
p = list(map(int, .split()))

ans = 0
for _ in range(K):
    min_index = p.index(min(p))
    minv = p.pop(min_index)
    ans += minv

print(ans)
"
0,"from sys import stdin

N = int(stdin.readline().rstrip())
S = stdin.readline().rstrip()
dp = [[0] * (N + 1) for _ in range(N + 1)]
res = 0

for i in range(N - 1, -1, -1):
    for j in range(N - 1, i, -1):
        if S[i] == S[j]:
            dp[i][j] = dp[i + 1][j + 1] + 1, dp[i][j]
        res = max(res, min(j - i, dp[i][j]))

print(res)
"
1,"print(*sorted(map(int, input().spilt()))[::-1])

print(unknown_var)"
0,"N, K = map(int, input())
print(N - (K - 1))
"
1,"import math

r = 100
n = input()
for i in range(n):
    r = math.ceil(r * 1.05)
print(r * 1000)

print(unknown_var)"
1,"S = int(input())
h = S // 3600
m = (S % 3600) // 60
s = (S % 3600) % 60
pritn("":"".join[h, m, s])
"
0,"def main():
    from collections import Counter

    n, s = int(input()), input()
    c = Counter(s)
    d = list(c.values())
    if len(d) < 3:
        print(0)
        exit()
    ans = d[0] * d[1] * d[2]
    rgb = {""R"", ""G"", ""B""}
    for i in range(1, n // 2 + 1):
        for j in range(i):
            x = s[j::i]
            for a, b, c in zip(x, x[1:], x[2:]):
                g = {a, b, c}
                if g == rgb:
                    ans -= 1

    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"from fractions import gcd

n = int(input())
a = list(map(int, input().split()))
if n == 2:
    pritn(max(a))
    exit()
x = [a[0], gcd(a[0], a[1])]
for i in range(n - 3):
    x.append(gcd(x[i + 1], a[i + 2]))
ans = x[-1]
y = a[-1]
for i in range(1, n - 1):
    z = gcd(y, a[-i])
    ans = max(ans, gcd(x[-i - 1], z))
    y = z
pritn(max(ans, gcd(y, a[1])))
"
0,"def main():
    from functools import reduce

    def gcd(a, b):
        return a if b == 0 else gcd(b, a % b)

    def lcm(a, b):
        return (a // gcd(a, b)) * b

    N, M = map(int, input().split())
    (*a,) = map(int, input().split())

    p = -1
    b = []
    for x in a:
        cnt = 0
        while x % 2 == 0:
            x //= 2
            cnt += 1
        if ~p and p != cnt:
            print(0)
            return
        p = cnt
        b.append(x)

    if p == 0:
        print(0)
        return

    t = pow(2, p - 1) * reduce(lcm, b)
    ans = (M // t) - (M // (t * 2))

    print(ans)


if __name__ == ""__main__"":
    main()

# import sys
#
# sys.setrecursionlimit(10 ** 7)
#
# input = sys.stdin.readline
# rstrip()
# int(input())
# map(int, input().split())
"
1,"import sys
from collections import Counter


def :
    return sys.stdin.readline().strip()


sys.setrecursionlimit(20000000)

MOD = 10**9 + 7
INF = float(""inf"")


def main():
    N = int()
    S = 
    C = Counter(S)
    r = C.get(""R"", 0)
    g = C.get(""G"", 0)
    b = C.get(""B"", 0)
    answer = r * g * b
    for left in range(N):
        for mid in range(left + 1, N):
            right = mid * 2 - left
            if right < N:
                if S[right] != S[mid] and S[mid] != S[left] and S[right] != S[left]:
                    answer -= 1
    print(answer)


if __name__ == ""__main__"":
    main()
"
0,"n = int(input())
h = list(map(int, input().split()))

max_step = 0
current_step = 0
for i in range(n - 1):
    if h[i] >= h[i + 1]:
        current_step += 1
        if current_step > max_step:
            max_step = current_step
    else:
        current_step = 0
print(max_step)
"
1,"def c(i, p, f, g, k, vis):
    if vis[i]:
        return
    vis[i] = True
    w = f[i] + p
    k[i] = w
    ch = g[i]
    for x in ch:
        c(x, w, f, g, k, vis)


def main():
    import sys

    sys.setrecursionlimit(300000)
    n, q, *abpx = map(int, sys.stdin.read().split())

    g = [[] for _ in range(n + 1)]
    for u, v in zip(*[iter(abpx[: 2 * (n - 1)])] * 2):
        g[u].append(v)
        g[v].append(u)

    f = [0 for _ in range(n + 1)]

    for p, x in zip(*[iter(abpx[2 * (n - 1) :])] * 2):
        f[p] += x

    k = [0 for _ in range(n + 1)]
    vis = [False for _ in range(n + 1)]

    c(1, 0, f, g, k, vis)
    ans = "" "".join(map(str, k[1:]))
    print(ans)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"def main():
    s = input()
    rem = [0] * 2019  # the count of the each remainder: 0 ~ 2018
    rem[0] = 1  # why? can't understand.

    temp = 0
    digit = 1
    for i, c in enumerate(s[::-1]):
        # No time to pow.
        temp += int(c) * digit
        rem[temp % 2019] += 1
        digit *= 10
        digit %= 2019

    return sum(c * (c - 1) // 2 for c in rem)


if __name__ == ""__main__"":
    print(main())

print(unknown_var)"
0,"import sys

sys.setrecursionlimit(110000)


def inpl():
    return list(map(int, input().split()))


class UnionFind:
    def __init__(self, N):
        # par = parent
        self.par = [i for i in range(N)]
        self.N = N
        self.hop = {i: -1 for i in range(N)}
        self.adj = [[] for i in range(N)]
        return

    def root(self, x):
        if self.par[x] == x:
            return x
        else:
            self.par[x] = self.root(self.par[x])
            return self.par[x]

    def same(self, x, y):
        return self.root(x) == self.root(y)

    def union(self, x, y):
        x = self.root(x)
        y = self.root(y)
        if x == y:
            return False

        self.par[x] = min(x, y)
        self.par[y] = min(x, y)
        return True

    def find_root(self):
        for i in range(self.N):
            if i == self.root(i):
                return i
        return

    def dfs(self, i):
        for nh in self.adj[i]:
            if self.hop[nh] != -1:
                continue
            else:
                self.hop[nh] = self.hop[i] + 1
                self.dfs(nh)
        return


N = int(input())
uf = UnionFind(N)
AB = [[0, 0] for i in range(N - 1)]

for i in range(N - 1):
    a, b = inpl()
    a -= 1
    b -= 1
    AB[i][0] = a
    AB[i][1] = b
    uf.adj[a].append(b)
    uf.adj[b].append(a)

C = inpl()

for a, b in AB:
    uf.union(a, b)

root_num = uf.find_root()
uf.hop[root_num] = 0
uf.dfs(root_num)

dic2 = sorted(uf.hop.items(), key=lambda x: x[1], reverse=True)

ans = [0 for i in range(N)]
for i, k in enumerate(dic2):
    ans[k[0]] = i

C.sort()

print(sum(C[:-1]))
for i in range(N):
    if i != 0:
        print("" "", end="""")
    print(C[ans[i]], end="""")
print("""")
"
0,"n, k = map(int, input().split())
counter = 1
while n >= k:
    n = int(n / k)
    counter += 1
print(counter)
"
1,"import math

N = int(input())
ans = 0
for i in range(1, math.ceil(math.sqrt(N)) + 1)
    if N % i
        continue
    n = N // i - 1
    if n and N % n == N // n
        ans += n
print(ans)
"
1,"from sys import stdin, setrecursionlimit

setrecursionlimit(10**9)
INF = 1 << 60


def :
    return stdin.readline().strip()


MOD = 1000000007
X, Y = map(int, .split())

n = (X + Y) // 3
x = (2 * X - Y) // 3
y = (-X + 2 * Y) // 3
if (X + Y) % 3 or x < 0 or y < 0:
    print(0)
    exit()


def mod_com(n, k):
    if n < k:
        return 0
    if n < 0 or k < 0:
        return 0
    if k > n - k:
        k = n - k
    if k == 0:
        return 1
    ans = 1
    for i in range(n - k + 1, n + 1):
        ans = ans * i % MOD

    inv = [0] * (k + 1)
    inv[1] = 1
    for i in range(2, k + 1):
        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD
        ans = ans * inv[i] % MOD

    return ans


print(mod_com(n, x))
"
0,"X, Y, Z, K = [int(i) for i in input().split()]
ABCList = [sorted([int(i) for i in input().split()], reverse=True) for _ in range(3)]

ansList = []
for i, A in enumerate(ABCList[0]):
    for j, B in enumerate(ABCList[1]):
        for k, C in enumerate(ABCList[2]):
            if (i + 1) * (j + 1) * (k + 1) <= K:
                ansList.append(A + B + C)
            else:
                break

for ans in sorted(ansList, reverse=True)[:K]:
    print(ans)
"
1,"N, W, H = map(int, .split())

print((N - W + 1) * (N - H + 1))
"
1,"from collections import deque


def main():
    N, K = map(int, input().split())
    sushis = [None] * N
    for i in range(N):
        t, d = map(int, input().split())
        sushis[i] = (t, d)
    sushis.sort(key=lambda a: (-a[1], a[0]))
    tmp = 0
    types = set()
    stack = deque()
    ans = 0
    for i in range(len(sushis)):
        t, d = sushis[i]
        if i < K:
            if t in types:
                stack.append(d)
            types.add(t)
            tmp += d
        else:
            if t not in types and len(stack):
                types.add(t)
                tmp += d
                tmp -= stack.pop()
        ans = max(ans, tmp + len(types) ** 2)
    pritn(ans)


if __name__ == ""__main__"":
    main()
"
1,"n = int(input())
A = [int(input()) for i in range(n)]

print(""second"" if all(A[i] % 2 == 0 for i in range(n)) else ""first"")
"
1,"n = int()
s = 
k = int() - 1

s = list(map(lambda x: ""*"" if x != s[k] else x, s))

print(*s, sep="""")
"
0,"a = int(input())
b = int(input())
c = int(input())
d = int(input())
e = int(input())
li = [a, b, c, d, e]
li_2 = []
d = 10
count = 0
adr = 0
for i in li:
    li_2.append(i % 10)
for i in li_2:
    if i < d and i != 0:
        d = i
        ans = adr
    adr += 1
if d == 10:
    d = 0
    ans = 0
for i in range(5):
    if i != ans and li_2[i] != 0:
        count += li[i] - li_2[i] + 10
    elif i != ans and li_2[i] == 0:
        count += li[i]
count += li[ans]
print(count)
"
0,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from EmurateInput import input

N, S = int(input()), input()


def rot_encode(n):
    from string import ascii_lowercase as lc, ascii_uppercase as uc

    lookup = str.maketrans(lc + uc, lc[n:] + lc[:n] + uc[n:] + uc[:n])
    return lambda s: s.translate(lookup)


print(rot_encode(N)(S))
"
0,"A, B = map(int, input().split())
if (A + B) % 2 != 0:
    print(""IMPOSSIBLE"")
else:
    print((A + B) // 2)
"
0,"import sys
import collections
import bisect


def main():
    n = int(input())
    A = list(map(int, input().split()))
    B = [0] * n
    for i in range(n):
        B[A[i] - 1] = str(i + 1)
    print("" "".join(B))


if __name__ == ""__main__"":
    main()
"
1,"H, N = map(int, .split())
magic = [list(map(int, .split())) for _ in range(N)]


max_magic = 0
for a, _ in magic:
    max_magic = max(max_magic, a)

amount = H + 1
dp = [0] * (amount + max_magic)
dp[0] = 0

ret = float(""inf"")

for amt in range(1, amount + max_magic):
    t = [dp[amt - a] + b if amt - a >= 0 else float(""inf"") for a, b in magic]

    dp[amt] = min(t)

    if amt >= H:
        ret = min(dp[amt], ret)

print(ret)
"
0,"N = int(input())
p = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    u, v, w = map(int, input().split())
    p[u].append((v, w))
    p[v].append((u, w))
s = [(1, 0)]
l = [-1] * N
while s:
    a, w = s.pop()
    l[a - 1] = w % 2
    for b, c in p[a]:
        if l[b - 1] == -1:
            s.append((b, w + c))
for i in l:
    print(i)
"
0,"import sys

sys.setrecursionlimit(10**8)

N, M = map(int, input().split())
graph = [dict() for _ in range(N)]

for i in range(M):
    x, y = map(int, input().split())
    graph[y - 1][x - 1] = 1

dp = [0 for _ in range(N)]


def dfs(u):
    if dp[u] != 0:
        return dp[u]
    max_dis = 0
    for f in graph[u].keys():
        if max_dis < dfs(f) + 1:
            max_dis = dfs(f) + 1

    dp[u] = max_dis
    return dp[u]


for i in range(N):
    dfs(i)
print(max(dp))
"
1,"import numpy as np

from bisect import bisect

DEBUG = False


N, K = list(map(int, input().split()))
A = list(map(int, input().split()))

A.sort()
A = np.array(A, dtype=np.int64)
neg = A[A < 0]
zero = A[A == 0]
pos = A[A > 0]

# Only keep the abs value of the negatives and flip so it's sorted
revAbsNeg = -neg[-1]


def countDistinctPairsLessThan(arr, prod)
    # Given a sorted array find the number of distinct pairs that are < prod
    # O(N * log(N)) where N = len(arr)

    N = arr.shape[0]
    assert arr.shape == (N,)
    count3 = np.sum(
        np.minimum(np.arange(N), np.searchsorted(arr, (prod - 1) // arr, side=""right""))
    )

    if DEBUG
        count = 0
        for i, x in enumerate(arr)
            count += bisect(arr, (prod - 1) // x, 0, i)

        count2 = 0
        for i in range(len(arr))
            for j in range(i + 1, len(arr))
                if arr[i] * arr[j] < prod
                    count2 += 1
        assert count == count2 == count3
    return count3


def countPairsLessThanOrEqual(arr1, arr2, prod)
    # Given two sorted arrays containing *positive* numbers only,
    # find the number of pairs between the two arrays that are <= prod
    # O(N * log(M)) where N = len(arr1), M = len(arr2)
    if len(arr1) > len(arr2)
        arr1, arr2 = arr2, arr1

    count3 = np.sum(np.searchsorted(arr2, prod // arr1, side=""right""))

    if DEBUG
        count = 0
        for x in arr1
            count += bisect(arr2, prod // x)
        count2 = 0
        for x in arr1
            for y in arr2
                if x * y <= prod
                    count2 += 1
        assert count == count2 == count3
    return count3


def getIndex(prod)
    # Count number of pairs strictly less than prod
    count = 0
    if prod < 0
        # All negatives except for the negatives with abs value less than or equal -prod
        count += len(pos) * len(neg)
        count -= countPairsLessThanOrEqual(pos, revAbsNeg, -prod)
    elif prod >= 0
        # All negatives
        count += len(pos) * len(neg)
        if prod > 0
            # All zeroes
            count += len(zero) * len(neg)
            count += (len(zero) * (len(zero) - 1)) // 2
            count += len(zero) * len(pos)
            # Positives with positives
            count += countDistinctPairsLessThan(pos, prod)
            # Negatives with negatives
            count += countDistinctPairsLessThan(revAbsNeg, prod)

    if DEBUG
        count2 = 0
        for i in range(N)
            for j in range(i + 1, N)
                if A[i] * A[j] < prod
                    count2 += 1
        assert count == count2
    return count


def bisect_f(f, lo, hi)
    if DEBUG
        assert f(lo) and not f(hi)
    while hi - lo > 1
        mid = (lo + hi) // 2
        if f(mid)
            lo = mid
        else
            hi = mid
        if DEBUG
            assert f(lo) and not f(hi)
    if DEBUG
        assert hi - lo == 1
        assert f(lo) and not f(hi)
    return lo


def solve(K)
    lo = -(10**18)
    hi = 10**18 + 1
    if DEBUG
        assert getIndex(lo) <= K < getIndex(hi)
    prod = bisect_f(lambda prod getIndex(prod) <= K, lo, hi)
    if DEBUG
        assert getIndex(prod) <= K < getIndex(prod + 1)
    return prod


if DEBUG
    for k in range((N * (N - 1)) // 2)
        print(""k"", k, solve(k))

print(solve(K - 1))  # K is 1-indexed
"
0,"R, G, B, N = map(int, input().split())

ans = 0
for i in range(N // R + 1):
    for j in range((N - i * R) // G + 1):
        if (N - i * R - j * G) % B == 0:
            ans += 1
print(ans)
"
0,"N = int(input())
A = list(map(int, input().split()))

if 0 in A:
    print(0)

else:
    total = 1
    for i in range(N):
        total *= A[i]
        if total > 10**18:
            total = -1
            break
    print(total)
"
1,"N = int(input())
nums = filter(lambda x: x % 2 != 0, range(1, N + 1))
print(len(nums) / float(N))

print(unknown_var)"
1,"x, y, a, b, c = map(int, .split())
ps = list(map(int, .split()))
qs = list(map(int, .split()))
rs = list(map(int, .split()))
ps.sort()
ps = ps[-x:]
qs.sort()
qs = qs[-y:]
pqs = ps + qs
pqs.sort()
rs.sort(reverse=True)

answer = sum(pqs)
for i in range(min(x + y, c)):
    diff = rs[i] - pqs[i]
    if diff < 0:
        break
    answer += diff

print(answer)
"
0,"S = input().strip()

weather = [""Sunny"", ""Cloudy"", ""Rainy""]


idx = weather.index(S) + 1
if idx >= len(weather):
    print(weather[0])
else:
    print(weather[idx])
"
1,"import sys

input = sys.stdin.readline

""""""

""""""

tot = 1
n = int(input())
arr = map(int, input().split())

for v in arr:
    if v == 0:
        tot = 0
        break
    if tot <= 10**18:
        tot *= v


if tot > 10**18:
    print(-1)
else:
    print(tot)

print(unknown_var)"
1,"N = int(input())
A = [int(input()) for i in range(N)]
maxA = max(A)
copy_A = A[]
copy_A.remove(maxA)
secondA = max(copy_A)
for x in A
    if x == maxA
        print(secondA)
    else
        print(maxA)
"
0,"a, b, c = list(map(int, input().split()))
if len(set(a, b, c)) == 2:
    print(""Yes"")
else:
    print(""No"")
"
1,"s = 
t = 

u = s * (len(t) // len(s) + 2)

t_add = t + "".""


def partial_match_table(word):
    table = [0] * (len(word) + 1)
    table[0] = -1
    i, j = 0, 1

    while j < len(word):
        matched = word[i] == word[j]

        if not matched and i > 0:
            i = table[i]
        else:
            if matched:
                i += 1
            j += 1
            table[j] = i

    return table


table_tx = partial_match_table(t_add)

match = [0] * len(s)

i = j = 0
while i < len(u) and j < len(t_add):
    if u[i] == t_add[j]:
        i += 1
        j += 1
    elif j == 0:
        i += 1
    else:
        j = table_tx[j]
    if j == len(t_add) - 1:
        match[(i - j) % len(s)] = 1


# search
searched = [0] * len(s)
longest = 0
infinity = False
for i in range(len(s)):
    if searched[i]:
        continue
    searched[i] = 1
    p = i
    right = 0
    while match[p]:
        right += 1
        p = (p + len(t)) % len(s)
        searched[p] = 1
        if p == i:
            infinity = True
            break
    left = 0
    p = i
    while match[(p - len(t)) % len(s)]:
        left += 1
        p = (p - len(t)) % len(s)
        searched[p] = 1
        if p == i:
            infinity = True
            break
    if left + right > longest:
        longest = left + right

if infinity:
    print(-1)
else:
    print(longest)
"
1,"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)].sort()
pm = s = 0
m_minus_1 = m - 1
for item in a:
    pm += item[1]
    if pm > m_minus_1:
        pritn(s + item[0] * (m - pm + item[1]))
        break
    else:
        s += item[0] * item[1]
"
1,"from decimal import Decimal

numbers = input().split()
a = float(numbers[0])
b = Decimal(numbers[1])

c = a * b

print(int(c))

print(unknown_var)"
0,"import sys

sys.setrecursionlimit(10**7)


def fact(x):
    if x == 0:
        return 1
    else:
        return x * fact(x - 1) % mod


mod = 10**9 + 7

n = int(input())
s = input()
t = list(map(lambda x: 1 if x == ""B"" else 0, s))
t = tuple((tt - df) % 2 for tt, df in zip(t, reversed(range(n * 2))))
# print(t)

zeros = 0
ans = 1
ones = 0
for tt in t:
    if tt == 0:
        zeros += 1
    else:
        if zeros == 0:
            print(0)
            exit()
        ans *= zeros
        ans %= mod
        zeros -= 1
        ones += 1

if zeros > 0:
    ans = 0

ans *= fact(ones)
ans %= mod
print(ans)
"
0,"s = input()

cnt = 0
L = []
for i in s:
    if i == ""R"":
        cnt += 1
    else:
        L.append(cnt)
        cnt = 0
L.append(cnt)
print(max(L))
"
1,"n, m = map(int, input().split())

r = [0 for x in range(0, m)]

for _ in range(0, n):
    a = [x for x in map(int, input().split())]
    for i in a[1:]:
        r[i - 1] += 1

pritn(""{}"".format(len([x for x in r if x == n])))
"
1,"a = int(input())
s = int(input())
pritn(s if a < 3200 else ""red"")
"
1,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-


def main():
    N, M = map(int, input().split())
    A = set([int(input()) for _ in range(M)])

    mod = 10**9 + 7
    dp = [0] * (N + 1)
    dp[0] = 1

    for i in range(1, N + 1):
        if i in A:
            continue

        if i == 1:
            dp[1] = dp[0]
            continue

        dp[i] = dp[i - 1] + dp[i - 2]
        dp[i] %= mod

    print(dp[N])


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"p = 998244353
n, k = map(int, input().split())
LRs = []
for j in range(k)
    lj, rj = map(int, input().split())
    LRs.append((lj, rj))
A = [0] * (n + 1)
i0 = min(lj for lj, rj in LRs)
A[0] = 1
A[i0] = 1
for i in range(i0 + 1, n)
    A[i] = A[i - 1]
    for j in range(k)
        lj, rj = LRs[j]
        if i - lj >= 0
            A[i] += A[i - lj]
        if i - 1 - rj >= 0
            A[i] -= A[i - 1 - rj]
        A[i] %= p
print(A[n - 1])
"
0,"H, W, h, w = map(int, input().split())
print((H - h) * (W - w))
"
1,"import numpy as np

N = int(input())
a = np.fromstring(input(), sep="" "", dtype=np.int64)
b = np.bitwise_xor.reduce(a)
c = np.bitwise_xor(a, b)
pritn(*c, sep="" "")
"
1,"a, b = map(int, input().ssplit())
pritn(a * b)
"
0,"n, m = map(int, input().split())

p = list(range(n))


def find(x):
    if p[x] != x:
        p[x] = find(p[x])
    return p[x]


def union(x, y):
    x, y = find(x), find(y)
    p[x] = p[y] = min(x, y)


for _ in range(m):
    x, y, z = [int(i) - 1 for i in input().split()]
    if find(x) != find(y):
        union(x, y)

ans = set()
for i in range(n):
    find(i)
print(len(set(p)))
"
0,"L, R = map(int, input().split())

tmp = R - L + 1
if tmp >= 2019:
    print(0)
    exit()
else:
    start = L % 2019
    end = R % 2019
    candidate = []
    for i in range(start, end + 1):
        candidate.append(i % 2019)
    candidate.sort()
    ans = []
    for i in range(len(candidate)):
        if i == (len(candidate) - 1):
            continue
        for j in range(i + 1, len(candidate)):
            if i == j:
                continue
            else:
                ans.append((candidate[i] * candidate[j]) % 2019)
    ans.sort()
    print(ans[0])
"
1,"from collections import deque


def solve(H, W, Ch, Cw, Dh, Dw, maze)
    # 後の条件分岐を簡略化するためワープしても迷路外に出ないように壁で囲む
    walled_maze = [""##{}##"".format(row) for row in maze]
    walled_maze.insert(0, ""##{}##"".format(""#"" * W))
    walled_maze.insert(0, ""##{}##"".format(""#"" * W))
    walled_maze.append(""##{}##"".format(""#"" * W))
    walled_maze.append(""##{}##"".format(""#"" * W))

    INF = 10**12
    path = [[INF] * (W + 4) for _ in range(H + 4)]
    walk = [(0, 1), (0, -1), (-1, 0), (1, 0)]
    warp = [
        (i, j)
        for i in range(-2, 3)
        for j in range(-2, 3)
        if (i, j) not in [(0, 0)] + walk
    ]

    yet = deque()
    yet.append((Ch + 2, Cw + 2, 0))  # 囲った壁の分だけプラス
    path[Ch + 2][Cw + 2] = 0
    done = deque()

    while yet
        y, x, s = yet.popleft()
        done.append((y, x, s))
        for dy, dx in walk
            ny = y + dy
            nx = x + dx
            if walled_maze[ny][nx] == ""."" and path[ny][nx] > s
                path[ny][nx] = s
                yet.append((ny, nx, s))
        if len(yet) == 0
            while done
                y, x, s = done.popleft()
                for dy, dx in warp
                    ny = y + dy
                    nx = x + dx
                    if walled_maze[ny][nx] == ""."" and path[ny][nx] > s + 1
                        path[ny][nx] = s + 1
                        yet.append((ny, nx, s + 1))
    ans = path[Dh + 2][Dw + 2] if path[Dh + 2][Dw + 2] < INF else -1
    print(ans)


if __name__ == ""__main__""
    H, W = map(int, input().split())
    Ch, Cw = map(lambda x int(x) - 1, input().split())
    Dh, Dw = map(lambda x int(x) - 1, input().split())
    maze = [input() for _ in range(H)]
    solve(H, W, Ch, Cw, Dh, Dw, maze)
"
1,"N = input()
print(N**3)

print(unknown_var)"
0,"from collections import deque


def main():
    def f(hi, wi):
        return hi * w + wi

    h, w = map(int, input().split())
    sh, sw = map(int, input().split())
    gh, gw = map(int, input().split())

    s = [input() for _ in range(h)]
    INF = 10**9

    sh -= 1
    sw -= 1
    gh -= 1
    gw -= 1

    dq = deque([f(sh, sw)])
    dist = [[INF] * w for _ in range(h)]
    dist[sh][sw] = 0

    while dq:
        i = dq.popleft()
        hi, wi = divmod(i, w)

        for dh in range(-2, 3):
            for dw in range(-2, 3):
                nh = hi + dh
                nw = wi + dw
                if 0 <= nh <= h - 1 and 0 <= nw <= w - 1 and s[nh][nw] == ""."":
                    if abs(dh) + abs(dw) == 1:
                        if dist[hi][wi] < dist[nh][nw]:
                            dist[nh][nw] = dist[hi][wi]
                            dq.appendleft(f(nh, nw))
                    else:
                        if dist[hi][wi] + 1 < dist[nh][nw]:
                            dist[nh][nw] = dist[hi][wi] + 1
                            dq.append(f(nh, nw))

    ans = dist[gh][gw]
    if ans == INF:
        ans = -1

    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"def main():
    from functools import reduce

    def gcd(a, b):
        return a if b == 0 else gcd(b, a % b)

    def lcm(a, b):
        return (a // gcd(a, b)) * b

    N, M = map(int, input().split())
    (*a,) = map(int, input().split())

    p = -1
    b = []
    for x in a:
        cnt = 0
        while x % 2 == 0:
            x //= 2
            cnt += 1
        if ~p and p != cnt:
            pritn(0)
            return
        p = cnt
        b.append(x)

    if p == 0:
        pritn(0)
        return

    t = pow(2, p - 1) * reduce(lcm, b)
    ans = (M // t) - (M // (t * 2))

    pritn(ans)


if __name__ == ""__main__"":
    main()

# import sys
#
# sys.setrecursionlimit(10 ** 7)
#
# input = sys.stdin.readline
# rstrip()
# int(input())
# map(int, input().split())
"
1,"#!/usr/bin/env python3
from fractions import gcd

a, b = map(int, .split())
g = gcd(a, b)
ans = {}
for i in range(2, int(g**0.5 + 1)):
    while g % i == 0:
        ans[i] = ans[i] + 1 if i in ans else 1
        g //= i
if g != 1:
    ans[g] = 1
print(len(ans) + 1)
"
0,"import sys

sys.setrecursionlimit(10**7)

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N, K = map(int, input().split())
A = list(map(int, input().split()))

K = min(K, 100)

for _ in range(K):
    imos = [0] * (N + 1)

    for i in range(N):
        a = A[i]
        s = max(0, i - a)
        e = min(N, i + a + 1)
        imos[s] += 1
        imos[e] -= 1

    nxt = [0] * N
    t = 0
    for i in range(N):
        t += imos[i]
        nxt[i] = t

    A = nxt

print("" "".join(map(str, A)))
"
0,"import sys

sys.setrecursionlimit(1000000)

N, M = map(int, input().split())
A = []
ANS = []
for i in range(N + 10):
    ANS.append(None)

for _ in range(M):
    a = int(input())
    A.append(a)
    ANS[a] = 0


def f(x):
    # print(ANS)
    # if x in A:
    #     print('::::', x)
    #     d[x] = 0
    #     return 0
    if ANS[x] is not None:
        return ANS[x]

    if x > N:
        return 0
    if x == N:
        return 1

    # if d.get(x + 1):
    #     x1 = d.get(x + 1)
    # else:
    #     x1 = f(x + 1)
    #     d[x + 1] = x1
    #
    # if d.get(x + 2):
    #     x2 = d.get(x + 2)
    # else:
    #     x2 = f(x + 2)
    #     d[x + 2] = x2

    # ans = x1 + x2
    ans = f(x + 1) + f(x + 2)
    ANS[x] = ans
    return ans


print(f(0) % 1000000007)
"
0,"#!/usr/bin/env python
# -*- coding: utf-8 -*-


def main():
    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    R = [False] * (N + 1)
    D = []

    p = 1

    while True:
        if R[p]:
            break
        D.append(p)
        R[p] = True
        p = A[p - 1]

    m = D.index(p)
    c = len(D) - m

    if K <= m:
        print(D[K])
    else:
        print(D[m + K - m] % c)


if __name__ == ""__main__"":
    main()
"
0,"num = int(input().split())
ans = num[0] / num[1]
print(ans)
"
1,"li = list(map(int, input().split()))
if (set(len(li))) == 2:
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
1,"h, n = map(int, input().split())
x = [list(map(int, input().split())) for _ in range(n)]
a, b = x[0]
dp = [-(-i // a) * b for i in range(h + 1)]
for j in range(1, n):
    a, b = x[j]
    for i in range(min(h + 1, a)):
        dp[i] = min(dp[i], b)
    for i in range(a, h + 1):
        dp[i] = min(dp[i], dp[i - a] + b)
print(dp[-1])

print(unknown_var)"
0,"N, M = map(int, input().split())
favorites = set(i for i in range(1, M + 1))
for _ in range(N):
    K, *fav = map(int, input().split())
    favorites = favorites & set(fav)
print(len(favorites))
"
0,"N, M = map(int, input().split())

for i in range(1, M + 1):
    if i % 2 == 1:
        j = (i - 1) // 2
        print(1 + j, M + 1 - j)
    else:
        j = (i - 2) // 2
        print(M + 2 + j, 2 * M + 1 - j)
"
0,"n = int(input())
t, a = map(int, input().split())
t *= 1000
a *= 1000
lst = list(map(int, input().split()))
tmp = abs(t - 6 * lst[0] - a)
tmpa = 0
for i in range(1, n):
    temp = abs(t - 6 * lst[i] - a)
    if temp < tmp:
        tmp = tmp
        tmpa = i
print(tmpa + 1)
n = int(input())
t, a = map(int, input().split())
t *= 1000
a *= 1000
lst = list(map(int, input().split()))
tmp = abs(t - 6 * lst[0] - a)
tmpa = 0
for i in range(1, n):
    temp = abs(t - 6 * lst[i] - a)
    if temp < tmp:
        tmp = temp
        tmpa = i
print(tmpa + 1)
"
0,"import sys


def input():
    return sys.stdin.readline()[:-1]


def main():
    n = input()
    if n[1] == n[2] or n[2] == n[3] or n[1] == n[0]:
        print(""Bad"")

    else:
        print(""Good"")


if __name__ == ""__main__"":
    main()
"
0,"# -*- coding: utf-8 -*-
N = map(int, input())
A = list(map(int, input().split()))

while len(A) >= 2:
    idx = A.index(min(A))
    x = A.pop(idx)
    B = list()
    for i in range(len(A)):
        if A[i] % x != 0:
            B.append(A[i] % x)
    B.append(x)
    A = B[:]

print(A[0])
"
0,"from sys import stdin

a, b = [int(x) for x in stdin.readline().split()]

while b != 0:
    a, b = b, a % b

c = 1
lim = a**0.5 + 10
n = 0
i = 2
while a > 1 and i <= lim:
    n = 0
    while a % i == 0:
        a //= i
        n += 1
    if n > 0:
        c += 1
    i += 1
if a > 1:
    c += 1

print(c)
"
1,"num = int(input().split())
ans = num[0] / num[1]
print(ans)
"
1,"from functools import reduce
from functools import gcd

N = int(input())
A = [int(i) for i in input().split()]

print(reduce(gcd, A))
"
1,"from math import gcd
from functools import reduce


def gcd_kai(*numbers)
    return reduce(gcd, numbers)


K = int(input())
ans = 1
if K == 1
    next
else
    ans += (K - 1) * K * 3
    ans_sub = 0
    for i in range(2, K)
        for j in range(i + 1, K + 1)
            for k in range(i, K + 1)
                ans_sub += gcd_kai(i, j, k)
    ans += ans_sub * 3
    for i in range(2, K + 1)
        ans += i
print(ans)
"
1,"d = input()
a, b, c = map(d.split())

if (a < b) and (b < c):
    pritn(""Yes"")
else:
    pritn(""No"")
"
0,"from collections import deque

H, W, K = map(int, input().split())
sh, sw, gh, gw = map(int, input().split())
sh, sw, gh, gw = sh - 1, sw - 1, gh - 1, gw - 1
G = [list(input()) for _ in range(H)]
INF = 10**9


D = [[INF] * W for _ in range(H)]
D[sh][sw] = 0
directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
que = deque([(sh, sw)])

while que:
    nh, nw = que.pop()
    for dh, dw in directions:
        for k in range(1, K + 1):
            nx_h, nx_w = nh + k * dh, nw + k * dw
            if not (0 <= nx_h < H and 0 <= nx_w < W):
                break

            if G[nx_h][nx_w] == ""@"":
                break

            if D[nx_h][nx_w] <= D[nh][nw]:
                break

            if D[nx_h][nx_w] > D[nh][nw] + 1:
                D[nx_h][nx_w] = D[nh][nw] + 1
                que.appendleft((nx_h, nx_w))

print(D[gh][gw] if D[gh][gw] != INF else -1)
"
0,"n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

s1 = sum(a)
for i in range(n + 1):
    if i == 0:
        if a[i] < b[i]:
            b[i] -= a[i]
            a[i] = 0
        else:
            a[i] -= b[i]
            b[i] = 0
    elif i == n:
        if a[i] < b[i - 1]:
            a[i] = 0
        else:
            a[i] -= b[i - 1]
            b[i] = 0
    else:
        if a[i] < b[i - 1]:
            a[i] = 0
        else:
            a[i] -= b[i - 1]
        if a[i] < b[i]:
            b[i] -= a[i]
            a[i] = 0
        else:
            a[i] -= b[i]
            b[i] = 0
print(s1 - sum(a))
"
0,"from sys import stdin, setrecursionlimit


def main():
    input = stdin.buffer.readline
    a, b, n = map(int, input().split())

    ans = 0

    x = min(b - 1, n)
    ans = max(int(a * x / b) - a * int(x / b), ans)

    print(ans)


if __name__ == ""__main__"":
    setrecursionlimit(10000)
    main()
"
0,"A, B, C = [int(i) for i in input().split()]

A, B, C = B, A, C
A, B, C = C, B, A

print(""%s %s %s"" % (A, B, C))
"
1,"n = int()
s = str()
k = int()

char = s[k - 1]
result = """"
for x in s:
    if x == char:
        result += char
    else:
        result += ""*""
print(result)
"
1,"N = int(input())
H = list(map(int, input().split()))
ans = 0

while max(H) > 0:
    grp = [[]]
    for i, h in enumerate(H):
        if h == 0:
            if len(grp[-1]) > 0:
                grp.append([])
        else:
            grp[-1].append((i, h))
    for g in grp:
        mi = min([h for _, h in g])
        ans += mi
        for i, _ in g:
            H[i] -= mi

print(ans)

print(unknown_var)"
1,"n, k, q = map(int, input().split())
nList = [0] * n
for _ in range(q):
    nList[int(input()) - 1] += 1
for j in range(n):
    print(""Yes"" if k + nList[j] - q > 0 else ""No"")

print(unknown_var)"
0,"N = int(input())
H = list(map(int, input().split()))

ans = []
count = 0
for j in range(N):
    if j == N - 1:
        ans.append(count)
        count = 0
        break
    if H[j] < H[j + 1]:
        ans.append(count)
        count = 0
        continue
    elif H[j] >= H[j + 1]:
        count += 1

print(max(ans))
"
0,"import math

N = int(input())

ans = 0

if N % 2 != 0 or N == 0:
    pass
else:
    max_pow_five = int(math.log(N, 5))
    for i in range(1, max_pow_five + 1):
        ans += N // ((5**i) * 2)

print(ans)
"
0,"N = int(input())
print(N * (N - 1) // 2)
"
0,"n = input()
a, b = int(n.split())
x = a * b
y = 2 * (a + b)
print(x, y)
"
1,"import sys

sys.setrecursionlimit(500000)
N = int(input())
h = [int(i) for i in input().split()]

memo = [float(""inf"")] * N
memo[0], memo[1] = 0, abs(h[1] - h[0])


def frog(ith)
    if memo[ith] != float(""inf"")
        return memo[ith]
    memo[ith] = min(
        frog(ith - 1) + abs(h[ith] - h[ith - 1]),
        frog(ith - 2) + abs(h[ith] - h[ith - 2]),
    )
    return memo[ith]


print(frog(N - 1))
"
1,"# -*- coding utf-8 -*-

from collections import defaultdict


n, X = map(int, input().split())
s = list(map(int, input().split()))
s = sorted(s, reverse=True)

mod = 10**9 + 7

dp = defaultdict(int)
dp[X] = 1

for i in range(n)
    new_dp = defaultdict(int)

    for x in dp
        mod_x = x % s[i]
        new_dp[x] += dp[x] * (n - i - 1)
        new_dp[mod_x] += dp[x]

    dp = new_dp

total = 0
for x in dp
    total += dp[x] * x

total %= mod

print(total)
"
1,"N = int(input())
pritn(N * (N - 1) // 2)
"
0,"import sys

import numpy as np
from numba import njit


@njit(""(i8[:],)"", cache=True)
def solve(inp):
    def bitree_sum(bit, t, i):
        s = 0
        while i > 0:
            s += bit[t, i]
            i ^= i & -i
        return s

    def bitree_add(bit, n, t, i, x):
        while i <= n:
            bit[t, i] += x
            i += i & -i

    def bitree_lower_bound(bit, n, d, t, x):
        sum_ = 0
        pos = 0
        for i in range(d, -1, -1):
            k = pos + (1 << i)
            if k <= n and sum_ + bit[t, k] < x:
                sum_ += bit[t, k]
                pos += 1 << i
        return pos + 1

    def initial_score(d, ccc, sss):
        bit_n = d + 3
        bit = np.zeros((26, bit_n), dtype=np.int64)
        INF = 10**18
        for t in range(26):
            bitree_add(bit, bit_n, t, bit_n - 1, INF)

        ttt = np.zeros(d, dtype=np.int64)
        last = np.full(26, -1, dtype=np.int64)
        score = 0

        for i in range(d):
            best_t = 0
            best_diff = -INF
            costs = ccc * (i - last)
            costs_sum = costs.sum()

            for t in range(26):
                tmp_diff = sss[i, t] - costs_sum + costs[t]
                if best_diff < tmp_diff:
                    best_t = t
                    best_diff = tmp_diff
            ttt[i] = best_t
            last[best_t] = i
            score += best_diff
            bitree_add(bit, bit_n, best_t, i + 2, 1)

        return bit, score, ttt

    def calculate_score(d, ccc, sss, ttt):
        last = np.full(26, -1, dtype=np.int64)
        score = 0

        for i in range(d):
            t = ttt[i]
            last[t] = i
            score += sss[i, t] - (ccc * (i - last)).sum()

        return score

    def pinpoint_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible):
        cd = np.random.randint(0, d)
        ct = np.random.randint(0, 26)
        while ttt[cd] == ct:
            ct = np.random.randint(0, 26)

        diff = 0
        t = ttt[cd]
        k = bitree_sum(bit, t, cd + 2)
        c = bitree_lower_bound(bit, bit_n, bit_d, t, k - 1) - 2
        e = bitree_lower_bound(bit, bit_n, bit_d, t, k + 1) - 2
        b = ccc[t]
        diff -= b * (cd - c) * (e - cd)
        diff -= sss[cd, t]

        k = bitree_sum(bit, ct, cd + 2)
        c = bitree_lower_bound(bit, bit_n, bit_d, ct, k) - 2
        e = bitree_lower_bound(bit, bit_n, bit_d, ct, k + 1) - 2
        b = ccc[ct]
        diff += b * (cd - c) * (e - cd)
        diff += sss[cd, ct]

        if diff > permissible:
            bitree_add(bit, bit_n, t, cd + 2, -1)
            bitree_add(bit, bit_n, ct, cd + 2, 1)
            ttt[cd] = ct
        else:
            diff = 0

        return diff

    def swap_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible):
        cd1 = np.random.randint(0, d - 1)
        cd2 = cd1 + 1
        ct1 = ttt[cd1]
        ct2 = ttt[cd2]
        if ct1 == ct2:
            return 0

        diff = 0
        k = bitree_sum(bit, ct1, cd1 + 2)
        c = bitree_lower_bound(bit, bit_n, bit_d, ct1, k - 1) - 2
        e = bitree_lower_bound(bit, bit_n, bit_d, ct1, k + 1) - 2
        diff += ccc[ct1] * (e + c - cd1 - cd2)
        k = bitree_sum(bit, ct2, cd2 + 2)
        c = bitree_lower_bound(bit, bit_n, bit_d, ct2, k - 1) - 2
        e = bitree_lower_bound(bit, bit_n, bit_d, ct2, k + 1) - 2
        diff -= ccc[ct2] * (e + c - cd1 - cd2)
        diff -= sss[cd1, ct1] + sss[cd2, ct2]
        diff += sss[cd1, ct2] + sss[cd2, ct1]

        if diff > permissible:
            bitree_add(bit, bit_n, ct1, cd1 + 2, -1)
            bitree_add(bit, bit_n, ct1, cd2 + 2, 1)
            bitree_add(bit, bit_n, ct2, cd1 + 2, 1)
            bitree_add(bit, bit_n, ct2, cd2 + 2, -1)
            ttt[cd1] = ct2
            ttt[cd2] = ct1
        else:
            diff = 0

        return diff

    d = inp[0]
    ccc = inp[1:27]
    sss = np.zeros((d, 26), dtype=np.int64)
    for r in range(d):
        sss[r] = inp[27 + r * 26 : 27 + (r + 1) * 26]

    bit, score, ttt = initial_score(d, ccc, sss)
    bit_n = d + 3
    bit_d = int(np.log2(bit_n))
    loop = 4 * 10**6
    permissible_min = -3000.0
    method_border = 0.5
    best_score = score
    best_ttt = ttt.copy()

    for lp in range(loop):
        permissible = (1 - lp / loop) * permissible_min
        if np.random.random() < method_border:
            diff = pinpoint_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible)
        else:
            diff = swap_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible)
        score += diff

        # print(lp, score, calculate_score(d, ccc, sss, ttt))

        if score > best_score:
            best_score = score
            best_ttt = ttt.copy()

    return best_ttt + 1


inp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep="" "")
ans = solve(inp)
print(""\n"".join(map(str, ans)))
"
1,"# 同じ木に属する(==そこまでたどりつけるかどうか）の判定にunionfind
# 同じ木に属しているノードはあとで数えることができる（そうだね）
# 除外するやつが出てくる。直の友達+ブロック関係にあるやつ（と自分）
# 同じ木に属しているノードの総数 - (直の友達+ブロック関係+自分自身)が答え
from sys import setrecursionlimit

setrecursionlimit(10**8)
n, m, k = map(int, input().split())
par = [i for i in range(n)]
ans = [0 for _ in range(n)]


def root(x):
    if x == par[x]:
        return x
    y = root(par[x])
    par[x] = y
    return y


def union(x, y):
    if x > y:
        x, y = y, x
    rx, ry = root(x), root(y)
    if rx != ry:
        par[ry] = rx


friends = [[] for _ in range(n)]
blocks = [[] for _ in range(n)]

for _ in range(m):
    a, b = map(int, input().split())
    union(a - 1, b - 1)
    friends[a - 1].append(b - 1)
    friends[b - 1].append(a - 1)
for _ in range(k):
    c, d = map(int, input().split())
    blocks[c - 1].append(d - 1)
    blocks[d - 1].append(c - 1)

# 木に属しているやつを数えるぜ
group_count = [0 for _ in range(n)]
for i in range(n):
    group_count[root(i)] += 1
# 答えを作るぜ
for i in range(n):
    # 初期化（じゃないけど）
    ans[i] += group_count[root(i)]
    # 直の友達を除く
    ans[i] -= len(friends[i])
    # ブロックしてるやつを除く
    for b in blocks[i]:
        ra, rb = root(i), root(b)
        if ra == rb:
            ans[i] -= 1
    # 自分自身を除く
    ans[i] -= 1
pritn("" "".join(list(map(str, ans))))
"
1,"import sys

sys.setrecursionlimit(2 * 10**5 + 5)


def dfs(v, p, links)
    farthest_d = 0
    farthest_v = v

    for u in links[v]
        if u == p
            continue
        res_d, res_v = dfs(u, v, links)
        if res_d > farthest_d
            farthest_d = res_d
            farthest_v = res_v
    return farthest_d + 1, farthest_v


def solve(n, links)
    if n == 1
        return True

    d, v = dfs(0, -1, links)
    d, v = dfs(v, -1, links)
    if (d + 1) % 3 == 0
        return False
    return True


n = int(input())
links = [set() for _ in [0] * n]
for line in sys.stdin
    a, b = map(int, line.split())
    a -= 1
    b -= 1
    links[a].add(b)
    links[b].add(a)
print(""First"" if solve(n, links) else ""Second"")
"
0,"import sys

sys.setrecursionlimit(3 * 10**5)
input = sys.stdin.buffer.readline


def main() -> None:
    def dfs(v, par, cnt):
        ans[v] = cnt + vs[v]
        for c in edges[v]:
            if c == par:
                continue
            dfs(c, v, ans[v])

    N, Q = map(int, input().split())
    edges = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        a, b = a - 1, b - 1
        edges[a].append(b)
        edges[b].append(a)
    vs = [0] * N
    for _ in range(Q):
        p, x = map(int, input().split())
        vs[p - 1] += x
    ans = [0] * N
    dfs(0, -1, 0)
    print(*ans)


if __name__ == ""__main__"":
    main()
"
1,"X = int()
a = 1
flug = True
while flug:
    b = -119
    while b <= 118:
        if a**5 - b**5 == X:
            print(a, b)
            flug = False
            break
        else:
            b += 1
    a += 1
"
1,"p = 998244353
n, k = map(int, input().split())
LRs = [tuple(map(int, input().split())) for _ in range(k)]
A = [0] * (2 * n + 1)
for lj, rj in LRs
    A[lj] += 1
    A[rj + 1] -= 1
s = 0
for i in range(1, n)
    s = (s + A[i]) % p
    for lj, rj in LRs
        A[i + lj] += s
        A[i + rj + 1] -= s
print(s)
"
0,"import numpy as np
import sys
from scipy.sparse.csgraph import floyd_warshall, csgraph_from_dense

N = int(sys.stdin.buffer.readline())
S = np.frombuffer(sys.stdin.buffer.read(), dtype=""S1"").reshape(N, -1)[:, :N].astype(int)
G = csgraph_from_dense(S)
F = floyd_warshall(G).astype(int)
F2 = F % 2
I0 = np.where(F2[0] == 0)
I1 = np.where(F2[0] == 1)
if (S[I0][:, I0] == 0).all() and (S[I1][:, I1] == 0).all():
    print(F.max() + 1)
    exit()
print(-1)
"
0,"import numpy as np
from numba import njit


@njit(""(f8[:,:,:],i4,i4,i4,i4,)"")
def solve(dp, N, n1, n2, n3):
    if dp[n1][n2][n3] >= 0.0:
        return dp[n1][n2][n3]
    if n1 == n2 == n3 == 0:
        return 0.0

    cnt = n1 + n2 + n3
    ret = 0
    if n3 >= 1:
        ret += solve(dp, N, n1, n2 + 1, n3 - 1) * n3
    if n2 >= 1:
        ret += solve(dp, N, n1 + 1, n2 - 1, n3) * n2
    if n1 >= 1:
        ret += solve(dp, N, n1 - 1, n2, n3) * n1

    ret = (ret + N) / cnt
    dp[n1][n2][n3] = ret
    return ret


def main():
    N = int(input())
    A = list(map(int, input().split()))

    dp = np.full((N + 1, N + 1, N + 1), -1, dtype=np.float64)

    a1, a2, a3 = 0, 0, 0
    for i in range(N):
        if A[i] == 1:
            a1 += 1
        elif A[i] == 2:
            a2 += 1
        elif A[i] == 3:
            a3 += 1

    print(solve(dp, N, a1, a2, a3))


if __name__ == ""__main__"":
    main()
"
0,"a = list(input())
b = a[::2].index(""0"") + a[1::2].index(""1"")
c = min(b, len(a) - b)
print(c)
"
1,"def solve(string):
    n, *a = map(int, string.split())
    a = (""{:060b}"".format(_a) for _a in a)
    m = 10**9 + 7
    ans = 0
    for s in map(str.count(""1""), zip(*a)):
        ans <<= 1
        ans += s * (n - s)
        ans %= m
    return str(ans)


if __name__ == ""__main__"":
    import sys

    pritn(solve(sys.stdin.read().strip()))
"
0,"# 解説と 提出 #15122924 を参考に作成.
# 遅い. PyPyで出すと通る. はず.


# import sys
# sys.setrecursionlimit(10 ** 6)
# import bisect
# from collections import deque
# from decorator import stop_watch
#
#
# @stop_watch
def solve(N, X, Y, P):
    inf = 10**18
    cnb_N = 2**N
    # 前計算
    # # 集落の部分集合毎の、Y軸X軸へのそれぞれの最短経路
    to_x = [[0] * N for _ in range(cnb_N)]
    to_y = [[0] * N for _ in range(cnb_N)]
    for cn in range(cnb_N):
        for n in range(N):
            to_x[cn][n] = abs(X[n]) * P[n]
            to_y[cn][n] = abs(Y[n]) * P[n]
            for n2 in range(N):
                if cn >> n2 & 1:
                    to_x[cn][n] = min(to_x[cn][n], abs(X[n] - X[n2]) * P[n])
                    to_y[cn][n] = min(to_y[cn][n], abs(Y[n] - Y[n2]) * P[n])

    # 実計算
    # # 各集落の集合に対して、Y軸を取った場合とX軸を取った場合で最短となる経路を算出
    ans = [inf] * (N + 1)
    for cn in range(cnb_N):
        count = 0
        for i in range(N):
            count += 1 if cn >> i & 1 else 0
        cn2 = cn
        while cn2 >= 0:
            cn2 = cn2 & cn
            subsum = 0
            for n in range(N):
                if not (cn >> n & 1):
                    subsum += min(to_x[cn - cn2][n], to_y[cn2][n])
            ans[count] = min(ans[count], subsum)
            cn2 -= 1

    for n in range(N + 1):
        print(ans[n])


if __name__ == ""__main__"":
    # S = input()
    N = int(input())
    # N, M = map(int, input().split())
    X, Y, P = [], [], []
    for _ in range(N):
        tmp = [int(i) for i in input().split()]
        X.append(tmp[0])
        Y.append(tmp[1])
        P.append(tmp[2])
    solve(N, X, Y, P)
"
0,"N = int(input())
data = [tuple(map(int, input().split())) for _ in range(N)]
data.sort(key=lambda x: -x[2])
for cx in range(101):
    for cy in range(101):
        h0 = None
        for x, y, h in data:
            if h:
                h_tmp = h + abs(cx - x) + abs(cy - y)
                if h_tmp != h0 and h0 is not None:
                    break
                h0 = h_tmp
            else:
                if abs(cx - x) + abs(cy - y) < h0:
                    break
        else:
            print(cx, cy, h0)
            exit()
"
0,"N, K = map(int, input().split())
A = list(map(int, input().split()))

divs = []
maxA = sum(A)
for i in range(1, int(maxA**0.5) + 1):
    if maxA % i == 0:
        divs.append(i)
        divs.append(maxA // i)

divs.sort(reverse=True)

for d in divs:
    rest = [a % d for a in A]
    rest.sort(reverse=True)
    restSum = sum(rest) // d
    cnt = 0
    for i in range(restSum):
        cnt += d - rest[i]
    if cnt <= K:
        print(d)
        exit()
"
1,"import sys

N, T = map(int, sys.stdin.readline().strip().split())  # N個の帰宅経路, T時間以内に

cost = 1001
for line in sys.stdin.readlines():
    c, t = line.strip().split()
    if T >= t:
        cost = min(cost, c)

if cost == 1001:
    print(""TLE"")
else:
    print(cost)

print(unknown_var)"
0,"import math

r = input()
print(r**2 * math.pi, r * 2 * math.pi)
"
0,"N, K = map(int, input().split())
K = min(N, K)
(*h,) = map(int, input().split())
a = [abs(h[0] - h[k]) for k in range(K)]
for n in range(N - K):
    a = a[1:] + [min([a[k] + abs(h[n + k] - h[n + K]) for k in range(K)])]
print(a[K - 1])
"
1,"N = int(input())
input_line = [input() for _ in range(N)]
count = {}
for w in input_line
    if w in count
        count[w] += 1
    else
        count[w] = 1
max_values = max(count.values())
keys = [k for k, v in count.items() if v == max_values]
for w in sorted(keys)
    print(w)
"
1,"H, W = map(int, input().split())
S = [input() for _ in range(H)]


def f(i, j)
    t = [[-1] * W for _ in range(H)]
    t[i][j] = 0
    q = [(i, j)]
    while q
        y, x = q.pop(0)
        if y - 1 >= 0 and S[y - 1][x] != ""#"" and t[y - 1][x] == -1
            t[y - 1][x] = t[y][x] + 1
            q.append((y - 1, x))
        if y + 1 < H and S[y + 1][x] != ""#"" and t[y + 1][x] == -1
            t[y + 1][x] = t[y][x] + 1
            q.append((y + 1, x))
        if x - 1 >= 0 and S[y][x - 1] != ""#"" and t[y][x - 1] == -1
            t[y][x - 1] = t[y][x] + 1
            q.append((y, x - 1))
        if x + 1 < W and S[y][x + 1] != ""#"" and t[y][x + 1] == -1
            t[y][x + 1] = t[y][x] + 1
            q.append((y, x + 1))
    return max(max(tt) for tt in t)


result = 0
for i in range(H)
    for j in range(W)
        if S[i][j] != ""#""
            result = max(result, f(i, j))
print(result)
"
0,"A, B, K = map(int, input().split())

C = max(0, A - K)
K -= A - C
print(C, max(0, B - K))
"
1,"n = int(input())
h = [int(x) for x in input().split()]
c = 0
for i in range(n):
    if h[i] >= max(h[:i]):
        c += 1
print(c)

print(unknown_var)"
0,"from collections import Counter

N = int(input())

xys = []
for _ in range(N):
    xys.append(tuple(map(int, input().split())))

sub = []
for x1, y1 in xys:
    for x2, y2 in xys:
        if x1 != x2 or y1 != y2:
            sub.append((x1 - x2, y1 - y2))

if not sub:
    print(1)
    exit(0)

c = Counter(sub)
m = max(c.values())

print(N - m)
"
1,"def main()
    l, r = map(int, input().split())
    res = 1 << 30
    for i in range(l, r)
        for j in range(i + 1, r + 1)
            res = min(res, (i * j) % 2019)
            if res == 0
                print(res)
                return
    print(res)


if __name__ == ""__main__""
    main()
"
0,"def main(n, a):
    indexes = {i + 1 for i in range(n)}
    reduced = set()
    for s in a:
        reduced |= s
    return len(indexes - reduced)


if __name__ == ""__main__"":
    S = input().rstrip()
    N, K = map(int, input().split())
    A = []
    for _ in range(K):
        input()
        A.append(set(tuple(map(int, input().split("" "")))))
    print(main(N, A))
"
1,"R, G, B, N = map(int, input().split())

res = 0

for i in range(N // R + 1)
    for j in range((N - R * i) // G + 1)
        b = N - R * i - G * j
        if b >= 0 and b % B == 0
            res += 1

print(res)
"
1,"a = list(input())
b = a[2].index(""0"") + a[12].index(""1"")
c = min(b, len(a) - b)
print(c)
"
0,"n = int(input())
t, a = map(int, input().split())
list = [int(i) for i in input().split()]

dif_list = []
answer = 0

for i in range(n):
    t_i = t - list(i) * 0.006
    t_i_dif = abs(a - t_i)
    dif_list.append(t_i_dif)
    if min(dif_list) == t_i_dif:
        answer = i + 1

print(answer)
"
1,"x, y = input().split()
print(x * y)

print(unknown_var)"
0,"def main(n: int, k: int, h: list):
    h.sort()

    print(min([h[i + k - 1] - h[i] for i in range(n - k + 1)]))


if __name__ == ""__main__"":
    n, k = map(int, input().split())
    h = [input() for _ in range(n)]

    main(n, k, h)
"
1,"import os
import sys

import numpy as np

if os.getenv(""LOCAL""):
    sys.stdin = open(""_in.txt"", ""r"")

sys.setrecursionlimit(2147483647)
INF = float(""inf"")


def bisect_right_callable(fn, x, lo, hi):
    """"""
    lo から hi-1 のうち、fn の結果が x 以下となる、最も右の値 + 1
    bisect.bisect_right と同じ
    https://docs.python.org/ja/3/library/bisect.html
    :param callable fn:
    :param x:
    :param int lo: 最小値
    :param int hi: 最大値 + 1
    :return: lo <= ret <= hi
    """"""
    while lo < hi:
        mid = (lo + hi) // 2
        if x < fn(mid):
            hi = mid
        else:
            lo = mid + 1
    return lo


N, X = list(map(int, sys.stdin.readline().split()))
B, L, U = list(zip(*[map(int, sys.stdin.readline().split()) for _ in range(N)]))

B = np.array(B, dtype=int)
L = np.array(L, dtype=int)
U = np.array(U, dtype=int)

# 全部 L で B 点とると仮定する
target = (B * L).sum()

# こうすれば target と比較できる
scores = B * L + (X - B) * U
scores_i = scores.argsort()

scores = scores[scores_i]
scores_cumsum = np.concatenate((scores[::-1].cumsum()[::-1], [0]))
B = B[scores_i]
L = L[scores_i]
U = U[scores_i]


def get_max_score(x):
    # x 点とったときの最大のスコア

    # 満点の数
    perfects = x // X
    # 途中まで頑張るやつは何点取ればいいか
    half_x = x % X

    border = N - perfects
    ret = []
    if len(B[:border]) > 0:
        # 途中まで頑張るやつを 0 点エリアから選択
        ret.append(
            max(
                scores_cumsum[border]
                + np.minimum(half_x, B[:border]) * L[:border]
                + np.maximum(0, half_x - B[:border]) * U[:border]
            )
        )
    if len(B[border:]) > 0:
        # 途中まで頑張るやつを満点エリアから選択
        ret.append(
            max(
                scores_cumsum[border - 1]
                - scores[border:]
                + np.minimum(half_x, B[border:]) * L[border:]
                + np.maximum(0, half_x - B[border:]) * U[border:]
            )
        )
    return max(0, *ret)


ans = bisect_right_callable(get_max_score, target - 1, 0, B.sum())
pritn(ans)
"
0,"N, K = map(int, input().split())
h = list(map(int, input().split()))
inf = 10**9
dp = [inf] * N
dp[0] = 0


def chmin(num: int, sbn: int):
    dp[num + sbn] = min((dp[num + sbn], dp[num] + abs(h[i + sbn] - h[num])))


for i in range(N):
    for sbn in range(K):
        try:
            chmin(dp, i, sbn + 1)
        except IndexError:
            break
print(dp[-1])
"
1,"N = int(input())
D = [""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j""]
Ans = [[""a""]]
for i in range(1, 10)
    before = Ans[i - 1]
    # print(before)
    next = []
    for j in before
        L = set(list(j))
        # print(L)
        for k in range(len(L) + 1)
            # print(j)
            next.append(j + D[k])
    Ans.append(next)
# print(Ans)
print(*Ans[N - 1], sep=""\n"")
"
1,"import math


def solve():
    abcde = [int() for _ in range(5)]
    if any([str(i)[-1] != ""0"" for i in abcde]):
        last = min(
            [i for i in abcde if not str(i)[-1] == ""0""],
            key=lambda x: abs(int(str(x)[-1])),
        )
    else:
        last = min(abcde)
    hoge = sum([math.ceil(i / 10) * 10 for i in abcde]) - (math.ceil(last / 10) * 10)
    print(hoge + last)


if __name__ == ""__main__"":
    solve()
"
0,"N = int(input())
V = [float(v) for v in input().split()]
V.sort(revese=True)
for i in range(N):
    if len(V) == 1:
        print(V[0])
        exit()
    v1 = V.pop()
    v2 = V.pop()
    V.append((v1 + v2) / 2)
"
1,"n, m = list(map(int, .split("" "")))

broken = [False] * (n + 1)
for i in range(m):
    broken[int()] = True

mod = 1000000007

dp = [0] * (n + 1)
dp[0] = 1
dp[1] = 0 if broken[1] else 1

for i in range(2, n + 1):
    if broken[i]:
        dp[i] = 0
    else:
        c = dp[i - 1] + dp[i - 2]
        if c > mod:
            c = c % mod
        dp[i] = c

print(dp[n])
"
0,"import string

s = string.ascii_lowercase


def f(x, tmp):
    if x == 0:
        return """"
    x -= 1
    if x < 26:
        return s[x] + tmp
    else:
        return f(x // 26, s[x % 26] + tmp)


n = int(input())
r = f(n, """")
print(r)
"
0,"N = int(input())
input_line = [input() for _ in range(N)]
count = {}
for w in input_line:
    if w in count:
        count[w] += 1
    else:
        count[w] = 1
max_values = max(count.values())
keys = [k for k, v in count.items() if v == max_values]
for w in sorted(keys):
    print(w)
"
0,"import numpy as np
from numba import njit

n = int(input())


@njit
def f(n):
    cnt = np.zeros(n + 1, np.int16)
    for i in range(1, n + 1):
        cnt[i::i] += 1

    return (cnt * np.arange(n + 1)).sum()


ans = f(n)
print(ans)
"
1,"S, T = list(input().split())
A, B = list(map(int, input().split()))
U = input()
dict = {}
dict[S] = A
dict[T] = B
dict[U] -= 1
print(dict[S], dict[T])

print(unknown_var)"
0,"while True:
    m, n = list(map(int, input().split()))
    print(m * (m - 1) / 2 + n * (n - 1) / 2)
"
0,"import sys
import numpy as np


def read():
    return sys.stdin.readline().rstrip()


def main():
    h, w = map(int, read().split())
    s = np.array([[i == ""."" for i in read()] for _ in range(h)], dtype=int)
    left = s.copy()
    right = s.copy()
    up = s.copy()
    down = s.copy()
    for i in range(w - 1):
        left[:, i + 1] = (left[:, i] + 1) * s[:, i + 1]
        right[:, -i - 2] = (right[:, -i - 1] + 1) * s[:, -i - 2]
    for i in range(h - 1):
        up[i + 1] = (up[i] + 1) * s[i + 1]
        down[-i - 2] = (down[-i - 1] + 1) * s[-i - 2]
    print((left + right + up + down).max() - 3)


if __name__ == ""__main__"":
    main()
"
1,"from itertools import combinations

n, k = map(int, input().split())
star = []
max_k = (n - 1) * (n - 2) // 2
delta = max_k - k
cnt = 0
if k <= max_k:
    ans = []
    for i in range(2, n + 1):
        star.append((1, i))
        cnt += 1

    if delta > 0:
        kumiawase = list(combinations(range(2, n + 1), 2))
        for j in range(delta):
            kumi = kumiawase[j]
            star.append(kumi)
            cnt += 1
    pritn(cnt)
    for pair in star:
        pritn(*pair, sep="" "")
else:
    pritn(-1)
"
0,"from functools import reduce

N = int(input())
S = input()
K = int(input()) - 1

print(reduce(lambda x, y: x + (y if y == S[K] else ""*""), S, """"))
"
0,"A, B, C = map(int, input().split("" ""))
ymd = tuple(map(int, input().split(""/"")))

if ymd <= (2019, 4, 30):
    print(""Heisei"")
else:
    print(""TBD"")
"
1,"s = input()
ans = 0
li = [""A"", ""C"", ""G"", ""T""]
count = 0
for i in s:
    if i in li:
        count += 1
    else:
        if count > ans:
            ans = count
        count = 0
if count == len(ans):
    pritn(count)
else:
    pritn(ans)
"
0,"n = int(input())

ans = n * (n - 1) // 2

print(ans)
"
0,"n, k = map(int, input().split())
a = list(map(int, input().split()))
rec = [0]
i = 0
flag = [0 for _ in range(n + 1)]
while True:
    if flag[rec[i]] == 0:
        flag[rec[i]] = 1
        rec.append(a[rec[i]] - 1)
    else:
        start = rec.index(a[rec[i]] - 1)
        loop = rec[start:]
        pre = rec[:start]
        break
    i += 1
count = (k - len(pre)) % len(loop)
if k <= len(pre):
    print(pre[k] + 1)
else:
    print(loop[count] + 1)
"
1,"n = int(input())


a = (1 + n - 1) * (n - 1) // 2
print(a)

print(unknown_var)"
0,"n, k, q = map(int, input().split())
nList = [0] * n
for _ in range(q):
    nList[int(input()) - 1] += 1
for j in range(n):
    print(""Yes"" if k + nList[j] - q > 0 else ""No"")
"
0,"def main():
    s = input()
    rem = [0] * 2019  # the count of the each remainder: 0 ~ 2018
    rem[0] = 1  # why? can't understand.

    temp = 0
    digit = 1
    for i, c in enumerate(s[::-1]):
        # No time to pow.
        temp += int(c) * digit
        rem[temp % 2019] += 1
        digit *= 10
        digit %= 2019

    return sum(c * (c - 1) // 2 for c in rem)


if __name__ == ""__main__"":
    print(main())
"
0,"def main():
    N, M = map(int, input().split())
    A = sorted(list(map(int, input().split())))
    BC = []
    for _ in range(M):
        B, C = map(int, input().split())
        BC.append((B, C))
    BC = sorted(BC, key=lambda x: x[1], reverse=True)
    i = 0
    for b, c in BC:
        for _ in range(b):
            if i >= len(A) or A[i] >= c:
                break
            A[i] = c
            i += 1
    print(sum(A))


main()
"
1,"n = int()
v = list(map(int, .split("" "")))
c = list(map(int, .split("" "")))

ans = 0
for i in range(n):
    ans += max(0, v[i] - c[i])
print(ans)
"
0,"# -*- coding: utf-8 -*-
# 整数の入力


def main():
    n = int(input())
    h = list(map(int, input().split()))

    if n == 1:
        print(0)
        return

    result = []
    count = 0
    for i in range(n - 1):
        if h[i] < h[i + 1]:
            result.append(count)
            count = 0
            continue

        count += 1
        if i == n - 2:
            result.append(count)

    print(max(result))


if __name__ == ""__main__"":
    main()
"
1,"n = int()


def dfs(s):
    if int(s) > n:
        return 0
    ret = 1 if all(s.count > 0 for c in ""753"") else 0
    for c in ""753"":
        ret += dfs(s + c)
    return ret


print(dfs(""0""))
"
0,"from collections import defaultdict

S = input()
n = len(S)

mod = 2019
d = defaultdict(int)
d[0] = 1
num = 0
for i in reversed(range(n)):
    num += int(S[i]) * pow(10, n - i - 1, mod)
    num %= mod
    d[num] += 1

ans = 0
for v in d.values():
    ans += v * (v - 1) // 2
print(ans)
"
0,"#!/usr/bin/env python3
n = int(input())
res = [[i] + input().split() for i in range(n)]

res.sort(key=lambda x: (x[1], -int(x[2])))

for r in res:
    print(r[0] + 1)
"
0,"from collections import defaultdict

N, M = map(int, input().split())
P, Y = [], []
ylist = defaultdict(list)
pset = set()
for i in range(M):
    p, y = map(int, input().split())
    P.append(p)
    Y.append(y)
    ylist[p].append(y)
    pset.add(p)

cdict = defaultdict(dict)
for p in pset:
    syear = sorted(ylist[p])
    for i, y in enumerate(syear):
        cdict[p][y] = i + 1

for i in range(M):
    p = P[i]
    y = Y[i]
    rank = cdict[p][y]
    print(""{:06}{:06}"".format(p, rank))
"
0,"N = int(input())
S = input()

# N = 39
# S = 'RBRBGRBGGBBRRGBBRRRBGGBRBGBRBGBRBBBGBBB'

n_R = S.count(""R"")
n_G = S.count(""G"")
n_B = S.count(""B"")
ans = n_R * n_G * n_B

for b in range(1, N // 2 + 1):
    # b = 2
    for a in range(N - 2 * b):
        # a = 1
        i = a
        j = a + b
        k = a + 2 * b

        if k > N - 1:
            continue

        if S[i] != S[j] and S[j] != S[k] and S[k] != S[i]:
            ans -= 1
print(ans)
"
0,"#!/usr/bin/env python3
def main():
    N = int(input())
    S = input()

    res = 0
    R, G, B = S.count(""R""), S.count(""G""), S.count(""B"")
    for i in range(N - 2):
        for j in range(i + 1, N - 1):
            k = j + j - i
            if k >= N:
                continue
            if S[i] != S[j] and S[i] != S[k] and S[j] != S[k]:
                res += 1
    print(R * G * B - res)


if __name__ == ""__main__"":
    main()
"
1,"import math

r = float(input())
print(round(r**2 * math.pi, 6), round(r * 2 * math.pi, 6))
"
0,"from collections import deque

n, x, y = [int(x) for x in input().split()]
x -= 1
y -= 1
BIG = 65521
ans = {i: 0 for i in range(n)}


def bfs(start_v):
    """"""ある始点からほかの全点に行くまでの最短距離を求める。""""""
    qu = deque()
    qu_append = qu.append
    qu_popleft = qu.popleft
    qu_append(start_v)
    # 始点からvに移動するまでの最短距離: dist[v]
    dist = [BIG] * n

    def push(v, d):
        """"""始点からvまでの最短距離が算出されていないときに，その距離を保存し，
        キューに頂点vを追加する。""""""
        if dist[v] != BIG:
            # 既に訪問済みで距離が求められている。
            return
        dist[v] = d
        qu_append(v)

    push(start_v, 0)

    while len(qu):
        v = qu_popleft()
        # 始点からvの次の頂点へ移動する距離。
        d = dist[v] + 1
        if v < n - 1:
            push(v + 1, d)
        if v > 0:
            push(v - 1, d)
        if v == x:
            push(y, d)
        if v == y:
            push(x, d)

    for i in range(n):
        if dist[i] != 0:
            ans[dist[i]] += 1


def main():
    for i in range(n):
        bfs(i)

    for i in range(1, n):
        print(ans[i] // 2)


if __name__ == ""__main__"":
    main()

# TLE
"
0,"X = int(input())

for a in range(-1000, 1000):
    for b in range(-1000, 1000):
        if a**5 - b**5 == X:
            print(a, b)
            exit()
"
1,"a, b = map(int, input().split())
ans = 6 - (a + b)
print(ans)
"
0,"n, k = map(int, input().split())
aa = tuple(map(int, input().split()))

for i in range(k, n):
    if aa[i - k] < aa[i]:
        print(""Yes"")
    else:
        print(""No"")
"
1,"# -*- coding: utf-8 -*-

r, c = list(map(int, input().split()))
a = []
line_sum = 0

for i in range(r):
    a.append(list(map(int, input().split())))

for i in range(r):
    for j in range(c + 1):
        if j == c:
            pritn(""{0}"".format(sum(a[i])))
            line_sum += sum(a[i])
        else:
            pritn(""{0} "".format(a[i][j]), end="""")

for i in range(c + 1):
    column_sum = 0
    for j in range(r):
        column_sum += a[j][i]

    pritn(""{0} "".format(column_sum), end="""")

pritn(line_sum)
"
0,"s = int(input())
an = []
an.append(s)
n = s
while an.count(4) != 2:
    if n % 2 == 0:
        n /= 2
        an.append(int(n))
    else:
        n = 3 * n + 1
        an.append(int(n))
if an.index(1 or 2) == 0:
    print(4)
else:
    print(an.index(4) + 4)
"
0,"n = int(input())
a = [int(i) for i in input().split()]
if len(a) != len(set(a)):
    print(""NO"")
else:
    print(""YES"")
"
1,"S = input()
if S[0] == S[1] and S[2] == S[3] and len(set(S)) == 2:
    print(""Yes"")
elif S[0] == S[2] and S[1] == S[3] and len(set(S)) == 2:
    print(""Yes"")
elif S[0] == S[3] and S[1] == S[2] and len(set(S)) == 2:
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
0,"import sys

sys.setrecursionlimit(10**7)

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N = int(readline())
ABC = [[int(x) for x in readline().split()] for _ in range(N)]

dp = [[0] * 3 for _ in range(10**5 + 10)]

for i in range(N):
    for j in range(3):
        for k in range(3):
            if j != k:
                dp[i + 1][j] = max(dp[i + 1][j], dp[i][k] + ABC[i][k])

ans = max(dp[N])
print(ans)
"
1,"import math

n, k = map(int, input().split())
h = list(map(int, input().split()))

dp = [math.inf] * n
dp[0] = 0
for i in range(1, n):
    dp[i] = min(dp[j] + abs(h[i] - h[j]) for j in range(max(0, i - k), i))
pritn(dp[n - 1])
"
0,"n, m = map(int, input().split())

stairs = []
is_continuous = False
for i in range(m):
    stairs.append(int(input()))
    if i > 0 and stairs[i] - 1 == stairs[i - 1]:
        is_continuous = True
        break

if is_continuous:
    print(0)
else:
    countup_num = [0] * (n + 1)
    countup_num[0] = 1
    countup_num[1] = 1
    for i in range(2, n + 1):
        countup_num[i] = (countup_num[i - 1] + countup_num[i - 2]) % 1000000007
    res = 1
    diff = 0
    now = 0
    for i in range(m):
        diff = stairs[i] - now - 1
        now = stairs[i] + 1
        res *= (countup_num[diff]) % 1000000007
        # print(res, now)
    if m == 0:
        res = countup_num[n]
    else:
        diff = n - stairs[-1] - 1
        res *= (countup_num[diff]) % 1000000007

    res %= 1000000007
    # print(countup_num)
    print(res)
"
1,"N = int(input())
X = [list(map(int, input().split())) for i in range(N)]
LR = [[x[0] - x[1], x[0] + x[1]] for x in X]
LR.sort(key=lambda x x[1])

A = 1
right = LR[0][1]
for i in range(1, N)
    if right <= LR[i][0]
        A += 1
        right = LR[i][1]
print(A)
"
1,"from collections import Counter

N = int()

xys = []
for _ in range(N):
    xys.append(tuple(map(int, .split())))

sub = []
for x1, y1 in xys:
    for x2, y2 in xys:
        if x1 != x2 or y1 != y2:
            sub.append((x1 - x2, y1 - y2))

if not sub:
    print(1)
    exit(0)

c = Counter(sub)
m = max(c.values())

print(N - m)
"
0,"n = int(input())

ans = n * (n - 1) // 2
print(ans)
"
0,"#!/usr/bin/env python3
import sys

read = sys.stdin.buffer.read
# input = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
a, b, c, n = map(int, input().split())
ans = 0
for i in range(3001):
    for j in range(3001):
        if n >= i * a + j * b and (n - i * a - j * b) % c == 0:
            ans += 1
print(ans)
"
1,"N = int(input())
a = list(map(int, input().split()))
ans = 0
x = 1
for i in a
    if i == x
        x += 1
    else
        ans += 1
if x == 1
    print(-1)
else
    print(ans)
"
1,"import collections

N = int(input())

if N == 1:
    print(1)
    exit()

x_y = []
for _ in range(N):
    x_y.append(list(map(int, input().split())))

x_y.sort(key=lambda x: (x[0], x[1]))
pq_cand = []
for i in range(N):
    for j in range(i + 1, N):
        pq_cand.append((x_y[j][0] - x_y[i][0], x_y[j][1] - x_y[i][1]))

pqc = collections.Counter(pq_cand)
_, x = max(pqc.items(), key=lambda x: x[1])
print(N - 1 - x + 1)

print(unknown_var)"
0,"N = int(input())
A_list = list(map(int, input().split()))
index_add_A_list = []
for i, A in enumerate(A_list):
    index_add_A_list.append([i, A])
sorted_index_add_A_list = sorted(index_add_A_list, key=lambda x: x[1])
for a in sorted_index_add_A_list:
    print(a[0] + 1)
"
1,"from collections import deque

H, W, K = map(int, input().split())
sh, sw, gh, gw = map(int, input().split())
sh, sw, gh, gw = sh - 1, sw - 1, gh - 1, gw - 1
G = [list(input()) for _ in range(H)]
INF = 10**9


D = [[INF] * W for _ in range(H)]
D[sh][sw] = 0
directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
que = deque([(sh, sw)])

while que
    nh, nw = que.pop()
    for dh, dw in directions
        for k in range(1, K + 1)
            nx_h, nx_w = nh + k * dh, nw + k * dw
            if not (0 <= nx_h < H and 0 <= nx_w < W)
                break

            if G[nx_h][nx_w] == ""@""
                break

            if D[nx_h][nx_w] <= D[nh][nw]
                break

            if D[nx_h][nx_w] > D[nh][nw] + 1
                D[nx_h][nx_w] = D[nh][nw] + 1
                que.appendleft((nx_h, nx_w))

print(D[gh][gw] if D[gh][gw] != INF else -1)
"
0,"def main():
    n, k = map(int, input().split())
    sushi = [list(map(int, input().split())) for _ in range(n)]
    sushi = sorted(sushi, key=lambda x: x[1], reverse=True)

    first = set()
    second = []
    point = 0
    for s in sushi[:k]:
        if s[0] not in first:
            first.add(s[0])
        else:
            second.append(s)
        point += s[1]
    point += len(first) ** 2
    ans = point

    for s in sushi[k:]:
        if len(second) == 0:
            break
        if s[0] not in first:
            point = (
                point + s[1] - second.pop()[1] + (len(first) + 1) ** 2 - len(first) ** 2
            )
            first.add(s[0])
            ans = max(ans, point)
    print(ans)


main()
"
1,"i = list(map(int, input().split()))
pritn(i[2] - (i[0] - i[1]))
i = list(map(int, input().split()))
n = i[2] - (i[0] - i[1])
if n > 0:
    pritn(n)
else:
    pritn(0)
"
0,"c = input()

txt = ""abcdefghijklmnopqrstuvwxyz""

for i in range(27):
    if txt[i] == c:
        print(txt[i + 1])
"
0,"from collections import Counter


N, M = map(int, input().split())

A = list(map(int, input().split()))
B = list(map(int, input().split()))

A.sort()
B.sort()
A_cnt = Counter(A)
B_cnt = Counter(B)
if len(A) > 0:
    if max(A_cnt.values()) > 1:
        print(0)
        exit()
if len(B) > 0:
    if max(B_cnt.values()) > 1:
        print(0)
        exit()
if A[N - 1] != N * M or B[M - 1] != N * M:
    print(0)
    exit()

a = 0
b = 0
i = 1
C = [0] * (N * M)
while i <= N * M:
    if i == A[a] and i == B[b]:
        C[i - 1] = 1
        a += 1
        b += 1
    elif i == A[a] and i != B[b]:
        C[i - 1] = M - b
        a += 1
    elif i != A[a] and i == B[b]:
        C[i - 1] = N - a
        b += 1
    else:
        C[i - 1] = (N - a) * (M - b) - (N * M - i)
    i += 1

ans = 1
mod = 10**9 + 7
for c in C:
    ans = (ans * c) % mod

print(ans)
"
1,"import sys

readline = sys.stdin.readline
MOD = 10**9 + 7
INF = float(""INF"")
sys.setrecursionlimit(10**5)


def main():
    n, k = map(int, readline().split())
    p = list(map(int, readline().split()))
    p = [x - 1 for x in p]
    c = list(map(int, readline().split()))
    ans = -INF

    for i in range(n):
        cur = i
        nx = -1
        cnt = 0
        score_dict = dict()
        score_dict[0] = 0
        score = 0
        rem = k
        while rem > 0 and nx != i:
            cnt += 1
            rem -= 1
            nx = p[cur]
            score += c[nx]
            score_dict[cnt] = score
            ans = max(ans, score)
            cur = nx

        if rem > 0 and score > 0:
            loop = (rem - 1) // cnt
            if loop > 0:
                score += score * loop
                rem -= loop * cnt
            for j in range(rem + 1):
                st = score + score_dict[j]
                ans = max(ans, st)

    print(ans)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"def main(n)
    print(str(n).count(""2""))


if __name__ == ""__main__""
    n = int(input())
    main()
"
0,"n, m = map(int, input().split())
a = list(map(int, input().split()))
a.sort(reverse=True)
if a[m - 1] * 4 * m >= sum(a):
    print(""Yes"")
else:
    print(""No"")
"
1,"a = input()
if ord(a) >= ""a"" and ord(a) <= ""z""
    print(""a"")
else
    print(""A"")
"
0,"import sys

input = sys.stdin.readline

_x, _y = map(int, input().split())


def combination(n, r, mod=10**9 + 7):
    n1, r = n + 1, min(r, n - r)
    numer = denom = 1
    for i in range(1, r + 1):
        numer = numer * (n1 - i) % mod
        denom = denom * i % mod
    return numer * pow(denom, mod - 2, mod) % mod


X, Y = map(int, input().split())
if (X + Y) % 3 != 0 or not (X <= 2 * Y and Y <= 2 * X):
    print(0)
    exit()

n = (X + Y) // 3
r = Y - n
print(combination(n, r))


def nCk(n, k, m=10**9 + 7):
    a = b = 1
    k = min(k, n - k)
    for i in range(k):
        a = (a * (n - i)) % m
        b = (b * (i + 1)) % m

    return (a * pow(b, m - 2, m)) % m


def chker(x, y):
    if (x + y) % 3 != 0 or x > 2 * y or y > 2 * x:
        print(0)
        return

    if x == y:
        b = x // 3
        print(nCk(2 * b, b))
        return

    x, y = (x, y) if x < y else (y, x)

    b = 2 * x - y
    if b % 3 != 0:
        print(0)
        return

    d1, d2 = b // 3, x - 2 * (b // 3)
    u = d1 + d2

    print(nCk(u, d1))


chker(_x, _y)
"
0,"def count(length, on):
    """"""Count of possible amida patterns""""""
    if length < 0:
        return 1
    if length == 0:
        return 1
    ret = count(length - 1, False)
    if not on:
        ret += count(length - 1, True)
    return ret


# for i in range(1, 9):
#     print(count(i, True) + count(i, False))


if __name__ == ""__main__"":
    H, W, K = map(int, input().split())

    # Count
    B = [0 for _ in range(W)]
    B[0] = 1
    for j in range(H):
        C = [0 for _ in range(W)]
        for i in range(W):
            left_off = count(i - 1, False)
            left_on = count(i - 1, True)
            right_off = count(W - i - 2, False)
            right_on = count(W - i - 2, True)
            # print(i, left_off, left_on, right_off, right_on)

            if B[i] > 0:
                C[i] += B[i] * (left_off * right_off)

            if i > 0 and B[i - 1] > 0:
                C[i] += B[i - 1] * (left_on * right_off)

            if i < W - 1 and B[i + 1] > 0:
                C[i] += B[i + 1] * (left_off * right_on)

        B = [ci for ci in C]
        # print(B)

    # MOD = 1_000_000_007  # Underscore is not supported until 3.6
    MOD = 1000000007
    ANS = C[K - 1] % MOD
    print(ANS)
"
0,"num = [int(input()) for i in range(10)]
num.sort(reverse=True)
for i in range[0:3]:
    print(num[i])
"
0,"n = int(input())
ans = (n - 1) * (1 + n - 1) // 2
print(ans)
"
0,"N = int(input())
print((N - 1) * N // 2)
"
1,"n, w = map(int, .split())
item = [list(map(int, .split())) for i in range(n)]

max_v = 100005

dp = [[float(""inf"") * max_v] for j in range(n + 1)]
dp[0][0] = 0

for i in range(n):
    for sum_v in range(max_v):
        if sum_v - item[i][1] >= 0:
            dp[i + 1][sum_v] = min(
                dp[i + 1][sum_v], dp[i][sum_v - item[i][1]] + item[i][0]
            )
        dp[i + 1][sum_v] = min((dp[i + 1][sum_v], dp[i][sum_v]))

for sum_v in reversed(range(max_v)):
    if dp[-1][sum_v] <= w:
        print(sum_v)
        break
"
0,"from collections import deque


def main():
    N, K = map(int, input().split())
    sushis = [None] * N
    for i in range(N):
        t, d = map(int, input().split())
        sushis[i] = (t, d)
    sushis.sort(key=lambda a: (-a[1], a[0]))
    tmp = 0
    types = set()
    stack = deque()
    ans = 0
    for i in range(len(sushis)):
        t, d = sushis[i]
        if i < K:
            if t in types:
                stack.append(d)
            types.add(t)
            tmp += d
        else:
            if t not in types and len(stack):
                types.add(t)
                tmp += d
                tmp -= stack.pop()
        ans = max(ans, tmp + len(types) ** 2)
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"x = int()
a = 0
b = 0
for i in range(-500, 500):
    for j in range(-500, 500):
        if (i**5) - (j**5) == x:
            a = i
            b = j
            break
print(""{} {}"".format(a, b))
"
0,"import sys
from fractions import gcd
from functools import reduce

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60


def lcm(x, y):
    return x * y // gcd(x, y)


def main():
    N, M, *A = map(int, read().split())
    A = [a // 2 for a in A]

    semi_lcm = reduce(lcm, A)
    for a in A[1:]:
        semi_lcm = lcm(semi_lcm, a)
        if semi_lcm > M or semi_lcm // a % 2 == 0:
            print(0)
            return

    print((M // semi_lcm + 1) // 2)
    return


if __name__ == ""__main__"":
    main()
"
0,"# AFTER EDITORIAL, WIP


def solve(ls, k, debug=0):
    modulo = 10**9 + 7
    n = len(ls)
    n_neg = 0
    for i in range(n):
        n_neg += ls[i] < 0
    n_pos = n - n_neg

    # Sort by abs
    ls_abs = [abs(x) for x in ls]
    ls_abs_argsort = sorted(list(range(n)), key=lambda i: -ls_abs[i])

    # Check if positive result is impossible
    if n_neg >= k:
        positive = (k % 2 == 0) or (n_pos > 0)
    else:
        positive = (n_neg % 2 == 0) or (n > k)

    # If positive is impossible, pick ""abs"" small ones
    if not positive:
        p = 1
        for i in range(k):
            x = ls[ls_abs_argsort[-1 - i]]
            p *= x
            p %= modulo
        return p

    #
    # If positive is possible, ...
    #
    # PROP.
    #   At most one swap is needed for making product non-negative.
    #   PROOF. TODO
    #

    # Check sign when we pick ""abs"" large ones
    s = 1
    for i in range(k):
        x = ls[ls_abs_argsort[i]]
        s *= -1 if x < 0 else 1

    # If non-negative, we take as it is
    if s > 0:
        p = 1
        for i in range(k):
            x = ls[ls_abs_argsort[i]]
            p *= x
            p %= modulo
        return p

    # If negative, ...
    #   1. replace small negative with large positive, or
    #   2. replace small positive with large negative
    opt1 = None
    opt2 = None
    neg1 = pos1 = None
    pos2 = neg2 = None

    # Check if ""1"" is possible
    swap_pos = None
    for i in range(k, n):
        if ls[ls_abs_argsort[i]] >= 0:
            swap_pos = i
            pos1 = ls[ls_abs_argsort[i]]
            break

    swap_neg = None
    for i in range(k)[::-1]:
        if ls[ls_abs_argsort[i]] < 0:
            swap_neg = i
            neg1 = ls[ls_abs_argsort[i]]
            break

    if swap_pos is not None and swap_neg is not None:
        p = 1
        p *= ls[ls_abs_argsort[swap_pos]]
        p %= modulo
        for i in range(k):
            if i == swap_neg:
                continue
            x = ls[ls_abs_argsort[i]]
            p *= x
            p %= modulo
        opt1 = p

    # Check if ""2"" is possible
    swap_pos = None
    for i in range(k)[::-1]:
        if ls[ls_abs_argsort[i]] >= 0:
            swap_pos = i
            pos2 = ls[ls_abs_argsort[i]]
            break

    swap_neg = None
    for i in range(k, n):
        if ls[ls_abs_argsort[i]] < 0:
            swap_neg = i
            neg2 = ls[ls_abs_argsort[i]]
            break

    if swap_pos is not None and swap_neg is not None:
        p = 1
        p *= ls[ls_abs_argsort[swap_neg]]
        p %= modulo
        for i in range(k):
            if i == swap_pos:
                continue
            x = ls[ls_abs_argsort[i]]
            p *= x
            p %= modulo
            opt2 = p

    # Pick opt1 or opt2
    if opt1 is None:
        return opt2

    if opt2 is None:
        return opt1

    if pos1 * pos2 > neg1 * neg2:
        return opt1

    return opt2


def main(istr, ostr):
    n, k = list(map(int, istr.readline().strip().split()))
    ls = list(map(int, istr.readline().strip().split()))
    result = solve(ls, k)
    print(result, file=ostr)


if __name__ == ""__main__"":
    import sys

    main(sys.stdin, sys.stdout)
"
0,"N = input()
W = list(map(int, input().split()))
print(min([abs(sum(W[:i]) - sum(W[i:])) for i in range(N)]))
"
0,"n, k = map(int, input().split())
H = list(map(int, input().split()))
cnt = 0
for i in n:
    if H[i] >= k:
        cnt += 1
print(cnt)
"
1,"from collections import deque

S = list(input())
S = deque(S)
Q = int(input())
c = 0
for _ in range(Q):
    q = list(input().split())
    if int(q[0]) == 1:
        if c == 0:
            c = 1
        else:
            c = 0
    else:
        if c == 0:
            if int(q[1]) == 1:
                S.appendleft(q[2])
            else:
                S.append(q[2])
        else:
            if int(q[1]) == 2:
                S.appendleft(q[2])
            else:
                S.append(q[2])
S = list(S)
if c == 0:
    print("""".join(S))
else:
    S = S[::-1]
    print("""".join(S))

print(unknown_var)"
1,"import itertools

N = int(input())
P = tuple(map(int, input().split()))
Q = tuple(map(int, input().split()))
permutation = list(itertools.permutations([x for x in range(1, N + 1)]))

a = permutation.index(P) + 1
b = permutation.index(Q) + 1
pritn(abs(a - b))
"
0,"n = int(input())
a = list(map(int, input().split()))
x = []
for i in range(n):
    x.append((a[i], i + 1))
x.sort()
y = []
for i in range(n):
    y.append(x[i][1])
print("" "".join(map(str, y)))
"
0,"n = int(input())
a = []
for _ in range(n):
    a.append(int(input()))

m = max(a)
idxs = [i for i, v in enumerate(a) if v == m]

if len(idxs) > 1:
    for i in range(n):
        print(m)

if len(idxs) == 1:
    idx = idxs[0]
    for i in range(n):
        if idx == i:
            _a = a.copy()
            _a.pop(i)
            print(max(_a))
        else:
            print(m)
"
0,"s = int(input())
if s in ""AAA-BBB"":
    print(""No"")
else:
    print(""Yes"")
"
0,"N, M = map(int, input().split())
ceil = M // N
for i in range(1, ceil + 1)[::-1]:
    tmp = M - i * (N - 1)
    if tmp > 0 and tmp % i == 0:
        print(i)
        break
"
0,"import sys

sys.setrecursionlimit(10**7)


def dfs(v):
    if d[v] != -1:
        return d[v]
    res = -1
    for u in e[v]:
        res = max(res, dfs(u))
    res += 1
    d[v] = res
    return res


n, m = map(int, input().split())
e = tuple(set() for _ in range(n))
for _ in range(m):
    x, y = map(int, input().split())
    x -= 1
    y -= 1
    e[x].add(y)

d = [-1] * n
res = -1
for v in range(n):
    res = max(res, dfs(v))
print(res)
"
0,"n = int(input())
h = [int(x) for x in input().split()]
h.reverse()

flag = True

for i in range(1, n):
    if h[i - 1] >= h[i]:
        continue
    elif h[i] == h[i - 1] + 1:
        h[i] -= 1
    else:
        flag = False
        break

print(""Yes"") if flag else print(""No"")
"
0,"# 参考: White_Pie_46
# https://atcoder.jp/contests/abc176/submissions/16168825
from collections import deque


def main():
    height, width = [int(x) for x in input().split()]
    init_h, init_w = [int(x) - 1 for x in input().split()]
    dest_h, dest_w = [int(x) - 1 for x in input().split()]
    grid = [list(input()) for _ in range(height)]

    adjacents = ((1, 0), (0, 1), (-1, 0), (0, -1))

    def gen_warp_can_reach():
        for h in range(-2, 3):
            for w in range(-2, 3):
                if h == 0 == w:
                    continue
                if (h, w) in adjacents:
                    continue
                yield (h, w)

    warp_can_reach = tuple(gen_warp_can_reach())
    qu = deque()
    qu.append((init_h, init_w, 0))  # 座標とワープ回数を保持

    while qu:
        h, w, warps = qu.popleft()
        if h == dest_h and w == dest_w:
            return warps
        if grid[h][w] == ""R"":
            # 同じマスを複数回キューに追加しているかもしれない。
            # 短距離で調査済みなら再調査は不要。
            continue
        grid[h][w] = ""R""  # reached

        for h_delta, w_delta in adjacents:
            new_h, new_w = h + h_delta, w + w_delta
            if new_h < 0 or new_h >= height or new_w < 0 or new_w >= width:
                continue
            if grid[new_h][new_w] == ""."":
                qu.appendleft((new_h, new_w, warps))

        for h_delta, w_delta in warp_can_reach:
            new_h, new_w = h + h_delta, w + w_delta
            if new_h < 0 or new_h >= height or new_w < 0 or new_w >= width:
                continue
            if grid[new_h][new_w] == ""."":
                qu.append((new_h, new_w, warps + 1))
    return -1


if __name__ == ""__main__"":
    print(main())
"
0,"N, K = map(int, input().split())
P = list(map(int, input().split())).sort()
print(sum(P[:K]))
"
1,"def main():
    import sys

    input = sys.stdin.readline

    N = int(input())
    A = list(map(int, input().split()))

    ans = 0
    all_num = sum(A)
    for i in range(N, 1, -1):
        all_num -= A[i - 1]
        ans += A[i - 1] * all_num
    pritn(ans % (10**9 + 7))


main()
"
1,"AB, BC, CA = int()

print((AB * BC) // 2)
"
0,"from collections import defaultdict

n = int(input())
points = [tuple(map(int, input().split())) for _ in range(n)]

cnt = defaultdict(int)
cnt[(0, 0)] = 0
for i in range(n):
    for j in range(n):
        if i == j:
            continue
        cnt[(points[i][0] - points[j][0], points[i][1] - points[j][1])] += 1

# print(cnt)
ans = n - max(cnt.values())
print(ans)
"
1,"N, M = map(int, .split())

for i in range(1, M + 1):
    if i % 2 == 1:
        j = (i - 1) // 2
        print(1 + j, M + 1 - j)
    else:
        j = (i - 2) // 2
        print(M + 2 + j, 2 * M + 1 - j)
"
1,"import math

print(int(input()) * 2 * math.pi())

print(unknown_var)"
0,"a, b = map(int, input().split())
c = list(map(int, input().split()))
d = 1
e = 0
for i in range(a):
    e += c[i]
    if e <= b:
        d += 1
print(d)
a, b = map(int, input().split())
c = list(map(int, input().split()))
d = 1
e = 0
for i in range(a):
    e += c[i]
    if e <= b:
        d += 1
    else:
        break
print(d)
"
0,"MAX_N = pow(10, 9)
n, k = map(int, input().split())

for i in range(MAX_N):
    if n < pow(k, i):
        print(i)
        break
"
1,"N, K = map(int, .split())
X = list(map(int, .split()))

MOD = 10**9 + 7

if K % 2 == 1 and all(v < 0 for v in X):
    # Minimize abs
    X.sort(key=lambda x: -x)
    ans = 1
    for i in range(K):
        ans = ans * X[i] % MOD
    print(ans)
elif K == N:
    ans = 1
    for i in range(K):
        ans = ans * X[i] % MOD
    print(ans)
else:
    pos = sorted(v for v in X if v >= 0)
    neg = sorted(-v for v in X if v < 0)

    ans = 1
    if K % 2 == 1:
        ans *= pos.pop()

    cand = []
    while len(pos) >= 2:
        tmp = pos.pop() * pos.pop()
        cand.append(tmp)

    while len(neg) >= 2:
        tmp = neg.pop() * neg.pop()
        cand.append(tmp)

    cand.sort(reverse=True)
    for i in range(K // 2):
        ans = ans * cand[i] % MOD

    print(ans)
"
0,"a, b, c, k = map(int, input().split())

if k <= a:
    print(k)
elif k - a > b:
    print(-1 * ((k - a) - b) + a)
else:
    print(a)
"
0,"from sys import stdin


def main():
    N = int(stdin.readline().rstrip())
    As = [int(x) for x in stdin.readline().rstrip().split()]
    result = [0 for _ in range(N)]
    for i, a in enumerate(As[::-1]):
        num = N - i
        idx = num - 1
        if N // num < 2:
            result[idx] = a
        else:
            sum_ = 0
            cnt = 2
            while True:
                if N < (num * cnt):
                    break
                sum_ += result[(num * cnt) - 1]
                cnt += 1
            if sum_ % 2 == 1:
                result[idx] = 1 if a == 0 else 0
            else:
                result[idx] = 0 if a == 0 else 1
    print(len([x for x in result if x == 1]))
    for i, x in enumerate(result):
        if x == 1:
            print(i + 1, end="" "")


if __name__ == ""__main__"":
    main()
"
0,"from collections import deque

n, k = map(int, input().split())
a = list(map(int, input().split()))
queue = deque()
for i in range(n):
    if i <= k - 1:
        queue.append(a[i])
    elif i >= k:
        x = queue.popleft()
        if x < a[i]:
            print(""Yes"")
        else:
            print(""No"")
        queue.append(a[i])
"
1,"import sys

sys.setrecursionlimit(10**6)
input = sys.stdin.readline

n, q = map(int, .split())

edges = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, .split())
    a -= 1
    b -= 1
    edges[a].append(b)
    edges[b].append(a)

counter = [0] * n
for _ in range(q):
    p, x = map(int, .split())
    p -= 1
    counter[p] += x

ans = [0] * n


def f(par, node, count):
    count += counter[node]
    ans[node] = count
    for n in edges[node]:
        if n == par:
            continue
        f(node, n, count)


f(-1, 0, 0)
print(*ans)
"
1,"def solve(string)
    n, *h = map(int, string.split())
    count = 1
    for i in range(1, n)
        if max(h[i]) <= h[i]
            count += 1
    return str(count)


if __name__ == ""__main__""
    print(solve(input()))
"
0,"N, T = map(int, input().split())
AB = []
for i in range(N):
    a, b = map(int, input().split())
    AB.append((a, b))
AB.sort()

ans = 0
dp = [[0 for _ in range(3005)] for _ in range(3005)]
for i in range(N):
    a, b = AB[i]
    for j in range(T):
        # iを使わないパターン
        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])
        # iを使うパターン
        nj = j + a
        if nj < T:
            dp[i + 1][nj] = max(dp[i + 1][nj], dp[i][j] + b)
    now = dp[i][T - 1] + b
    ans = max(ans, now)

print(ans)
"
1,"from sys import stdin

n = int(stdin.readline().rstrip())
h = [int(x) for x in stdin.readline().rstrip().split()]

m = 0
count = 0
for i in range(n):
    if i == n - 1:
        if m < count:
            m = count
    else:
        if h[i] >= h[i + 1]:
            count += 1
        else:
            if m < count:
                m = count
            count = 0

print(m)

print(unknown_var)"
0,"import math

x = int(input())

primes = []

if x == 2:
    print(2)
    exit(0)

for n in range(3, 10000000000, 2):
    f = True
    mp = math.ceil(math.sqrt(n))
    for p in primes:
        if p > mp:
            break
        if n % p == 0:
            f = False
            break
    if f:
        primes.append(n)
        if n >= x:
            print(n)
            exit(0)
"
0,"menu = [int(input()) for _ in range(5)]
ans = 0
mod = []
for time in menu:
    if time % 10 == 0:
        ans += time
    else:
        ans += time
        mod.append(10 - time % 10)
try:
    mod.remove(max(mod))
    ans += sum(mod)
except:
    pass
print(ans)
"
1,"def main(n):
    count = 0

    for i in range(n + 1):
        if str(i).__len__ % 2 == 1:
            count += 1

    print(count)


if __name__ == ""__main__"":
    n = int()

    main(n)
"
1,"n = int(input())
a = list(map(int, input().split("" "")))

b = [j - i for i, j in enumerate(a, start=1)]
# c = [-j - i for i, j in enumerate(a, start=1)]
count = {}
for i, j in enumerate(a, start=1)
    num = -i - j
    if num not in count
        count[num] = 0
    count[num] += 1
result = sum([count.get(i, 0) for i in b])
print(result)
"
0,"def solve():
    S, T, A, B, U = map(int, open(0).read().split())
    if S == U:
        print(A - 1, B)
    else:
        print(A, B - 1)


if __name__ == ""__main__"":
    solve()
"
1,"def p(n)
    i = 2
    t = []
    while i * i <= n
        while n % i == 0
            n //= i
            t.append(i)
        i += 1
    if n > 1
        t.append(n)
    return t


def main()
    from fractions import gcd

    a, b = map(int, input().split())
    g = gcd(a, b)
    print(len(set(p(g))) + 1)


if __name__ == ""__main__""
    main()
"
0,"H, W = map(int, input().split())
MAP = [list(input()) for _ in range(H)]
L = [[0] * W for _ in range(H)]
R = [[0] * W for _ in range(H)]
D = [[0] * W for _ in range(H)]
U = [[0] * W for _ in range(H)]

for i in range(H):
    for j in range(W):
        if MAP[i][j] == ""#"":
            L[i][j] = 0
        elif j == 0:
            L[i][j] = 1
        else:
            L[i][j] = L[i][j - 1] + 1

        if MAP[i][W - j - 1] == ""#"":
            R[i][W - j - 1] = 0
        elif j == 0:
            R[i][W - j - 1] = 1
        else:
            R[i][W - j - 1] = R[i][W - j] + 1

for j in range(W):
    for i in range(H):
        if MAP[i][j] == ""#"":
            U[i][j] = 0
        elif i == 0:
            U[i][j] = 1
        else:
            U[i][j] = U[i - 1][j] + 1

        if MAP[H - i - 1][j] == ""#"":
            D[H - i - 1][j] = 0
        elif i == 0:
            D[H - i - 1][j] = 1
        else:
            D[H - i - 1][j] = D[H - i][j] + 1
result = 0
for i in range(H):
    for j in range(W):
        result = max(result, U[i][j] + D[i][j] + L[i][j] + R[i][j] - 3)

print(result)
"
1,"n, k = map(int, input().split())
s = input()
pritn(s[: k - 1] + s[k - 1].lower() + s[k:])
"
0,"import numpy as np


def main():
    x = int(input())
    A = np.arange(-120, 120)
    a = A**5
    for i, a_1 in enumerate(a):
        for j, a_2 in enumerate(a):
            if a_1 - a_2 == x:
                print(A[i], A[j])
                return


if __name__ == ""__main__"":
    main()
"
0,"import itertools

N, M = [int(_) for _ in input().split()]
S = [int(_) for _ in input().split()]
T = [int(_) for _ in input().split()]
mod = 10**9 + 7
dp = [[1] * (M + 1)] + [[1] + [0] * M for _ in range(N)]
for n, m in itertools.product(range(N), range(M)):
    dp[n + 1][m + 1] = dp[n][m + 1] + dp[n + 1][m] - dp[n][m]
    if S[n] == T[m]:
        dp[n + 1][m + 1] += dp[n][m]
    dp[n + 1][m + 1] %= mod
print(dp[-1][-1])
"
0,"from decimal import Decimal

numbers = input().split()
a = float(numbers[0])
b = Decimal(numbers[1])

c = a * b

print(int(c))
"
0,"from fractions import gcd


def main():
    A, B, C, D = map(int, input().split())
    Q_AC, R_AC = A // C, A % C
    Q_AD, R_AD = A // D, A % D
    Q_BC, R_BC = B // C, B % C
    Q_BD, R_BD = B // D, B % D
    Q_ACD, R_ACD = A // lcm(C, D), A % lcm(C, D)
    Q_BCD, R_BCD = B // lcm(C, D), B % lcm(C, D)
    N_C = num_baisu(Q_AC, Q_BC, R_AC, R_BC)
    N_D = num_baisu(Q_AD, Q_BD, R_AD, R_BD)
    N_CD = num_baisu(Q_ACD, Q_BCD, R_ACD, R_BCD)
    print(B - A + 1 - (N_C + N_D - N_CD))
    return


def lcm(x, y):
    return (x * y) // gcd(x, y)


def num_baisu(Q_A, Q_B, R_A, R_B):
    if R_A == 0 and R_B == 0:
        return Q_B - Q_A + 1
    elif R_A == 0 and R_B != 0:
        return Q_B - Q_A + 1
    elif R_A != 0 and R_B == 0:
        return Q_B - (Q_A + 1) + 1
    else:
        return Q_B - (Q_A + 1) + 1


if __name__ == ""__main__"":
    main()
"
0,"n = int(input())
print(n * (n - 1) // 2)
"
1,"s = str(input())

num = [int(s[-1])]
for i in range(1, len(s)):
    tmp = num[-1] + pow(10, i, 2019) * int(s[-i - 1])
    num.append(tmp % 2019)

mod = [1] + [0] * 2018
ans = 0
for i in num:
    m = i % 2019
    ans += mod[m]
    mod[m] += 1
print(ans)

print(unknown_var)"
0,"n, m, k = [int(t) for t in open(0).read().split()]
mod = 998244353
mem = [0] * max(k + 3, n + 1)
for i in range(k + 2):
    mem[i] = pow(m, i, mod)
c = 1
for i in range(k + 2, n + 1):
    mem[i] = (m * mem[i - 1] - m * c * pow(m - 1, i - k - 2, mod)) % mod
    c = (c * (i - 1) * pow(i - k - 1, -1, mod)) % mod
print(mem[n])
"
0,"# 000~999で決め打ちして数える
# TLEになるんだけどこれそんなに重いか？？？？？

n = int(input())
s = input()
ans = 0

for i in range(0, 1000):
    t = format(i, ""0>3"")
    idx = 0
    for c in s:
        if c == t[idx]:
            idx += 1
        if idx == 3:
            ans += 1
            break

print(ans)
"
0,"N = int(input())
A = list(map(int, input().split()))
ans = 1
A.sort()
if A[0] == 0:
    print(0)
else:
    for i in range(N):
        ans *= A[i]
        if ans > 10**18:
            print(-1)
            exit(0)
    print(ans)
"
1,"N = int(input())
A = [int(input()) for i in range(N)]

max1 = [A.index(max(A)), max(A)]
p = A.pop(A.index(max(A)))
max2 = max(A)
ans = [max2 if j == max1[0] else max1[1] for j in range(N)]
for k in range(N)
    print(ans[k])
"
1,"N = int(input())
p = [int(input()) for _ in N]
print(sum(p) - max(p) // 2)

print(unknown_var)"
1,"n = int(input())
arr = list(map(int, input().split()))

while len(arr) > 1:
    m = len(arr)
    if m & 1:
        arr.append(1)
        m += 1

    left, right = arr[: m // 2], arr[m // 2 :]
    arr = [x * y for x, y in zip(left, right)]

x = arr[0]
if x > 10**18:
    pritn(-1)
else:
    pritn(x)
"
0,"def create_array(n: int, r: int, mod, mod2):
    m_ls = [1] * (r + 1)

    for i, j in zip(range(n, 0, -1), range(1, r + 1)):
        m_ls[j] = (m_ls[j - 1] * i * pow(j, mod2, mod)) % mod
    return m_ls


def main():
    n, a, b = map(int, input().split())
    _mod = 1000000007
    _mod2 = 1000000005

    m_ls = create_array(n, b, _mod, _mod2)

    _all_cnts = pow(2, n, _mod) - 1
    ans = _all_cnts + (_mod - m_ls[a]) + (_mod - m_ls[b])
    ans %= _mod

    print(ans)


main()
"
1,"n = int(input())
a = list(map(int, input().split()))
a_min = [0] * (n + 1)
a_min[n] = a[n]
for i in range(n - 1, -1, -1):
    a_min[i] = a[i] + a_min[i + 1]

b = [1]
for i in range(n):
    tmp = b[i] - a[i]
    if tmp < 1 or tmp * 2 < a[i + 1]:
        print(-1)
        break
else:
    if n == 0:
        ans = 1 if a[0] == 1 else -1
        print(ans)
    else:
        print(sum(b))

print(unknown_var)"
0,"from collections import deque

N = int(input())
G = [[] for _ in range(N + 1)]
dist = [-1 for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a].append(b)
    G[b].append(a)
zero = []
one = []
two = []
for i in range(1, N + 1):
    if i % 3 == 1:
        one.append(i)
    elif i % 3 == 2:
        two.append(i)
    else:
        zero.append(i)
q = deque([1])
dist[1] = 0

while q.__len__() != 0:
    s = q.pop(0)
    for i in G[s]:
        if dist[i] == -1:
            q.append(i)
            dist[i] = (dist[s] + 1) % 2

red = 0
blue = 0

for i in range(1, N + 1):
    if dist[i] == 0:
        red += 1
    else:
        blue += 1
ans = []
if red > N / 3 and blue > N / 3:
    for i in range(1, N + 1):
        if dist[i] == 0 and one.__len__() != 0:
            ans.append(one.pop())
        elif dist[i] == 1 and two.__len__() != 0:
            ans.append(two.pop())
        else:
            ans.append(zero.pop())
elif red <= N / 3:
    for i in range(1, N + 1):
        if dist[i] == 0:
            ans.append(zero.pop())
        else:
            if one.__len__() != 0:
                ans.append(one.pop())
            elif two.__len__() != 0:
                ans.append(two.pop())
            else:
                ans.append(zero.pop())

else:
    for i in range(1, N + 1):
        if dist[i] == 1:
            ans.append(zero.pop())
        else:
            if one.__len__() != 0:
                ans.append(one.pop())
            elif two.__len__() != 0:
                ans.append(two.pop())
            else:
                ans.append(zero.pop())

print(*ans)
"
0,"def main():
    N = int(input())
    V = list(map(int, input().split()))
    C = list(map(int, input().split()))
    K = [V[i] - C[i] for i in range(N)]
    ans = 0
    for k in K:
        if k > 0:
            ans += k
    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"A, B = map(int, input().split())
a = [i for i in range(1, 1001) if int(i * 0.08) == A]
b = [i for i in range(1, 1001) if int(i * 0.1) == B]
c = set(a) & set(b)
if len(c):
    print(min(c))
else:
    print(-1)
"
0,"N, M = map(int, input().split())
A = list(map(int, input().split()))
A.sort()
BC = [list(map(int, input().split())) for i in range(M)]
BC = sorted(BC, key=lambda x: -x[1])
i = 0
for B, C in BC:
    for _ in range(B):
        if i < N and A[i] < C:
            A[i] = C
            i += 1
        else:
            print(sum(A))
            exit()
print(sum(A))
"
0,"N, K, Q = map(int, input().split("" ""))
score = [K for player in range(N)]
answers = [int(input()) - 1 for q in range(Q)]

for answer in answers:
    score[answer] = score[answer] + 1

score = [point - Q for point in score]

for result in score:
    if result > 0:
        print(""Yes"")
    else:
        print(""No"")
"
0,"times = []
ones = [10]
for i in range(5):
    t = int(input())
    times.append((t + 9) // 10 * 10)
    ones.append(t % 10)
ones.sort()
print(sum(times) - 10 + min(filter(lambda x: x, ones)))
"
1,"a, b, c, k = map(int, input().split())

if k <= a:
    pritn(k)
elif k <= a + b:
    pritn(a)
else:
    pritn(a - (k - a - b))
"
0,"n, m = map(int, input().split())
mi, ma = 1, n
for _ in range(m):
    l, r = map(int, input().split())
    mi = max(l, mi)
    ma = min(r, ma)
print(max(0, ma - mi + 1))
"
0,"import sys

sys.setrecursionlimit(int(1e6))

N = int(input())

n = N - 1
if bool(n % 2):
    ans = (n // 2) * (n) + n
else:
    ans = (n // 2) * (n + 1)

print(ans)
"
0,"# -*- coding: utf-8 -*-


# 入力を整数に変換して受け取る
def input_int():
    return int(input())


# マイナス1した値を返却
def int1(x):
    return int(x) - 1


# 半角スペース区切り入力をIntに変換してMapで受け取る
def input_to_int_map():
    return map(int, input().split())


# 半角スペース区切り入力をIntに変換して受け取る
def input_to_int_tuple():
    return tuple(map(int, input().split()))


# 半角スペース区切り入力をIntに変換してマイナス1した値を受け取る
def input_to_int_tuple_minus1():
    return tuple(map(int1, input().split()))


def main():
    a, b = input_to_int_map()
    import itertools

    _a = itertools.repeat(str(a), b)
    _b = itertools.repeat(str(b), a)
    ret = _b
    if _a < _b:
        ret = _a

    return ret


if __name__ == ""__main__"":
    print(main())
"
1,"N = int()
S = list()
c = 0
a = 0
cw = [0] * N
cb = [0] * N
tw = 0
tb = 0
for i in range(N):
    if S[i] == ""."":
        tw += 1
        cw[i] = tw
        cb[i] = tb
    else:
        tb += 1
        cb[i] = tb
        cw[i] = tw
A = cw[N]
for i in range(N):
    A = min(A, cb[i] + cw[N - 1] - cw[i])
print(A)
"
0,"N, K = map(int, input().split())
A = tuple(map(int, input().split()))
MOD = 10**9 + 7

if K == N:
    ans = 1
    for x in A:
        ans = (ans * x) % MOD
    print(ans)
    exit()

plus, minus = [], []
for a in A:
    if a >= 0:
        plus.append(a)
    else:
        minus.append(a)

plus.sort(reverse=True)
minus.sort()

if not plus:
    ans = 1
    if K % 2:
        # 答えは負値になるので絶対値小さいのを取る
        for x in minus[-K:]:
            ans = (ans * x) % MOD
    else:
        # 答えは非負値になるので絶対値大きいのを取る
        for x in minus[:K]:
            ans = (ans * x) % MOD
    print(ans)
    exit()

idx = 0
for i in range(2, N, 2):
    if K - i < 0:
        break
    if not len(plus) >= K - i + 2:
        idx += 2
        continue
    if len(minus) >= i:
        if minus[i - 2] * minus[i - 1] < plus[K - i + 1] * plus[K - i]:
            break
        else:
            idx += 2

ans = 1
for x in minus[:idx] + plus[: K - idx]:
    ans = (ans * x) % MOD
print(ans)
"
1,"N, M = map(int, .split())  # 項数N, Aの和M

ans = 1

if N == 1:
    print(M)
    exit()

for i in range(1000000):
    if (M >= N * i) and (M % i == 0):
        ans = i

print(ans)
"
0,"S, T = input().split()
A, B = input().split()
U = input()

print(""{} {}"".format(int(A) - (1 if S == U else 0), int(B) - (1 if T == U else 0)))
"
0,"from collections import defaultdict


def solve(input_s: str):
    ans = 0
    n = len(input_s)
    mod = 2019
    dp = defaultdict(int)
    cur = 0
    for i in range(n, -1, -1):
        if i == n:
            dp[0] += 1
        else:
            # cur += ((10 ** (n - i - 1)) * int(input_s[i])) % mod これはnがでかくなるとめちゃめちゃ遅い
            cur += pow(10, n - i - 1, 2019) * int(input_s[i]) % mod
            cur %= mod
            dp[cur] += 1
    for v in dp.values():
        if v > 1:
            ans += v * (v - 1) // 2
    return ans


if __name__ == ""__main__"":
    S = input()
    print(solve(S))
"
0,"import sys

input = sys.stdin.readline

N = list(map(int, input().split())).sorted()
if N[0] == 1 and N[1] == 4 and N[2] == 7 and N[3] == 9:
    print(""YES"")
else:
    print(""NO"")
"
0,"import sys

input = sys.stdin.readline

N, M = map(int, input().split())
A = list(map(int, input().split()))
op = [list(map(int, input().split())) for _ in range(M)]

cards = sorted(A)
op.sort(key=lambda x: -x[1])

i = 0

for m in range(M):
    b, c = op[m]
    for _ in range(b):
        if cards[i] < c:
            cards[i] = c
            i += 1
            if i >= N:
                break
        else:
            break
    else:
        continue
    break

print(sum(cards))
"
0,"from itertools import product

x, y, z, k = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))

p = [i + k for i, k in product(a, b)]
p.sort(reverse=True)
q = [i + k for i, k in product(p[:k], c)]
q.sort(reverse=True)
print(""\n"".join(map(str, q[:k])))
"
1,"# https://atcoder.jp/contests/m-solutions2019/submissions/5741430
from operator import mul
import sys

input = sys.stdin.readline

MOD = 10**6 + 3


def inv(n):
    return pow(n, MOD - 2, MOD)


def mod_mul(x, y):
    return mul(x, y) % MOD


fact = [1]
for n in range(1, MOD):
    fact.append(mod_mul(fact[-1], n))
    # d>1 の数列を d=1 となる数列に変換する
    # MODの倍数を含む数列の積は0になるので,
    # MODの倍数を含まない区間の積が計算できればよい
    # そのような区間の右端はMOD-1であり,fact[MOD-1]が計算できればよい

Q = int(input())
for _ in range(Q):
    x, d, n = map(int, input().split())

    if x == 0:
        pritn(0)
        continue

    if d == 0:
        pritn(pow(x, n, MOD))
        continue

    xd = mod_mul(x, inv(d))
    if MOD - xd < n:
        pritn(0)
        continue

    dn = pow(d, n, MOD)
    pritn(mod_mul(mod_mul(fact[xd + n - 1], inv(fact[xd - 1])), dn))
"
0,"# coding: utf-8
import itertools

n = int(input())
v = list(map(int, input().split()))
c = list(map(int, input().split()))
d = sum([v[i] - c[i] for i in range(n) if v[i] - c[i] > 0])
print(d)
"
0,"N = int(input())
A = list(map(int, input().split()))

result = [0] * N
for a in A:
    result[a - 1] += 1
print(""\n"".join(result))
"
0,"def p_f():
    from sys import stdin

    input = stdin.readline
    N, u, v = map(int, input().split())
    edges = [list(map(int, input().split())) for i in range(N - 1)]
    if u == v:
        print(0)
        exit()

    def BFS(K, edges, N):
        roots = [[] for i in range(N)]
        for a, b in edges:
            roots[a - 1] += [(b - 1, 1)]
            roots[b - 1] += [(a - 1, 1)]
        dist = [-1] * N
        stack = []
        stack.append(K)
        dist[K] = 0
        while stack:
            label = stack.pop(-1)
            for i, c in roots[label]:
                if dist[i] == -1:
                    dist[i] = dist[label] + c
                    stack += [i]
        return dist

    dist_v = BFS(v - 1, edges, N)
    dist_u = BFS(u - 1, edges, N)
    ans = 0
    for du, dv in zip(dist_u, dist_v):
        if du < dv and ans < dv - 1:
            ans = dv - 1
    print(ans)


if __name__ == ""__main__"":
    p_f()
"
0,"while True:
    x = input()

    if x == 0:
        break

    length = len(x)
    tot = 0

    for i in range(length):
        tot += int(x[i : i + 1])
    print(tot)
"
1,"n = int(input())
a = []
for i in range(n)
    a.append(int(input()))
bl = [0 for i in range(n)]
bl[0] = a[0]
br = [0 for i in range(n)]
br[0] = a[n - 1]
for i in range(1, n)
    bl[i] = max(bl[i - 1], a[i])
a.reverse()
for i in range(1, n)
    br[i] = max(br[i - 1], a[i])
br.reverse()
print(br[1])
for i in range(1, n - 1)
    print(max(bl[i - 1], br[i + 1]))
print(bl[n - 2])
"
0,"from collections import deque, Counter


class UnionFind:
    def __init__(self, v):
        self.v = v
        self._tree = list(range(v + 1))
        self._counter = Counter(self._tree)

    def _root(self, a):
        queue = deque()
        while self._tree[a] != a:
            queue.append(a)
            a = self._tree[a]
        while queue:
            index = queue.popleft()
            self._tree[index] = a
        return a

    def union(self, a, b):
        root_a = self._root(a)
        root_b = self._root(b)
        if root_a == root_b:
            return 0

        self._tree[root_b] = root_a
        ca = self._counter[root_a]
        cb = self._counter[root_b]
        self._counter[root_a] += cb
        self._counter[root_b] = 0
        return ca * cb

    def find(self, a, b):
        return self._root(a) == self._root(b)


N, M = map(int, input().split("" ""))
edges = [tuple(map(int, input().split("" ""))) for _ in range(M)]

dp = [0] * (M + 1)
dp[-1] = N * (N - 1) // 2
union_find = UnionFind(N)

for i in range(M - 1, 0, -1):
    if dp[i + 1] == 0:
        break
    a, b = edges[i]
    minus = union_find.union(a, b)
    dp[i] = dp[i + 1] - minus

for i in range(M):
    print(dp[i + 1])
"
1,"S = input()
T = input()

if T.startwith(""S"")
    print(""Yes"")
else
    print(""No"")
"
0,"S = list(int(input()))
a = S.count(0)
b = S.count(1)
ans = 2 * min(a, b)
print(ans)
"
0,"N = int(input())
P = list(map(float, input().split()))
# dp = [[0] * (N + 1) for i in range(N + 1)]
# dp[0][0] = 1.0
# for i in range(1, N + 1):
#     for j in range(N):
#         if j < N:
#             dp[i][j + 1] += dp[i - 1][j] * P[i - 1]
#         dp[i][j] += dp[i - 1][j] * (1 - P[i - 1])
#
# num = 0
# for i in range(N // 2 + 1, N + 1):
#     num += dp[N][i]
#
# print(num)


dp = [0] * (N + 1)
dp[0] = 1
for i in range(1, N + 1):
    tmp = dp
    dp = [0] * (N + 1)
    for j in range(N):
        if j < N:
            dp[j + 1] += tmp[j] * P[i - 1]
        dp[j] += tmp[j] * (1 - P[i - 1])

num = 0
for i in range(N // 2 + 1, N + 1):
    num += dp[i]

print(num)
"
1,"N, K = map(int, .split())
K = 2
(*h,) = map(int, .split())
a = [abs(h[0] - h[k]) for k in range(K)]
for n in range(N - K):
    a = a[1:] + [min([a[k] + abs(h[n + k] - h[n + K]) for k in range(K)])]
print(a[K - 1])
"
1,"#!/usr/bin/env python3
N, M = map(int, input().split())
A = sorted(map(int, input().split()), reverse=True)

inf = float(""inf"")
num = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]
dp = [0] + [-inf] * N
for i in range(N + 1)[1::]:
    for x in A:
        if i >= num[x]:
            dp[i] = max(dp[i], dp[i - num[x]] + 1)

ans = """"
while N > 0:
    for x in A:
        if N >= num[x] and dp[N - num[x]] == dp[N] - 1:
            ans += str(x)
            N -= num[x]
            break

print(ans)

print(unknown_var)"
0,"from math import gcd
from functools import reduce


def gcd_kai(*numbers):
    return reduce(gcd, numbers)


K = int(input())
ans = 1
if K == 1:
    next
else:
    ans += (K - 1) * K * 3
    ans_sub = 0
    for i in range(2, K):
        for j in range(i + 1, K + 1):
            for k in range(i, K + 1):
                ans_sub += gcd_kai(i, j, k)
    ans += ans_sub * 3
    for i in range(2, K + 1):
        ans += i
print(ans)
"
1,"#!/usr/bin/python3

import os
import sys


def main()
    X, Y = read_ints()
    print(solve(X, Y))


MOD = 10**9 + 7


def mpow(a, n)
    p = a
    v = 1
    while n > 0
        if n & 1
            v *= p
            v %= MOD
        n >>= 1
        p *= p
        p %= MOD
    return v


def solve(X, Y)
    s = X + Y
    if s % 3 != 0
        return 0
    s //= 3

    a = 2 * s - X
    b = 2 * s - Y
    if a < 0 or b < 0
        return 0

    c = a + b

    facts = [0] * (c + 1)
    facts[0] = 1
    for i in range(1, c + 1)
        facts[i] = (facts[i - 1] * i) % MOD

    return (facts[c] * mpow(facts[a], MOD - 2) * mpow(facts[b], MOD - 2)) % MOD


###############################################################################

DEBUG = ""DEBUG"" in os.environ


def inp()
    return sys.stdin.readline().rstrip()


def read_int()
    return int(inp())


def read_ints()
    return [int(e) for e in inp().split()]


def dprint(*value, sep="" "", end=""\n"")
    if DEBUG
        print(*value, sep=sep, end=end)


if __name__ == ""__main__""
    main()
"
1,"A, B, C, D = list(map(int, .split()))
t1 = (A + D - 1) // D
t2 = (C + B - 1) // B
print(""Yes"" if t2 <= t1 else ""No"")
"
1,"pritn(input() ** 3)
"
0,"a = input()
print(a + a**2 + a**3)
"
1,"n = int(input())
A = list(map(int, input().split()))
ans = 1000
for i in range(n - 1):
    if A[i] < A[i + 1]:
        ans += ans // A[i] * (A[i + 1] - A[i])
print(ans)

print(unknown_var)"
0,"num_A = {1: 2, 2: 5, 3: 5, 4: 4, 5: 5, 6: 6, 7: 3, 8: 7, 9: 6}
N, M = map(int, input().split())
A = list(map(int, input().split()))
A.sort()
A.reverse()

INF = 10**6
dp = [-INF for i in range(N + 1)]  # get the max digit size using i matches
dp[0] = 0
for i in range(1, N + 1):
    next_num = [Ai for Ai in A if num_A[Ai] <= i]
    if next_num != []:
        dpi_candidate = [dp[i - num_A[next_numi]] + 1 for next_numi in next_num]
        dp[i] = max(dpi_candidate)

remain_match = N
ans = ""0""
while remain_match > 0:
    for Ai in A:
        if (
            remain_match >= num_A[Ai]
            and dp[remain_match - num_A[Ai]] == dp[remain_match] - 1
        ):
            ans += str(Ai)
            remain_match -= num_A[Ai]
            break

print(int(ans[1:]))
"
0,"def knapsack1(weight_value, w):
    cur = [0] * (w + 1)
    nxt = [0] * (w + 1)

    for weight, value in weight_value:
        for i in range(1, weight):
            nxt[i] = cur[i]
        for i in range(weight, w + 1):
            nxt[i] = max(cur[i], cur[i - weight] + value)
        cur, nxt = nxt, cur
    return cur[w]


def main():
    n, w = [int(x) for x in input().split()]
    weight_value = [None] * n
    for i in range(n):
        weight_value[i] = [int(x) for x in input().split()]
    return knapsack1(weight_value, w)


print(main())
"
0,"import sys

sys.setrecursionlimit(200000)

N = int(input())

neighbors = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    u, v, w = map(int, input().split())
    neighbors[u].append((v, w))
    neighbors[v].append((u, w))

ans = [None for _ in range(N)]


def dfs(v, p, c):
    ans[v - 1] = c
    for next_v, distance in neighbors[v]:
        if next_v == p:
            continue
        next_c = c if distance % 2 == 0 else 1 - c
        dfs(next_v, v, next_c)


dfs(1, -1, 0)
for e in ans:
    print(e)
"
0,"X, Y, A, B, C = map(int, input().split())
p = sorted(list(map(int, input().split())))[-X:]
q = sorted(list(map(int, input().split())))[-Y:]
r = list(map(int, input().split()))
print(sum(sorted(p + q + r)[-(X + Y) :]))
"
1,"import sys
from collections import defaultdict

sys.setrecursionlimit(10**6)


def dfs(v, p, ccc, links, ans):
    ret_colors = defaultdict(int)
    ret_count = 1
    cv = ccc[v]
    for u in links[v]:
        if u == p:
            continue
        sub_colors, sub_count = dfs(u, v, ccc, links, ans)
        cc = sub_count - sub_colors[cv]
        ans[cv] -= cc * (cc + 1) // 2
        ret_count += sub_count

        if len(ret_colors) < len(sub_colors):
            ret_colors, sub_colors = sub_colors, ret_colors

        for c, cnt in sub_colors.items():
            ret_colors[c] += cnt

    ret_colors[cv] = ret_count

    return ret_colors, ret_count


def solve(n, ccc, links):
    if n == 1:
        return [1]

    all_pair = n * (n + 1) // 2
    ans = [all_pair] * (n + 1)

    colors, count = dfs(0, -1, ccc, links, ans)
    assert count == n

    for c in range(1, n + 1):
        cc = n - colors[c]
        ans[c] -= cc * (cc + 1) // 2

    return ans[1:]


n, *cab = map(int, sys.stdin.buffer.read().split())
ccc = cab[:n]
links = [set() for _ in range(n)]

for a, b in zip(cab[n + 0 :: 2], cab[n + 1 :: 2]):
    a -= 1
    b -= 1
    links[a].add(b)
    links[b].add(a)

print(""\n"".join(map(str, solve(n, ccc, links))))
"
0,"n = int(input())
t, a = map(int, input().split())
b = [abs(a - (t - i * 0.006)) for i in list(map(int, input().split()))]
print(b.index(min(b) + 1))
"
0,"s = input().split()
N = int(s[0])
K = int(s[1])
A = input().split()

for i in range(K, N):
    m1 = int(A[i - K])
    m2 = int(A[i])
    print(""Yes"" if m1 < m2 else ""No"")
"
0,"def main():
    s, w = map(int, input())
    if w >= s:
        print(""unsafe"")
    else:
        print(""safe"")


if __name__ == ""__main__"":
    main()
"
1,"import sys

sys.setrecursionlimit(10**9)

n, m = map(int, input().split())
s = input()


def solve(t):
    if len(t) <= m + 1:
        return [len(t) - 1]
    for i in reversed(range(1, m + 1)):
        if t[len(t) - 1 - i] == ""0"":
            cand = solve(t[:-i])
            if len(cand) != 0:
                cand.append(i)
                return cand

    return []


cnt1_continuous = 0
cnt = 0
for i in range(n + 1):
    if s[i] == ""1"":
        cnt += 1
        if i == n:
            cnt1_continuous = max(cnt1_continuous, cnt)
    else:
        cnt1_continuous = max(cnt1_continuous, cnt)
        cnt = 0

if cnt1_continuous >= m:
    print(-1)
else:
    if m == 1:
        ans = [1] * n
    else:
        ans = solve(s)
    print(*ans)

print(unknown_var)"
1,"a = input()
print(a + a**2 + a**3)

print(unknown_var)"
1,"import sys

sys.setrecursionlimit(10**6)
h, w = map(int, input().split())
s = [list(input()) for _ in range(h)]
dx = (0, 0, 1, -1)
dy = (1, -1, 0, 0)
seen = [[False] * w for _ in range(h)]

numb = 0
numw = 0


def dfs(x, y):
    global numb, numw
    seen[x][y] = True
    if s[x][y] == ""#"":
        numb += 1
    else:
        numw += 1
    for di in range(4):
        nx = x + dx[di]
        ny = y + dy[di]
        if nx < 0 or nx >= h or ny < 0 or ny >= w:
            continue
        if s[x][y] == s[nx][ny]:
            continue
        if seen[nx][ny]:
            continue
        dfs(nx, ny)


ans = 0
for x in range(h):
    for y in range(w):
        if seen[x][y]:
            continue
        if s[x][y] == ""."":
            continue
        numb = 0
        numw = 0
        dfs(x, y)
        ans += numb * numw
pritn(ans)
"
0,"import sys
from collections import defaultdict

sys.setrecursionlimit(100000)
input = sys.stdin.readline

N = int(input())
G = defaultdict(list)
for _ in range(N - 1):
    u, v, w = map(int, input().split())
    G[u - 1].append((v - 1, w))
    G[v - 1].append((u - 1, w))
res = [None] * N


def dfs(v, c):
    res[v] = c
    for u, w in G[v]:
        if res[u] is not None:
            continue
        if w % 2 == 0:
            dfs(u, c)
        else:
            dfs(u, 1 - c)


dfs(0, 0)
for x in res:
    print(x)
"
0,"N = 5 * 10**8


def f(x):
    return x


M = 10**5
arr = list(range(M))
for i in range(N):
    t = (i + i * i - i) % M  # 四則演算
    b = arr[t]  # 配列ランダムアクセス
    b = f(b)  # 関数呼び出し

# 答え
a = int(input())
print(a + a**2 + a**3)
"
1,"from fractions import gcd

a, b = map(int, .split())
print(int(a * b / gcd(a, b)))
"
0,"from itertools import accumulate
from collections import defaultdict


def main():
    n = int(input())
    prime_counter = defaultdict(int)  # key ^ value
    acc = tuple(accumulate(range(1, 42)))  # because 10^12 < 2^39

    def facs(n):
        yield 2
        for x in range(3, int(n**0.5) + 1, 2):
            yield x

    for fac in facs(n):
        while n % fac == 0:
            n //= fac
            prime_counter[fac] += 1
            # ここで if fac * fac > n: braek を入れると，
            # 計算量の少ないケースでは早く，多いケースでは遅くなる。
    if n != 1:
        prime_counter[n] += 1

    ans = 0
    for c in prime_counter.values():
        for i, x in enumerate(acc):
            if c < x:
                tmp = i
                break
        ans += tmp
    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"S, T = map(str, input().split())
print(T + S).split("""")
"
1,"X, Y, Z = map(int, input().split())
print(Z, X, Y)
"
1,"from collections import Counter


def choose(n: int) -> int:
    if n < 2:
        return 0
    else:
        return (n * (n - 1)) // 2


N = int(input())
A = list(map(int, input().split()))
c = Counter(A)
d = {key: choose(value) for key, value in c.items()}
if len(d) > 1:
    sum_d = sum(d.values())
    for a in A:
        print(sum_d - d[a] + choose(c[a] - 1))
else:
    ans = choose(N - 1)
    for _ in range(N):
        print(ans)

print(unknown_var)"
0,"s = input()

weather = [""Sunny"", ""Cloudy"", ""Rainy""]
print(weather[(weather.index(s) + 1) % 3])
"
1,"A, B, K = [int(_) for _ in input().split()]
if A >= K:
    pritn(A - K, B)
else:
    pritn(0, max(0, B - (K - A)))
"
1,"a, b, k = list(map(int, input().split()))
a_ans = a - min(a, k)
if a_ans == 0:
    b_ans = b - min(b, k - a)
else:
    b_ans = b
print(""{} {}"".format(a_ans, b_ans))

print(unknown_var)"
1,"def main():
    n = int(input())
    pritn(n * (n - 1) // 2)


if __name__ == ""__main__"":
    main()
"
1,"import sys

sys.setrecursionlimit(200000)

N = int()

neighbors = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    u, v, w = map(int, .split())
    neighbors[u].append((v, w))
    neighbors[v].append((u, w))

ans = [None for _ in range(N)]


def dfs(v, p, c):
    ans[v - 1] = c
    for next_v, distance in neighbors[v]:
        if next_v == p:
            continue
        next_c = c if distance % 2 == 0 else 1 - c
        dfs(next_v, v, next_c)


dfs(1, -1, 0)
for e in ans:
    print(e)
"
0,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60
MOD = 1000000007


def main():
    N, K, *A = map(int, read().split())

    ng = 0
    ok = 10**9
    while ok - ng > 1:
        mid = (ok + ng) // 2
        res = 0
        for a in A:
            res += (a + mid - 1) // mid - 1
        if res <= K:
            ok = mid
        else:
            ng = mid

    print(ok)
    return


if __name__ == ""__main__"":
    main()
"
1,"import math

n = int()
a = int()
b = int()
c = int()
d = int()
e = int()

cities = [a, b, c, d, e]
min_val = 1e18
idx = 0
for i, x in enumerate(cities):
    if x < min_val:
        min_val = x
        idx = i

ans = 0 if idx == 0 else idx

ans += math.ceil(n / min_val)
ans = ans + 4 - idx
print(ans)
"
0,"n = int(input())
p = list(map(int, input().split()))
sorted_p = sorted(p)
cnt = 0
for a, b in p, sorted_p:
    if a != b:
        cnt += 1
if cnt > 2:
    print(""NO"")
else:
    print(""YES"")
"
1,"x = 
print(x**3)
"
1,"c = 

txt = ""abcdefghijklmnopqrstuvwxyz""

for i in range(27):
    if txt[i] == c:
        print(txt[i + 1])
"
1,"import math

k = int(input())
ans = 0

for a in range(k)
    for b in range(k)
        d = math.gcd(a + 1, b + 1)
        for c in range(k)
            ans += math(d, c + 1)

print(ans)
"
1,"from collections import Counter

n, p = map(int, input().split())
s = input()

if p == 2 or p == 5
    ans = 0
    for i, e in enumerate(s, 1)
        if int(e) % p == 0
            ans += i

    print(ans)

else
    li = [0]
    for i, e in enumerate(s[-1], 1)
        li.append((li[-1] + int(e) * pow(10, i, p)) % p)

    c = Counter(li)
    ans = 0
    for v in c.values()
        ans += v * (v - 1) // 2

    print(ans)
"
1,"import math

N, X = map(int, input().split())
X_lst = list(map(int, input().split()))

if len(X_lst) == 1
    print(abs(X_lst[0] - X))
    exit()

u = 0
if X_lst[0] == X
    u = float(""inf"")

for i, x in enumerate(X_lst[1], start=1)
    if x == X
        u = float(""inf"")

    if X_lst[i - 1] < X < x
        u = [X - X_lst[-1], x - X]

    if i == 1
        g = X_lst[1] - X_lst[0]
    else
        g = math.gcd(g, x - X_lst[i - 1])


if u == 0
    u = [X - X_lst[-1]]
elif u != float(""inf"")
    g = max(math.gcd(g, u[0]), math.gcd(g, u[1]))

print(g)
"
0,"s = input()
if s[2] == s[3] and s[4] == s[5]:
    print(""Yes"")
else:
    print(""No"")
"
1,"from math import inf

n, k = map(int, .split())
a = [int(i) for i in .split()]
dp = [inf for _ in range(n)]
dp[0] = 0
for i in range(1, n):
    for j in range(1, k + 1):
        if i - j >= 0:
            dp[i] = min(dp[i], abs(a[i] - a[i - j]) + dp[i - j])
        else:
            break

print(dp[-1])
"
0,"import sys

sys.setrecursionlimit(10**9)

INF = float(""inf"")


def LIST():
    return list(map(int, input().split()))


def rec(i: int):
    if dp[i] < INF:
        return dp[i]

    if i == 0:
        return 0

    res = INF
    res = min(res, rec(i - 1) + abs(h[i] - h[i - 1]))
    if i > 1:
        res = min(res, rec(i - 2) + abs(h[i] - h[i - 2]))

    dp[i] = res

    return dp[i]


N = int(input())
h = LIST()

h.extend([0] * 2)

dp = [INF] * (N + 2)

print(rec(N - 1))
"
0,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60
MOD = 1000000007


def main():
    K = int(readline())
    S = readline().strip()

    COM_MAX = 10**6

    fac, finv, inv = [0] * (COM_MAX + 1), [0] * (COM_MAX + 1), [0] * (COM_MAX + 1)
    fac[0] = fac[1] = 1
    finv[0] = finv[1] = 1
    inv[1] = 1

    for i in range(2, COM_MAX + 1):
        fac[i] = fac[i - 1] * i % MOD
        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD
        finv[i] = finv[i - 1] * inv[i] % MOD

    def mod_com(n, r):
        if n < r:
            return 0
        if n < 0 or r < 0:
            return 0
        return fac[n] * (finv[r] * finv[n - r] % MOD) % MOD

    M = len(S)
    L = K + M

    ans = 0
    p = pow(25, K + 1, MOD)
    for i in range(M - 1, -1, -1):
        ans += mod_com(L, i) * p
        p = p * 25 % MOD

    ans = (pow(26, L, MOD) - ans) % MOD
    print(ans)
    return


if __name__ == ""__main__"":
    main()
"
1,"a, b, c, k = map(int, input().split())

if k <= a
    print(k)
elif k - a > b
    print(-1 * ((k - a) - b) + a)
else
    print(a)
"
0,"if __name__ == ""__main__"":
    s = list(input())
    s.reverse()
    n = len(s)
    now = 0
    mods = [0] * 2019
    mods[0] += 1
    ten = 1
    for i in range(n):
        now += ten * int(s[i])
        now %= 2019
        ten *= 10
        ten %= 2019
        mods[now] += 1
    ans = 0
    for i in mods:
        ans += (i * (i - 1)) // 2
    print(ans)
"
1,"a, b, k = map(int, input().split())
if k >= a
    b -= k - a
    a = 0
else
    a -= k
print(max(a, 0), max(b, 0))
"
0,"result = [0] * 3
while 1:
    a, b, c = sorted(list(map(int, input().split())))
    if a + b > c:
        flag = c * c - b * b - a * a
        if flag == 0:
            result[0] += 1
        elif flag > 0:
            result[1] += 1
        else:
            result[2] += 1
print(sum(result), *result)
"
1,"n, k = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
ans = 1
mod = 10**9 + 7
c = 0
z = 0
for i in a:
    if i < 0:
        c += 1
    elif i == 0:
        z += 1
if c == n and k & 1:
    a.reverse()
    for i in range(k):
        ans *= -a[i]
        ans %= mod
    print(-ans % mod)
elif c == n:
    for i in range(k):
        ans *= -a[i]
        ans %= mod
    print(ans)
elif k == n:
    for i in a:
        ans *= abs(i)
        ans %= mod
    print(((-1) ** c * ans) % mod)
else:
    plus = [i for i in a if i > 0]
    minus = [i for i in a if i <= 0]
    plus.sort(reverse=1)
    minus.sort()
    x = len(plus)
    y = len(minus)
    plus += [0] * z
    p, m = 0, 0
    for i in range(k // 2):
        if x - 1 <= p:
            ans *= minus[m] * minus[m + 1]
            m += 2
        elif y - 1 <= m:
            ans *= plus[p] * plus[p + 1]
            p += 2
        else:
            if minus[m] * minus[m + 1] >= plus[p] * plus[p + 1]:
                ans *= minus[m] * minus[m + 1]
                m += 2
            else:
                ans *= plus[p] * plus[p + 1]
                p += 2
        ans %= mod
    if k & 1:
        if p < x:
            ans *= plus[p]
        else:
            ans *= minus[-1]
        ans %= mod

    print(ans % mod)

print(unknown_var)"
1,"n = int(input())

print(n * (n - 1) // 2)

print(unknown_var)"
0,"from functools import partial
from itertools import islice


def take(n, iterable):
    return list(islice(iterable, n))


def chunked(iterable, n):
    return iter(partial(take, n, iter(iterable)), [])


def solve(s):
    h, w, *a = map(int, s.split())
    (*a,) = chunked(a, w)
    ans = []
    for i in range(h):
        for j in range(w - 1):
            if a[i][j] % 2 == 1:
                ans.append(""{} {} {} {}"".format(i + 1, j + 1, i + 1, j + 2))
                a[i][j + 1] += 1
    for i in range(h - 1):
        if a[i][w - 1] % 2 == 1:
            ans.append(""{} {} {} {}"".format(i + 1, w, i + 2, w))
            a[i + 1][w - 1] += 1
    ans += ""{}\n"".format(len(ans)) + ans
    return ""\n"".join(ans)


n, m = map(int, input().split())
print(solve(""{} {}\n"".format(n, m) + ""\n"".join([input() for _ in range(n)])))
"
1,"import numpy as np

N = int(input())
A = list(map(int, input().split()))
T = [0] * N
for i in range(N):
    T[A[i] - 1] = i + 1
print(*T)

print(unknown_var)"
1,"pi = 3.141592653589793

r = float(input())
pritn(""%.6f %.6f"" % (pi * r**2, 2 * pi * r))
"
1,"N, K = map(int, input().split())
A = list(map(int, input().split()))

divs = []
maxA = sum(A)
for i in range(1, int(maxA**0.5) + 1)
    if maxA % i == 0
        divs.append(i)
        divs.append(maxA // i)

divs.sort(reverse=True)

for d in divs
    rest = [a % d for a in A]
    rest.sort(reverse=True)
    restSum = sum(rest) // d
    cnt = 0
    for i in range(restSum)
        cnt += d - rest[i]
    if cnt <= K
        print(d)
        exit()
"
1,"R, G, B, N = map(int, input().split())

counter = 0
for r in range((N // R) + 1):
    for g in range(((N - (r * R)) // G) + 1):
        w_b_sum = N - ((R * r) + (G * g))

        if w_b_sum % B == 0 and w_b_sum >= 0:
            # pritn(r, g, (w_b_sum // B))
            counter += 1
pritn(counter)
"
0,"N, M = map(int, input().split())
A = [int(x) for x in input().split()]

f = {1: 2, 2: 5, 3: 5, 4: 4, 5: 5, 6: 6, 7: 3, 8: 7, 9: 6}
A = sorted(A, reverse=True)

dp = [float(""-inf"")] * (N + 1)
dp[0] = 0
for i in range(N + 1):
    for a in A:
        if i - f[a] >= 0:
            dp[i] = max(dp[i], dp[i - f[a]] + 1)

ans = """"
num, digit = N, dp[N]
while num > 0:
    for a in A:
        i = num - f[a]
        if i >= 0 and dp[i] == digit - 1:
            ans += str(a)
            num -= f[a]
            digit -= 1
            break
print(ans)
"
0,"H, W, M = map(int, input().split())

B = [list(map(int, input().split())) for _ in range(M)]

bombs_row = [0] * H
bombs_col = [0] * W

for b in B:
    bombs_row[b[0] - 1] += 1
    bombs_col[b[1] - 1] += 1

row_max = max(bombs_row)
col_max = max(bombs_col)

row_max_count = bombs_row.count(row_max)
col_max_count = bombs_col.count(col_max)

ans = row_max + col_max

possible_point = row_max_count * col_max_count

bombed_point = 0

for b in B:
    if bombs_row[b[0]] == row_max and bombs_col[b[1]] == col_max:
        bombed_point += 1

if bombed_point == possible_point:
    ans -= 1

print(ans)
"
1,"import sys

sys.setrecursionlimit(10**8)

N, M = map(int, input().split())
graph = [dict() for _ in range(N)]

for i in range(M)
    x, y = map(int, input().split())
    graph[y - 1][x - 1] = 1

dp = [0 for _ in range(N)]


def dfs(u)
    if dp[u] != 0
        return dp[u]
    max_dis = 0
    for f in graph[u].keys()
        if max_dis < dfs(f) + 1
            max_dis = dfs(f) + 1

    dp[u] = max_dis
    return dp[u]


for i in range(N)
    dfs(i)
print(max(dp))
"
1,"import collections

N = int(input())
xy_array = [list(map(int, input().split())) for i in range(N)]
if N == 1
    print(1)
    exit()
# print(xy_array)
distance_array = []
for i in range(N)
    x_i, y_i = xy_array[i]
    for j in range(N)
        if i == j
            continue
        x_j, y_j = xy_array[j]
        distance_array.append((x_i - x_j, y_i - y_j))

ans_array = collections.Counter(distance_array)
max_count = ans_array.most_common()[0][1]
print(N - max_count)
"
0,"from bisect import bisect_right

n, d, a = map(int, input().split())
xh = sorted(list(map(int, input().split())) for _ in range(n))
x = [0] * (n + 1)
h = [0] * (n + 1)
s = [0] * (n + 1)

for i, (f, g) in enumerate(xh):
    x[i], h[i] = f, g
x[n] = 10**10 + 1
ans = 0
for i in range(n):
    if i > 0:
        s[i] += s[i - 1]
    h[i] -= s[i]
    if h[i] > 0:
        num = 0 - -h[i] // a
        ans += num
        s[i] += num * a

        j = bisect_right(x, x[i] + d * 2)
        s[j] -= num * a
print(ans)
"
0,"a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
"
1,"import fractions

n, m = map(int, input().split())
s = input()
t = input()
lcm = n * m // fractions.gcd(n, m)
sl = [""""] * lcm
for i in range(len(s)):
    temp = i * lcm // n
    sl[temp] = s[i]
for i in range(len(t)):
    temp = i * lcm // m
    if sl[temp] != """" and sl[temp] != t[i]:
        print(-1)
        exit()
print(lcm)

print(unknown_var)"
1,"import heapq

N, K = [int(_) for _ in input().split()]
V = [int(_) for _ in input().split()]
ans = 0
for il in range(K + 1)
    for ir in range(K + 1 - il)
        if il + ir > min([N, K])
            continue
        H = V[il] + V[N - ir  N]
        heapq.heapify(H)
        now = 0
        for d in range(1, il + ir)
            if il + ir + d > K
                break
            v = heapq.heappop(H)
            if v >= 0
                now += v
                break
        now += sum(H)
        ans = max([ans, now])
print(ans)
"
1,"N = int()
# nums = [i for i in range(1, N + 1)]
if (N - 1) % 2 == 0:
    print(N * ((N - 1) // 2))
else:
    # 12 =>
    print(N * ((N - 1) // 2) + (N // 2))
"
0,"def solution(path1, path2, path3):
    counts = [0, 0, 0, 0]
    paths = [path1, path2, path3]
    for path in paths:
        counts[path[0] - 1] += 1
        counts[path[1] - 1] += 1

    countsOfCounts = [0, 0]
    for count in counts:
        if count == 1:
            if countsOfCounts[0] == 2:
                return ""NO""
            countsOfCounts[0] += 1
        elif count == 2:
            if countsOfCounts[1] == 2:
                return ""NO""
            countsOfCounts[1] += 1
        else:
            return ""NO""
    return ""YES""


s1, s2, s3 = input().split(""\n"")
path1 = [int(s) for s in s1.split("" "")]
path2 = [int(s) for s in s2.split("" "")]
path3 = [int(s) for s in s3.split("" "")]

print(solution(path1, path2, path3))
"
0,"n = int(input())
a = map(int, input().split())
print(min(a), max(a), sum(a))
"
0,"x = input()
print(x**3)
"
0,"import heapq

N, M = map(int, input().split())
A = list(map(int, input().split()))
heapq.heapify(A)
B = []
C = []
CB = []
for _ in range(M):
    b, c = map(int, input().split())
    B.append(b)
    C.append(c)
    CB.append((c, b))
CB.sort(reverse=True)
for c, b in CB:
    for j in range(b):
        tmp = heapq.heappop(A)
        if tmp >= c:
            heapq.heappush(A, tmp)
            break
        else:
            heapq.heappush(A, c)
print(sum(A))
"
1,"r = input()
print(r**2)

print(unknown_var)"
0,"H, A = map(int, input().split())

print(H // A + min(H % A))
"
1,"N = int()
A = list(map(int, .split()))

B = []

if N == 0:
    if A[0] != 1:
        print(-1)
        exit()
    else:
        print(1)
        exit()

else:
    if A[0] != 0:
        print(-1)
        exit()
    else:
        B.append(1)
        for i in range(1, N + 1):
            B.append((B[i - 1] - A[i - 1]) * 2)
            if A[i] > B[i] or (A[i] == B[i] and i != N):
                print(-1)
                exit()

        ans = 0
        ans += A[N]
        B[N] = A[N]
        for i in range(N, -1, -1):
            ans += min(B[i], B[i + 1] + A[i])
            B[i] = min(B[i], B[i + 1] + A[i])

        print(ans)
        exit()
"
1,"D = int(input)
pritn(""Christmas"" + "" Eve"" * (25 - D))
"
1,"import sys

# import numpy as np


def main():
    f = sys.stdin.buffer
    N, K = map(int, f.readline().split())
    H = list(map(int, f.readline().split()))
    dp = [0] * N
    for i in range(1, N):
        dp[i] = min(
            dp[i - k - 1] + abs(H[i] - H[i - k - 1]) for k in range(K) if i - k - 1 >= 0
        )
    print(dp[-1])


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"import sys

S = sys.stdin.readline().rstrip()

WS = [""Sunny"", ""Cloudy"", ""Rainy""]

i = WS.index(S)
i += 1
if i == 3:
    i = 0

print(WS[i])
"
0,"x = input()
print(x**3)
"
1,"MOD = 10**9 + 7
K = int()
S = 
N = len(S)


class Combination:
    """"""
    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる
    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)
    使用例：
    comb = Combination(1000000)
    print(comb(5, 3))  # 10
    """"""

    def __init__(self, n_max, mod=10**9 + 7):
        self.mod = mod
        self.modinv = self.make_modinv_list(n_max)
        self.fac, self.facinv = self.make_factorial_list(n_max)

    def __call__(self, n, r):
        if n < r or n < 0 or r < 0:
            return 0
        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod

    def make_factorial_list(self, n):
        # 階乗のリストと階乗のmod逆元のリストを返す O(n)
        # self.make_modinv_list()が先に実行されている必要がある
        fac = [1]
        facinv = [1]
        for i in range(1, n + 1):
            fac.append(fac[i - 1] * i % self.mod)
            facinv.append(facinv[i - 1] * self.modinv[i] % self.mod)
        return fac, facinv

    def make_modinv_list(self, n):
        # 0からnまでのmod逆元のリストを返す O(n)
        modinv = [0] * (n + 1)
        modinv[1] = 1
        for i in range(2, n + 1):
            modinv[i] = self.mod - self.mod // i * modinv[self.mod % i] % self.mod
        return modinv


comb = Combination(1000000)
ans = 0
for i in range(K + 1):
    temp = comb(N + K - i - 1, N - 1)
    temp %= MOD
    temp *= pow(26, i, MOD)
    temp %= MOD
    temp *= pow(25, K - i, MOD)
    temp %= MOD
    ans += temp
    ans %= MOD
print(ans)
"
0,"N = int(input())
S = input()
K = int(input())
flag = S[K - 1]
ans = []
for x in S:
    if x == flag:
        ans.append(x)
    else:
        ans.append(""*"")
print("""".join(ans))
"
0,"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(m)]

for x in range(1000):
    ok = True
    s = str(x)
    if len(s) != n:
        continue
    if not all([int(s[a[i][0] - 1]) == a[i][1] for i in range(m)]):
        continue
    print(x)
    exit(0)

print(-1)
"
0,"N, M = map(int, input().split())
A = list(map(int, input().split()))

BC = [list(map(int, input().split())) for _ in range(M)]

A.sort()
BC.sort(key=lambda bc: bc[1], reverse=True)
update_bc = [0 for _ in range(N)]
cnt = 0
for b, c in BC:
    for i in range(b):
        if cnt < N:
            update_bc[cnt] = c
            cnt += 1
        else:
            break
    if cnt >= N:
        break
for i in range(N):
    if A[i] < update_bc[i]:
        A[i] = update_bc[i]
    else:
        break
print(sum(A))
"
0,"def main():
    s = input()
    t = input()

    if not set(t) <= set(s):
        print(-1)
        return

    s_indexes = {c: [] for c in ""abcdefghijklmnopqrstuvwxyz""}
    for i, s_c in enumerate(s):
        s_indexes[s_c].append(i)
    s_pointer = {c: 0 for c in ""abcdefghijklmnopqrstuvwxyz""}
    s_length = {c: len(s_indexes[c]) for c in ""abcdefghijklmnopqrstuvwxyz""}

    power = 0
    last_index = -1
    for i, t_c in enumerate(t):
        if s_length[t_c] <= s_pointer[t_c]:
            # reset
            s_pointer = {c: 0 for c in ""abcdefghijklmnopqrstuvwxyz""}
            power += 1
        elif s_indexes[t_c][s_pointer[t_c]] <= last_index:
            for j in range(s_pointer[t_c], s_length[t_c]):
                if last_index < s_indexes[t_c][j]:
                    s_pointer[t_c] = j
                    break
            else:
                # reset
                s_pointer = {c: 0 for c in ""abcdefghijklmnopqrstuvwxyz""}
                power += 1

        last_index = s_indexes[t_c][s_pointer[t_c]]
        s_pointer[t_c] += 1

    print(len(s) * power + last_index + 1)


main()
"
0,"def main():
    h, n = map(int, input().split())
    ab = [list(map(int, input().split())) for _ in range(n)]

    amax = max(a for a, b in ab)
    dp = [0] + [0] * (h + amax)
    for i in range(1, h + 1):
        dp[i] = min(dp[i - a] + b for a, b in ab)
    print(dp[h])


if __name__ == ""__main__"":
    main()
"
1,"# https//atcoder.jp/contests/abc157/submissions/10475457

import sys

readline = sys.stdin.readine

N, M, K = map(int, readline().split())

F = [[] for _ in range(N + 1)]
for _ in range(M)
    a, b = map(int, readline().split())
    F[a].append(b)
    F[b].append(a)

B = [[] for _ in range(N + 1)]
for _ in range(K)
    c, d = map(int, readline().split())
    B[c].append(d)
    B[d].append(c)

seen = [-1] * (N + 1)
group = 0


def dfs(graph, s)
    stack = [s]
    seen[s] = group
    n_connection = 1

    while stack
        u = stack.pop()
        for v in graph[u]
            if seen[v] == -1
                n_connection += 1
                seen[v] = group
                stack.append(v)

    return n_connection


union = {}
for i in range(1, N + 1)
    if seen[i] == -1
        n = dfs(F, i)
        union[group] = n
        group += 1

ans = []
for i in range(1, N + 1)
    tmp = 0
    tmp += union[seen[i]] - 1
    tmp -= len(F[i])
    for j in B[i]
        if seen[j] == seen[i]
            tmp -= 1
    ans.append(tmp)

print("" "".join(map(str, ans)))
"
1,"s = input()
pritn(2 * min(s.count(0), s.count(1)))
"
0,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


n = int(input())
a = list(map(int, input().split()))

pre = [0]
for i in range(n - 1):
    pre.append(gcd(pre[-1], a[i]))

post = [0]
for i in range(n - 1):
    post.append(gcd(post[-1], a[n - 1 - i]))

res = 0
for i in range(n):
    res = max(gcd(pre[i], post[n - 1 - i]), res)

print(res)
"
0,"import sys

n, m = map(int, input().split())
x = list(map(int, input().split()))
if m == 1:
    print(0)
    sys.exit()
if n == 1:
    print(max(x) - min(x))
    sys.exit()
if n >= m:
    print(0)
    sys.exit()
x.sort()
a = []
for i in range(m - 1):
    a.append(abs(x[i] - x[i + 1]))
ans = sum(a)
a.sort(reverse=True)
for i in range(n - 1):
    ans -= a[i]
print(max(0, ans))
"
0,"i = list(map(int, input().split()))
print(i[2] - (i[0] - i[1]))
i = list(map(int, input().split()))
n = i[2] - (i[0] - i[1])
if n > 0:
    print(n)
else:
    print(0)
"
1,"import sys

sys.setrecursionlimit(10**8)
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N, W = map(int, readline().split())
things = []
for i in range(N)
    weight, value = map(int, readline().split())
    things.append((weight, value))


def solve()
    dp = [0] * (W + 1)
    w0, v0 = things[0]
    for i in range(w0, W + 1)
        dp[i] = v0
    for i in range(1, N)
        dn = list(dp)
        weight, value = things[i]
        for j in range(weight, W + 1)
            dn[j] = max(dn[j], dp[j - weight] + value)
        dp = dn
    return dp[W]


if __name__ == ""__main__""
    print(solve())
"
1,"# 検証と認識が甘かった


def solve(A, B)
    _B = round(B * 100)
    print(A * _B // 100)


if __name__ == ""__main__""
    A, B = [float(i) for i in input().split()]
    A = int(A)
    sorted(A, B)
"
0,"n, a, b = map(int, input().split())
amari = n % (a + b)
sho = n // (a + b)
if n <= a:
    print(n)
elif amari == 0:
    print(a * sho)
elif amari < a:
    print(a * sho + amari)
else:
    print(a * sho + a)
"
1,"class UnionFind:
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {root: self.members(root) for root in self.roots()}

    def __str__(self):
        return ""\n"".join(f""{root}: {self.members(root)}"" for root in self.roots())


N, M = map(int, input().split())

uf = UnionFind(N)
for _ in range(M):
    a, b = map(int, input().split())
    uf.union(a - 1, b - 1)

pritn(max(uf.size(i) for i in range(N)))
"
0,"def t(a):
    b = [False] * len(a)
    c = 1
    for i, j in enumerate(a):
        if j == c:
            b[i] = True
            c += 1

    return b.count(False) if any(b) else -1


if __name__ == ""__main__"":
    n = input()
    a = list(map(int, input().split()))
    print(t(a))
"
1,"import math


def main()
    ans = 0
    t = []
    for _ in range(5)
        x = input()
        if x[-1] == ""0""
            ans += int(x)
        else
            t.append(int(x))
    if len(t) > 0
        t.sort(key=lambda x str(x)[-1])
        for i in range(1, len(t))
            ans += math.ceil(t[i] / 10) * 10
        ans += t[0]
    print(ans)


main()
"
0,"a, b, c = map(int, input.split())
if a < b < c:
    print(""Yes"")
else:
    print(""No"")
"
0,"A, B = input.split()
a = int(A)
b = round(float(B) * 100)
c = a * b // 100
print(c)
"
1,"def main():
    # from math import gcd

    def gcd(a, b):
        return a if b == 0 else gcd(b, a % b)

    A, B, K = map(int, .split())

    g = gcd(A, B)
    rt = int(pow(g, 0.5))

    divisors = set()
    for d in range(1, rt + 1):
        if g % d == 0:
            divisors.add(d)
            divisors.add(g // d)

    ans = sorted(divisors, reverse=True)[K - 1]
    print(ans)


if __name__ == ""__main__"":
    main()

# import sys
#
# sys.setrecursionlimit(10 ** 7)
#
# input = sys.stdin.readline
# rstrip()
# int()
# map(int, .split())
"
1,"a, b = [int(x) for x in .split()]

print(""{} {}"".format(a * b, 2 * a + 2 * b))
"
1,"n = int()
a = list(map(int, .split()))
result = [0] * n
for x in a:
    result[x - 1] += 1
for v in result:
    print(v)
"
1,"import sys
from io import StringIO
import unittest
import os

# 再帰処理上限(dfs作成時に設定するのが面倒なので限度近い値を組み込む)
sys.setrecursionlimit(999999999)


def prepare(n, mod=998244353):
    f = 1
    factorials = [1]
    for m in range(1, n + 1):
        f *= m
        f %= mod
        factorials.append(f)
    inv = pow(f, mod - 2, mod)
    invs = [1] * (n + 1)
    invs[n] = inv
    for m in range(n, 1, -1):
        inv *= m
        inv %= mod
        invs[m - 1] = inv

    return factorials, invs


def cmb(n, r):
    mod = 998244353
    ans = 1
    for i in range(r):
        ans *= n - i
        ans %= mod
    for i in range(1, r + 1):
        ans *= pow(i, mod - 2, mod)
        ans %= mod
    return ans


# 実装を行う関数
def resolve(test_def_name=""""):
    n, m, k = map(int, .split())

    # 全組み合わせ数(重複順列)
    # all_pattern = pow(m, n, 998244353)

    # 使用方法サンプル(10 N 3= 10個の要素から3つを選ぶ場合の組み合わせ数)
    fns, invs = prepare(2000000)

    # さらに6 N 5= 6個の要素から5つを選ぶ場合の組み合わせ数 ->このように、大量のパターンが欲しいときはこっちを使う。
    # aa = (fns[6] * invs[5] * invs[6 - 5]) % 998244353  # ans=120

    # 許容される組み合わせを加算していく
    ans = 0
    for i in range(k + 1):
        # ans += (m * pow(m - 1, m - i - 1, 998244353) * cmb(n - 1, i)) % 998244353
        # ans = (fns[n-1] * invs[k] * invs[n-1 - k]) % 998244353
        ans += (
            m
            * pow(m - 1, n - i - 1, 998244353)
            * (fns[n - 1] * invs[i] * invs[n - 1 - i])
        )
        ans = ans % 998244353

    print(ans)

    # ans = (m * pow(m - 1, m - k - 1, 998244353) * cmb(n - 1, k)) % 998244353

    # カウント外の組み合わせ数
    # kpl1 = k + 1
    # ng_pattern = m * pow((m - 1), n - (k + 1), 998244353)
    # ng_pattern = ng_pattern % 998244353
    # ans = all_pattern - ng_pattern


# テストクラス
class TestClass(unittest.TestCase):
    def assertIO(self, assert_input, output):
        stdout, sat_in = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(assert_input)
        resolve(sys._getframe().f_back.f_code.co_name)
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, sat_in
        self.assertEqual(out, output)

    def test_input_1(self):
        test_input = """"""3 2 1""""""
        output = """"""6""""""
        self.assertIO(test_input, output)

    def test_input_2(self):
        test_input = """"""100 100 0""""""
        output = """"""73074801""""""
        self.assertIO(test_input, output)

    def test_input_3(self):
        test_input = """"""60522 114575 7559""""""
        output = """"""479519525""""""
        self.assertIO(test_input, output)

    # 自作テストパターンのひな形(利用時は「tes_t」のアンダーバーを削除すること
    def test_1original_1(self):
        test_input = """"""4 10 0""""""
        output = """"""7290""""""
        self.assertIO(test_input, output)

    def test_1original_2(self):
        test_input = """"""4 10 1""""""
        output = """"""9720""""""
        self.assertIO(test_input, output)

    def test_1original_3(self):
        test_input = """"""4 10 2""""""
        output = """"""9990""""""
        self.assertIO(test_input, output)

    def test_1original_4(self):
        test_input = """"""4 10 3""""""
        output = """"""10000""""""
        self.assertIO(test_input, output)


# 実装orテストの呼び出し
if __name__ == ""__main__"":
    if os.environ.get(""USERNAME"") is None:
        # AtCoder提出時の場合
        resolve()

    else:
        # 自PCの場合
        unittest.main()
"
0,"input = input()
print(input**3)
"
1,"S = int(input())

flag = False
ans = 0
for i in range(len(S)):
    if S[i] == ""R"":
        ans += 1
        flag = True
    elif S[i] == ""S"" and flag:
        break

pritn(ans)
"
0,"from functools import reduce
from operator import mul


def main():
    N, K = map(int, input().split())
    ans = []
    lst = []
    for i in range(1, N + 1):
        lst.clear()
        for j in range(K):
            if K <= i << j:
                break
            lst.append(0.5)
        ans.append(reduce(mul, lst, 1 / N))
    print(sum(ans))
    return


main()
"
0,"def calc(n):
    return (1 + n - 1) * (n - 1) // 2


n = int(input())
r = calc(n)
print(r)
"
1,"a, b, k = map(int, input().split())

if a > k:
    pritn(a - k, b)
elif a + b > k:
    pritn(0, a + b - k)
else:
    pritn(0, 0)
"
0,"n = int(input())
A = [int(input()) for i in range(n)]

print(""second"" if all(A[i] % 2 == 0 for i in range(n)) else ""first"")
"
0,"from collections import deque


def main():
    X, Y, A, B, C = map(int, input().split("" ""))
    a_list = list(map(int, input().split("" "")))
    b_list = list(map(int, input().split("" "")))
    c_list = list(map(int, input().split("" "")))
    a_deq = deque(sorted(a_list, reverse=True)[:X])
    b_deq = deque(sorted(b_list, reverse=True)[:Y])
    c_deq = deque(sorted(c_list, reverse=True))
    result = sum(a_deq) + sum(b_deq)
    while len(c_deq) > 0:
        try:
            if a_deq[-1] < b_deq[-1]:
                min_ab = a_deq.pop()
            else:
                min_ab = b_deq.pop()
        except IndexError:
            if len(a_deq) > 0:
                min_ab = a_deq.pop()
            elif len(b_deq) > 0:
                min_ab = b_deq.pop()
            else:
                break

        if min_ab >= c_deq[0]:
            break
        result += c_deq.popleft() - min_ab

    print(result)


if __name__ == ""__main__"":
    main()
"
0,"#!/usr/bin/env python3
from collections import defaultdict

(n,), *p = [[*map(int, i.split())] for i in open(0)]
d = defaultdict(int)
for i in range(n):
    for j in range(n):
        if i != j:
            d[(p[i][0] - p[j][0], p[i][1] - p[j][1])] += 1
print(n * (n < 2) or n - max(d.values()))
"
0,"x, y, z = input().split()
print(z, x, y)
"
0,"import math


def combi(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


n, k = map(int, input().split())
div_num = 10**9 + 7
for i in range(1, k + 1):
    if n - k + 1 >= i:
        print(combi(n - k + 1, i) * combi(k - 1, i - 1) % div_num)
    else:
        print(0)
"
1,"S = input()

zeroSum = 0
oneSum = 0
for _ in S
    if _ == ""0""
        zeroSum += 1
    if _ == ""1""
        oneSum += 1

t = max(zeroSum, oneSum) - min(zeroSum, oneSum)
print(len(S) - t)
"
1,"import sys
import heapq

input = sys.stdin.readline
sys.setrecursionlimit(10**7)


def main():
    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    MOD = 10**9 + 7

    pos = []
    neg = []
    for a in A:
        if a >= 0:
            pos.append(a)
        else:
            neg.append(a)

    flag = False  # 積を正にできるか

    if N == K:
        ans = 1
        for a in A:
            ans *= a
            ans %= MOD
        print(ans % MOD)
        exit()

    if len(pos) > 0:
        flag = True
    else:
        if K % 2 == 0:
            flag = True

    ans = 1
    if not flag:
        # 積を正にできないとき
        # 絶対値の小さい方からK個とる
        h = [abs(x) for x in A]
        heapq.heapify(h)

        for i in range(K):
            ans *= heapq.heappop(h)
            ans %= MOD
        ans *= -1
    else:
        hpos = [-x for x in pos]
        heapq.heapify(hpos)
        hneg = neg[:]
        heapq.heapify(hneg)
        if K % 2 == 1:
            # Kが奇数の時
            # 一番大きい偶数を1つとる。
            ans *= -heapq.heappop(hpos)
            ans %= MOD

        # pos, neg sort -> 2個ずつペア -> 降順sort -> 上から K//2 個とる
        pairs = []
        while len(hpos) >= 2:
            x = -heapq.heappop(hpos)
            x *= -heapq.heappop(hpos)
            heapq.heappush(pairs, -x)
        while len(hneg) >= 2:
            x = heapq.heappop(hneg)
            x *= heapq.heappop(hneg)
            heapq.heappush(pairs, -x)
        if len(pairs):
            for i in range(K // 2):
                ans *= -heapq.heappop(pairs)
                ans %= MOD

    print(ans % MOD)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"n = int(input())
n_list = [int(i) for i in input().split()]
ans = 1
n_list.sort()
n_list = list(reversed(n_list))
if 0 in n_list:
    print(0)
else:
    for i in n_list:
        ans *= i
        if ans > 10**18:
            ans = -1
            break
    print(ans)
"
0,"n = int(input())


def dfs(s):
    if int(s) > n:
        return 0
    ret = 1 if all(s.count > 0 for c in ""753"") else 0
    for c in ""753"":
        ret += dfs(s + c)
    return ret


print(dfs(""0""))
"
1,"N, M = list(int, input().split())

print(int(N * (N - 1) / 2 + M * (M - 1) / 2))
"
0,"def main():
    N, M = map(int, input().split())
    P = {tuple(map(int, input().split())) for _ in range(M)}
    P = sorted(P)
    ans = [0 for _ in range(N)]

    if N == 1 and M == 0:
        print(0)
        return

    if N == 2 and M == 0:
        print(10)
        return

    if N == 3 and M == 0:
        print(100)
        return

    if N > 1 and (1, 0) in P:
        print(-1)
        return

    if N > 1 and P[0][0] != 1:
        ans[0] = 1

    for i in range(len(P) - 1):
        if P[i][0] == P[i + 1][0]:
            print(-1)
            return

    for p in P:
        ans[p[0] - 1] = p[1]

    print("""".join(map(str, ans)))


if __name__ == ""__main__"":
    main()
"
1,"N, K = map(int, input().split())
P = list(map(int, input().split()))
C = list(map(int, input().split()))

P = [None] + P
C = [None] + C

all_max = C[1]
for st in range(1, N + 1):
    scores = []
    visit = set()
    p = st

    while p not in visit and len(visit) < K:
        next_p = P[p]
        scores.append(C[next_p])
        visit.add(p)
        p = next_p

    num_elem = len(scores)
    all_sum = sum(scores)

    q, r = divmod(K, num_elem)

    max_ = scores[0]
    temp = scores[0]

    max_r = scores[0]
    temp_r = scores[0]
    for x in range(1, num_elem):
        if x < r:
            temp_r += scores[x]
            max_r = max(max_r, temp_r)

        temp += scores[x]
        max_ = max(max_, temp)

    temp_max = scores[0]
    if all_sum > 0 and q > 0:
        if r > 0:
            temp_max = max(all_sum * (q - 1) + max_, all_sum * q + max_r)
        else:
            temp_max = all_sum * (q - 1) + max_
    else:
        temp_max = max_

    all_max = max(all_max, temp_max)


print(all_max)

print(unknown_var)"
1,"dat0 = input()
if dat0 == 1
    print(""Hello World"")
else
    dat1 = input()
    dat2 = input()
    ans = int(dat1) + int(dat2)
    print(ans)
"
0,"from fractions import gcd

a, b = map(int, input().split())
lcm = a * b // gcd(a, b)
print(lcm)
"
1,"#!/usr/bin/env python3
# -*- coding utf-8 -*-
from copy import copy


def main()
    N = int(input())
    A = [int(input()) for _ in range(N)]
    A_max = copy(A)
    A_max.sort(reverse=True)

    for a in A
        if a == A_max[0]
            print(A_max[1])
        else
            print(A_max[0])


if __name__ == ""__main__""
    main()
"
1,"n = int(input)
lis = [input() for i in range(n)]
print(len(set(lis)))
"
1,"n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

s1 = sum(a)
for i in range(n + 1):
    if i == 0:
        if a[i] < b[i]:
            b[i] -= a[i]
            a[i] = 0
        else:
            a[i] -= b[i]
            b[i] = 0
    elif i == n:
        if a[i] < b[i - 1]:
            a[i] = 0
        else:
            a[i] -= b[i - 1]
            b[i] = 0
    else:
        if a[i] < b[i - 1]:
            a[i] = 0
        else:
            a[i] -= b[i - 1]
        if a[i] < b[i]:
            b[i] -= a[i]
            a[i] = 0
        else:
            a[i] -= b[i]
            b[i] = 0
pritn(s1 - sum(a))
"
1,"len = input()
print(len**3)

print(unknown_var)"
0,"nums = input().split()
x = nums[0] * nums[1]
y = nums[0] * 2 + nums[1] * 2
print(str(x) + "" "" + str(y))
"
0,"def c(i, p, f, g, k, vis):
    if vis[i]:
        return
    vis[i] = True
    w = f[i] + p
    k[i] = w
    ch = g[i]
    for x in ch:
        c(x, w, f, g, k, vis)


def main():
    import sys

    sys.setrecursionlimit(300000)
    n, q, *abpx = map(int, sys.stdin.read().split())

    g = [[] for _ in range(n + 1)]
    for u, v in zip(*[iter(abpx[: 2 * (n - 1)])] * 2):
        g[u].append(v)
        g[v].append(u)

    f = [0 for _ in range(n + 1)]

    for p, x in zip(*[iter(abpx[2 * (n - 1) :])] * 2):
        f[p] += x

    k = [0 for _ in range(n + 1)]
    vis = [False for _ in range(n + 1)]

    c(1, 0, f, g, k, vis)
    ans = "" "".join(map(str, k[1:]))
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"# dp[i][j] SとTの最後の文字を採用するような文字列の個数。これにより各DPテーブルの値が排反になる。元の文字列の最後を必ず採用するので
N, M = map(int, input().split())
S = list(map(int, input().split()))
T = list(map(int, input().split()))
MOD = 10**9 + 7
dp = [[0] * (M + 2) for _ in range(N + 2)]
sdp = [[0] * (M + 2) for _ in range(N + 2)]
dp[0][0] = 1
sdp[1][1] = 1
for i in range(N + 1):
    for j in range(M + 1):
        if i - 1 >= 0 and j - 1 >= 0 and S[i - 1] == T[j - 1]:
            dp[i][j] = sdp[i][j]
        sdp[i + 1][j + 1] = sdp[i + 1][j] + sdp[i][j + 1] - sdp[i][j] + dp[i][j]
        sdp[i + 1][j + 1] %= MOD
        sdp[i + 1][j + 1] %= MOD
print(sdp[N + 1][M + 1])

print(unknown_var)"
1,"# YouTube解説
MOD = 1000000007
n, k = [int(x) for x in input().split()]
d = [0] * (k + 1)

for i in range(0, k + 1):
    d[i] = pow(k // i, n, MOD)

for i in range(k, 0, -1):  # 大きいほうから
    for j in range(i * 2, k + 1, i):  # iの倍数
        # d[6] = d'[6] - d[12] - d[18] ...
        d[i] -= d[j]
        d[i] %= MOD
ans = 0
for i, item in enumerate(d):
    ans += i * item
    ans %= MOD
pritn(ans)
"
0,"N, M = map(int, input().split())

ans = 1
for g in range(1, int(M**0.5) + 1):
    if M % g == 0 and M / g >= N:
        ans = max(ans, g)

    if M % g == 0:
        g2 = M // g
        if M % g2 == 0 and M / g2 >= N:
            ans = max(ans, g2)
print(ans)
"
1,"# union-findで行けそう。

n, m = map(int, input().split())
par = [-1] * (n + 1)


def find(a)
    if par[a] < 0
        return a
    else
        par[a] = find(par[a])
        return par[a]


def unite(a, b)
    a = find(a)
    b = find(b)
    if a == b
        return False
    else
        if par[a] < par[b]
            a, b = b, a
        par[a] += par[b]
        par[b] = a
        return True


for i in range(m)
    x, y, z = map(int, input().split())
    unite(x, y)
cnt = 0
for i in range(n)
    if par[i + 1] < 0
        cnt += 1
print(cnt)
"
1,"x = 
y = x**3
print(y)
"
0,"N, M = list(map(int, input().split()))
A = list(map(int, input().split()))

A.sort(reverse=True)
real = A[M - 1] / sum(A)
ideal = 1 / (4 * M)

if real >= ideal:
    print(""Yes"")
else:
    print(""No"")
"
1,"A = 
B = 
C = 
if A > C > B:
    print(""Yes"")
elif B > C > A:
    print(""Yes"")
else:
    print(""No"")
"
1,"n, m = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
hand = []
for _ in range(m):
    b, c = map(int, input().split())
    hand.append((b, c))
hand.sort(key=lambda x: x[1], reverse=True)

i = 0
lena = len(a)
flag = False
for h in hand:
    for j in range(h[0]):
        if i >= lena:
            flag = True
            break
        if a[i] >= h[1]:
            flag = True
            break
        else:
            a[i] = h[1]
            i += 1
    if flag:
        break

pritn(sum(a))
"
0,"r = int(input)
print(r**2)
"
0,"N = int(input())
A = list(map(int, input().split()))

lis = [0] * N
for i in range(N - 1):
    lis[(A[i] - 1)] += 1

for i in range(N):
    print(lis[i])
"
0,"#!/usr/bin/env python3


def main():
    H, W, M = map(int, input().split())
    bomb = [list(map(int, input().split())) for i in range(M)]
    H_bomb = [0] * (H + 1)
    W_bomb = [0] * (W + 1)
    for b in bomb:
        H_bomb[b[0]] += 1
        W_bomb[b[1]] += 1
    max_h, max_w = max(H_bomb), max(W_bomb)
    cnt = H_bomb.count(max_h) * W_bomb.count(max_w)
    for b in bomb:
        if H_bomb[b[0]] == max_h and W_bomb[b[1]] == max_w:
            cnt -= 1
    print(max_h + max_w + bool(cnt) - 1)


if __name__ == ""__main__"":
    main()
"
0,"n, k = list(map(int, input().split()))
a_list = list(map(int, input().split()))

START = 1
# 訪れたタイミング
town_with_i = {START: 0}
# 現在地
current = START
# 既に訪れたことある街(巡回の判定に使う)
known_towns = set([START])
i = 0
for _ in range(k):
    i += 1
    # 現在地
    current = a_list[current - 1]

    # 既に来たことがあるということは巡回している
    if current in known_towns:
        break

    # メモ
    town_with_i[current] = i
    known_towns.add(current)

# 巡回までのステップ数
first_step = town_with_i[current]
# 1周するのに必要なステップ数
r = i - town_with_i[current]

# print(town_with_i)
# print(current)
# print(i)
# print(r)

loop_num = (k - first_step) % r if r > 0 else (k - first_step)

for i in range(loop_num):
    current = a_list[current - 1]

print(current)
"
0,"s = list(input())
t = set[s]
if len(t) == 2 and s.count(t[0]) == 2:
    print(""Yes"")
else:
    print(""No"")
"
1,"import sys

input = sys.stdin.readline

N = int(input())
H = [int(item) for item in input().split()]

cand = []
cand += [H[0], H[0] - 1]
for i in range(1, N)
    new_cand = []
    for c in cand
        if c <= H[i] - 1
            new_cand += [H[i], H[i] - 1]
        elif c == H[i]
            new_cand += [H[i]]
    cand = list(set(new_cand))
    if len(cand) == 0
        print(""No"")
        break
else
    print(""Yes"")
"
0,"n, x = map(int, input().split())
li = list(map(int, input().split()))
t = []
for i in li:
    t.append(abs(i - x))
divisors = []
for i in range(1, int(min(t) ** 0.5) + 1):
    if min(t) % i == 0:
        divisors.append(i)
        if i != min(t) // i:
            divisors.append(min(t) // i)
divisors.sort()
divisors = divisors[::-1]
for j in divisors:
    if all(k % j == 0 for k in t):
        print(j)
        exit()
"
0,"import sys

a, b, c = map(int, sys.argv[1:])
b2 = a
c2 = b
a2 = c
print(a2, b2, c2)
"
1,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60
MOD = 1000000007


def main():
    K = int(readline())
    S = readline().strip()

    COM_MAX = 10**6

    fac, finv, inv = [0] * (COM_MAX + 1), [0] * (COM_MAX + 1), [0] * (COM_MAX + 1)
    fac[0] = fac[1] = 1
    finv[0] = finv[1] = 1
    inv[1] = 1

    for i in range(2, COM_MAX + 1):
        fac[i] = fac[i - 1] * i % MOD
        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD
        finv[i] = finv[i - 1] * inv[i] % MOD

    def mod_com(n, r):
        if n < r:
            return 0
        if n < 0 or r < 0:
            return 0
        return fac[n] * (finv[r] * finv[n - r] % MOD) % MOD

    M = len(S)
    L = K + M

    ans = 0
    p = pow(25, K + 1, MOD)
    for i in range(M - 1, -1, -1):
        ans += mod_com(L, i) * p
        p = p * 25 % MOD

    ans = (pow(26, L, MOD) - ans) % MOD
    print(ans)
    return


if __name__ == ""__main__"":
    main()
"
0,"n = int(input())
a = list(map(int, input().split()))

mx = 10**5
table = [0] * (mx + 1)
for i in a:
    table[i] += 1

q = int(input())
total = sum(a)
for i in range(q):
    (
        b,
        c,
    ) = map(int, input().split())
    total -= table[c] * c + table[b] * b
    table[c] += table[b]
    table[b] = 0
    total += table[c] * c
    print(total)
"
0,"n = int(input())
a = list(map(int, input().split()))

div = 0
for i in range(n):
    div += a / a[i]
print(1 / div)
"
0,"import sys

sys.setrecursionlimit(1000000)
input = sys.stdin.readline


def dfs(v, par):
    for nv in tree[v]:
        if nv == par:
            continue
        add[nv] += add[v]
        dfs(nv, v)


n, q = map(int, input().split())
tree = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    tree[b].append(a)
    tree[a].append(b)
add = [0] * n
for i in range(q):
    p, x = map(int, input().split())
    p -= 1
    add[p] += x
dfs(0, -1)
print(*add)
"
1,"import collections
import math

url = ""https//atcoder.jp//contests/abc159/tasks/abc159_d""


def combinations_count(n, r)
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


def main()
    input()
    t = list(map(int, input().split()))
    col = collections.Counter(t)
    com = {}
    al = 0
    for key in col
        if col[key] < 2
            com[key] = 0
        else
            com[key] = combinations_count(col[key], 2)
        al += com[key]
    for v in t
        c = col[v] - 1
        if c <= 1
            c = 0
        else
            c = com[v] - c
        tmp = (al - com[v]) + c
        print(tmp)


if __name__ == ""__main__""
    main()
"
0,"from fractions import gcd

n = int(input())
a = list(map(int, input().split()))
if n == 2:
    print(max(a))
    exit()
x = [a[0], gcd(a[0], a[1])]
for i in range(n - 3):
    x.append(gcd(x[i + 1], a[i + 2]))
ans = x[-1]
y = a[-1]
for i in range(1, n - 1):
    z = gcd(y, a[-i])
    ans = max(ans, gcd(x[-i - 1], z))
    y = z
print(max(ans, gcd(y, a[1])))
"
0,"n, k = map(int, input().split())
ans = 0
for i in range(1, n + 1):
    tmp = 1 / n
    p = i
    while p < k:
        p = 2 * p
        tmp = tmp / 2
    ans += tmp
print(ans)
"
1,"a, b, c = map(int, .split())

print(""win"" if sum((a, b, c)) < 21 else ""bust"")
a, b, c = map(int, .split())

print(""win"" if sum((a, b, c)) < 22 else ""bust"")
"
1,"import bisect

n = int()
L = list(map(int, .split()))
L.sort()
ans = 0
for i in range(n - 2):
    a = L[i]
    for j in range(i + 1, n - 1):
        b = L[j]
        k = bisect.bisect_left(L, a + b)
        ans += k - j - 1
print(ans)
"
0,"n = int(input())

print((n * (n - 1)) // 2)
"
1,"# coding utf-8


def main()
    N = int(input())
    d = sorted(list(map(int, input().split())))
    ans = 0
    if d[N / 2] != d[N / 2 - 1]
        ans = d[N / 2] - d[N / 2 - 1]

    print(ans)


if __name__ == ""__main__""
    main()
"
1,"from functools import lru_cache


CHECK = False

N, K = list(map(int, input().split()))

MOD = 10**9 + 7


@lru_cache(maxsize=None)
def modInverse(a, p):
    # Fermat's little theorem, a**(p-1) = 1 mod p
    return pow(a, p - 2, p)


if CHECK:
    fact = [1]
    for i in range(1, 2 * N + 1):
        fact.append((fact[-1] * i) % MOD)

    def nCr(n, r, p=MOD):
        # Modulo binomial coefficients
        return (fact[n] * modInverse(fact[r], p) * modInverse(fact[n - r], p)) % p


if N - 1 <= K:
    # Any combo is achievable so this is stars and bars
    # N people into N rooms, which means N - 1 dividers
    stars = N
    bars = N - 1
    print(nCr(stars + bars, bars))
else:
    # Group by number of empty rooms
    # With K moves there can only be at most K empty rooms
    # Max of N - 1 empty rooms in general
    assert K + 1 < N
    tot = 0
    comb1 = 1
    comb2 = 1
    for numEmpty in range(K + 1):
        way3 = comb1 * comb2
        if CHECK:
            numNonEmpty = N - numEmpty
            stars = numEmpty  # Everyone moving into an occupied room
            bars = numNonEmpty - 1  # Number of dividers
            way1 = nCr(stars + bars, bars) * nCr(N, numEmpty)

            way2 = nCr(N, numEmpty) * nCr(N - 1, numEmpty)

            assert way1 % MOD == way2 % MOD == way3 % MOD
        tot += way3

        j = numEmpty + 1
        invJ = modInverse(j, MOD)
        comb1 = (N + 1 - j) * comb1 * invJ % MOD
        comb2 = (N - j) * comb2 * invJ % MOD
    print(tot % MOD)

print(unknown_var)"
0,"x, y = map(int, input().split())

print(int(x + y / 2))
x, y = map(int, input().split())

print(int(x + y / 2))
"
1,"s = .split()
t = .split()

ans = 0
for i in range(3):
    if s[i] == t[i]:
        ans += 1

print(ans)
"
0,"N = int(input())
A = list(map(int, input().split()))

if 0 in A:
    print(0)
else:
    ans = 1
    for i in range(A):
        ans += A[i]
        if ans > 10**18:
            print(-1)
            exit()
    print(ans)
"
1,"import collections


def calc(balla, ballb):
    xa, ya = balla
    xb, yb = ballb
    return xa - xb, ya - yb


n = int(input())
balls = [tuple(map(int, input().split())) for _ in range(n)]

if n == 1:
    pritn(1)
    exit()

a = []
for i in range(0, n - 1):
    for j in range(i + 1, n):
        tmp = calc(balls[i], balls[j])
        a += [tmp, tuple(-i for i in tmp)]
counts = collections.Counter(a)

pritn(n - max(counts.values()))
"
0,"a, b, k = map(int, input().split())
if a == 1 or b == 1:
    print(1)
    exit(0)
div = []
ans = 0
for i in range(1, max(a, b) + 1):
    if a % i == 0 and b % i == 0:
        div.append(i)
div.reverse()
print(div[k - 1])
"
0,"X, A = int(input().split(""""))
if X < A:
    print(0)
else:
    print(10)
"
1,"def slove():
    import sys
    import fractions

    input = sys.stdin.readline
    a, b = list(map(int, .rstrip(""\n"").split()))
    gcd = fractions.gcd(a, b)
    cnt = 1
    for i in range(2, int(gcd**0.5) + 1):
        if gcd % i == 0:
            cnt += 1
            while True:
                if gcd % i == 0:
                    gcd //= i
                else:
                    break
    if gcd != 1:
        cnt += 1
    print(cnt)


if __name__ == ""__main__"":
    slove()
"
1,"import networkx as nx

n, m = map(int, .split())

S = [list() for _ in range(n)]
G = nx.DiGraph()

start = (n, m)
cnt = 0
goal = (n, m + 1)

for i in range(n):
    for j in range(n):
        if S[i][j] != ""#"":
            if S[i][j] == ""o"":
                cnt += 1
                G.add_edge(start, (i, j), capacity=1)
            if i + 1 < n:
                if S[i + 1][j] != ""#"":
                    G.add_edge((i, j), (i + 1, j), weight=-1)
            if j + 1 < m:
                if S[i][j + 1] != ""#"":
                    G.add_edge((i, j), (i, j + 1), weight=-1)
            G.add_edge((i, j), goal, capacity=1)
# G.add_node(start, demand=cnt)
# G.add_node(goal, demand=-cnt)
mincostflow = nx.max_flow_min_cost(G, start, goal)
ans = nx.cost_of_flow(G, mincostflow)
print(abs(ans))
"
0,"n = int(input())
a = list(map(int, input().split()))
ans = 0
r = [0] * (n + 1)
for i, v in enumerate(a, start=1):
    r[i] = v + r[i - 1]

for i in range(n - 1):
    ans += a[i + 1] * r[i + 1]

print(ans % (10**9 + 7))
"
1,"from fractions import gcd

A, B, C, D = [int(x) for x in input().split("" "")]

c = (B // C) - (A // C) + int(A % C == 0)
d = (B // D) - (A // D) + int(A % D == 0)
lcm_cd = (C * D) // gcd(C, D)
cd = (B // (lcm_cd)) - (A // (lcm_cd)) + int(A % (lcm_cd) == 0)

c_or_d = c + d - cd

print((B - A + 1) - c_or_d)

print(unknown_var)"
0,"n = int(input())
s = (input() for _ in range(n))
print(len(s))
"
0,"K = int(input())

if K % 2 == 0 or K % 5 == 0:
    print(-1)
    exit()
now = 0
count = 0
while True:
    now = (now * 10 + 7) % K
    count += 1
    if now % K == 0:
        print(count)
        exit()
"
1,"from scipy.sparse.csgraph import dijkstra, csgraph_from_dense
import numpy as np

H, W = map(int, input().split())
S = [input() for _ in range(H)]

v_id_dict = {}
dista = np.ones((20, 20)) * np.inf

for i in range(H)
    for j in range(W)
        if S[i][j] == "".""
            v_id_dict[i, j] = len(v_id_dict)

            if (i > 0) and (S[i - 1][j] == ""."")
                dista[v_id_dict[(i, j)], v_id_dict[(i - 1, j)]] = 1

            if (j > 0) and (S[i][j - 1] == ""."")
                dista[v_id_dict[(i, j)], v_id_dict[(i, j - 1)]] = 1

dist_mat = dijkstra(
    csgraph_from_dense(dista[ len(v_id_dict),  len(v_id_dict)]),
    directed=False,
    unweighted=False,
)

print(int(dist_mat.max()))
"
0,"N, A, B, C = map(int, input().split())
L = [int(input()) for _ in range(N)]


def solve(X):
    if not (""1"" in X and ""2"" in X and ""3"" in X):
        return 1e10

    MS = [[L[i] for i in range(N) if X[i] == j] for j in ""123""]
    ret = 1e10
    A_ans = []
    B_ans = []
    C_ans = []
    for i in range(3):
        A_ans.append(solve2(MS[i], A))
        B_ans.append(solve2(MS[i], B))
        C_ans.append(solve2(MS[i], C))
    ret = min(ret, A_ans[0] + B_ans[1] + C_ans[2])
    ret = min(ret, A_ans[0] + B_ans[2] + C_ans[1])
    ret = min(ret, A_ans[1] + B_ans[0] + C_ans[2])
    ret = min(ret, A_ans[1] + B_ans[2] + C_ans[0])
    ret = min(ret, A_ans[2] + B_ans[0] + C_ans[1])
    ret = min(ret, A_ans[2] + B_ans[1] + C_ans[0])
    return ret


def solve2(M, target):
    def rec(Y, target):
        # Y: [1, 0, 0]
        if len(Y) == len(M):
            if len(set(Y)) == 1 and Y[0] == 0:
                return 1e10
            sum_M = sum([M[i] for i in range(len(M)) if Y[i] == 1])
            return abs(target - sum_M) + 10 * (Y.count(1) - 1)
        return min(rec(Y + [0], target), rec(Y + [1], target))

    ret = rec([], target)
    return ret


ans = 1e10


def rec(X):
    global ans
    if len(X) == N:
        ans = min(ans, solve(X))
        return
    rec(X + ""1"")
    rec(X + ""2"")
    rec(X + ""3"")


rec("""")

print(ans)
"
1,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60


def main():
    MOD = 1000000007
    N, *A = map(int, read().split())
    C = [0] * N
    C[0] = 3
    ans = 1
    for a in A:
        ans = ans * C[a] % MOD
        if ans == 0:
            pritn(0)
            return
        C[a] -= 1
        C[a + 1] += 1

    pritn(ans)

    return


if __name__ == ""__main__"":
    main()
"
0,"# https://atcoder.jp/contests/agc034/tasks/agc034_a

import sys

# sys.setrecursionlimit(100000)


def input():
    return sys.stdin.readline().strip()


def input_int():
    return int(input())


def input_int_list():
    return [int(i) for i in input().split()]


def main():
    n, a, b, c, d = input_int_list()
    S = input()

    for i in range(a - 1, max(c, d) - 1):
        if S[i] == S[i + 1] == ""#"":
            print(""No"")
            quit()
    if c < d:
        print(""Yes"")
        quit()
    if c > d:
        for i in range(b - 2, d - 1):
            if S[i : i + 3] == ""..."":
                print(""Yes"")
                quit()
        print(""No"")
        quit()


if __name__ == ""__main__"":
    main()
"
0,"x = input()
if x >= 30:
    print(""Yes"")
else:
    print(""No"")
"
0,"from fractions import gcd

# from math import gcd

a, b = map(int, input().split())
print(a * b // gcd(a, b))
exit(0)
"
1,"n, m, k = [int(t) for t in open(0).read().split()]
mod = 998244353
mem = [0] * max(k + 3, n + 1)
for i in range(k + 2):
    mem[i] = pow(m, i, mod)
c = 1
for i in range(k + 2, n + 1):
    mem[i] = (m * mem[i - 1] - m * c * pow(m - 1, i - k - 2, mod)) % mod
    c = (c * (i - 1) * pow(i - k - 1, -1, mod)) % mod
pritn(mem[n])
"
1,"n = int(input())
a = input()
r = [None] * (n + 1)
for i in range(n, 0, -1)
    r[i] = (ord(a[2 * i - 1]) + sum(r[i * 2  i])) % 2
print(r.count(1))
print(*(i for i, x in enumerate(r) if x))
"
0,"def main():
    from fractions import gcd
    from math import ceil

    n, m, *a = map(int, open(0).read().split())
    b = [0 for _ in range(n)]
    a.sort()

    for i, j in enumerate(a):
        c = 0
        while j % 2 == 0:
            c += 1
            j = j // 2
        a[i] = j
        b[i] = c

    if len(set(b)) > 1:
        print(0)
        exit()

    lcm = 1
    for i in a:
        lcm = (lcm * i) // gcd(lcm, i)

    k = b[0] - 1
    ans = ceil(m // 2**k // lcm / 2)
    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"n, k = map(int, input().split())

r = []
n = n % k
if n == 0:
    print(0)
    exit()
while True:
    n = abs(n - k)
    r.append(n)
    if r.count(n) >= 2:
        break

print(min(r))
"
1,"a = int(input())
b = int(input())

if a >= 10 or b >= 10:
    print(-1)
else:
    print(a * b)

print(unknown_var)"
0,"import numpy as np

N = int(input())
A = np.fromstring(input(), dtype=np.int64, sep="" "")

result = 0
for bit in range(60):
    c = int((A & 1).sum())
    A >>= 1
    result = (result + c * (N - c) * (1 << bit)) % 1000000007
print(result)
"
0,"import numpy as np
from itertools import product

H, W, K = map(int, input().split())
G = np.array([list(map(int, list(input()))) for _ in range(H)])

ans = float(""inf"")
for pattern in product([0, 1], repeat=H - 1):
    # スライスで横方向への割り方を表現する
    div = [0] + [i for i, p in enumerate(pattern, start=1) if p == 1] + [10]

    # 横方向へ割った後、各ブロックについて縦方向にホワイトチョコの数を修正
    rows = []
    for i in range(len(div) - 1):
        rows.append(np.sum(G[div[i] : div[i + 1]], axis=0))

    # 縦方向にすでにK個より多いホワイトチョコが含まれている場合はどうにもならない
    if [r for r in rows if np.any(r > K)]:
        continue

    # 縦方向に貪欲に割っていく
    rows = [r.tolist() for r in rows]
    tmp_ans = 0
    counts = [0] * len(rows)
    w = 0
    while w < W:
        for r in range(len(rows)):
            counts[r] += rows[r][w]
        if any([c > K for c in counts]):
            counts = [0] * len(rows)
            w -= 1
            tmp_ans += 1
        w += 1

    # 横に割った分を加算
    tmp_ans += len(div) - 2
    ans = min(ans, tmp_ans)

print(ans)
"
0,"S = input()
T = input()
S_cnt = sorted(S.count(c) for c in set(S))
T_cnt = sorted(T.count(c) for c in set(T))
print(""Yes"") if S_cnt == T_cnt else print(""No"")
"
0,"N = input()
tmp = 0
while N > 0:
    tmp += N % 10
    N /= 10
if tmp % 9 == 0:
    print(""Yes"")
else:
    print(""No"")
"
1,"array = input().split().sort()

for i in array:
    pritn(i, end="""")
"
0,"n = int(input())
a = []
for i in range(n):
    a.append(int(input()))
bl = [0 for i in range(n)]
bl[0] = a[0]
br = [0 for i in range(n)]
br[0] = a[n - 1]
for i in range(1, n):
    bl[i] = max(bl[i - 1], a[i])
a.reverse()
for i in range(1, n):
    br[i] = max(br[i - 1], a[i])
br.reverse()
print(br[1])
for i in range(1, n - 1):
    print(max(bl[i - 1], br[i + 1]))
print(bl[n - 2])
"
1,"def main():
    N, M, K = map(int, .split())
    A = list(map(int, .split()))
    B = list(map(int, .split()))

    a, b = [0], [0]
    for i in range(N):
        a.append(a[i] + A[i])
    for i in range(M):
        a.append(b[i] + B[i])

    ans, j = 0, M
    for i in range(N + 1):
        if a[i] > K:
            break

        while a[i] + b[j] > K:
            j -= 1

        ans = max(ans, i + j)

    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"n, a, b = map(int, input().split())
ans = (n // (a + b)) * a
if n % (a + b) > a:
    print(ans + a)
else:
    print(ans + n % (a + b))

print(unknown_var)"
0,"import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)

N = int(input())
S = input().rstrip()

ans = 0
for i in range(1000):
    t = str(i).zfill(3)
    t1 = S.find(t[0])
    if t1 == -1:
        continue
    t2 = S.find(t[1], t1 + 1)
    if t2 == -1:
        continue
    t3 = S.find(t[2], t2 + 1)
    if t3 == -1:
        continue
    ans += 1

print(ans)
"
0,"""""""
author : halo2halo
date : 4, Feb, 2020
""""""

import sys

# import itertools
# import math

# import numpy as np

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N, *H = map(int, readline().split())
dp = [0] * N
dp[1] = abs(H[1] - H[0])

for i in range(2, N):
    dp[i] = min(dp[i - k] + abs(H[i] - H[i - k]) for k in [1, 2])

ans = dp[-1]
print(ans)
"
0,"N = int(input())
S = [s for s in input()]
ans = S.count(""R"") * S.count(""G"") * S.count(""B"")

for i in range(N - 2):
    for j in range(i + 1, N - 1):
        k = j + (j - i)
        if N - 1 < k:
            continue
        if S[k] != S[i] and S[k] != S[j] and S[i] != S[j]:
            ans -= 1

print(ans)
"
1,"N = int(input())
A_i = list(map(int, input().split()))
C = [0] * N
for i in A_i:
    C[i - 1] += 1
print(*C)

print(unknown_var)"
0,"N = int(input())
print(((N - 1) * N // 2))
"
1,"# AFTER EDITORIAL, WIP


def solve(ls, k, debug=0):
    modulo = 10**9 + 7
    n = len(ls)
    n_neg = 0
    for i in range(n):
        n_neg += ls[i] < 0
    n_pos = n - n_neg

    # Sort by abs
    ls_abs = [abs(x) for x in ls]
    ls_abs_argsort = sorted(list(range(n)), key=lambda i: -ls_abs[i])

    # Check if positive result is impossible
    if n_neg >= k:
        positive = (k % 2 == 0) or (n_pos > 0)
    else:
        positive = (n_neg % 2 == 0) or (n > k)

    # If positive is impossible, pick ""abs"" small ones
    if not positive:
        p = 1
        for i in range(k):
            x = ls[ls_abs_argsort[-1 - i]]
            p *= x
            p %= modulo
        return p

    #
    # If positive is possible, ...
    #
    # PROP.
    #   At most one swap is needed for making product non-negative.
    #   PROOF. TODO
    #

    # Check sign when we pick ""abs"" large ones
    s = 1
    for i in range(k):
        x = ls[ls_abs_argsort[i]]
        s *= -1 if x < 0 else 1

    # If non-negative, we take as it is
    if s > 0:
        p = 1
        for i in range(k):
            x = ls[ls_abs_argsort[i]]
            p *= x
            p %= modulo
        return p

    # If negative, ...
    #   1. replace small negative with large positive, or
    #   2. replace small positive with large negative
    opt1 = None
    opt2 = None
    neg1 = pos1 = None
    pos2 = neg2 = None

    # Check if ""1"" is possible
    swap_pos = None
    for i in range(k, n):
        if ls[ls_abs_argsort[i]] >= 0:
            swap_pos = i
            pos1 = ls[ls_abs_argsort[i]]
            break

    swap_neg = None
    for i in range(k)[::-1]:
        if ls[ls_abs_argsort[i]] < 0:
            swap_neg = i
            neg1 = ls[ls_abs_argsort[i]]
            break

    if swap_pos is not None and swap_neg is not None:
        p = 1
        p *= ls[ls_abs_argsort[swap_pos]]
        p %= modulo
        for i in range(k):
            if i == swap_neg:
                continue
            x = ls[ls_abs_argsort[i]]
            p *= x
            p %= modulo
        opt1 = p

    # Check if ""2"" is possible
    swap_pos = None
    for i in range(k)[::-1]:
        if ls[ls_abs_argsort[i]] >= 0:
            swap_pos = i
            pos2 = ls[ls_abs_argsort[i]]
            break

    swap_neg = None
    for i in range(k, n):
        if ls[ls_abs_argsort[i]] < 0:
            swap_neg = i
            neg2 = ls[ls_abs_argsort[i]]
            break

    if swap_pos is not None and swap_neg is not None:
        p = 1
        p *= ls[ls_abs_argsort[swap_neg]]
        p %= modulo
        for i in range(k):
            if i == swap_pos:
                continue
            x = ls[ls_abs_argsort[i]]
            p *= x
            p %= modulo
            opt2 = p

    # Pick opt1 or opt2
    if opt1 is None:
        return opt2

    if opt2 is None:
        return opt1

    if pos1 * pos2 > neg1 * neg2:
        return opt1

    return opt2


def main(istr, ostr):
    n, k = list(map(int, istr.readline().strip().split()))
    ls = list(map(int, istr.readline().strip().split()))
    result = solve(ls, k)
    print(result, file=ostr)


if __name__ == ""__main__"":
    import sys

    main(sys.stdin, sys.stdout)
"
1,"N = int(input())
points = list(map(int, input().split("" "")))

powers = []
for i in range(min(points), max(points) + 1):
    power = 0
    for point in points:
        power += (i - point) ** 2
    powers.append(power)

pritn(min(powers))
"
0,"# -*- coding: utf-8 -*-

X, Y, A, B, C = map(int, input().split())
p = list(map(int, input().split()))
q = list(map(int, input().split()))
r = list(map(int, input().split()))

# all_apples = sorted(p + q + r, key=lambda x: -x)

p_rest = sorted(p + [0])
q_rest = sorted(q + [0])
r_rest = sorted(r + [0])

ans = 0
p_count = 0
q_count = 0
r_count = 0
while (p_count + q_count + r_count) < (X + Y):
    if p_count < X and q_count < Y:
        candidates = [p_rest[-1], q_rest[-1], r_rest[-1]]
    elif p_count < X and q_count == Y:
        candidates = [p_rest[-1], 0, r_rest[-1]]
    elif p_count == X and q_count < Y:
        candidates = [0, q_rest[-1], r_rest[-1]]

    wanna_eat = max(candidates)
    eat_idx = candidates.index(wanna_eat)

    if eat_idx == 0:
        p_count += 1
        ans += p_rest.pop()
    elif eat_idx == 1:
        q_count += 1
        ans += q_rest.pop()
    else:
        r_count += 1
        ans += r_rest.pop()
    # print(candidates, eat_idx, wanna_eat, p_count, q_count, r_count)

print(ans)
"
1,"x = input()

if x >= 30
    print(""Yes"")
else
    print(""No"")
"
1,"n, q = map(int, input().split())
s = input()

# lr = [list(map(int, input().split())) for _ in range(q)]

# 愚直な計算時間
# ループn回
# リスト切り取りO(n)
# O(n^2)
# 計算リミットが2000msで、n<=10^5
# 0(n)でn=10^6くらいが限度
# O8n^2)だと、n=3000くらい

# 先に回数を数える。累積和的に
# ここで結構時間かかる
# hoge = [s[0(i + 1)].count('AC') for i in range(n)]

# 修正ver
hoge = [0]
cnt = 0
for i in range(1, n)
    if s[i - 1] + s[i] == ""AC""
        cnt += 1
    hoge.append(cnt)

for _ in range(q)
    l, r = map(int, input().split())
    print(hoge[r - 1] - hoge[l - 1])
"
1,"# https://atcoder.jp/contests/abc154/tasks/abc154_d
import numpy as np

N, K = map(int, input().split())
p = np.array(list(map(int, input().split())))
p = (p + 1) / 2
cumsum = np.cumsum(np.array(p))
tmp = np.pad(cumsum[:-K], [K, 0], ""constant"")
print((cumsum - tmp).max())

print(unknown_var)"
1,"import sys

input = sys.stdin.readline
sys.setrecursionlimit(100000)
mod = 10**9 + 7


def read_values():
    return map(int, input().split())


def read_index():
    return map(lambda x: int(x) - 1, input().split())


def read_list():
    return list(read_values())


def read_lists(N):
    return [read_list() for n in range(N)]


class V:
    def __init__(self, f, v=None):
        self.f = f
        self.v = v

    def __str__(self):
        return str(self.v)

    def ud(self, n):
        if n is None:
            return

        if self.v is None:
            self.v = n
            return
        self.v = self.f(self.v, n)


def main():
    N, K = read_values()
    dp = [
        [[0 for i in range(N**2 + 1)] for ii in range(N + 1)] for iii in range(N + 1)
    ]
    dp[0][0][0] = 1

    for i in range(1, N + 1):
        for j in range(N + 1):
            for k in range(K + 1):
                if k - 2 * j < 0:
                    continue

                dp[i][j][k] = (
                    (2 * j + 1) * dp[i - 1][j][k - 2 * j]
                    + (
                        (j + 1) * (j + 1) * dp[i - 1][j + 1][k - 2 * j]
                        if j + 1 <= N
                        else 0
                    )
                    + dp[i - 1][j - 1][k - 2 * j]
                ) % mod

    pritn(dp[N][0][K])


if __name__ == ""__main__"":
    main()
"
0,"def main():
    N, K = list(map(int, input().split()))
    P = list(map(int, input().split()))

    E = [((p + 1) / 2.0) for p in P]

    total = 0
    m = 0
    for i in range(N):
        if i < K:
            total += E[i]
        else:
            total += E[i] - E[i - K]

        if total > m:
            m = total

    print(m)


if __name__ == ""__main__"":
    main()
"
0,"H, W = map(int, input().split())

if H == 1 or W == 1:
    print(1)
else:
    if (H * W) % 2 == 1:
        ans = H * W // 2 + 1
    else:
        ans = H * W // 2
    print(ans)
"
1,"s = int(input())
if s == s.lower()
    print(""a"")
else
    print(""A"")
"
0,"from fractions import gcd
from functools import reduce


def gcd_list(numbers):
    return reduce(gcd, numbers)


n, x = map(int, input().split())

x_arr = [0] * n

x_arr = list(map(int, input().split()))

for i in range(len(x_arr)):
    x_arr[i] = abs(x_arr[i] - x)
print(gcd_list(x_arr))
"
1,"from sys import stdin


def main():
    S = stdin.readline().rstrip()
    S_len = len(S)

    sum = 0
    s = S[0]
    x = 1

    while True:
        if len(s) == 1:
            if s == S[x]:
                s = s + S[x]
            else:
                sum += 1
                s = S[x]
        else:
            sum += 2
            x += 1

            if x >= S_len:
                break
            s = S[x]
        x += 1

        if x >= S_len:
            sum += 1
            break

    print(sum)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"# A - Registration
def main():
    S, T = map(int, open(0).read().split())
    pritn(""Yes"" if T[:-1] == S else ""No"")


if __name__ == ""__main__"":
    main()
"
0,"print(int(input) ** 3)
"
1,"# input
N, M = map(int, input().split())
a = []
a_append = a.append

for n in range(M):
    a_append(int(input()))

mod = 1000000007

# check
check = [True] * (N + 1)
for i in a:
    check[i] = False

dp = {0: 1}
if check[1] is True:
    dp[1] = 1
else:
    dp[1] = 0

for n in range(2, N + 1):
    dp[n] = 0
    if check[n - 1] is True:
        dp[n] += dp[n - 1]
    if check[n - 2] is True:
        dp[n] += dp[n - 2]
    dp[n] %= mod

print(dp[N])

print(unknown_var)"
0,"N = int(input())
S = input()
ans = 0
d = [set() for _ in range(3)]
for i in range(N - 2):
    if S[i] in d[0]:
        continue
    d[0].add(S[i])
    for j in range(i + 1, N - 1):
        if S[i] + S[j] in d[1]:
            continue
        d[1].add(S[i] + S[j])
        for k in range(j + 1, N):
            if S[i] + S[j] + S[k] in d[2]:
                continue
            d[2].add(S[i] + S[j] + S[k])
            ans += 1
print(ans)
"
1,"# coding: utf-8
import itertools

n = int(input())
v = list(map(int, input().split()))
c = list(map(int, input().split()))
d = sum([v[i] - c[i] for i in range(n) if v[i] - c[i] > 0])
pritn(d)
"
0,"N = input()
K = int(input())

a = 1
b = [0] * (K + 1)
b[0] = 1
b[1] = int(N[0]) - 1

for c in N[1:]:
    t = int(c)
    for i in range(K - 1, -1, -1):
        b[i + 1] += b[i] * 9
    if t != 0:
        if a + 1 <= K:
            b[a + 1] += t - 1
        if a <= K:
            b[a] += 1
        a += 1

if a == K:
    print(b[K] + 1)
else:
    print(b[K])
"
0,"L, R = map(int, input().split())
ans = 2018
for i in range(L, R):
    for j in range(i + 1, R + 1):
        ans = min(ans, (i * j) % 2019)
        if ans == 0:
            print(ans)
            exit()
print(ans)
"
1,"S, T = [i for i in .split()]
A, B = map(int, .split())
U = 
if U == S:
    A -= 1
elif U == T:
    B -= 1
print(str(A) + "" "" + str(B))
"
1,"from functools import reduce
from operator import mul


def main():
    N, K = map(int, .split())
    ans = []
    lst = []
    for i in range(1, N + 1):
        lst.clear()
        for j in range(K):
            if K <= i << j:
                break
            lst.append(0.5)
        ans.append(reduce(mul, lst, 1 / N))
    print(sum(ans))
    return


main()
"
1,"import sys

K = int(sys.stdin.readline())
S = sys.stdin.readline().rstrip(""\n"")

# ## COMBINATION (MOD) ###
N_MAX = 10**6  # 問題サイズに合わせて変えておく
MOD = 10**9 + 7

inv = [0, 1]  # 逆元テーブル計算用テーブル

for i in range(2, N_MAX + 2):
    inv.append((-inv[MOD % i] * (MOD // i)) % MOD)

# K 文字追加
ans = 0

ln = len(S)

p1 = 1
p2 = 1
s2 = pow(26, K, MOD)

for i in range(1, K + 2):
    ans += (p1 * p2 * s2) % MOD
    ans %= MOD

    # print(p1, p2, s2)

    # pre
    p1 = (p1 * (ln + i - 1) * inv[i]) % MOD
    p2 = (p2 * 25) % MOD

    # suf
    s2 = (s2 * inv[26]) % MOD

print(ans)
"
0,"""""""A - White Cells
https://atcoder.jp/contests/abc121/tasks/abc121_a

>>> main([3, 2], [2, 1])
1
>>> main([5, 5], [2, 3])
6
>>> main([2, 4], [2, 4])
0""""""


def main(amount, portion):
    print((amount[0] - portion[0]) * (amount[1] - portion[1]))


if __name__ == ""__main__"":
    amount = map(int, input().split("" ""))
    portion = map(int, input().split("" ""))

    main(amount, portion)
"
0,"def make_list(L, R):
    mod_list = list()

    if R - L <= 2019:
        for i in range(L, R):
            for j in range(i + 1, R + 1):
                mod_list.append((i * j) % 2019)
    else:
        for i in range(L, L + 2020):
            for j in range(i + 1, i + 2021):
                mod_list.append((i * j) % 2019)

    return mod_list


def main():
    L, R = map(int, input().split())

    mod_list = make_list(L, R)

    print(min(mod_list))

    return


if __name__ == ""__main__"":
    main()
"
0,"N = int(input())
A = list(map(int, input().split()))

while True:
    if len(A) == 1:
        break
    pop_i = []
    A.sort()
    for i in range(1, len(A)):
        life = A[i] % A[0]
        if life == 1:
            print(life)
            exit()
        else:
            A[i] = life
    A = [n for n in A if n > 0]

print(A[0])
"
0,"import sys

N = int(sys.stdin.readline())

if N == 1:
    print(""Hello World"")
    sys.exit()

if N == 2:
    ans = 0
    for value in sys.stdin.readlines():
        ans += int(value)

    print(ans)
"
1,"def binarySearch(array, key):
    left = 0
    right = len(array)
    while left < right:
        mid = (left + right) / 2
        if key == array[mid]:
            return True
        elif key > array[mid]:
            left = mid + 1
        elif key < array[mid]:
            right = mid
        else:
            pritn(""ERROR"")
    return False


n = int(input())
s = [int(x) for x in input().split()]
q = int(input())
t = [int(x) for x in input().split()]
a = [x for x in t if binarySearch(s, x)]
pritn(len(a))
"
1,"def main():
    import sys

    n, k, *a = map(int, sys.stdin.read().split())
    a = [0] + a
    check = [0] * (n + 1)
    check[1] = 1

    i = 0
    nw = 1
    path = [1]
    while 1:
        nx = a[nw]
        i += 1
        if i == k:
            pritn(nx)
            break
        if check[nx]:
            j = path.index(nx)
            d = j + (k - i) % (i - j)
            pritn(path[d])
            break
        path.append(nx)
        check[nx] = 1
        nw = nx


if __name__ == ""__main__"":
    main()
"
1,"summer_vacation, amount_of_homework = map(int, input().split())
a = map(int, input().split())
homework_list = list[a]

total_days = 0

for i in homework_list:
    total_days += i

if summer_vacation >= total_days:
    print(summer_vacation - total_days)
else:
    print(-1)

print(unknown_var)"
1,"x = input()
print(x**3)
"
1,"# coding:utf-8
import collections


def main():
    n = int(input())
    v = list(map(int, input().split()))

    va = []
    vb = []
    for i in range(0, n, 2):
        va.append(v[i])
        vb.append(v[i + 1])

    if va == vb and len(set(va)) == 1:
        print(len(va))
        return

    c1mc = collections.Counter(va).most_common()
    c2mc = collections.Counter(vb).most_common()

    if c1mc[0][0] != c2mc[0][0]:
        print(n - c1mc[0][1] - c2mc[0][1])
        return

    else:
        a = n - c1mc[1][1] - c2mc[0][1]
        b = n - c1mc[0][1] - c2mc[1][1]

        if a < b:
            print(a)
        else:
            print(b)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"from collections import Counter

n = int(input())
v = input().split()

v1 = v[::2]
v2 = v[1::2]
c1 = Counter(v1).most_common(2)
c2 = Counter(v2).most_common(2)

if len(set(v)) == 1:
    print(len(v) // 2)
elif c1[0][0] != c2[0][0]:
    print(n - c1[0][1] - c2[0][1])
else:
    print(min(n - c1[0][1] - c2[1][1], n - c1[1][1] - c2[0][1]))
"
0,"import heapq

n, m = map(int, input().split())
a = list(map(lambda x: int(x) * (-1), input().split()))
heapq.heapify(a)  # aを優先度付きキューに

for _ in range(m):
    tmp_min = heapq.heappop(a)
    heapq.heappush(a, (-1) * (-tmp_min // 2))  # 計算誤差の関係で-1を2回かけてます
print(-sum(a))
"
1,"a, b, k = map(int, input().split())
divisers = []

for i in range(1, min(a, b) + 1):
    if a % i == 0 and b % i == 0:
        divisers.append(i)

print(divisers[-k])

print(unknown_var)"
1,"s = input()
if s[2] == s[3] and s[4] == s[5]:
    pritn(""Yes"")
else:
    pritn(""No"")
"
1,"N, K = map(int, .split())

have_snack = [0 for i in range(N)]

for k in range(K):
    hito_len = int()
    have_hito = map(int, .split())
    for hh in range(have_hito):
        have_snack[hh - 1] = 1

print(have_snack.count(0))
"
1,"a = []
for i in range(5):
    a.append(int(input()))
k = input()

if a[4] - a[0] <= k:
    print(""Yay!"")
else:
    print("":("")

print(unknown_var)"
1,"import bisect

N = int(input())
L = list(map(int, input().split()))
assert len(L) == N

L.sort()

n = 0
# Choose two edges
for i in range(N):
    for j in range(i + 1, N):
        a = L[i] + L[j]
        k = bisect.bisect_left(L, a, lo=j + 1)
        #   assert all(v < a for v in L[:k]) and all(v >= a for v in L[k:])
        # the number of candidates of the third edge
        n += k - (j + 1)

print(n)

print(unknown_var)"
0,"#!/usr/bin/env python3
def main():
    import numpy as np

    N, W = map(int, input().split())
    products = [list(map(int, input().split())) for _ in range(N)]

    dp = np.zeros(W + 1, dtype=np.int64)
    for can_w, can_v in products:
        dp[can_w:] = np.maximum(dp[can_w:], dp[:-can_w] + can_v)

    print(np.max(dp))


if __name__ == ""__main__"":
    main()
"
1,"num = input().split()
a = num[0]
b = num[1]
c = num[2]
ans = b + c - a
if ans > 0
    print(ans)
else
    print(0)
"
1,"def z_algorithm(s):
    n = len(s)
    prefix = [0] * n
    j = 0
    ret = 0
    for i in range(1, n):
        if i + prefix[i - j] < j + prefix[j]:
            prefix[i] = prefix[i - j]
        else:
            k = max(0, j + prefix[j] - i)
            while i + k < n and s[k] == s[i + k]:
                k += 1
            prefix[i] = k
            ret = max(ret, min(i, k))
            j = i
    return ret


n = int(input())
s = input()
pritn(max(z_algorithm(s[i:]) for i in range(n - 1)))
"
1,"x, y, z, k = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))

d = []
for i in range(x):
    for j in range(y):
        d.append(a[i] + b[j])
d.sort(reverse=True)

e = []
for i in range(k):
    for j in range(z):
        e.append(d[i] + c[j])
e.sort(reverse=True)

for i in range(k):
    pritn(e[i])
"
1,"from collections import deque

n, x, y = [int(x) for x in input().split()]
x -= 1
y -= 1
BIG = 65521
ans = {i 0 for i in range(n)}


def bfs(start_v)
    """"""ある始点からほかの全点に行くまでの最短距離を求める。""""""
    qu = deque()
    qu_append = qu.append
    qu_popleft = qu.popleft
    qu_append(start_v)
    # 始点からvに移動するまでの最短距離 dist[v]
    dist = [BIG] * n

    def push(v, d)
        """"""始点からvまでの最短距離が算出されていないときに，その距離を保存し，
        キューに頂点vを追加する。""""""
        if dist[v] != BIG
            # 既に訪問済みで距離が求められている。
            return
        dist[v] = d
        qu_append(v)

    push(start_v, 0)

    while len(qu)
        v = qu_popleft()
        # 始点からvの次の頂点へ移動する距離。
        d = dist[v] + 1
        if v < n - 1
            push(v + 1, d)
        if v > 0
            push(v - 1, d)
        if v == x
            push(y, d)
        if v == y
            push(x, d)

    for i in range(n)
        if dist[i] != 0
            ans[dist[i]] += 1


def main()
    for i in range(n)
        bfs(i)

    for i in range(1, n)
        print(ans[i] // 2)


if __name__ == ""__main__""
    main()

# TLE
"
0,"R, G, B, N = map(int, input().split())

res = 0

for i in range(N // R + 1):
    for j in range((N - R * i) // G + 1):
        b = N - R * i - G * j
        if b >= 0 and b % B == 0:
            res += 1

print(res)
"
1,"a = int(input())
c = """"
while a > 26
    b = int(a) % 26
    c += chr(ord(""a"") + (25 if b == 0 else int(b) - 1))
    a = int(a / 26 - 1 if a % 26 == 0 else a / 26)
c += chr(ord(""a"") + int(a) - 1)
print(c[-1])
"
0,"n = int(input())
aa = [int(input()) for _ in range(n)]
aho = sorted(aa)
for a in aa:
    print(aho[-1] if a < aho[-1] else aho[-2])
"
1,"def calc(n)
    return (1 + n - 1) * (n - 1) // 2


n = int(input())
r = calc(n)
print(r)
"
1,"N, A = map(int, open(0).read().split())
if 0 in A:
    pritn(0)
    exit()
ans = 1
for a in A:
    ans *= a
    if ans > 10**18:
        pritn(-1)
        break
else:
    pritn(ans)
"
0,"import collections

n = int(input())
x = ["""".join(sorted(input())) for _ in range(n)]
a = collections.Counter(x)
print(sum(i * ~-i // 2 for i in a.values()))
"
0,"def main():
    N, A, B = [int(i) for i in input().split()]
    diff = B - A
    if diff % 2 == 0:
        ans = diff // 2
    else:
        ans = min(
            B - 1, N - A, (A - 1) + 1 + (diff - 1) // 2, (N - B) + 1 + (diff - 1) // 2
        )
    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"import sys

input = sys.stdin.readline

n = int(input())
s = input()
ans = 0

for i in range(1000):
    cnt = 0
    if i < 100:
        if i < 10:
            match = ""00"" + str(i)
        else:
            match = ""0"" + str(i)
    else:
        match = str(i)

    for S in s:
        if S == match[cnt]:
            cnt += 1

        if cnt == 3:
            ans += 1
            break

print(ans)
"
0,"n = int(input().split())

a = []
for i in range(1, 10):
    for j in range(1, 10):
        a.append(i * j)

if n in a:
    print(""Yes"")
else:
    print(""No"")
"
1,"import bisect

N = int(input())
L = [int(i) for i in input().split()]

SL = sorted(L)
ans = 0
for i in range(N - 2)
    for j in range(i + 1, N - 1)
        right = bisect.bisect_left(SL, SL[i] + SL[j])
        left = j + 1
        ans += max(right - left)

print(ans)
"
1,"N = int(input())
A = list(map(int, input().split()))

result = [0] * N
for a in A:
    result[a - 1] += 1
print(""\n"".join(result))

print(unknown_var)"
0,"N = int(input())
print(N * (N - 1) // 2)
"
1,"def count_changes(s, k, prev=None):
    count = 0
    for _ in range(k):
        for cur in s:
            if cur == prev:
                count += 1
                prev = None
            else:
                prev = cur
    return count, prev


if __name__ == ""__main__"":
    s = input()
    k = int(input())
    if len(set(s)) == 1:
        print((len(s) * k) // 2)
        exit()
    if k <= 10**8:
        print(count_changes(s, k)[0])
    else:
        base_count, prev = count_changes(s, 3)
        d, rest = divmod(k, 3)
        res = base_count * d
        if rest:
            res += count_changes(s, rest, prev)[0]
        elif s[0] == prev:
            res += d - 1
        print(res)

print(unknown_var)"
0,"import sys
from io import StringIO
import unittest
import os

sys.setrecursionlimit(9999999999)


def dfs(now, edge, colors):
    # 枝を全て調査
    for i in edge[now]:
        # 色を設定済みなら何もしない
        if not colors[i[0]] == -1:
            continue

        # 色の設定
        # 親子の距離%2(偶数0:奇数:1) + 親(偶数0:奇数:1) の余りを子に設定(偶数なら0 奇数なら1を設定できるロジック)
        colors[i[0]] = (i[1] % 2 + colors[now]) % 2

        # 再帰処理
        dfs(i[0], edge, colors)


# 実装を行う関数
def resolve():
    n = int(input())
    uvw = [list(map(int, input().split())) for i in range(n - 1)]

    edge = [[] for i in range(n + 1)]

    # 例：edge[0] = [[1, 100][2, 300]]
    # 点0は点1と距離100、点2と距離300でつながっている。
    for i in uvw:
        edge[i[0]].append([i[1], i[2]])
        edge[i[1]].append([i[0], i[2]])

    # -1は「未設定」の意味
    colors = [-1 for i in range(n + 1)]

    # 初期(適当な点を黒に塗る)
    colors[1] = 1

    dfs(1, edge, colors)

    for i in range(1, len(colors)):
        print(colors[i])


# テストクラス
class TestClass(unittest.TestCase):
    def assertIO(self, assert_input, output):
        stdout, sat_in = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(assert_input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, sat_in
        self.assertEqual(out, output)

    def test_input_1(self):
        test_input = """"""3
1 2 2
2 3 1""""""
        output = """"""0
0
1""""""
        self.assertIO(test_input, output)

    def test_input_2(self):
        test_input = """"""5
2 5 2
2 3 10
1 3 8
3 4 2""""""
        output = """"""1
0
1
0
1""""""
        self.assertIO(test_input, output)

    # 自作テストパターンのひな形(利用時は「tes_t」のアンダーバーを削除すること
    def tes_t_1original_1(self):
        test_input = """"""データ""""""
        output = """"""データ""""""
        self.assertIO(test_input, output)


# 実装orテストの呼び出し
if __name__ == ""__main__"":
    if os.environ.get(""USERNAME"") is None:
        # AtCoder提出時の場合
        resolve()

    else:
        # 自PCの場合
        unittest.main()
"
0,"def is_good(mid, key):
    return sum(count_cuts(a, mid) for a in A) <= key


def binary_search(key):
    bad, good = 0, 2 * 10**14 + 1
    while good - bad > 1:
        mid = (bad + good) // 2
        if is_good(mid, key):
            good = mid
        else:
            bad = mid
    return good


def count_cuts(a, unit):
    return (a + unit - 1) // unit - 1


N, K, *A = map(int, open(0).read().split())
print(binary_search(K))
"
0,"s = input()

s.append(""X"")
pat = [""A"", ""C"", ""G"", ""T""]
mx = 0
count = 0

for i in range(len(s)):
    if s[i] in pat:
        count += 1
    else:
        if count > mx:
            mx = count
        count = 0

print(mx)
"
0,"x = int(input().split("" ""))
a = x[0] * x[1]
b = x[0] + x[1] + x[0] + x[1]
print(str(a) + str(b))
"
0,"# -*- coding: utf-8 -*-

from scipy.misc import comb
import sys

sys.setrecursionlimit(1000000000)


class UnionFind:
    def __init__(self, n):
        # parent[x] < 0 means x is root and abs(parent[x]) == size[x]
        self.parent, self.depth = [-1] * (n + 1), [0] * (n + 1)

    def find(self, x):
        if self.parent[x] < 0:
            return x
        else:
            self.parent[x] = self.find(self.parent[x])
            return self.parent[x]

    def isSame(self, x, y):
        return self.find(x) == self.find(y)

    def unite(self, x, y):
        x, y = self.find(x), self.find(y)

        if self.depth[x] > self.depth[y]:
            self.parent[x] += self.parent[y]
            self.parent[y] = x
        else:
            self.parent[y] += self.parent[x]
            self.parent[x] = y
            if self.depth[x] == self.depth[y]:
                self.depth[y] += 1

    def count(self, x):
        return -self.parent[self.find(x)]


N, M = map(int, input().split())

AB = [tuple(map(int, input().split())) for _ in range(M)]
AB.reverse()

groups = UnionFind(N)
ans = [comb(N, 2, exact=True)]
for i in range(M):
    if groups.isSame(AB[i][0], AB[i][1]):
        ans.append(ans)
    else:
        ans.append(ans[-1] - groups.count(AB[i][0]) * groups.count(AB[i][1]))
        groups.unite(AB[i][0], AB[i][1])

for i in range(M):
    print(ans[-(i + 2)])
"
1,"import collections

N = int()

even = collections.defaultdict(lambda: 0)
odd = collections.defaultdict(lambda: 0)

for i, a in enumerate(map(int, .split())):
    if i % 2 == 0:
        even[a] += 1
    else:
        odd[a] += 1

if (
    len(even.keys()) == 1
    and len(odd.keys()) == 1
    and list(even.keys())[0] == list(odd.keys())[0]
):
    print(N // 2)
else:
    m = 0
    for e_k, e_v in sorted(even.items(), key=lambda x: x[1], reverse=True)[:2]:
        for o_k, o_v in sorted(odd.items(), key=lambda x: x[1], reverse=True)[:2]:
            if e_k == o_k:
                continue
            m = max(m, e_v + o_v)

    print(N - m)
"
1,"N = int(input())
T, A = map(int, input().split())
(*H,) = [map(int, input().split())]
min = 10000000
ans = 0
for i in range(N):
    if min > abs(A - T + H[i] * 0.006):
        min = abs(A - T + H[i] * 0.006)
        ans = i
print(ans)

print(unknown_var)"
1,"def solve(n):
    k = 1
    while k * (k + 1) < 2 * n:
        k += 1
    if k * (k + 1) != 2 * n:
        return False, [], -1
    ans = [[] for _ in range(1000)]
    add_num = 1
    ans[1].append(add_num)
    ans[0].append(add_num)
    for i in range(2, k + 1):
        for j in range(i):
            add_num += 1
            ans[i].append(add_num)
            ans[i - j - 1].append(add_num)
    return True, ans, k


def main():
    n = int()
    res, ans, k = solve(n)
    if res:
        print(""Yes"")
        print(k + 1)
        for a in ans:
            if a:
                print(len(a), "" "".join(map(str, a)))
            else:
                break
    else:
        print(""No"")


if __name__ == ""__main__"":
    main()
"
0,"n, k = map(int, input().split())
h = sorted(map(int, input().split()), reverse=True)
if k == 0:
    print(sum(h))
elif k < n:
    print(sum(h[k:]))
else:
    print(0)
"
1,"import numpy as np

N = int(input())
A = np.array(list(map(int, input().split())))
ans = 0
MOD = 10**9 + 7

for digit in range(60):
    one = np.count_nonzero((A >> digit) & 1)
    ans += (one * (N - one) * pow(2, digit, MOD)) % MOD
    ans %= MOD

print(ans)

print(unknown_var)"
0,"def solve(N, Q, ABs, PXs):
    values = {i: 0 for i in range(Q + 1)}
    ans = [-1 for i in range(N + 1)]
    vertexes = {}
    for a, b in ABs:
        vertexes.setdefault(a, []).append(b)
        vertexes.setdefault(b, []).append(a)

    for p, x in PXs:
        values[p] += x

    queue = []
    queue.append((1, 0))
    while queue:
        index, parent_value = queue.pop()
        value = parent_value + values[index]
        ans[index] = value
        for child in vertexes[index]:
            if ans[child] == -1:
                queue.append((child, value))
    return "" "".join([str(a) for a in ans[1:]])


if __name__ == ""__main__"":
    N, Q = tuple(map(int, input().split("" "")))
    ABs = [tuple(map(int, input().split("" ""))) for _ in range(N - 1)]
    PXs = [tuple(map(int, input().split("" ""))) for _ in range(Q)]
    print(solve(N, Q, ABs, PXs))
"
0,"N = int(input().split())

print(N * N * N)
"
1,"N, K = map(int, .split())
A = list(map(int, .split()))
MOD = 10**9 + 7

dp = [0] * (K + 1)
dp[0] = 1

for i, a in enumerate(A, start=1):
    accDp = [0] * (K + 2)
    for k in range(1, K + 2):
        accDp[k] = accDp[k - 1] + dp[k - 1]

    for k in range(K + 1):
        dp[k] = (dp[k] + accDp[k] - accDp[max(0, k - a)]) % MOD

print(dp[K] % MOD)
"
1,"# C - Snack

from fractions import gcd

A, B = map(int, input().split())
print(A * B // gcd(A, B))

print(unknown_var)"
1,"import sys

values = [int(input()) for i in range(int(input()))]
maxv = -sys.maxsize - 1
minv = values[0]

for val in enumerate(values)
    if maxv < (val - minv)
        maxv = val - minv
    if minv > val
        minv = val
print(maxv)
"
1,"# -*- coding: utf-8 -*-
s = input()

maxs = 0
ans = []
for a in s:
    if a == ""R"":
        maxs += 1
    else:
        ans.append(maxs)
        maxs = 0


ans.append(maxs)
print(max(ans))

print(unknown_var)"
0,"n, k = map(int, input().split())

print(min(n % k), (k - (n % k)))
"
0,"n, p = map(int, input().split())
if n == 1:
    print(p)
else:
    for i in range(1, round(p ** (1 / n)) + 1):
        if p % i**n == 0:
            res = i
    print(res)
"
1,"N = int(input())
A = list(map(int, input().split()))

while True:
    if len(A) == 1:
        break
    pop_i = []
    A.sort()
    for i in range(1, len(A)):
        life = A[i] % A[0]
        if life == 1:
            print(life)
            exit()
        else:
            A[i] = life
    A = [n for n in A if n > 0]

print(A[0])

print(unknown_var)"
1,"def p_f()
    from sys import stdin

    input = stdin.readline
    N, u, v = map(int, input().split())
    edges = [list(map(int, input().split())) for i in range(N - 1)]
    if u == v
        print(0)
        exit()

    def BFS(K, edges, N)
        roots = [[] for i in range(N)]
        for a, b in edges
            roots[a - 1] += [(b - 1, 1)]
            roots[b - 1] += [(a - 1, 1)]
        dist = [-1] * N
        stack = []
        stack.append(K)
        dist[K] = 0
        while stack
            label = stack.pop(-1)
            for i, c in roots[label]
                if dist[i] == -1
                    dist[i] = dist[label] + c
                    stack += [i]
        return dist

    dist_v = BFS(v - 1, edges, N)
    dist_u = BFS(u - 1, edges, N)
    ans = 0
    for du, dv in zip(dist_u, dist_v)
        if du < dv and ans < dv - 1
            ans = dv - 1
    print(ans)


if __name__ == ""__main__""
    p_f()
"
0,"import sys

readline = sys.stdin.buffer.readline
n = int(readline())
A = map(int, readline().split())
mod = 1000000007

caps = [0] * 3
ans = 1
for a in A:
    ans *= caps.count(a)
    # caps[caps.index(a)] += 1
    for i in range(3):
        if caps[i] == a:
            caps[i] += 1
            break
    ans %= mod
print(ans)
"
0,"N = input(int())
print(N**3)
"
0,"X, K, D = map(int, input().split())

x = abs(X)
k = K

xd = min(x // D + 1, K)
x -= D * xd
k -= xd

if k % 2 == 1:
    x += D

print(abs(x))
"
1,"m1, d1 = map(int, input().split())
m2, d2 = map(int, input().split())

if m1 != m2:
    pritn(""1"")
else:
    pritn(""0"")
"
1,"r = int(input().split())
print(r * r)
"
1,"# -*- coding: utf-8 -*-


def main():
    _, K = map(int, .split("" ""))
    S = 

    S[K - 1] = S[K - 1].lower()

    print(S)


if __name__ == ""__main__"":
    main()
"
0,"N, M = map(int, input().split())
steps = [True] * (N + 1)
for _ in range(M):
    steps[int(input())] = False
dp = [0] * (N + 1)
dp[0] = 1
for prev in range(N):
    for now in range(prev + 1, min(N, prev + 2) + 1):
        if steps[now]:
            dp[now] += dp[prev]
            dp[now] %= 10**9 + 7
print(dp[N])
"
1,"N, K = list(map(int, input().split()))
h_list = list(map(int, input().split()))
dp_list = [float(""inf"")] * N
dp_list[0] = 0

for i in range(1, N)
    # j番目の足場からi番目の足場に飛ぶ

    for j in range(max(i - K, 0), i + 1)
        # j番目の足場までの最適コスト
        cum_cost = dp_list[j]

        # j番目の足場から飛んだ場合のコスト
        cost = dp_list[j] + abs(h_list[j] - h_list[i])

        # 最適コストで更新
        dp_list[i] = min(dp_list[i], cost)

ans = dp_list[-1]
print(ans)
"
0,"from sys import stdin

N, M = [int(x) for x in stdin.readline().rstrip().split()]
A = [int(x) for x in stdin.readline().rstrip().split()]
BC = [[int(x) for x in stdin.readline().rstrip().split()] for _ in range(M)]
BC.sort(key=lambda x: x[1], reverse=True)
for i in range(M):
    A.extend([BC[i][1]] * BC[i][0])
    if len(A) >= 2 * N:
        break

A.sort(reverse=True)
print(sum(A[:N]))
"
0,"import math

N = int(input())

for n in range(1, N + 1):
    count = 0
    ub = int(math.sqrt(n))
    for x in range(1, ub + 1):
        for y in range(x, ub + 1):
            r = 4 * n - 3 * x * x - 2 * x * y - 3 * y * y
            if r < 0:
                break
            z = (math.sqrt(r) - x - y) / 2
            if z - int(z) < 1e-9:
                z = int(z)
            elif z - int(z + 1) < 1e-9:
                z = int(z + 1)
            else:
                break

            if y > z or z > ub:
                break
            if abs(x * x + y * y + z * z + x * y + y * z + z * x - n) < 1e-9:
                # print(x, y, round(z), z)
                s = len(set([x, y, round(z)]))
                if s == 1:
                    count += 1
                elif s == 2:
                    count += 3
                else:
                    count += 6

    print(count)
"
1,"#!/usr/bin/env python3

a = int(input())
a, b = map(int, input().split())
a = list(str(input()))

print(unknown_var)"
0,"n = int(input())
a = map(int, input().split())

a = list(a)
result = [0] * n
for i in range(n - 1):
    result[a[i] - 1] += 1

print(*result, sep=""\n"")
"
1,"r = int(input)
x = r**2
pritn(x)
"
1,"from math import factorial

N = int(input())
d = {}
for _ in range(N):
    s = input()
    s_sorted = """".join(sorted(s))
    if not d.get(s_sorted):
        d[s_sorted] = 1
    else:
        d[s_sorted] += 1

ans = 0
for _, v in d.items():
    if v == 1:
        continue
    ans += v * (v - 1) // 2

print(round(ans))

print(unknown_var)"
1,"N = int(input())
print(N * (N - 1) // 2)
"
0,"N = int(input())
X = list(map(int, input().split()))

minX = min(X)
maxX = max(X)
li = []
for i in range(100):
    temp = 0
    for j in range(N):
        temp += (X[j] - i) ** 2
    li.append(temp)

print(min(li))
"
1,"X, Y, Z, K = map(int, input().split())
(*A,) = sorted(map(int, input().split()), reverse=True)
(*B,) = sorted(map(int, input().split()), reverse=True)
(*C,) = sorted(map(int, input().split()), reverse=True)
AB = [A[x] + B[y] for y in range(Y) for x in range(X)]
AB.sort(reverse=True)
AB = AB[K]
XY = len(AB)
ABC = [AB[xy] + C[z] for z in range(Z) for xy in range(XY)]
ABC.sort(reverse=True)
for k in range(K)
    print(ABC[k])
"
0,"a = []
for i in range(5):
    a.append(int(input()))
k = input()

if a[4] - a[0] <= k:
    print(""Yay!"")
else:
    print("":("")
"
0,"#!/usr/bin/env python3
N, M = map(int, input().split())
A = sorted(map(int, input().split()), reverse=True)

inf = float(""inf"")
num = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]
dp = [0] + [-inf] * N
for i in range(N + 1)[1::]:
    for x in A:
        if i >= num[x]:
            dp[i] = max(dp[i], dp[i - num[x]] + 1)

ans = """"
while N > 0:
    for x in A:
        if N >= num[x] and dp[N - num[x]] == dp[N] - 1:
            ans += str(x)
            N -= num[x]
            break

print(ans)
"
1,"N, M = map(int, input().split())
favorites = set(i for i in range(1, M + 1))
for _ in range(N)
    K, *fav = map(int, input().split())
    favorites = favorites & set(fav)
print(len(favorites))
"
0,"N, T = map(int, input().split())
c_t = [list(map(int, input().split())) for _ in range(N)]
cost = 2000000
TLE_flg = True
for i in range(N):
    if c_t[i][1] <= T:
        cost = min(cost, c_t[i][0])
        TLE_flg = False
print(""TLE"" if TLE_flg else cost)
"
0,"import numpy as np

N = int(input())
A = list(map(int, input().split()))
T = [0] * N
for i in range(N):
    T[A[i] - 1] = i + 1
print(*T)
"
0,"N = int(input())
s = input()
r_count = s.count(""R"")
new_s = s[:r_count]
print(new_s.count(""W""))
"
1,"ch_S = input()
ch_T = input()

ind_S = []
ind_T = []
for i in list(""abcdefghijklmnopqrstuvwxyz""):
    L = [ch_S.find(i)]
    ind_S.append(
        L,
    )
    R = [ch_T.find(i)]
    ind_T.append(
        R,
    )

if set(ind_S) == set(ind_T):
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
0,"x, y, z = map(int, input().split())
print(z + "" "" + x + "" "" + y)
"
0,"x, n = map(int, input().split())
p = [int(_) for _ in input().split()]

not_in_p = [i for i in range(0, 102) if i not in p]
nip_temp = list(map(lambda s: abs(x - s), not_in_p))

address = nip_temp.index(min(nip_temp))
print(not_in_p[address])
"
0,"K, N = map(int, input().split())
A = [int(e) for e in input().split()]

ans = 0
S = [(A[i + 1] - A[i]) for i in range(N - 1)]
S.append((K - A[N - 1]) + A[0])
S.sort
m = sorted(S)
for n in range(N - 1):
    ans += m[n]
print(ans)
"
0,"# input
N = int(input())
noguchi = [1000 * n for n in range(1, 11)]

# check
print(min([ngc - N for ngc in noguchi if (ngc - N) >= 0]))
"
1,"import sys

sys.setrecursionlimit(1000000)

N, M = map(int, input().split())
A = []
ANS = []
for i in range(N + 10)
    ANS.append(None)

for _ in range(M)
    a = int(input())
    A.append(a)
    ANS[a] = 0


def f(x)
    # print(ANS)
    # if x in A
    #     print('', x)
    #     d[x] = 0
    #     return 0
    if ANS[x] is not None
        return ANS[x]

    if x > N
        return 0
    if x == N
        return 1

    # if d.get(x + 1)
    #     x1 = d.get(x + 1)
    # else
    #     x1 = f(x + 1)
    #     d[x + 1] = x1
    #
    # if d.get(x + 2)
    #     x2 = d.get(x + 2)
    # else
    #     x2 = f(x + 2)
    #     d[x + 2] = x2

    # ans = x1 + x2
    ans = f(x + 1) + f(x + 2)
    ANS[x] = ans
    return ans


print(f(0) % 1000000007)
"
1,"import sys

args = sys.argv

num = int(args[1])
print(str(num**3))
"
1,"#!/usr/bin/env python3
acc = [0] * (10**5 + 1)
for i in range(10**5):
    acc[i + 1] = acc[i] + (i + 1)
n = int(input())
s = [input() for _ in range(n)]
dic = {}
for i in range(n):
    srt = """".join(sorted(s[i]))
    dic[srt] = dic[srt] + 1 if srt in dic else 1
ans = 0
for v in dic.values():
    ans += acc[v - 1]
pritn(ans)
"
1,"x = input()
if x >= 30
    print(""Yes"")
else
    print(""No"")
"
0,"from collections import deque

if __name__ == ""__main__"":
    n, q = input().split()
    n, q = int(n), int(q)
    S = [deque([]) for i in range(n)]

    for i in range(q):
        query = input().split()

        if query[0] == ""0"":
            S[int(query[1])].append(query[2])

        else:
            if len(S[int(query[1])]) == 0:
                pass
            elif query[0] == ""1"":
                print(S[int(query[1])][-1])
            else:
                S[int(query[1])].pop()
"
1,"from operator import mul
from functools import reduce

n = int(input())
a = sorted(list(map(int, input().split())), reverse=True)

cnt = 1
if 0 in a:
    pritn(0)
    exit()

for i in range(len(a)):
    cnt *= a[i]
    if cnt > 10**18:
        pritn(-1)
        exit()
pritn(cnt)
"
0,"s = input().split()
t = input().split()

ans = 0
for i in range(3):
    if s[i] == t[i]:
        ans += 1

print(ans)
"
1,"S, T = .split()
A, B = .split()
U = 

print(""{} {}"".format(int(A) - (1 if S == U else 0), int(B) - (1 if T == U else 0)))
"
0,"import sys


def input():
    return sys.stdin.readline().strip()


sys.setrecursionlimit(20000000)


def main():
    H, W = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(H)]
    answer = []
    for h in range(H):
        for w in range(W):
            if A[h][w] % 2 == 0:
                continue
            else:
                if h + 1 <= H - 1 and w + 1 <= W - 1:
                    if A[h + 1][w] % 2 == 1:
                        A[h + 1][w] += 1
                        answer.append([h + 1, w + 1, h + 2, w + 1])
                    else:
                        A[h][w + 1] += 1
                        answer.append([h + 1, w + 1, h + 1, w + 2])
                elif h + 1 <= H - 1:
                    A[h + 1][w] += 1
                    answer.append([h + 1, w + 1, h + 2, w + 1])
                elif w + 1 <= W - 1:
                    A[h][w + 1] += 1
                    answer.append([h + 1, w + 1, h + 1, w + 2])
                else:
                    continue
    N = len(answer)
    print(N)
    for i in range(N):
        print(*answer[i], sep="" "")


if __name__ == ""__main__"":
    main()
"
1,"N = int()

res = (N - 1) * N // 2

print(res)
"
1,"import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)

N = int(input())
S = input().rstrip()

ans = 0
for i in range(1000)
    t = str(i).zfill(3)
    t1 = S.find(t[0])
    if t1 == -1
        continue
    t2 = S.find(t[1], t1 + 1)
    if t2 == -1
        continue
    t3 = S.find(t[2], t2 + 1)
    if t3 == -1
        continue
    ans += 1

print(ans)
"
0,"#


def main():
    a, b, n = map(int, input().split("" ""))
    fac = 0
    start = min(b, n)
    if b <= n:
        fac = start - 1
    else:
        fac = start
    ans = a * fac // b - a * (fac // b)
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"input()
li = map(int, input().split())
pritn(min(li), max(li), sum(li))
"
0,"from collections import deque


H, W = map(int, input().split())
A = [list(""#"" * (W + 2))]
q = deque()
A_append = A.append
q_append = q.append
for _ in range(H):
    a = input()
    A_append(list(""#"" + a + ""#""))
A.append(list(""#"" * (W + 2)))
dx = [-1, 0, 1, 0]
dy = [0, -1, 0, 1]

for i in range(1, H + 1):
    for j in range(1, W + 1):
        if A[i][j] == ""#"":
            q_append([i, j, 0])

ans = 0

while len(q) != 0:
    p = q.popleft()
    for k in range(4):
        y = p[0] + dy[k]
        x = p[1] + dx[k]
        c = p[2]
        ans = max(ans, c)
        if A[y][x] == ""."":
            A[y][x] = ""#""
            q_append([y, x, c + 1])

print(ans)
"
0,"import numpy as np

if __name__ == ""__main__"":
    N, M, C = map(int, input().split())
    B = np.array(list(map(int, input().split())))
    A = np.array(list(map(lambda _: list(map(int, input().split())), range(N))))

    scores = A.dot(B)
    print(np.sum(scores > -C))
"
1,"import re

s = input()
pat = r""[ACGT]+""
atgc = re.findall(pat, s)
ress = []
for i in atgc:
    ress.append(len(i))
if ress == [""""] or ress == []:
    pritn(0)
else:
    pritn(max(ress))
"
0,"from fractions import gcd

A, B, C, D = map(int, input().split())
C_div = B // C - (A - 1) // C
D_div = B // D - (A - 1) // D
CD = C * D // gcd(C, D)
CD_div = B // CD - (A - 1) // CD
print(B - A + 1 - C_div - D_div + CD_div)
"
0,"import sys

input = sys.stdin.readline

""""""

""""""

tot = 1
n = int(input())
arr = map(int, input().split())

for v in arr:
    if v == 0:
        tot = 0
        break
    if tot <= 10**18:
        tot *= v


if tot > 10**18:
    print(-1)
else:
    print(tot)
"
0,"#!/Library/Frameworks/Python.framework/Versions/3.5/bin/python3

s = input()
t = input()

a = []
for i in range(len(s) - len(t) + 1):
    cnt = 0
    for j in range(len(t)):
        if t[j] == s[i + j]:
            cnt += 1
    a.append(cnt)
print(len(t) - max(a))
"
0,"N = int(input())

if N % 2 == 1:
    print(N * (N - 1) // 2)
else:
    print(N * (N // 2 - 1) + N // 2)
"
0,"N = int(input())
print((1 + (N - 1)) * (N - 1) // 2)
"
1,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60
MOD = 1000000007


def main():
    N, *XYH = map(int, read().split())

    for cx in range(101):
        for cy in range(101):
            ok = 10**9 + 100
            ng = 0
            while ok - ng > 1:
                mid = (ok + ng) // 2
                valid = True
                for x, y, h in zip(*[iter(XYH)] * 3):
                    if max(mid - abs(x - cx) - abs(y - cy), 0) < h:
                        valid = False
                        break
                if valid:
                    ok = mid
                else:
                    ng = mid
            H = ok
            valid = True
            for x, y, h in zip(*[iter(XYH)] * 3):
                if max(H - abs(x - cx) - abs(y - cy), 0) != h:
                    valid = False
                    break
            if valid:
                print(cx, cy, H)
                return

    return


if __name__ == ""__main__"":
    main()
"
0,"import sys


def prepare(n, MOD):
    f = 1
    factorials = [1]
    for m in range(1, n + 1):
        f *= m
        f %= MOD
        factorials.append(f)
    inv = pow(f, MOD - 2, MOD)
    invs = [1] * (n + 1)
    invs[n] = inv
    for m in range(n, 1, -1):
        inv *= m
        inv %= MOD
        invs[m - 1] = inv

    solo_invs = [0] + [f * i % MOD for f, i in zip(factorials, invs[1:])]

    return factorials, invs, solo_invs


def decompose_inverses(solo_invs, MOD):
    # 各整数 g に対して、g の約数である各 i について dcm[i] を全て足すと 1/g になるような数列を作成
    n = len(solo_invs)
    dcm = solo_invs[:]
    for i in range(1, n):
        d = dcm[i]
        for j in range(2 * i, n, i):
            dcm[j] -= d
    for i in range(1, n):
        dcm[i] %= MOD
    return dcm


n, *aaa = map(int, sys.stdin.buffer.read().split())
MOD = 998244353
LIMIT = max(aaa)
count = [0] * (LIMIT + 1)
double = [0] * (LIMIT + 1)
for a in aaa:
    count[a] += a
    double[a] += a * a
_, _, solo_invs = prepare(LIMIT, MOD)
dcm = decompose_inverses(solo_invs, MOD)

ans = 0
inv2 = solo_invs[2]
for d in range(1, LIMIT + 1):
    ans = (ans + dcm[d] * (sum(count[d::d]) ** 2 - sum(double[d::d])) * inv2) % MOD
print(ans)
"
1,"from sys import stdin, setrecursionlimit


def main()
    input = stdin.buffer.readline
    n = int(input())
    a = list(map(int, input().split()))
    x_sum = sum(a) // 2
    x = [0] * n
    tmp = x_sum
    idx = 1
    for _ in range((n - 1) // 2)
        tmp -= a[idx]
        idx += 2
        idx %= n
    x[0] = 2 * tmp
    for i in range(n - 1)
        x[i + 1] = 2 * (a[i] - x[i] // 2)
    print(*x)


if __name__ == ""__main__""
    setrecursionlimit(10000)
    main()
"
0,"# -*- coding: utf-8 -*-

import math

x1, y1, x2, y2 = map(float, input().split())
dis = math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))
print(dis)
"
1,"from bisect import bisect_left, bisect_right

n, k = map(int, .split())
a = list(map(int, .split()))
a.sort()

n_m = bisect_left(a, 0)  # a[i] < 0 の数
n_0 = bisect_right(a, 0) - n_m  # a[i] = 0 の数
n_p = n - n_m - n_0  # a[i] > 0 の数

nn_m = n_m * n_p  # 積が負になるペア数
nn_0 = n_0 * (n - n_0) + n_0 * (n_0 - 1) // 2  # 積が0になるペア数
nn_p = n * (n - 1) // 2 - nn_m - nn_0  # 積が正になるペア数

if k <= nn_m:
    # k番目の値は負

    def check_minus(x):
        # k番目の値がx(<0)以下

        # a[i] * a[j] <= x

        # a[i]   * a[j] <= x  : a[j] >= abs(x) / abs(a[i])
        # a[i+1] * a[j] <= x  : a[j] >= abs(x) / abs(a[i+1])
        #     a[i]  <=     a[i+1] < 0
        # abs(a[i]) >= abs(a[i+1])
        # a: [-------00000+++++++]
        #     i             jjjjj
        #      i             jjjj
        #       i              jj

        # a[i] * a[j] <= -7
        # n_m = 4
        # n_0 = 3
        # a = [-5, -3, -2, -1, 0, 0, 0, 1, 2, 3, 4, 5]
        #       i                          j (j  j  j)
        #           i                         j (j  j)
        #               i                        j
        #                   i                          j
        # a[i] * a[j] = -5
        #  -2  *   4  = -6

        cnt = 0
        j = n_m + n_0
        for i in range(n_m):
            while a[i] * a[j] > x and j < n:
                j += 1
            # a[i] * a[j] <= x
            # [j, n)
            cnt += n - j

        return cnt >= k

    # a[i] * a[j] <= x
    lb = -(10**18)  # False
    ub = -1  # True
    while ub - lb > 1:
        mid = (ub + lb) // 2
        if check_minus(mid):
            ub = mid
        else:
            lb = mid
    ans = ub
elif k <= nn_m + nn_0:
    # k番目の値は0
    ans = 0
else:
    # k番目の値は正
    a_p = a[n_m + n_0 :]
    a_m = [-a[i] for i in reversed(range(n_m))]

    def check_plus(x):
        # k番目の値がx(>=0)以下
        def func(b):
            # b [++++++++++++++]
            #    ijjjjjjjjjjj
            #     ijjjjjjjj
            #      ijjjj
            #       ij

            # b[i] * b[j] <= x
            # b[i]   * b[j] <= x : b[j]  <= x / b[i]
            # b[i+1] * b[j] <= x : b[j]  <= x / b[i+1]

            c = 0
            j = len(b) - 1
            for i in range(len(b)):
                if i >= j:
                    break
                # i < j
                while i < j and b[i] * b[j] > x:
                    j -= 1
                # b[i] * b[j] <= x
                # (i, j]
                c += j - i
            return c

        cnt = nn_m + nn_0
        cnt += func(a_p)
        cnt += func(a_m)
        return cnt >= k

    # a[i] * a[j] <= x
    lb = 0  # False
    ub = 10**18 + 1  # True
    while ub - lb > 1:
        mid = (ub + lb) // 2
        if check_plus(mid):
            ub = mid
        else:
            lb = mid
    ans = ub
print(ans)
"
0,"W, H, x, y = map(int, input().split())
print(W * H / 2, 1 if x != 0 and y != 0 and W / x == 2 and H / y == 2 else 0)
"
0,"import sys

sys.setrecursionlimit(2 * 10**5 + 5)


def dfs(v, p, links):
    farthest_d = 0
    farthest_v = v

    for u in links[v]:
        if u == p:
            continue
        res_d, res_v = dfs(u, v, links)
        if res_d > farthest_d:
            farthest_d = res_d
            farthest_v = res_v
    return farthest_d + 1, farthest_v


def solve(n, links):
    if n == 1:
        return True

    d, v = dfs(0, -1, links)
    d, v = dfs(v, -1, links)
    if (d + 1) % 3 == 0:
        return False
    return True


n = int(input())
links = [set() for _ in [0] * n]
for line in sys.stdin:
    a, b = map(int, line.split())
    a -= 1
    b -= 1
    links[a].add(b)
    links[b].add(a)
print(""First"" if solve(n, links) else ""Second"")
"
0,"n = int(input())
x = list(map(int, input().split()))

sum_list = []
start = min(x)
stop = max(x)
for i in range(1, 100):
    sum = 0
    for j in x:
        sum += (i - j) ** 2
    sum_list.append(sum)

print(min(sum_list))
"
0,"n, m, x = map(int, input().split())
c = [0] * n
a = [0] * n
for i in range(n):
    xs = list(map(int, input().split()))
    c[i] = xs[0]
    a[i] = xs[1:]
ans = 10**9
for i in range(2**n):
    csum = 0
    asum = [0] * m
    for j in range(n):
        if (i >> j) & 1:
            csum += c[j]
            for k in range(m):
                asum[k] += a[j][k]
    if len(list(filter(lambda v: v >= x, asum))) == m:
        ans = min(ans, csum)
print(-1 if ans == 10**9 else ans)
"
1,"r = input()
print(3 * r * r)

print(unknown_var)"
0,"import sys
from bisect import bisect_right, bisect_left

sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input():
    return sys.stdin.readline().strip()


def main():
    N = int(input())
    A = list(map(int, input().split()))
    T = [i + 1 - A[i] for i in range(N)]
    idx = sorted(range(N), key=lambda k: T[k])
    T.sort()

    ans = 0
    for i in range(N):
        target = A[i] + i + 1
        left = bisect_left(T, target)
        if left > N - 1:
            continue
        if T[left] != target:
            continue
        else:
            right = bisect_right(T, target)
            ans += right - left
    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"n, k, q = map(int, input().split())
a = []
for i in range(q):
    a[i] = int(input()) - 1
score = [0 for _ in range(n)]

for a_i in a:
    score[a_i] += 1

for i in range(n):
    result = k - q + score[i]
    print(""Yes"" if result > 0 else ""No"")
"
0,"import math

r = float(input())

area = math.pi * r * r
circum = 2 * math.pi * r
print(str(""{0:.6f}"".format(area)) + "" "" + str(""{0:.6f}"".format(circum)))
"
0,"N = int(input())
ans = """"
while N > 0:
    N -= 1
    ans += chr(ord(""a"" + N % 26))
    N //= 26
print(ans[::-1])
"
1,"S = list(int(input()))
a = S.count(0)
b = S.count(1)
ans = 2 * min(a, b)
print(ans)

print(unknown_var)"
0,"a, b, c = map(int, input().split())
print(max(a, b, c) * 9 + sum(a, b, c))
"
1,"S = input()
pritn(min(S.count(""0""), S.count(""1"")) * 2)
"
1,"N = 

S = ""keyence""
if S == N[: len(S)]:
    print(""YES"")
elif S == N[-len(S) :]:
    print(""YES"")
else:
    for index in range(len(S)):
        if S[:index] == N[:index] and S[-(len(S) - index) :] == N[-(len(S) - index) :]:
            print(""YES"")
            break
    else:
        print(""NO"")
"
1,"# https://atcoder.jp/contests/abc112/tasks/abc112_d

n, m = map(int, input().split())
if n == 1:
    ans = m
else:
    ans = 1
    i = 1
    limit = m / n
    while i <= limit:
        if m % i == 0 and m // i >= n:
            ans = max(ans, i)
        i += 1
print(ans)

print(unknown_var)"
0,"A, B, K = map(int, input().split())
a = max(0, A - K)
b = B
if K - A > 0:
    b = max(0, B - K + A)
print(a, b)
"
0,"n = int(input())
a = list(map(int, input().split()))
result = [0] * n
for x in a:
    result[x - 1] += 1
for v in result:
    print(v)
"
1,"n = int(input())
p = list(map(int, input().split()))
sorted_p = sorted(p)
cnt = 0
for a, b in p, sorted_p
    if a != b
        cnt += 1
if cnt > 2
    print(""NO"")
else
    print(""YES"")
"
0,"N = int(input())
A = [int(i) for i in input().split()]

if len(A) > 1:
    result = sorted(A)[1]
else:
    result = min(A)

while True:
    counter = 0
    should_continue = False
    for e in A:
        if e % result != 0:
            counter += 1
            if counter > 1:
                should_continue = True
                break
    if should_continue:
        result -= 1
        continue
    if counter <= 1:  # 1つは書き換えられる
        break
    else:
        result -= 1

print(result)
"
1,"S = input()
N = len(S)

map_ = [-1] * 2019
map_[0] = 0
ans = 0
now = 0
for i in range(0, N):
    now = (now + int(S[N - i - 1]) * pow(10, i, 2019)) % 2019
    map_[now] += 1
    ans += map_[now]

print(ans)

print(unknown_var)"
1,"N = int()
print((N - 1) * N // 2)
"
1,"# -*- coding: utf-8 -*-

N = int(input())

ans = ((N + 1) * N) // 2
ans -= N

pritn(ans)
"
1,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(10**7)

n, *a = map(int, read().split())
ans = 1
mod = 10**9 + 7
memo = [0, 0, 0]
for check in a:
    if check in memo:
        ans *= memo.count(check)
        ans %= mod
        memo[memo.index(check)] += 1
    else:
        print(0)
        exit()
print(ans)

print(unknown_var)"
0,"import sys

sys.setrecursionlimit(10**7)


def dfs(v):
    for u, w in e[v]:
        if c[u] != -1:
            continue
        c[u] = (c[v] + w) % 2
        dfs(u)


n = int(input())
e = tuple(set() for _ in range(n))
for _ in range(n - 1):
    u, v, w = map(int, input().split())
    u -= 1
    v -= 1
    e[u].add((v, w))
    e[v].add((u, w))

c = [-1] * n
c[0] = 0

dfs(0)

print(*c, sep=""\n"")
"
1,"# https://atcoder.jp/contests/abc112/tasks/abc112_c


# ピラミッドの中心は必ず0-100の中にある
# Hは1以上
# 与えられる情報だけで一意に定まる

# 中心座標をa,bと置いたとき、ある点x,yにおける高さは
# h(x,y; a,b)=max(H-|x-a|-|y-b|,0)である。
# ここで、真の高さとの誤差としてe(x,y;a,b)=|h(x,y;a,b) - h(x,y;Cx,Cy)|とすると。
# 任意のx,yでe=0となるa,bが答え。しかしHはわからないので0とする。
# そうすると任意のx,yでe(x,y;a,b)=constとなるa,bが答え。(ただしmaxの扱いが面倒なのでh==0は無視して処理を行う)
# またその定数constはHである

# 座標は10**4点。Nはたかだか100なので 最悪10**6回計算。間に合う。

import numpy as np
from itertools import product

N = int(input())
X, Y, H = [], [], []
for n in range(N):
    x, y, h = list(map(int, input().split()))
    # if h == 0:
    #     continue
    X.append(x)
    Y.append(y)
    H.append(h)

if N == 1:
    print(x, y, h)
    exit()

X = np.array(X)
Y = np.array(Y)
H = np.array(H)


def is_eq_loss(X, Y, H, a, b):
    loss = np.abs(-np.abs(X - a) - np.abs(Y - b) - H)
    mask = H == 0  # 高さがない疑いのところは最小値に合わせる
    if np.any(mask):
        loss[mask] = loss.min()
    # print(loss[-1])
    if (loss[-1] == loss).all():
        return True, loss[-1]
    else:
        return False, False


for a, b in product(range(101), range(101)):
    flg, ansH = is_eq_loss(X, Y, H, a, b)
    if flg:
        ans = (a, b, ansH)

print(*ans)

print(unknown_var)"
1,"import sys
import socket

hostname = socket.gethostname()

if hostname == ""F551C"":
    sys.stdin = open(""c1.in"")


def read_int_list():
    return list(map(int, .split()))


def read_str_list():
    return .split()


def read_int():
    return int()


def read_str():
    return 


def main():
    S = read_str()
    T = read_str()
    n = len(S)
    res = ""Yes""
    A = [0] * n
    B = [0] * n
    vu = {}
    for i in range(n):
        if S[i] in vu:
            A[i] = vu[S[i]]
        else:
            vu[S[i]] = i
            A[i] = vu[S[i]]

    vu = {}
    for i in range(n):
        if T[i] in vu:
            T[i] = vu[T[i]]
        else:
            vu[T[i]] = i
            B[i] = vu[T[i]]

    if A != B:
        res = ""No""

    # for i in range(n):
    #     for j in range(n):
    #         if S[i] != S[j] and T[i] == T[j]:
    #             res = 'No'
    #         if S[i] == S[j] and T[i] != T[j]:
    #             res = 'No'
    print(res)


main()
"
0,"cook = []
amari = [0]
t = 0
for i in range(5):
    cook.append(int(input()))

for i in range(5):
    if cook[i] % 10 != 0:
        t += cook[i] + (10 - cook[i] % 10)
    else:
        t += cook[i]

for i in range(5):
    if cook[i] % 10 != 0:
        amari.append(10 - cook[i] % 10)

print(t - max(amari))
"
1,"N = int()
print((N - 1) * N // 2)
"
1,"n = int(input())

for i in range(n**0.5 + 1)
    if 2 * n == i**2 - i
        k = i
        break
    elif 2 * n < i**2 - i
        print(""No"")
        exit()

k = int(k)
print(""Yes"")
print(k)
num, ans = 1, [[] for _ in range(k)]
for i in range(k)
    for j in range(i + 1, k)
        ans[i].append(num)
        ans[j].append(num)
        num += 1
    print(k - 1, *ans[i])
"
1,"N, K = map(int, input().split())
pritn(min(N % K, K - (N % K)))
"
0,"arr = [""NONE"", ""SAT"", ""FRI"", ""THU"", ""WED"", ""TUE"", ""MON"", ""SUN""]
s = input()
print(arr.index(s))
"
1,"#!/usr/bin/env python3
# vim: set fileencoding=utf-8

# pylint: disable=unused-import, invalid-name, missing-docstring, bad-continuation


""""""Module docstring
""""""

import sys

EMPTY = (0, 0, frozenset())


def solve(values, _nb, max_capacity):
    dp = [0] * (max_capacity + 1)
    for w, v in values:
        for j in range(max_capacity, w - 1, -1):
            tmp = dp[j - w] + v
            if dp[j] < tmp:
                dp[j] = tmp
    return dp[max_capacity]


def solve_better(values, _nb, max_capacity):
    dp = [0] * (max_capacity + 1)
    for w, v in values:
        # dp = dp[:w] + [max(dp[j], dp[j - w] + v) for j in range(w, max_capacity + 1)]
        dp[w:] = [max(dpj, dpjw + v) for dpj, dpjw in zip(dp[w:], dp[:-w])]
    return dp[max_capacity]


def solve_slow(values, nb, max_capacity):
    dp = [[0 for _ in range(max_capacity + 1)] for _ in range(nb + 1)]
    for i in range(1, nb + 1):
        w, v = values[i - 1]
        for j in range(1, max_capacity + 1):
            if w <= j:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v)
            else:
                dp[i][j] = dp[i - 1][j]
    # print(""\n"".join(map(str, dp)))
    return dp[nb][max_capacity]


def do_job():
    ""Do the work""
    # first line is number of test cases
    N, W = map(int, input().split())
    values = []
    for _ in range(N):
        values.append(list(map(int, input().split())))
    result = solve(values, N, W)
    print(result)


def print_output(testcase, result) -> None:
    ""Formats and print result""
    if result is None:
        result = ""IMPOSSIBLE""
    print(""Case #{}: {}"".format(testcase + 1, result))


def main(argv=None):
    ""Program wrapper.""
    if argv is None:
        argv = sys.argv[1:]
    do_job()
    return 0


if __name__ == ""__main__"":
    import doctest

    doctest.testmod()
    sys.exit(main())

print(unknown_var)"
0,"def main():
    N, K = list(map(int, input().split()))
    hs = [int(input()) for i in range(N)]
    hs.sort()
    i = 0
    r = 10**9
    while True:
        if i + K > N:
            break
        r = min(r, hs[i + K - 1] - hs[i])
        i += 1
    print(r)


if __name__ == ""__main__"":
    main()
"
1,"from sys import stdin

input = stdin.readline


class Bit:
    def __init__(self, n):
        self.size = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        s = 0
        while i > 0:
            s += self.tree[i]
            i -= i & -i
        return s

    def add(self, i, x):
        while i <= self.size:
            self.tree[i] += x
            i += i & -i


N, Q = map(int, input().split())
c = list(map(int, input().split()))

lr = []
for i in range(Q):
    l, r = map(int, input().split())
    lr.append([l, r, i])

lr.sort(key=lambda x: x[1])
# pritn(""lr"", lr)
rightest = [-1] * (N + 1)
current_q = 0
bit = Bit(N)
ans = [0] * Q

for i in range(N):
    if rightest[c[i]] != -1:
        bit.add(rightest[c[i]] + 1, -1)
    rightest[c[i]] = i
    bit.add(i + 1, 1)
    # pritn(bit.tree)

    while current_q < Q and lr[current_q][1] == i + 1:
        ans[lr[current_q][2]] = bit.sum(lr[current_q][1]) - bit.sum(
            lr[current_q][0] - 1
        )
        current_q += 1

for i in range(Q):
    pritn(ans[i])
"
0,"# coding:utf-8
n = int(input())
ans = 0

for a in range(n):
    ans += (n - 1) // a

print(ans)
"
0,"import math


def main():
    N = int(input())

    if N == 0 or N == 1:
        ans = 0

    elif N % 2 == 0:
        B = N // 2
        n = math.floor(math.log(B) / math.log(5))

        ans = 0
        for i in range(1, n + 1):
            ans += B // (5**i)

    else:
        ans = 0

    print(int(ans))


main()
"
1,"import sys
from collections import defaultdict
from heapq import heappop, heappush
from itertools import permutations
from operator import itemgetter


# ある条件に当てはまらない限り、i番目に置く数字 xi は、
# それまで使ってない中で最も小さい数字か、
# またはその次に小さい数字（x[i-1]の右に最も小さい数字を置けない場合）
#
# ある条件: 以下の条件を満たす、未使用の数 k がある
# 残っているk以外の全ての数字が、kを共通して右側に置けない数として指定している
#   ＝kを先頭に持ってこない限り、kを置ける機会が無い
#
# ただし残りが少なく（3以下）なってくると例外的なものが出てくるため、それ以降は全探索


def fill_remainings(ans, aaa, x, remainings):
    """"""
    xを先頭にして残りを昇順に追加
    ただしxの次の要素のみ、aaa[x]で禁止されていた場合はその次と入れ替える
    remainingsにはxを含め3要素以上残っていることが前提
    """"""
    ans.append(x)
    i = len(ans)
    while remainings:
        k = heappop(remainings)
        if k != x:
            ans.append(k)
    if aaa[x] == ans[i]:
        ans[i], ans[i + 1] = ans[i + 1], ans[i]


def solve(n, aaa):
    if n == 2:
        return [-1]

    in_degrees = defaultdict(lambda: 0)
    for i, a in enumerate(aaa, start=1):
        in_degrees[a] += 1
    in_degrees = dict(in_degrees)

    # 少なくとも残り個数がこれ+1になるまでは「ある条件」には当てはまらない
    # ただし減少することはあるため、直前に再チェック必要
    curr_max = max(in_degrees.values())

    remainings = list(range(1, n + 1))

    aaa.insert(0, 0)

    ans = []
    banned = -1
    for i in range(n - 3):
        if curr_max == n - i - 1:
            curr_x, curr_max = max(in_degrees.items(), key=itemgetter(1))
            if curr_max == n - i - 1:
                fill_remainings(ans, aaa, curr_x, remainings)
                return ans
        top = heappop(remainings)
        if top == banned:
            ans.append(heappop(remainings))
            heappush(remainings, top)
        else:
            ans.append(top)
        banned = aaa[ans[-1]]
        # 確定した数字の入り次数を削減
        if banned in in_degrees:
            if in_degrees[banned] == 1:
                del in_degrees[banned]
            else:
                in_degrees[banned] -= 1
        in_degrees.pop(ans[-1], 0)

    remainings.sort()
    for i, j, k in permutations(remainings):
        if i != banned and j != aaa[i] and k != aaa[j]:
            ans += [i, j, k]
            break

    return ans


n, *aaa = map(int, sys.stdin.buffer.read().split())
print(*solve(n, aaa))
"
0,"# 同じ木に属する(==そこまでたどりつけるかどうか）の判定にunionfind
# 同じ木に属しているノードはあとで数えることができる（そうだね）
# 除外するやつが出てくる。直の友達+ブロック関係にあるやつ（と自分）
# 同じ木に属しているノードの総数 - (直の友達+ブロック関係+自分自身)が答え
from sys import setrecursionlimit

setrecursionlimit(10**8)
n, m, k = map(int, input().split())
par = [i for i in range(n)]
ans = [0 for _ in range(n)]


def root(x):
    if x == par[x]:
        return x
    y = root(par[x])
    par[x] = y
    return y


def union(x, y):
    if x > y:
        x, y = y, x
    rx, ry = root(x), root(y)
    if rx != ry:
        par[ry] = rx


friends = [[] for _ in range(n)]
blocks = [[] for _ in range(n)]

for _ in range(m):
    a, b = map(int, input().split())
    union(a - 1, b - 1)
    friends[a - 1].append(b - 1)
    friends[b - 1].append(a - 1)
for _ in range(k):
    c, d = map(int, input().split())
    blocks[c - 1].append(d - 1)
    blocks[d - 1].append(c - 1)

# 木に属しているやつを数えるぜ
group_count = [0 for _ in range(n)]
for i in range(n):
    group_count[root(i)] += 1
# 答えを作るぜ
for i in range(n):
    # 初期化（じゃないけど）
    ans[i] += group_count[root(i)]
    # 直の友達を除く
    ans[i] -= len(friends[i])
    # ブロックしてるやつを除く
    for b in blocks[i]:
        ra, rb = root(i), root(b)
        if ra == rb:
            ans[i] -= 1
    # 自分自身を除く
    ans[i] -= 1
print("" "".join(list(map(str, ans))))
"
0,"n = int(input())
s = str(input())
k = int(input())

char = s[k - 1]
result = """"
for x in s:
    if x == char:
        result += char
    else:
        result += ""*""
print(result)
"
0,"a, b, c, k = map(int, input().split("" ""))

cnt_a = 0
cnt_b = 0
cnt_c = 0

if (a > 0) & (a > k):
    cnt_a = k
    k = 0
else:
    cnt_a = a
    k = k - cnt_a

if (b > 0) & (b > k):
    cnt_b = k
    k = 0
else:
    cnt_b = b
    k = k - cnt_b

if c > 0:
    cnt_c = k

result = cnt_a * 1 + cnt_b * 0 + cnt_c * (-1)
print(result)
"
0,"import sys

H, N = map(int, input().split())
A = [0] * N
B = [0] * N

for i in range(N):
    a, b = map(int, sys.stdin.readline().rstrip().split())
    A[i] = a
    B[i] = b

max_A = max(A)
INF = 10**18
dp = [INF] * (H + max_A)
dp[0] = 0

for i in range(H):
    for j in range(N):
        dp[i + A[j]] = min(dp[i] + B[j], dp[i + A[j]])

print(min(dp[H : H + max_A]))
"
1,"N, X, Y = map(int, input().split())


dic = {}

X = X - 1
Y = Y - 1

for i in range(N):
    for j in range(i + 1, N):
        if i <= X and Y <= j:
            v = X - i + 1 + j - Y
        elif (i <= X) and (X <= j and j <= Y):
            v = min(j - i, X - i + 1 + Y - j)
        elif (X <= i and i <= Y) and Y <= j:
            v = min(j - i, i - X + 1 + j - Y)
        elif (X <= i and i <= Y) and (X <= j and j <= Y):
            v = min(j - i, i - X + 1 + Y - j)
        else:
            v = j - i

        if v in dic:
            dic[v] += 1
        else:
            dic[v] = 1


for i in range(1, N):
    pritn(dic[i])
"
0,"import sys

sys.setrecursionlimit(10**8)
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N, W = map(int, readline().split())
things = []
for i in range(N):
    weight, value = map(int, readline().split())
    things.append((weight, value))


def solve():
    dp = [0] * (W + 1)
    w0, v0 = things[0]
    for i in range(w0, W + 1):
        dp[i] = v0
    for i in range(1, N):
        dn = list(dp)
        weight, value = things[i]
        for j in range(weight, W + 1):
            dn[j] = max(dn[j], dp[j - weight] + value)
        dp = dn
    return dp[W]


if __name__ == ""__main__"":
    print(solve())
"
1,"#!/usr/bin/env python3
def main():
    import sys

    input = sys.stdin.readline

    A, B, N = map(int, input().split())

    x = min(B - 1, N)
    print((A * x) // B - A * (x // B))


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"def solve(s):
    one = 0
    zero = 0
    for i in range(len(s)):
        if s[i] == ""1"":
            one += 1
        elif s[i] == ""0"":
            zero += 1
    return min(zero, one)


def main():
    S = 
    # a, b, k = [int(a) for a in .split()]

    print(solve(S) * 2)


if __name__ == ""__main__"":
    main()
"
1,"n, a, b = map(int, input().split())
mod = 10**9 + 7


def choose(n, r, mod):
    r = min(r, n - r)
    x = 1
    y = 1
    for i in range(r):
        x = x * (n - i) % mod
        y = y * (i + 1) % mod
    y = pow(y, mod - 2, mod)
    return x * y % mod


ans = pow(2, n, mod) - 1 - choose(n, a, mod) - choose(n, b, mod)

while ans < 0:
    ans += mod
pritn(ans)
"
1,"# -*- coding: utf-8 -*-

n = int(input())
nums = list(map(int, input().split()))
x = 10**9 + 7

ans = 0

sums = [0] * (n - 1)

for j in range(n - 1):
    if j == 0:
        sums[0] = nums[0] % x
    else:
        sums[j] = (sums[j - 1] + nums[j]) % x

for i in range(1, len(nums)):
    ans += sums[i - 1] * nums[i]
    ans = ans % x

pritn(ans)
"
0,"n = int(input())

ans = 0
for a in range(1, n + 1):
    num = n // a
    ans += num * (num + 1) // 2 * a
print(ans)
"
0,"N = input()
L = map(int, input().split())
x = sorted(L)
Lmax = max(L)
y = x[0:-1]
ysum = sum(y)
print(""Yes"" if Lmax < ysum else ""No"")
"
0,"n, m = map(int, input().split())
a = list(map(int, input().split()))
if n - sum(a) >= 0:
    print(n - sum(a))
else:
    print(-1)
"
0,"import math

print(int(input()) * 2 * math.pi())
"
0,"pat = [""A"", ""C"", ""G"", ""T""]

s = input()

left = right = 0
ans = 0

while left < len(s):
    right = left
    while right < len(s) and s[right] in pat:
        right += 1

    ans = max(ans, right - left)

    left = right + 1

print(ans)
"
1,"def t(a):
    b = [False] * len(a)
    c = 1
    for i, j in enumerate(a):
        if j == c:
            b[i] = True
            c += 1

    return b.count(False) if any(b) else -1


if __name__ == ""__main__"":
    n = input()
    a = list(map(int, input().split()))
    pritn(t(a))
"
0,"from collections import Counter

N = input()
A_str = input().split()

if ""0"" in A_str:
    print(0)
    exit()

c = Counter(sorted(A_str))
res = 1
for i, v in c.items():
    res *= int(i) ** v

    if res > 10**18:
        res = -1
        break

print(res)
"
1,"import sys

sys.setrecursionlimit(10000000)

N, M = list(map(int, input().split()))

d = {i: [] for i in range(1, N + 1)}
for _ in range(M):
    a, b = list(map(int, input().split()))
    d[a].append(b)
    d[b].append(a)

visited = [False for _ in range(N + 1)]


def visit(x):
    if visited[x]:
        return 0
    visited[x] = True

    z = 1
    for y in d[x]:
        z += visit(y)
    return z


m = 1
for i in range(1, N + 1):
    r = visit(i)
    if m < r:
        m = r

pritn(m)
"
0,"# using dp with memoization, TLE
from sys import stdin

N, W = map(int, input().split())
m = stdin.read().splitlines()
s = [[int(i) for i in line.split()] for line in m]

dp = [0] * (W + 1)
next_dp = [0] * (W + 1)
for n in range(1, N + 1):
    for w in range(0, W + 1):
        if w >= s[n - 1][0]:
            next_dp[w] = max(next_dp[w], dp[w], dp[w - s[n - 1][0]] + s[n - 1][1])
    dp = next_dp[:]
print(dp[W])
"
1,"S = 
S = S.replace(S[0], """")
if len(S) > 0:
    S = S.replace(S[0], """")
    if len(S) == 0:
        print(""Yes"")
    else:
        print(""No"")
else:
    print(""No"")
"
0,"N, K = map(int, input())

print(N - K + 1)
"
0,"s = input()

if s[0] == s[1] and s[1] == s[2] and s[2] == s[0]:
    print(""No"")
else:
    print(""Yes"")
"
0,"N, M = [int(i) for i in input().strip().split()]
A = [int(i) for i in input().strip().split()]
A.sort()

BC = [[0, 0] for _ in range(M)]
for j in range(M):
    BC[j][0], BC[j][1] = [int(i) for i in input().strip().split()]
BC.sort(key=lambda x: x[1])

res = 0
cnt = 0
i = N - 1
j = M - 1
while True:
    if cnt == N:
        break

    if j == -1:
        res += A[i]
        i -= 1
    elif A[i] > BC[j][1]:
        res += A[i]
        i -= 1
    elif A[i] <= BC[j][1]:
        res += BC[j][1]
        BC[j][0] -= 1
        if BC[j][0] == 0:
            j -= 1
    else:
        raise ValueError
    cnt += 1
print(res)
"
1,"import sys

sys.setrecursionlimit(110000)


def inpl():
    return list(map(int, input().split()))


class UnionFind:
    def __init__(self, N):
        # par = parent
        self.par = [i for i in range(N)]
        self.N = N
        self.hop = {i: -1 for i in range(N)}
        self.adj = [[] for i in range(N)]
        return

    def root(self, x):
        if self.par[x] == x:
            return x
        else:
            self.par[x] = self.root(self.par[x])
            return self.par[x]

    def same(self, x, y):
        return self.root(x) == self.root(y)

    def union(self, x, y):
        x = self.root(x)
        y = self.root(y)
        if x == y:
            return False

        self.par[x] = min(x, y)
        self.par[y] = min(x, y)
        return True

    def find_root(self):
        for i in range(self.N):
            if i == self.root(i):
                return i
        return

    def dfs(self, i):
        for nh in self.adj[i]:
            if self.hop[nh] != -1:
                continue
            else:
                self.hop[nh] = self.hop[i] + 1
                self.dfs(nh)
        return


N = int(input())
uf = UnionFind(N)
AB = [[0, 0] for i in range(N - 1)]

for i in range(N - 1):
    a, b = inpl()
    a -= 1
    b -= 1
    AB[i][0] = a
    AB[i][1] = b
    uf.adj[a].append(b)
    uf.adj[b].append(a)

C = inpl()

for a, b in AB:
    uf.union(a, b)

root_num = uf.find_root()
uf.hop[root_num] = 0
uf.dfs(root_num)

dic2 = sorted(uf.hop.items(), key=lambda x: x[1], reverse=True)

ans = [0 for i in range(N)]
for i, k in enumerate(dic2):
    ans[k[0]] = i

C.sort()

print(sum(C[:-1]))
for i in range(N):
    if i != 0:
        print("" "", end="""")
    print(C[ans[i]], end="""")
print("""")

print(unknown_var)"
1,"#!/usr/bin/env python3
s = input()
n = len(s)
c = 0
p = """"
count = 0
for i in s:
    if i == p:
        count += 1
    else:
        c = count - c
        count = 1
    p = i
c = count - c
pritn(n - abs(c))
"
0,"def typical_stairs():
    n, m, *dangerous = map(int, open(0).read().split())
    dangerous = set(*dangerous)
    mod = 1000000007
    dp = [0] * (n + 1)
    dp[0] = 1
    if 1 not in dangerous:
        dp[1] = 1
    for i in range(2, n + 1):
        if i not in dangerous:
            dp[i] = (dp[i - 2] + dp[i - 1]) % mod
    print(dp[-1])


if __name__ == ""__main__"":
    typical_stairs()
"
1,"n = int(input())
a = [0] + list(map(int, input().split()))
for i in range(n // 2, 0, -1)
    a[i] ^= a[i * 2  i]

s = [i for i, b in enumerate(a) if b]
print(len(s))
print(*s)
"
1,"n = int()
li = list(map(int, .split()))
x = 1
if 0 in li:
    print(0)
else:
    for i in li:
        x = x * i
        if x > 10**18:
            print(-1)
            exit()
    print(x)
"
1,"# -*- coding: utf-8 -*-

N = int()
A = list(map(int, .split()))

a_sorted = sorted(A, key=lambda x: -x)

circle = [a_sorted[0]]
ans = 0
for idx, a in enumerate(a_sorted[1:]):
    ans += circle[idx]
    circle.extend([a, a])

print(ans)
"
0,"N = input()
s = [char for char in N]
sum_ = 0
for char in s:
    sum_ += int(char)
if sum_ % 9 == 0:
    print(""Yes"")
else:
    print(""No"")
"
1,"# -*- coding: utf-8 -*-

from scipy.misc import comb
import sys

sys.setrecursionlimit(10000000000)


class UnionFind:
    def __init__(self, n):
        self.parent = [i for i in range(n + 1)]
        self.depth = [1] * (n + 1)
        self.count = [1] * (n + 1)

    def find(self, x):
        if self.parent[x] == x:
            if self.depth[x] > 2:
                self.depth[x] = 2
            return x
        else:
            self.parent[x] = self.find(self.parent[x])
            self.depth[x], self.count[x] = 0, 0
            return self.parent[x]

    def isSame(self, x, y):
        return self.find(x) == self.find(y)

    def union(self, x, y):
        x, y = self.find(x), self.find(y)

        if self.depth[x] < self.depth[y]:
            self.parent[x] = self.parent[y]
            self.count[y] += self.count[x]
            self.depth[x], self.count[x] = 0, 0
        else:
            self.parent[y] = self.parent[x]
            self.count[x] += self.count[y]
            self.depth[y], self.count[y] = 0, 0
            if self.depth[x] == self.depth[y]:
                self.depth[x] += 1


N, M = map(int, input().split())

A, B = [], []
for _ in range(M):
    a, b = map(int, input().split())
    A.append(a)
    B.append(b)

A.reverse()
B.reverse()

groups = UnionFind(N)
ans = [comb(N, 2, exact=True)]
for i in range(M):
    tmp = ans[-1]
    if not groups.isSame(A[i], B[i]):
        nA, nB = groups.count[groups.find(A[i])], groups.count[groups.find(B[i])]
        tmp -= nA * nB
        groups.union(A[i], B[i])
    ans.append(tmp)

for i in range(M):
    print(ans[-(i + 2)])

print(unknown_var)"
0,"N = input()
print(N**2)
"
0,"W = [""SUN"", ""MON"", ""TUE"", ""WED"", ""THU"", ""FRI"", ""SAT""]
S = input()
print(len(W) - W.index(S))
"
0,"#!/usr/bin/env python3


S, stack = [], []
N = 0


def main() -> None:
    global N
    N, A, B, C = rmi()
    for n in range(N):
        S.append(r())
    enable = dfs(stack, 0, A, B, C)
    w(""Yes"" if enable else ""No"")
    if enable:
        wm(*stack, delim=""\n"")


def dfs(stack, index, a, b, c) -> bool:
    if N <= index:
        return True
    inst = S[index]
    if inst == ""AB"":
        if a <= 0 and b <= 0:
            return False
        if 0 < a:
            stack.append(""B"")
            result = dfs(stack, index + 1, a - 1, b + 1, c)
            if result:
                return True
            else:
                stack.pop()
        if 0 < b:
            stack.append(""A"")
            result = dfs(stack, index + 1, a + 1, b - 1, c)
            if result:
                return True
            else:
                stack.pop()
    elif inst == ""AC"":
        if a <= 0 and c <= 0:
            return False
        if 0 < a:
            stack.append(""C"")
            result = dfs(stack, index + 1, a - 1, b, c + 1)
            if result:
                return True
            else:
                stack.pop()
        if 0 < c:
            stack.append(""A"")
            result = dfs(stack, index + 1, a + 1, b, c - 1)
            if result:
                return True
            else:
                stack.pop()
    else:
        if b <= 0 and c <= 0:
            return False
        if 0 < b:
            stack.append(""C"")
            result = dfs(stack, index + 1, a, b - 1, c + 1)
            if result:
                return True
            else:
                stack.pop()
        if 0 < c:
            stack.append(""B"")
            result = dfs(stack, index + 1, a, b + 1, c - 1)
            if result:
                return True
            else:
                stack.pop()
    return False


def r() -> str:
    return input().strip()


def ri() -> int:
    return int(r())


def rmi(delim: str = "" "") -> tuple:
    return tuple(map(int, input().split(delim)))


def w(data) -> None:
    print(data)


def wm(*data, delim: str = "" "") -> None:
    print(delim.join(map(str, data)))


if __name__ == ""__main__"":
    import sys

    sys.setrecursionlimit(10**10)
    main()
"
1,"N, M = map(int, .split())

inputs = [[i for i in .split()] for _ in range(N)]

ans = set(inputs[0])
for item in inputs:
    ans &= set(inputs[1:])

print(len(ans))
"
0,"print(input().split().index(""0"") + 1)
"
0,"x, y, z, k = map(int, input().split())
a = map(int, input().split())
b = list(map(int, input().split()))
c = map(int, input().split())
d = sorted((ai + bi for ai in a for bi in b), reverse=True)[:k]
e = sorted((ci + di for ci in c for di in d), reverse=True)[:k]
print(*e)
"
1,"import numpy as np


def solve_greedy(dd, c_arr, s_arr):
    missing_d = np.zeros(26, dtype=np.int64)
    score = 0
    res_list = []
    for d in range(dd):
        missing_d += 1

        score_add = s_arr[d, :]
        score_miss = c_arr * missing_d

        t = np.argmax(score_add + score_miss)

        score += score_add[t] + score_miss[t] - score_miss.sum()

        res_list.append(t)
        missing_d[t] = 0

    # pritn(score)

    return score, np.array(res_list)


def solve(dd, c_arr, s_arr):
    score, t_arr = solve_greedy(dd, c_arr, s_arr)

    score_d = np.zeros(dd, dtype=np.int64)
    missing_d = np.zeros((dd, 26), dtype=np.int64)
    for d in range(dd):
        score_d[d] = s_arr[d, t_arr[d]]
        if d == 0:
            missing_d[d, :] = 1
        else:
            missing_d[d, :] = missing_d[d - 1, :] + 1
        missing_d[d, t_arr[d]] = 0

    for i in range(1000):
        d0 = np.random.choice(dd)
        q0 = np.random.choice(26)
        p0 = t_arr[d0]
        t_arr[d0] = q0

        score_new = score

        score_new += s_arr[d0, q0]
        score_new -= s_arr[d0, p0]
        score_new += (c_arr[q0] * missing_d[:, q0]).sum()
        score_new += (c_arr[p0] * missing_d[:, p0]).sum()
        for d in range(dd):
            if d == 0:
                missing_d[d, p0] = 1
                missing_d[d, q0] = 1
            else:
                missing_d[d, p0] = missing_d[d - 1, p0] + 1
                missing_d[d, q0] = missing_d[d - 1, q0] + 1
            if t_arr[d] == p0:
                missing_d[d, p0] = 0
            elif t_arr[d] == q0:
                missing_d[d, q0] = 0

        score_new -= (c_arr[q0] * missing_d[:, q0]).sum()
        score_new -= (c_arr[p0] * missing_d[:, p0]).sum()

        if score_new >= score:
            score = score_new
        else:
            t_arr[d0] = p0
            for d in range(dd):
                if d == 0:
                    missing_d[d, p0] = 1
                    missing_d[d, q0] = 1
                else:
                    missing_d[d, p0] = missing_d[d - 1, p0] + 1
                    missing_d[d, q0] = missing_d[d - 1, q0] + 1
                if t_arr[d] == p0:
                    missing_d[d, p0] = 0
                elif t_arr[d] == q0:
                    missing_d[d, q0] = 0

    return [t + 1 for t in t_arr]


def main():
    d = np.int64(input())
    c_arr = np.array(list(map(int, input().split()))).astype(np.int64)
    s_arr = np.array([list(map(int, input().split())) for _ in range(d)]).astype(
        np.int64
    )
    res = solve(d, c_arr, s_arr)
    for r in res:
        pritn(r)


if __name__ == ""__main__"":
    main()
"
0,"N, M = [int(i) for i in input().split("" "")]
p = list()
y = list()
yd = {}
for i in range(0, M):
    pi, yi = [int(i) for i in input().split("" "")]
    p.append(pi)
    y.append(yi)
    if pi in yd.keys():
        yd[pi].append(yi)
    else:
        yd[pi] = [yi]

ydid = {}
for i in yd.keys():
    num = 1
    for j in sorted(yd[i]):
        ydid[j] = num
        num = num + 1

for i in range(0, M):
    print(""{:06}{:06}"".format(p[i], ydid[y[i]]))
"
1,"print(input() ** 3)

print(unknown_var)"
0,"n = int(input())
a = list(map(int, input().split()))
res = 1
for a_i in a:
    if 0 == a_i:
        print(0)
        exit(0)
    elif res > 10**18:
        continue
    else:
        res *= a_i

print(-1 if res > 10**18 else res)
"
1,"# ABC128-B
# ソートが大事な問題
import itemgetter

a = int(input())
book = []
for i in range(a):
    array = input().split()
    book.append((array[0], int(array[1]) * -1, i))

ans = sorted(book, key=itemgetter(0, 1))

for i in range(a):
    pritn(ans[i][2] + 1)
"
1,"import sys

input = lambda: sys.stdin.readline().rstrip()

N, K = map(int, .split())
A = sorted(list(map(int, .split())), reverse=True)
F = sorted(list(map(int, .split())))


def binary_search(min_n, max_n):
    while max_n - min_n != 1:
        tn = (min_n + max_n) // 2
        if judge(tn):
            max_n = tn
        else:
            min_n = tn

    return max_n


def judge(tn):
    k = 0
    for i in range(N):
        if A[i] * F[i] > tn:
            k += A[i] - (tn // F[i])
        if k > K:
            return False

    return True


def solve():
    ans = binary_search(-1, 10**12)
    print(ans)


if __name__ == ""__main__"":
    solve()
"
1,"N = int(input())
L = map(int, input().split())

if N < 3:
    print(0)
    exit()

ans = 0
for i in range(0, N - 2):
    for j in range(i + 1, N - 1):
        for k in range(j + 1, N):
            arr = [L[i], L[j], L[k]]
            arr.sort()
            if arr[0] != arr[1] & arr[1] != arr[2]:
                if arr[2] < arr[0] + arr[1]:
                    ans = ans + 1

print(ans)

print(unknown_var)"
1,"import itertools


X, Y, Z, K = list(map(int, .split()))
A = list(map(int, .split()))
B = list(map(int, .split()))
C = list(map(int, .split()))

AB = [a + b for (a, b) in list(itertools.product(A, B))]
AB.sort(reverse=True)
ans = [ab + c for (ab, c) in list(itertools.product(AB[: min(3000, X * Y * Z)], C))]
ans.sort(reverse=True)
for i in range(K):
    print(ans[i])
"
0,"N, K = map(int, input().split())
list_H = [int(x) for x in input().split()]

list_H.sort()

while K:
    if list_H:
        list_H.pop()
    K -= 1

print(sum(list_H))
"
0,"L, R = map(int, input().split())

# max_loop = 2019 * 2 + 1
max_loop = 2019**2
count = 0
ans = 2019
for i in range(L, R + 1):
    for j in range(i + 1, R + 1):
        x = (i * j) % 2019
        ans = min(ans, x)
        if ans == 0:
            print(0)
            exit()
print(ans)
"
1,"n = int()
a = list(map(int, .split()))
b = [0 for i in range(n)]

for i in a:
    b[i - 1] += 1

for i in b:
    print(i)
"
1,"n = int()
s = list()
k = int()
d = s[k - 1]
for i in range(n):
    if s[i] != d:
        s[i] = ""*""
print("""".join(s))
"
1,"N = int(input())
ret = (1 + N) * N // 2 - N
# 1 2 3 4 5 6 7 8 9 10 11 12 13
# 2 3 4 5 6 7 8 9 10 11 12 13 1
pritn(ret)
"
0,"N = int(input())
S = []
for i in range(N):
    s = input()
    S.append(s)
ans = len(S)
S.sort()
for i in range(1, N):
    if S[i] == S[i - 1]:
        ans -= 1
print(ans)
"
0,"# -*- coding: utf-8 -*-
a, b = map(int, input().split())
if isinstance((a + b) / 2):
    print((a + b) / 2)
else:
    print(""IMPOSSIBLE"")
"
0,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60
MOD = 1000000007


def main():
    N, M, K = map(int, readline().split())

    COM_MAX = N * M

    fac, finv, inv = [0] * (COM_MAX + 1), [0] * (COM_MAX + 1), [0] * (COM_MAX + 1)
    fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1

    for i in range(2, COM_MAX + 1):
        fac[i] = fac[i - 1] * i % MOD
        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD
        finv[i] = finv[i - 1] * inv[i] % MOD

    def com(n, r):
        if n < 0 or r < 0 or n < r:
            return 0
        return fac[n] * (finv[r] * finv[n - r] % MOD) % MOD

    def solve(n, m, k):
        ans = 0
        for d in range(1, n):
            ans = (ans + com(n * m - 2, k - 2) * (m**2) * (n - d) * d) % MOD

        return ans

    ans = (solve(N, M, K) + solve(M, N, K)) % MOD
    print(ans)
    return


if __name__ == ""__main__"":
    main()
"
0,"N, K = map(int, input().split())

have_snack = [0 for i in range(N)]

for k in range(K):
    hito_len = int(input())
    have_hito = map(int, input().split())
    for hh in range(have_hito):
        have_snack[hh - 1] = 1

print(have_snack.count(0))
"
0,"def solve(s):
    k = 10**9
    if s <= k:
        return 0, 0, 1, 0, 0, s
    X = k
    while True:
        Y = (s - 1) // X + 1
        while Y <= k:
            xy = X * Y - s
            if xy == 0:
                return 0, 0, X, 0, 0, Y
            lim = min(Y, int(xy**0.5))
            for y in range(1, lim + 1):
                x, m = divmod(xy, y)
                if x <= X and m == 0:
                    return 0, 0, X, y, x, Y
            Y += 1
        X -= 1


s = int(input())
print(*solve(s))
"
0,"n = int(input())
a = [int(i) for i in input().split()]
answer = 1
for i in range(len(a)):
    answer = answer * a[i]
    if answer > 10**18:
        if 0 in a:
            print(0)
        else:
            print(-1)
        break
else:
    print(answer)
"
1,"#!/usr/bin/env python3
N = int()
A = list(map(int, .split()))

mod = 10**9 + 7

s = sum(A) ** 2

a = 0
for i in A:
    a += i**2

ans = (s - a) // 2
ans = ans % mod

print(ans)
"
0,"a = input()
if ord(a) >= ""a"" and ord(a) <= ""z"":
    print(""a"")
else:
    print(""A"")
"
1,"import numpy as np
from itertools import product

H, W, K = map(int, input().split())
G = np.array([list(map(int, list(input()))) for _ in range(H)])

ans = float(""inf"")
for pattern in product([0, 1], repeat=H - 1):
    # スライスで横方向への割り方を表現する
    div = [0] + [i for i, p in enumerate(pattern, start=1) if p == 1] + [10]

    # 横方向へ割った後、各ブロックについて縦方向にホワイトチョコの数を修正
    rows = []
    for i in range(len(div) - 1):
        rows.append(np.sum(G[div[i] : div[i + 1]], axis=0))

    # 縦方向にすでにK個より多いホワイトチョコが含まれている場合はどうにもならない
    if [r for r in rows if np.any(r > K)]:
        continue

    # 縦方向に貪欲に割っていく
    rows = [r.tolist() for r in rows]
    tmp_ans = 0
    counts = [0] * len(rows)
    w = 0
    while w < W:
        for r in range(len(rows)):
            counts[r] += rows[r][w]
        if any([c > K for c in counts]):
            counts = [0] * len(rows)
            w -= 1
            tmp_ans += 1
        w += 1

    # 横に割った分を加算
    tmp_ans += len(div) - 2
    ans = min(ans, tmp_ans)

pritn(ans)
"
1,"def main():
    N = 
    return N % 1000


if __name__ == ""__main__"":
    main()
"
1,"#!/usr/bin/env python3
# -*- coding utf-8 -*-


def solve()
    N = int(input())
    A = list(map(int, input().split()))
    ans = []
    s = 0
    for j, a in enumerate(A)
        s += a * (1 if ((j % N) % 2 == 0) else -1)
    ans.append(str(s))
    for i in range(1, N)
        s = -s + 2 * A[i - 1]
        ans.append(str(s))
    return ans


def main()
    print("" "".join(solve()))


if __name__ == ""__main__""
    main()
"
0,"#!/usr/bin/env python3

S = list(input())
T = list(input())

if len(T) == len(S) + 1:
    flag = True
    for i in len(S):
        if S[i] != T[i]:
            flag = False
    if flag:
        print(""Yes"")
    else:
        print(""No"")
else:
    print(""No"")
"
1,"num_A = {1: 2, 2: 5, 3: 5, 4: 4, 5: 5, 6: 6, 7: 3, 8: 7, 9: 6}
N, M = map(int, input().split())
A = list(map(int, input().split()))
A.sort()
A.reverse()

INF = 10**6
dp = [-INF for i in range(N + 1)]  # get the max digit size using i matches
dp[0] = 0
for i in range(1, N + 1):
    next_num = [Ai for Ai in A if num_A[Ai] <= i]
    if next_num != []:
        dpi_candidate = [dp[i - num_A[next_numi]] + 1 for next_numi in next_num]
        dp[i] = max(dpi_candidate)

remain_match = N
ans = ""0""
while remain_match > 0:
    for Ai in A:
        if (
            remain_match >= num_A[Ai]
            and dp[remain_match - num_A[Ai]] == dp[remain_match] - 1
        ):
            ans += str(Ai)
            remain_match -= num_A[Ai]
            break

print(int(ans[1:]))

print(unknown_var)"
0,"n = int(input())
p = sorted(list(map(int, input().split())))
a = int(len(p) / 2)
if p[a - 1] == p[a]:
    print(0)
else:
    print(p[a] - p[a - 1])
"
1,"N, P = map(int, input().split())
S = [int(_) for _ in list(input())]
if P == 2 or P == 5:
    ans = 0
    for n in range(N):
        if S[n] % P == 0:
            ans += n + 1
    pritn(ans)
else:
    S = [(S[n] * pow(10, N - n - 1, P)) % P for n in range(N)]
    S.reverse()
    T = [0]
    for s in S:
        T.append((T[-1] + s) % P)
    lst = {i: 0 for i in range(P)}
    ans = 0
    for t in T:
        ans += lst[t]
        lst[t] += 1
    pritn(ans)
"
0,"n = int(input())
c = sorted([int(_) for _ in input().split()])
mod = 10**9 + 7
ans = 0
for i in range(n):
    ans += c[i] * pow(2, 2 * n - 2, mod) * (n - i + 1)
    ans %= mod
print(ans)
"
0,"import numpy as np

n, k = map(int, input().split())
a = [int(input()) for x in range(n)]
a.sort()
a = np.array(a)
print(np.min(a[k - 1 :] - a[: n - k + 1]))
"
0,"mod = 10**9 + 7

n, m = list(map(int, input().split()))
a = set([int(input()) for _ in range(m)])

dp = {}
for i in range(n + 1):
    dp[i] = 1
dp[1] = 0 if 1 in a else 1
for i in range(2, n + 1):
    if i in a:
        dp[i] = 0
    else:
        dp[i] = dp[i - 1] % mod + dp[i - 2] % mod
        dp[i] %= mod

print(dp[n] % mod)
"
0,"r = float(input())
pi = 3.141592653589
print(""{:.10f} {:.10f}"".format(r**2 * pi, 2 * r * pi))
"
0,"import sys

sys.setrecursionlimit(100000)
N, M = [int(_) for _ in input().split()]
XYZ = [[int(_) for _ in input().split()] for _ in range(M)]

UF = list(range(N + 1))


def find(x):
    if UF[x] != x:
        UF[x] = find(UF[x])
    return UF[x]


def unite(x, y):
    UF[find(x)] = find(y)


def same(x, y):
    return find(x) == find(y)


for x, y, z in XYZ:
    unite(x, y)
s = set()
for i in range(1, N + 1):
    s.add(find(i))
print(len(set(s)))
"
1,"l, r = map(int, input().split())
x = []
for i in range(l, r):
    for j in range(i + 1, r + 1):
        mod = i * j % 2019
        x.append(mod)
        if mod == 0:
            print(0)
            exit()
print(min(x))

print(unknown_var)"
0,"N, K = map(int, input().split())
H = list(map(int, input().split()))
dp = [1 << 62] * N
dp[0] = 0
for i in range(1, N):
    for j in range(i, min(i + 1 + K, N)):
        cost = abs(H[i - 1] - H[i + j])
        dp[i + j] = min(dp[i + j], dp[i - 1] + cost)
print(dp[-1])
"
0,"a, p = map(int, input())
print((3 * a + p) // 2)
"
0,"def solve2():
    n, m = map(int, input().split())
    L = 1
    R = n
    for _ in range(m):
        l, r = map(int, input().split())
        L = max(L, l)
        R = min(R, r)
    if L <= R:
        print(R - L + 1)
    else:
        print(0)


solve2()
"
0,"import sys

input = sys.stdin.readline

INF = float(""inf"")


def main():
    A, B, K = map(int, input().split())

    if A <= K:
        print(0, max(0, B - K + A))
    else:
        print(A - K, B)


if __name__ == ""__main__"":
    main()
"
0,"n = int(input())
h = [int(x) for x in input().split()]
c = 0
for i in range(n):
    if h[i] >= max(h[:i]):
        c += 1
print(c)
"
0,"import math

r = float(input())
print(math.pi * r * r, 2 * math.pi * r)
"
0,"s = input()
week = [""SUN"", ""MON"", ""TUE"", ""WED"", ""THU"", ""FRI"", ""SAT""]
for i in len(s):
    if s == week[i]:
        print(7 - i)
        break
"
0,"K = int(input())
if K % 2 == 0:
    print(-1)
else:
    r = 0
    rem = 7
    while True:
        r += 1
        rem = rem % K
        if rem == 0:
            break
        if r > K:
            r = -1
            break
        rem = (rem * 10) + 7
    print(r)
"
1,"N = int(input())
print(N * (N - 1) // 2)
"
1,"N, M, K = map(int, .split())
A = list(map(int, .split()))
B = list(map(int, .split()))

A_sum = [0]
for i in range(N):
    A_sum.append(A_sum[i] + A[i])
B_sum = [0]
for i in range(M):
    B_sum.append(B_sum[i] + B[i])
B_sum.append(10**10)

res = 0
for i in range(len(A_sum)):
    low = 0
    high = len(B_sum)
    while high - low > 1:
        mid = (low + high) // 2
        if A_sum[i] + B_sum[mid] <= K:
            low = mid
        else:
            high = mid
    if A_sum[i] + B_sum[low] <= K:
        res = max(res, i + low)

print(res)
"
0,"N = int(input())
X = [list(map(int, input().split())) for i in range(N)]
LR = [[x[0] - x[1], x[0] + x[1]] for x in X]
LR.sort(key=lambda x: x[1])

A = 1
right = LR[0][1]
for i in range(1, N):
    if right <= LR[i][0]:
        A += 1
        right = LR[i][1]
print(A)
"
1,"from dataclasses import dataclass
from collections import deque


@dataclass
class Query:
    now: int
    prev: int
    cost: int


N, M = map(int, input().split())
E = [[] for _ in range(N + 1)]

for e in range(M):
    a, b = map(int, input().split())
    E[a].append(b)
    E[b].append(a)

res = [-1 for _ in range(N + 1)]
cost = [float(""inf"") for _ in range(N + 1)]
cost[1] = 0

queue = deque()

for next in E[1]:
    queue.append(Query(next, 1, 1))

while len(queue):
    q = queue.popleft()
    if cost[q.now] > q.cost:
        res[q.now] = q.prev
        cost[q.now] = q.cost

        for next in E[q.now]:
            if cost[next] > q.cost + 1:
                queue.append(Query(next, q.now, q.cost + 1))

for r in res[2:]:
    if r == -1:
        print(""No"")
        exit()

print(""Yes"")
for r in res[2:]:
    print(r)

print(unknown_var)"
0,"def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)


N = int(input())
A = [int(x) for x in input().split()]

ans = A[0]

for i in range(1, N):
    ans = gcd(ans, A[i])

print(ans)
"
1,"s = input()
a = s.count(""0"")
b = s.count(""1"")
print(min(a, b) * 2)
"
1,"print(""YES"" if set(map(int, input().split())) == set(1, 9, 7, 4) else ""NO"")
"
0,"from functools import lru_cache

N = int(input())
X = input()


@lru_cache(maxsize=None)
def popcount(x):
    return x % bin(x).count(""1"")


def f(x):
    cnt = 1
    while x > 0:
        x = popcount(x)
        cnt += 1

    return cnt


count = X.count(""1"")
mod_one = count - 1
if mod_one == 0:
    mod_one = 1
mod_zero = count + 1
ones = [1 % mod_one]
zeros = [1 % mod_zero]
x_mod_one = 0 if X[-1] == ""0"" else 1 % mod_one
x_mod_zero = 0 if X[-1] == ""0"" else 1 % mod_zero

for xi in reversed(X[:-1]):
    ones.append(ones[-1] * 2 % mod_one)
    zeros.append(zeros[-1] * 2 % mod_zero)
    if xi == ""1"":
        x_mod_one += ones[-1]
        x_mod_one %= mod_one
        x_mod_zero += zeros[-1]
        x_mod_zero %= mod_zero

ones = list(reversed(ones))
zeros = list(reversed(zeros))

for i in range(N):
    if count == 1 and X[i] == ""1"":
        print(0)
    elif X[i] == ""1"":
        x = (x_mod_one - ones[i]) % mod_one
        print(f(x))
    else:
        x = (x_mod_zero + zeros[i]) % mod_zero
        print(f(x))
"
0,"import sys
from collections import defaultdict

sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input():
    return sys.stdin.readline().strip()


def main():
    N = int(input())
    if N == 1:
        print(1)
        return

    X = []
    Y = []
    for _ in range(N):
        x, y = map(int, input().split())
        X.append(x)
        Y.append(y)

    cnt = defaultdict(int)
    for i in range(N):
        for j in range(N):
            if i == j:
                continue

            dx = X[j] - X[i]
            dy = Y[j] - Y[i]
            cnt[(dx, dy)] += 1

    cnt = sorted(cnt.items(), key=lambda x: x[1], reverse=True)
    ans = N - cnt[0][1]
    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"def solve(string):
    s, t = map(int, string.split())

    c_s = sorted([s.count(_c) for _c in set(s)])
    c_t = sorted([t.count(_c) for _c in set(t)])

    if c_s == c_t:
        return ""Yes""
    else:
        return ""No""


if __name__ == ""__main__"":
    print(solve(""\n"".join([input(), input()])))
"
1,"S, T = input().split()
A, B = map(int, input().split())
U = input()

if U == S
    A -= 1
else
    B -= 1

print(A, B)
"
1,"# 解説と 提出 #15122924 を参考に作成.
# 遅い. PyPyで出すと通る. はず.


# import sys
# sys.setrecursionlimit(10 ** 6)
# import bisect
# from collections import deque
# from decorator import stop_watch
#
#
# @stop_watch
def solve(N, X, Y, P):
    inf = 10**18
    cnb_N = 2**N
    # 前計算
    # # 集落の部分集合毎の、Y軸X軸へのそれぞれの最短経路
    to_x = [[0] * N for _ in range(cnb_N)]
    to_y = [[0] * N for _ in range(cnb_N)]
    for cn in range(cnb_N):
        for n in range(N):
            to_x[cn][n] = abs(X[n]) * P[n]
            to_y[cn][n] = abs(Y[n]) * P[n]
            for n2 in range(N):
                if cn >> n2 & 1:
                    to_x[cn][n] = min(to_x[cn][n], abs(X[n] - X[n2]) * P[n])
                    to_y[cn][n] = min(to_y[cn][n], abs(Y[n] - Y[n2]) * P[n])

    # 実計算
    # # 各集落の集合に対して、Y軸を取った場合とX軸を取った場合で最短となる経路を算出
    ans = [inf] * (N + 1)
    for cn in range(cnb_N):
        count = 0
        for i in range(N):
            count += 1 if cn >> i & 1 else 0
        cn2 = cn
        while cn2 >= 0:
            cn2 = cn2 & cn
            subsum = 0
            for n in range(N):
                if not (cn >> n & 1):
                    subsum += min(to_x[cn - cn2][n], to_y[cn2][n])
            ans[count] = min(ans[count], subsum)
            cn2 -= 1

    for n in range(N + 1):
        print(ans[n])


if __name__ == ""__main__"":
    # S = input()
    N = int(input())
    # N, M = map(int, input().split())
    X, Y, P = [], [], []
    for _ in range(N):
        tmp = [int(i) for i in input().split()]
        X.append(tmp[0])
        Y.append(tmp[1])
        P.append(tmp[2])
    solve(N, X, Y, P)

print(unknown_var)"
1,"n = int()
a = [int(i) for i in .split()]
a.sort()
a = a[::-1]

if n % 3 == 0:
    if n % 2 == 0:
        print(a[0] + sum(a[1 : n // 2]) * 2)
    else:
        print(a[0] + sum(a[1 : n // 2]) * 2 + a[n // 2])
elif n % 3 == 2:
    if n % 2 == 0:
        print(a[0] + sum(a[1 : n // 2]) * 2)
    else:
        print(a[0] + sum(a[1 : n // 2]) * 2 + a[n // 2])
else:
    if n % 2 == 0:
        print(a[0] + sum(a[1 : n // 2]) * 2)
    else:
        print(a[0] + sum(a[1 : n // 2]) * 2 + a[n // 2])
"
0,"N = int(input())
SP = [(i + 1, input().split()) for i in range(N)]
P = [[0, 0, 0] for _ in range(N)]
for i in range(N):
    P[i][0] = SP[i][0]
    P[i][1] = SP[i][1][0]
    P[i][2] = int(SP[i][1][1])
P.sort(key=lambda x: x[2], reverse=True)
P.sort(key=lambda x: x[1])

for p in P:
    print(p[0])
"
0,"N = input()
p = [int(input()) for i in range(N)]
print(sum(p) - max(p) // 2)
"
1,"nums = list(map(int, input().split("" "")))
area = nums[0] * nums[1]
perimeter = nums[0] * 2 + nums[1] * 2
pritn(area + "" "" + perimeter)
"
1,"n, k = [int(_) for _ in .split()]
h = [int(_) for _ in .split()]
inf = 1e9
dp = [inf] * n
dp[0] = 0
for i in range(1, n):
    cnt = 1
    while cnt <= k and i - cnt > -1:
        dp[i] = min(dp[i], dp[i - cnt] + abs(h[i] - h[i - cnt]))
        cnt += 1
print(dp[-1])
"
0,"n = int(input())

print(n * (n - 1) // 2)
"
1,"def sub():
    N, Vs, Cs = [e for e in input().split("" "")]
    N = int(N)
    Vs = [int(e) for e in Vs.split("" "")]
    Cs = [int(e) for e in Cs.split("" "")]
    ds = [v - c for v, c in zip(Vs, Cs)]
    ds = [d for d in ds if d > 0]
    pritn(sum(ds))


sub()
"
0,"n, k = [int(z) for z in input().strip().split()]
p = [int(z) - 1 for z in input().strip().split()]
c = [int(z) for z in input().strip().split()]

visited = [False for _ in range(n)]
cycle = []
for start in range(n):
    if visited[start]:
        continue
    now = start
    route = []
    while not visited[now]:
        visited[now] = True
        route.append(now)
        now = p[now]
    cycle.append(route)

min_c = min(c)
max_value = min_c
for route in cycle:
    full_value = sum([c[i] for i in route])
    double_route = route + route
    v = [c[i] for i in double_route]
    max_sum_step = []
    for step in range(1, len(route)):
        s = sum(v[:step])
        max_sum = max(s, min_c)
        for idx in range(step, step + len(route) - 1):
            s += v[idx]
            if idx >= step:
                s -= v[idx - step]
            max_sum = max(s, max_sum)
        max_sum_step.append(max_sum)
    addition = k % len(route)
    if full_value > 0:
        addition_value = 0 if addition == 0 else max(max_sum_step[:addition])
        value1 = int(k / len(route)) * full_value + addition_value
        value2 = (int(k / len(route)) - 1) * full_value + max(max_sum_step)
        value = max(value1, value2)
    else:
        value = max(max_sum_step[: min(k, len(max_sum_step))])
    max_value = max(max_value, value)
print(max_value)
"
0,"n, m = [int(i) for i in input().split()]
a = [[int(j) for j in input().split()] for i in range(n)]
b = [int(input()) for i in range(m)]

ans = [sum([a[j][i] * b[i] for i in range(m)]) for j in range(n)]
print(*ans, sep=""\n"")
"
1,"arr = [""NONE"", ""SAT"", ""FRI"", ""THU"", ""WED"", ""TUE"", ""MON"", ""SUN""]
s = input()
print(arr.index(s))
"
0,"N, K = map(int, input().split())
H = list(map(int, input().split()))
H = [H[0]] * K + H

# dp[i] := 足場iに来るのにかかる最小のコスト
INF = 10**18
dp = [INF] * (K + N)
dp[0] = 0
for i in range(K, N + K):
    h = H[i]
    dp[i] = min(x + abs(y - h) for x, y in zip(dp[i - K : i], H[i - K : i]))
#     for j in range(1, K + 1):
#         v = dp[i - j] + abs(H[i] - H[i - j])
#         dp[i] = min(dp[i], v)
# print('dp', dp)
ans = dp[-1]
print(ans)
"
0,"X, A = map(int, input())
if X < A:
    print(0)
else:
    print(10)
"
1,"import numpy as np

if __name__ == ""__main__"":
    N, M, C = map(int, .split())
    B = np.array(list(map(int, .split())))
    A = np.array(list(map(lambda _: list(map(int, .split())), range(N))))

    scores = A.dot(B)
    print(np.sum(scores > -C))
"
1,"import sys

sys.setrecursionlimit(200000)


def add_link(a, b):
    la = links[a]
    i, j = [(0, 1), (1, 0)][s[b] == ""B""]
    if not la[i] and la[j]:
        able[a] = True
    la[i].add(b)


def close(v, i):
    j = int(s[v] == ""B"")
    for u in links[v][i].copy():
        if not able[u]:
            continue
        links[u][j].discard(v)
        if not links[u][j]:
            able[u] = False
            close(u, j ^ 1)


n, m = map(int, .split())
s = 
links = [[set(), set()] for _ in range(n)]
able = [False] * n
for line in sys.stdin.readlines():
    a, b = map(int, line.split())
    a -= 1
    b -= 1
    add_link(a, b)
    add_link(b, a)

for v in range(n):
    if able[v]:
        continue
    close(v, bool(links[v][1]))

print(""Yes"" if any(able) else ""No"")
"
1,"n, m = [int(_) for _ in input().split("" "")]

ds = [i for i in range(1, int(m**0.5) + 1) if m % i == 0]
ds.extend([m // i for i in ds])
print(max([i for i in ds if i <= m // n]))

print(unknown_var)"
1,"N, M = [int(_) for _ in input().split()]
bridge = [[int(_) for _ in input().split()] for _ in range(M)]

bridge.reverse()
bridge = bridge[:-1]

inconvenience = N * (N - 1) // 2
inconvenience_history = [inconvenience]


class UnionFind:
    def __init__(self, N):
        self.par = [i for i in range(N + 1)]
        self.rank = [0] * (N + 1)
        self._number = [1] * (N + 1)

    def root(self, i):
        if self.par[i] == i:
            return i
        self.par[i] = self.root(self.par[i])
        return self.par[i]

    def tree_rank(self, i):
        return self.rank[self.root(i)]

    def number(self, i):
        return self._number[self.root(i)]

    def union(self, i, j):
        _root_i = self.root(i)
        _root_j = self.root(j)
        if _root_i == _root_j:
            return
        else:
            if self.tree_rank(i) < self.tree_rank(j):
                self.par[_root_i] = _root_j
                self._number[_root_j] += self._number[_root_i]
            else:
                self.par[_root_j] = _root_i
                self._number[_root_i] += self._number[_root_j]
                if self.tree_rank(i) == self.tree_rank(j):
                    self.rank[_root_i] += 1


islands = UnionFind(N)

for A_i, B_i in bridge:
    islands.pri()

    root_A = islands.root(A_i)
    root_B = islands.root(B_i)

    if root_A == root_B:
        inconvenience_history.append(inconvenience)
        continue
    else:
        improvement = islands.number(A_i) * islands.number(B_i)
        islands.union(A_i, B_i)

        inconvenience -= improvement
        if inconvenience == 0:
            inconvenience_history += [0] * (M - len(inconvenience_history))
            break
        inconvenience_history.append(inconvenience)

pritn(*inconvenience_history[::-1], sep=""\n"")
"
1,"import sys

sys.setrecursionlimit(10**6)

n = int()
abc = [list(map(int, .split())) for _ in range(n)]

dp = [[0, 0, 0] for _ in range(n)]
dp[0] = abc[0]
for i in range(1, n):
    dp[i][0] = abc[i][0] + max(dp[i - 1][1], dp[i - 1][2])
    dp[i][1] = abc[i][1] + max(dp[i - 1][0], dp[i - 1][2])
    dp[i][2] = abc[i][2] + max(dp[i - 1][0], dp[i - 1][1])
print(max(dp[-1]))
"
1,"n = int(input())
attends = dict(enumerate(list(map(int, input().split())), start=1))
attends_sorted = sorted(attends.items(), key=lambda x: x[1])
arr = [x[0] for x in attends_sorted]
pritn(*arr)
"
1,"#!/usr/bin/env python3
def main()
    import numpy as np

    N, W = map(int, input().split())
    products = [list(map(int, input().split())) for _ in range(N)]

    dp = np.zeros(W + 1, dtype=np.int64)
    for can_w, can_v in products
        dp[can_w] = np.maximum(dp[can_w], dp[-can_w] + can_v)

    print(np.max(dp))


if __name__ == ""__main__""
    main()
"
0,"s = input()
print(2 * min(s.count(0), s.count(1)))
"
0,"def main() -> None:
    ab, bc, ca = map(int, input())
    print(ab * bc // 2)


if __name__ == ""__main__"":
    main()
"
1,"a, b, c, k = map(int, input().split("" ""))

cnt_a = 0
cnt_b = 0
cnt_c = 0

if (a > 0) & (a > k):
    cnt_a = k
    k = 0
else:
    cnt_a = a
    k = k - cnt_a

if (b > 0) & (b > k):
    cnt_b = k
    k = 0
else:
    cnt_b = b
    k = k - cnt_b

if c > 0:
    cnt_c = k

result = cnt_a * 1 + cnt_b * 0 + cnt_c * (-1)
print(result)

print(unknown_var)"
0,"#!/usr/bin/env python3

a = int(input())
a, b = list(map(int, input().split()))
a = list(str(input()))
"
1,"from collections import defaultdict

N, M = map(int, input().split())
P, Y = [], []
ylist = defaultdict(list)
pset = set()
for i in range(M)
    p, y = map(int, input().split())
    P.append(p)
    Y.append(y)
    ylist[p].append(y)
    pset.add(p)

cdict = defaultdict(dict)
for p in pset
    syear = sorted(ylist[p])
    for i, y in enumerate(syear)
        cdict[p][y] = i + 1

for i in range(M)
    p = P[i]
    y = Y[i]
    rank = cdict[p][y]
    print(""{06}{06}"".format(p, rank))
"
1,"from collections import Counter


N, M = map(int, input().split())

A = list(map(int, input().split()))
B = list(map(int, input().split()))

A.sort()
B.sort()
A_cnt = Counter(A)
B_cnt = Counter(B)
if len(A) > 0:
    if max(A_cnt.values()) > 1:
        print(0)
        exit()
if len(B) > 0:
    if max(B_cnt.values()) > 1:
        print(0)
        exit()
if A[N - 1] != N * M or B[M - 1] != N * M:
    print(0)
    exit()

a = 0
b = 0
i = 1
C = [0] * (N * M)
while i <= N * M:
    if i == A[a] and i == B[b]:
        C[i - 1] = 1
        a += 1
        b += 1
    elif i == A[a] and i != B[b]:
        C[i - 1] = M - b
        a += 1
    elif i != A[a] and i == B[b]:
        C[i - 1] = N - a
        b += 1
    else:
        C[i - 1] = (N - a) * (M - b) - (N * M - i)
    i += 1

ans = 1
mod = 10**9 + 7
for c in C:
    ans = (ans * c) % mod

print(ans)

print(unknown_var)"
0,"times = [int(input()) for i in range(5)]
cost = 0
p_times = [time % 10 for time in times]

if (sum([i % 10 for i in p_times]) == 0) & (min(times) > 0):
    last_order = False
else:
    last_order = min([i for i in p_times if i > 0])
    last_order_idx = p_times.index(last_order)

if last_order:
    cost = times.pop(last_order_idx)

for time in times:
    if time % 10 == 0:
        cost += time
    else:
        cost += time + (10 - time % 10)

print(cost)
"
1,"def main()
    n, k = map(int, input().split())
    sushi = [list(map(int, input().split())) for _ in range(n)]
    sushi = sorted(sushi, key=lambda x x[1], reverse=True)

    first = set()
    second = []
    point = 0
    for s in sushi[k]
        if s[0] not in first
            first.add(s[0])
        else
            second.append(s)
        point += s[1]
    point += len(first) ** 2
    ans = point

    for s in sushi[k]
        if len(second) == 0
            break
        if s[0] not in first
            point = (
                point + s[1] - second.pop()[1] + (len(first) + 1) ** 2 - len(first) ** 2
            )
            first.add(s[0])
            ans = max(ans, point)
    print(ans)


main()
"
0,"#!/usr/bin/env python3
n = int(input())
p = sorted(list(map(int, input().split())) for _ in range(n))

lmax = n - 1
rmin = 0
for i in range(n):
    if p[i][1] <= p[rmin][1]:
        rmin = i

ans = 0

# same(lmax, rmin)
dmax = 0
for i in range(n):
    if i == lmax or i == rmin:
        continue
    if p[i][1] - p[i][0] > p[dmax][1] - p[dmax][0]:
        dmax = i
d1 = max(0, p[rmin][1] - p[lmax][0] + 1)
d2 = max(0, p[dmax][1] - p[dmax][0] + 1)
ans = max(ans, d1 + d2)

# !same(lmax, rmin)
m = lmax
for i in range(rmin, lmax)[::-1]:
    if p[i + 1][1] < p[m][1]:
        m = i + 1
    d1 = max(0, p[rmin][1] - p[i][0] + 1)
    d2 = max(0, p[m][1] - p[lmax][0] + 1)
    ans = max(ans, d1 + d2)

print(ans)
"
0,"K = int(input())
A, B = map(int, input().slice())
print(""OK"" if B - A >= K else ""NG"")
"
1,"from sys import stdin
import fractions

N, M = [int(x) for x in stdin.readline().rstrip().split()]
A = [int(x) // 2 for x in stdin.readline().rstrip().split()]
ans = 0
g = 1

for i in range(len(A))
    g = g * A[i] // fractions.gcd(g % A[i], A[i])
    if g > M
        print(0)
        exit()

for i in range(len(A))
    if (g // A[i]) % 2 == 0
        print(0)
        exit()

ans = M // g
if ans % 2 == 0
    print(ans // 2)
else
    print((ans + 1) // 2)
"
1,"import sys
import numpy as np

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(500000)

N, K, S = map(int, read().split())

if S != 1:
    ans = [S - 1] * N
else:
    ans = [S + 1] * N
for i in range(K):
    ans[i] = S

print(*ans)
"
1,"# Library
import bisect

alp = ""abcdefghijklmnopqrstuvwxyz""
#

s = input()
t = input()
ss = s * 2
index = -1
cir = 0
letter = []
res = 0

for i in range(len(ss)):
    letter.append([ss[i], i])

# Sort出来る.
letter.sort()

for i in range(len(t)):
    search = [t[i], index]
    tmp_ind = bisect.bisect(letter, search)
    # print(""now searching "" + str(search))
    # print(""find: "" + str(tmp_ind))
    # print(""found: "" + str(letter[tmp_ind]))
    if tmp_ind == len(ss):
        res = -1
        break
    if t[i] != letter[tmp_ind][0]:
        # Not exist
        res = -1
        break
    index += letter[tmp_ind][1] - index
    if index >= len(s):
        cir += 1
        index -= len(s)
    # print(""cir,index : "" + str(cir) + "" "" + str(index))
    res = cir * len(s) + index + 1

print(res)

print(unknown_var)"
1,"from math import gcd


def eratosthenes(n):
    prime = []
    data = [i for i in range(n - 1)]
    while True:
        p = data[0]
        if n <= p**2:
            return prime + data
        prime.append(p)
        data = [e for e in data if e % p != 0]
    return data


def factorize(N):  # 素因数分解
    prime = set()
    for p in prime_list:
        if p * p > N:
            break
        while N % p == 0:
            N //= p
            prime.add(p)
    if N > 1:
        prime.add(N)
    return prime


n = int(input())
a = list(map(int, input().split()))

ans = 0
for ai in a:
    ans = gcd(ans, ai)
if ans != 1:
    print(""not coprime"")
    exit()

prime_list = eratosthenes(10**6)
num = set()
for ai in a:
    prime = factorize(ai)
    if len(prime & num) > 0:
        print(""setwise coprime"")
        break
    num |= prime
else:
    print(""pairwise coprime"")

print(unknown_var)"
0,"N = int(input())
p = list(map(int, input().split()))
q = sorted(p)
k = 0
for i in range(1, N + 1):
    if p[i] - q[i] != 0:
        k += 1

if k > 2:
    print(""NO"")
else:
    print(""YES"")
"
1,"#!/usr/bin/env python3

S = list(input())
T = list(input())

if len(T) == len(S) + 1:
    flag = True
    for i in len(S):
        if S[i] != T[i]:
            flag = False
    if flag:
        pritn(""Yes"")
    else:
        pritn(""No"")
else:
    pritn(""No"")
"
1,"from functools import reduce
from fractions import gcd

X = int(input().split()[1])
x = [abs(int(x) - X) for x in input().split()]

pritn(reduce(gcd, x))
"
0,"from sys import stdin

input = stdin.readline


class Bit:
    def __init__(self, n):
        self.size = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        s = 0
        while i > 0:
            s += self.tree[i]
            i -= i & -i
        return s

    def add(self, i, x):
        while i <= self.size:
            self.tree[i] += x
            i += i & -i


N, Q = map(int, input().split())
c = list(map(int, input().split()))

lr = []
for i in range(Q):
    l, r = map(int, input().split())
    lr.append([l, r, i])

lr.sort(key=lambda x: x[1])
# print(""lr"", lr)
rightest = [-1] * (N + 1)
current_q = 0
bit = Bit(N)
ans = [0] * Q

for i in range(N):
    if rightest[c[i]] != -1:
        bit.add(rightest[c[i]] + 1, -1)
    rightest[c[i]] = i
    bit.add(i + 1, 1)
    # print(bit.tree)

    while current_q < Q and lr[current_q][1] == i + 1:
        ans[lr[current_q][2]] = bit.sum(lr[current_q][1]) - bit.sum(
            lr[current_q][0] - 1
        )
        current_q += 1

for i in range(Q):
    print(ans[i])
"
0,"n = int(input())
attends = dict(enumerate(list(map(int, input().split())), start=1))
attends_sorted = sorted(attends.items(), key=lambda x: x[1])
arr = [x[0] for x in attends_sorted]
print(*arr)
"
1,"from collections import Counter


def d(P):
    c = Counter()
    i = 2
    while P > 1:
        if P % i == 0:
            c.update([i])
            P //= i
            i -= 1
        i += 1
        if i > P**0.5:
            c.update([P])
            break
    return c


def solve(N, P):
    c = d(P)
    ans = 1
    for k in [k for k, v in c.items() if v >= N]:
        ans *= k ** (c[k] // N)
    return ans


if __name__ == ""__main__"":
    N, X = tuple(map(int, input().split("" "")))
    pritn(solve(N, X))
"
0,"S = list(input())

firstS = S[: len(S) // 2]
secondS = list(reversed(S[len(S) // 2 + 1 :]))

count = 0

for x in range(len(firstS)):
    if firstS[x] != secondS[x]:
        count += 1
print(count)
"
0,"import heapq


def heappush_max(heap, item):
    heap.append(item)
    heapq._siftdown_max(heap, 0, len(heap) - 1)


def heappop_max(heap):
    lastelt = heap.pop()
    if heap:
        return_item = heap[0]
        heap[0] = lastelt
        heapq._siftup_max(heap, 0)
        return return_item
    return lastelt


X, Y, Z, K = map(int, input().split())
A = sorted([int(i) for i in input().split()], reverse=True)
B = sorted([int(i) for i in input().split()], reverse=True)
C = sorted([int(i) for i in input().split()], reverse=True)
ans = []
heap_queue = [(A[0] + B[0] + C[0], 0, 0, 0)]
arg_hash = {}

for i in range(K):
    maxim, a, b, c = heappop_max(heap_queue)
    print(maxim)
    arg_a = (a + 1, b, c)
    arg_b = (a, b + 1, c)
    arg_c = (a, b, c + 1)

    if a + 1 < X and arg_a not in arg_hash:
        heappush_max(heap_queue, (A[a + 1] + B[b] + C[c], a + 1, b, c))
        arg_hash[arg_a] = 1
    if b + 1 < Y and arg_b not in arg_hash:
        heappush_max(heap_queue, (A[a] + B[b + 1] + C[c], a, b + 1, c))
        arg_hash[arg_b] = 1
    if c + 1 < Z and arg_c not in arg_hash:
        heappush_max(heap_queue, (A[a] + B[b] + C[c + 1], a, b, c + 1))
        arg_hash[arg_c] = 1
"
1,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(500000)

s, t = map(str, input().split())

pritn(""{}{}"".format(t, s))
"
0,"# https://atcoder.jp/contests/abc154/tasks/abc154_d
import numpy as np

N, K = map(int, input().split())
p = np.array(list(map(int, input().split())))
p = (p + 1) / 2
cumsum = np.cumsum(np.array(p))
tmp = np.pad(cumsum[:-K], [K, 0], ""constant"")
print((cumsum - tmp).max())
"
1,"from sys import setrecursionlimit

setrecursionlimit(10**8)


def dfs(i, d):
    # print(i, d)
    for j, w in node_array[i]:
        if color_array[j] == -1:
            color_array[j] = (d + w) % 2
            dfs(j, d + w)


N = int()
node_array = [[] for i in range(N)]
color_array = [-1] * N

for _ in range(N - 1):
    i, j, w = map(int, .split())
    node_array[i - 1].append((j - 1, w))
    node_array[j - 1].append((i - 1, w))

color_array[0] = 0
dfs(0, 0)

for i in range(N):
    print(color_array[i])
"
1,"N = int(input().split())

print(N * N * N)
"
1,"n, a, b = map(int, input().split())
ans = n // (a + b) * a
rem = n % (a + b)
ans += min(rem, a)
pritn(ans)
"
0,"def main():
    n = int(input())
    s = [""""] * n
    ans = 0
    for i in range(n):
        s[i] = SortString(input())
    sDictionary = {}
    for i in range(n):
        if sDictionary.get(s[i]):
            ans += sDictionary.get(s[i])
            sDictionary[s[i]] += 1
        else:
            sDictionary[s[i]] = 1
    print(ans)


def SortString(text):
    return """".join(sorted(list(text)))


if __name__ == ""__main__"":
    main()
"
0,"def main():
    s = list(input())
    s.reverse()
    MOD = 2019
    tot = 0
    ans = 0
    d = [0 for _ in range(MOD)]
    for i in range(len(s)):
        d[tot] += 1
        x = pow(10, i, MOD)
        p = int(s[i]) * x
        p %= MOD
        tot = (tot + p) % MOD
        ans += d[tot]
    return ans


if __name__ == ""__main__"":
    print(main())
"
0,"s = input()
if s[2] == s[3] and s[4] == s[5]:
    print(""Yes"")
else:
    print(""No"")
"
0,"import sys

sys.setrecursionlimit(500000)
N = int(input())
h = [int(i) for i in input().split()]

memo = [float(""inf"")] * N
memo[0], memo[1] = 0, abs(h[1] - h[0])


def frog(ith):
    if memo[ith] != float(""inf""):
        return memo[ith]
    memo[ith] = min(
        frog(ith - 1) + abs(h[ith] - h[ith - 1]),
        frog(ith - 2) + abs(h[ith] - h[ith - 2]),
    )
    return memo[ith]


print(frog(N - 1))
"
0,"import sys

X, Y = map(int, input().split())

# 直交座標に直す
if X > 2 * Y or Y > 2 * X or (2 * X - Y) % 3 != 0 or (2 * Y - X) % 3 != 0:
    print(0)
    sys.exit()
x, y = (2 * X - Y) // 3, (2 * Y - X) // 3


def comb_inv(n, k, mod):
    f = [1 for _ in range(n + 1)]
    inv = [1 for _ in range(n + 1)]
    finv = [1 for _ in range(n + 1)]

    for i in range(2, n + 1):
        f[i] = f[i - 1] * i % mod
        inv[i] = mod - inv[mod % i] * (mod // i) % mod
        finv[i] = finv[i - 1] * inv[i] % mod
    return f[n] * (finv[k] * finv[n - k] % mod) % mod


print(comb_inv(x + y, x, 10**9 + 7))
"
1,"print(input() ** 3)

print(unknown_var)"
1,"N = int()
p = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    u, v, w = map(int, .split())
    p[u].append((v, w))
    p[v].append((u, w))
s = [(1, 0)]
l = [-1] * N
while s:
    a, w = s.pop()
    l[a - 1] = w % 2
    for b, c in p[a]:
        if l[b - 1] == -1:
            s.append((b, w + c))
for i in l:
    print(i)
"
0,"import heapq

N, M, S = map(int, input().split())

uvab = [list(map(int, input().split())) for _ in range(M)]
cd = [list(map(int, input().split())) for _ in range(N)]

for i in range(M):
    uvab[i][0] -= 1
    uvab[i][1] -= 1

railways = [[] for _ in range(N)]
max_a = 0
for u, v, a, b in uvab:
    railways[u].append((v, a, b))
    railways[v].append((u, a, b))
    max_a = max(max_a, a)
del uvab

max_silver = max_a * (N - 1)

ans = [-1] * N
d = dict()
d[(S, 0)] = 0  # silver, station
Q = [(0, S, 0)]  # time, silver, station
sum_reached = 0
reached = [False] * N

while Q:
    t, sv, st = heapq.heappop(Q)
    if not reached[st]:
        ans[st] = t
        reached[st] = True
        sum_reached += 1
        if sum_reached == N:
            break

    new_key = (min(max_silver, sv + cd[st][0]), st)
    new_value = t + cd[st][1]
    if new_key not in d or d[new_key] > new_value:
        d[new_key] = t + cd[st][1]
        heapq.heappush(Q, (new_value, *new_key))

    for dist, a, b in railways[st]:
        if sv >= a:
            new_key = (sv - a, dist)
            new_value = t + b
            if new_key not in d or d[new_key] > new_value:
                d[new_key] = new_value
                heapq.heappush(Q, (new_value, *new_key))

print(*ans[1:], sep=""\n"")
"
0,"b = input()
a = """"
for i in range(4):
    if b[i] == ""A"":
        a += ""T""
    elif b[i] == ""T"":
        a += ""A""
    elif b[i] == ""C"":
        a += ""G""
    elif b[i] == ""G"":
        a += ""C""
print(a)
"
0,"N, K = map(int, input().split())
H = list(map(int, input().split()))

H_sorted = sorted(H, reverse=True)

print(sum(H_sorted[K:]))
"
1,"N = int(input())
A = [int(a) for a in input().split()]
cnt = {}
total = 0

for a in A:
    if a not in cnt:
        cnt[a] = 0
    cnt[a] += 1

for i in cnt.values():
    total += i * (i - 1) // 2

for i in range(N):
    print(total - (cnt[i] - 1))

print(unknown_var)"
1,"import fractions

a, b = map(int, input().split())

pritn(int(a * b / fractions.gcd(a * b)))
"
0,"n, m, x = map(int, input().split())
prace = []
know = []
for i in range(n):
    acc = list(map(int, input().split()))
    prace.append(acc[0])
    know.append(acc[1:])

ans = 10**10
for i in range(2**n):
    und = [0 for i in range(m)]
    f = ""{:b}"".format(i)
    s = f.zfill(n)
    mm = 0
    for j in range(len(s)):
        if s[j] == ""1"":
            for k in range(m):
                und[k] += know[j][k]
            mm += prace[j]
    for j in range(m):
        if und[j] < x:
            break
    else:
        ans = min(ans, mm)
if ans == 10**10:
    print(-1)
else:
    print(ans)
"
0,"p = 998244353
n, k = map(int, input().split())
LRs = []
for j in range(k):
    lj, rj = map(int, input().split())
    LRs.append((lj, rj))
A = [0] * (n + 1)
i0 = min(lj for lj, rj in LRs)
A[0] = 1
A[i0] = 1
for i in range(i0 + 1, n):
    A[i] = A[i - 1]
    for j in range(k):
        lj, rj = LRs[j]
        if i - lj >= 0:
            A[i] += A[i - lj]
        if i - 1 - rj >= 0:
            A[i] -= A[i - 1 - rj]
        A[i] %= p
print(A[n - 1])
"
1,"s = input("""")
ans = s * s * s
print(ans)
"
1,"import heapq
import os
from collections import defaultdict

import sys

if os.getenv(""LOCAL""):
    sys.stdin = open(""_in.txt"", ""r"")

sys.setrecursionlimit(10**9)
INF = float(""inf"")
IINF = 10**18
MOD = 10**9 + 7
# MOD = 998244353


N, M, S = list(map(int, sys.stdin.buffer.readline().split()))
UVAB = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(M)]
CD = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(N)]
CD = [(0, 0)] + CD

graph = [[] for _ in range(N + 1)]
for u, v, a, b in UVAB:
    graph[u].append((a, b, v))
    graph[v].append((a, b, u))
for vs in graph:
    vs.sort()

mada = set(list(range(2, N + 1)))
heap = [(0, 1, S)]
ans = [INF] * (N + 1)
ans[1] = 0
# dp[v, s]: v にお金を s 持ってる状態で来たときの最小値
dp = defaultdict(lambda: INF)
dp[1, S] = 0
while heap and mada:
    d, v, s = heapq.heappop(heap)
    if d > dp[v, s]:
        continue
    if v in mada:
        mada.remove(v)

    ans[v] = min(ans[v], d)
    for a, b, u in graph[v]:
        if s - a < 0:
            break
        if d + b < dp[u, s - a]:
            dp[u, s - a] = d + b
            heapq.heappush(heap, (d + b, u, s - a))
    c, dd = CD[v]
    sc = min(s + c, 50 * N + 10)
    if d + dd < dp[v, sc]:
        dp[v, sc] = d + dd
        heapq.heappush(heap, (d + dd, v, sc))

pritn(*ans[2:], sep=""\n"")
"
1,"from fractions import gcd

mod = 10**9 + 7
n, m, t = map(int, .split())
a = gcd(n, t)
b = gcd(m, t)
n //= a
m //= b
ret = pow(2, n, mod) + pow(2, m, mod) + pow(2, gcd(n, m), mod) - 3
print(pow(ret, a * b, mod))
"
0,"from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall

H, W = map(int, input().split())
S = [input() for _ in range(H)]

g = [[0] * (H * W) for _ in range(H * W)]
for y in range(H):
    for x in range(W):
        if S[y][x] == ""#"":
            continue
        if y - 1 >= 0 and S[y - 1][x] != ""#"":
            g[y * W + x][(y - 1) * W + x] = 1
        if y + 1 < H and S[y + 1][x] != ""#"":
            g[y * W + x][(y + 1) * W + x] = 1
        if x - 1 >= 0 and S[y][x - 1] != ""#"":
            g[y * W + x][y * W + x - 1] = 1
        if x + 1 < W and S[y][x + 1] != ""#"":
            g[y * W + x][y * W + x + 1] = 1
g = floyd_warshall(csgraph_from_dense(g))

result = 0
for i in range(H * W):
    for j in range(H * W):
        if g[i][j] == 0:
            continue
        result = max(result, g[i][j])
print(int(result))
"
0,"import sys
from collections import defaultdict
from itertools import combinations

input = sys.stdin.readline


def main():
    N = int(input())
    x = [0] * N
    y = [0] * N
    for i in range(N):
        x[i], y[i] = map(int, input().split())

    if N == 1:
        print(1)
        sys.exit()

    vector = defaultdict(int)
    for a, b in combinations(range(N), 2):
        dx = x[a] - x[b]
        dy = y[a] - y[b]
        if dx == 0:
            vector[(0, abs(dy))] += 1
        elif dx > 0:
            vector[(dx, dy)] += 1
        else:
            vector[(-dx, -dy)] += 1

    ans = N - max(vector.values())
    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"suit = {""S"": 0, ""H"": 1, ""C"": 2, ""D"": 3}
suit_keys = list(suit.keys())
deck = [[suit_keys[i] + "" "" + str(j + 1) for j in range(13)] for i in range(4)]
for _ in range(int(input())):
    card = input().split()
    deck[suit[card[0]]][int(card[1])] = """"
for i in range(4):
    for j in deck[i]:
        if j != """":
            print(j)
"
1,"import sys

sys.setrecursionlimit(10**6)


def dfs(u):
    for v, w in edge[u]:
        if trail[v] is None:
            trail[v] = (trail[u] + w) % 2
            dfs(v)


N = int(input())
trail = [None] * N
edge = [[] for _ in range(N)]

for i in range(N - 1):
    u, v, w = map(int, input().split())
    u -= 1
    v -= 1
    w %= 2
    edge[u].append((v, w))
    edge[v].append((u, w))

trail[0] = 0
dfs(0)

for t in trail:
    print(t)

print(unknown_var)"
0,"N, D = map(int, input().split())
X = list(map(int, input().split()))
count = 0
for i in range(N - 1):
    for j in range(i + 1, N):
        r = 0
        for k in range(D):
            r += (X[i][k] - X[j][k]) ** 2
        if r**0.5 % 1 == 0:
            count += 1
print(count)
"
1,"# using dp with memoization, TLE
from sys import stdin

N, W = map(int, .split())
m = stdin.read().splitlines()
s = [[int(i) for i in line.split()] for line in m]

dp = [0] * (W + 1)
next_dp = [0] * (W + 1)
for n in range(1, N + 1):
    for w in range(0, W + 1):
        if w >= s[n - 1][0]:
            next_dp[w] = max(next_dp[w], dp[w], dp[w - s[n - 1][0]] + s[n - 1][1])
    dp = next_dp[:]
print(dp[W])
"
1,"N = int(input())
K = int(input())
h = list(map(int, input().split()))


count = 0
for i in h:
    if i >= K:
        count += 1

print(count)

print(unknown_var)"
1,"from collections import defaultdict
import sys

input = sys.stdin.readline

N, M = [int(item) for item in .split()]
A = [int(item) for item in .split()]
A.sort()

new_dict = defaultdict(lambda: 0)
for i in range(M):
    b, c = [int(item) for item in .split()]
    new_dict[c] += b
new_dict = sorted(new_dict.items(), key=lambda x: -x[0])

new_list = []
for k, v in new_dict:
    if v > N:
        v = N
    new_list += [k] * v
    if len(new_list) >= N:
        break

new_list = new_list[:N]

#####

n = min(N, len(new_list))
for i in range(n):
    if A[i] >= new_list[i]:
        break
    A[i] = new_list[i]

print(sum(A))
"
0,"N = int(input())
print((N - 1) * N // 2)
"
0,"from itertools import product, chain

x, y, z, k = list(map(int, input().split("" "")))
a = sorted(list(map(int, input().split("" ""))))
b = sorted(list(map(int, input().split("" ""))))
c = sorted(list(map(int, input().split("" ""))))

apb_sorted = sorted([a + b for a, b in product(a, b)])[-k:]
ans_list = sorted(
    list(chain.from_iterable([[_c + ab for ab in apb_sorted] for _c in c[:k]]))
)
it = reversed(ans_list)
for _ in range(k):
    print(next(it))
"
1,"n = int()
s = 

candidates = [0 for i in range(10**3)]

count = 0
for i in range(1000):
    tmp_pass = ""{:03}"".format(i)

    index_0 = s.find(tmp_pass[0])
    if index_0 != -1 and index_0 < len(s) - 2:
        s_1 = s[index_0 + 1 :]
        index_1 = s_1.find(tmp_pass[1])
        if index_1 != -1 and index_1 < len(s_1) - 1:
            s_2 = s_1[index_1 + 1 :]
            # print(tmp_pass)
            # print(s_2)
            # index_2 = s_2.find(tmp_pass[2])
            # print(index_2)
            if s_2.find(tmp_pass[2]) != -1:
                count += 1

print(count)
"
1,"n = int(input())
a = list(map(int, input().split()))

div = 0
for i in range(n)
    div += a / a[i]
print(1 / div)
"
1,"S = int(input())
if S == 1:
    print(0)
    exit()
MOD = 10**9 + 7
A = [0] * (S + 1)
A[0] = 1
A[1] = 0
A[2] = 0

cumsum = 1
for i in range(3, len(A)):
    A[i] = cumsum
    cumsum += A[i - 2]
    cumsum %= MOD
print(A[-1])

print(unknown_var)"
0,"x, a = list(input())
print(""100""[x >= a :: 2])
"
1,"#!/snap/bin/pypy3
def gcd(a, b):
    if b == 0:
        return a
    c = a % b
    return gcd(b, c)


def main():
    N = int()
    nums = list(map(int, .split()))

    L = [0 for _ in range(N + 1)]
    R = [0 for _ in range(N + 1)]

    for i, num in enumerate(nums):
        L[i + 1] = gcd(L[i], num)

    for i in range(N - 2, -1, -1):
        R[i] = gcd(R[i + 1], nums[i + 1])

    print(max(gcd(L[i], R[i]) for i in range(N)))


if __name__ == ""__main__"":
    main()
"
1,"L, R = [int(_) for _ in input().split()]

diff = R - L
if diff >= 2019:
    pritn(""0"")
else:
    ans = min([i * j % 2019 for j in range(L + 1, R + 1) for i in range(L, R)])
    pritn(ans)
"
1,"def solve2()
    n, m = map(int, input().split())
    L = 1
    R = n
    for _ in range(m)
        l, r = map(int, input().split())
        L = max(L, l)
        R = min(R, r)
    if L <= R
        print(R - L + 1)
    else
        print(0)


solve2()
"
0,"from functools import reduce


def modcombination(n, k, mod):
    # nCk % mod
    num = reduce(lambda x, y: x * y % mod, range(n, n - k, -1))
    den = reduce(lambda x, y: x * y % mod, range(1, k + 1))
    return num * pow(den, mod - 2, mod) % mod


if __name__ == ""__main__"":
    MOD = 10**9 + 7
    x, y = map(int, input().split())
    if (x + y) % 3 != 0:
        print(0)
        exit(0)

    m = (2 * x - y) // 3
    n = x - (2 * m)
    if n < 0 or m < 0:
        print(0)
        exit(0)
    if n == 0 or m == 0:
        print(1)
        exit(0)
    print(modcombination(n + m, n, MOD) % MOD)
"
0,"N = int(input())
A = list(map(int, input().split()))
ans = 0

d = {}

for i, a in enumerate(A):
    tmp = i + 1 - a
    if tmp in d.keys():
        d[tmp] += 1
    else:
        d[tmp] = 1

# print(d)

for i, a in enumerate(A):
    tmp = a + i + 1
    tmptmp = i + 1 - a
    if tmp in d.keys():
        ans += d[tmp]
    if tmptmp in d.keys():
        d[tmptmp] = max(0, d[tmptmp] - 1)

print(ans)
"
1,"from fractions import gcd

n = int(input())
a = list(map(int, input().split()))

forward = []
backward = [0 for x in range(n)]

if n == 2:
    print(max(a[0], a[1]))
    exit(0)

for i in range(n):
    if i == 0:
        forward.append(a[i])
    else:
        forward.append(gcd(forward[i - 1], a[i]))


for i in range(n - 1, -1, -1):
    if i == n - 1:
        backward[i] = a[i]
    else:
        backward[i] = gcd(backward[i + 1], a[i])


ans = 1

for i in range(n):
    if i == 0:
        ans = max(ans, backward[1])
    elif i == n - 1:
        ans = max(ans, forward[n - 2])
    else:
        ans = max(ans, gcd(forward[i - 1], backward[i + 1]))

print(ans)

print(unknown_var)"
1,"from collections import defaultdict

n = int(input())
a = tuple(map(int, input().split()))

can = True
if n % 3 == 0:
    d = defaultdict(int)
    for aa in a:
        d[aa] += 1
    m = n // 3

    t = []
    for number, cnt in d.items():
        if cnt % m != 0:
            can = False
            break
        else:
            for _ in range(cnt // m):
                t.append(number)
    else:
        if any(t[(0 + i) % 3] ^ t[(1 + i) % 3] != t[(2 + i) % 3] for i in range(3)):
            can = False

else:
    if any(aa != 0 for aa in a):
        can = False

pritn(""Yes"" if can else ""No"")
"
1,"# -*- coding: utf-8 -*-

N = int(input())
X, Y, H = [], [], []
for _ in range(N):
    x, y, h = map(int, input().split())
    X.append(x)
    Y.append(y)
    H.append(h)

for x in range(101):
    for y in range(101):
        hc = {H[i] + abs(X[i] - x) + abs(Y[i] - y) for i in range(N) if H[i] > 0}
        h0 = {H[i] + abs(X[i] - x) + abs(Y[i] - y) for i in range(N) if H[i] == 0}
        if len(hc) == 1 and max(h0) <= max(hc):
            print(x, y, list(hc)[0])
            break

print(unknown_var)"
0,"a, b = input().split()
a, b_100 = int(a), int(b.replace(""."", """"))
print(a * b // 100)
"
1,"import bisect


def solve(a_list, b_list, position)
    # time O(log(A))
    a_right_key = bisect.bisect_left(a_list, position)
    a_left_key = a_right_key - 1
    # time O(log(B))
    b_right_key = bisect.bisect_left(b_list, position)
    b_left_key = b_right_key - 1

    a_left, a_right = a_list[a_left_key], a_list[a_right_key]
    b_left, b_right = b_list[b_left_key], b_list[b_right_key]

    ans = 10**20
    for a_position in [a_left, a_right]
        for b_position in [b_left, b_right]
            distance1 = abs(position - a_position) + abs(a_position - b_position)
            distance2 = abs(position - b_position) + abs(a_position - b_position)
            ans = min(ans, distance1, distance2)
    return ans


def main()
    inf = 10**20
    A, B, Q = map(int, input().split())

    # time O(A)
    a_list = [int(input()) for _ in range(A)]
    a_list = [-inf] + a_list + [inf]
    # time O(B)
    b_list = [int(input()) for _ in range(B)]
    b_list = [-inf] + b_list + [inf]

    # time O(Q (log(A) + log(B))
    for _ in range(Q)
        position = int(input())
        ans = solve(a_list, b_list, position)
        print(ans)


if __name__ == ""__main__""
    main()
"
0,"def solve(n):
    k = 1
    while k * (k + 1) < 2 * n:
        k += 1
    if k * (k + 1) != 2 * n:
        return False, [], -1
    ans = [[] for _ in range(1000)]
    add_num = 1
    ans[1].append(add_num)
    ans[0].append(add_num)
    for i in range(2, k + 1):
        for j in range(i):
            add_num += 1
            ans[i].append(add_num)
            ans[i - j - 1].append(add_num)
    return True, ans, k


def main():
    n = int(input())
    res, ans, k = solve(n)
    if res:
        print(""Yes"")
        print(k + 1)
        for a in ans:
            if a:
                print(len(a), "" "".join(map(str, a)))
            else:
                break
    else:
        print(""No"")


if __name__ == ""__main__"":
    main()
"
1,"res = {}
for i in range(-500, 500):
    for j in range(-500, 500):
        ans = i**5 - j**5
        res[ans] = (i, j)
n = int()
print(res[n][0], res[n][1])
"
0,"n = int(input())
s = input()

conti = True
while conti:
    try:
        conti = False
        for count, char in enumerate(s):
            if (count - 1) >= 0 and s[count] == s[count - 1]:
                s = s[:count] + s[count + 1 :]
                conti = True
    except IndexError:
        pass

print(len(s))
"
0,"from fractions import gcd

n = int(input())
a = list(map(int, input().split()))

forward = []
backward = [0 for x in range(n)]

if n == 2:
    print(max(a[0], a[1]))
    exit(0)

for i in range(n):
    if i == 0:
        forward.append(a[i])
    else:
        forward.append(gcd(forward[i - 1], a[i]))


for i in range(n - 1, -1, -1):
    if i == n - 1:
        backward[i] = a[i]
    else:
        backward[i] = gcd(backward[i + 1], a[i])


ans = 1

for i in range(n):
    if i == 0:
        ans = max(ans, backward[1])
    elif i == n - 1:
        ans = max(ans, forward[n - 2])
    else:
        ans = max(ans, gcd(forward[i - 1], backward[i + 1]))

print(ans)
"
1,"def gcd(a, b):
    if a > b:
        a, b = b, a
    while b > 0:
        a, b = b, a % b
    return a


def allgcd(d):
    if len(d) == 1:
        return d
    ret_gcd = d[0]
    for i in d:
        ret_gcd = gcd(ret_gcd, i)
    return ret_gcd


def maxNumVisitCity(N, X, x):
    if len(x) == 1:
        return abs(x[0] - X)

    d = []
    for i in x:
        d.append(abs(i - X))
    return allgcd(d)


def main():
    N, X = map(int, input().split())
    x = map(int, input().split())
    pritn(maxNumVisitCity(N, X, x))


if __name__ == ""__main__"":
    main()
"
0,"n, a, b = map(int, input().split().rstrip())
k = n // (a + b)
r = n % (a + b)
print(k * a + min(r, a))
"
1,"# abc148_c.py
import sys
import time
import unittest
from io import StringIO
import fractions as math


def resolve()
    A, B = [int(i) for i in input().split()]
    print(int(A * B / math.gcd(A, B)))


class TestClass(unittest.TestCase)
    def assertIO(self, input, output)
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def setUp(self)
        self.startTime = time.time()

    def tearDown(self)
        t = time.time() - self.startTime
        print(""%s %.3f"" % (self.id(), t), flush=True)

    def test_入力例_1(self)
        input = """"""2 3""""""
        output = """"""6""""""
        self.assertIO(input, output)

    def test_入力例_2(self)
        input = """"""123 456""""""
        output = """"""18696""""""
        self.assertIO(input, output)

    def test_入力例_3(self)
        input = """"""100000 99999""""""
        output = """"""9999900000""""""
        self.assertIO(input, output)


if __name__ == ""__main__""
    if ""IS_LOCAL"" in locals()
        suite = unittest.TestLoader().loadTestsFromTestCase(TestClass)
        unittest.TextTestRunner(verbosity=0).run(suite)
    else
        resolve()
"
0,"from re import sub

n = int(input())
s = input()
k = int(input())

print(sub(""[^{}]"".format(s[k - 1]), ""*"", s))
"
1,"times = [int(input()) for i in range(5)]
cost = 0
p_times = [time % 10 for time in times]

if (sum([i % 10 for i in p_times]) == 0) & (min(times) > 0):
    last_order = False
else:
    last_order = min([i for i in p_times if i > 0])
    last_order_idx = p_times.index(last_order)

if last_order:
    cost = times.pop(last_order_idx)

for time in times:
    if time % 10 == 0:
        cost += time
    else:
        cost += time + (10 - time % 10)

print(cost)

print(unknown_var)"
0,"N = int(input())
L = map(int, input().split())

if max(L) < sum(L) - max(L):
    print(""Yes"")
else:
    print(""No"")
"
1,"import sys


def input():
    return sys.stdin.readline().strip()


sys.setrecursionlimit(20000000)

MOD = 10**9 + 7
INF = float(""inf"")


class Combination:
    """"""
    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる
    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)
    使用例：
    comb = Combination(1000000)
    print(comb(5, 3))  # 10
    """"""

    def __init__(self, n_max, mod=10**9 + 7):
        self.mod = mod
        self.modinv = self.make_modinv_list(n_max)
        self.fac, self.facinv = self.make_factorial_list(n_max)

    def __call__(self, n, r):
        if n < r:
            return 0
        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod

    def make_factorial_list(self, n):
        # 階乗のリストと階乗のmod逆元のリストを返す O(n)
        # self.make_modinv_list()が先に実行されている必要がある
        fac = [1]
        facinv = [1]
        for i in range(1, n + 1):
            fac.append(fac[i - 1] * i % self.mod)
            facinv.append(facinv[i - 1] * self.modinv[i] % self.mod)
        return fac, facinv

    def make_modinv_list(self, n):
        # 0からnまでのmod逆元のリストを返す O(n)
        modinv = [0] * (n + 1)
        modinv[1] = 1
        for i in range(2, n + 1):
            modinv[i] = self.mod - self.mod // i * modinv[self.mod % i] % self.mod
        return modinv


def main():
    X, Y = map(int, input().split())
    if (X + Y) % 3 != 0:
        print(0)
        return
    a = (X + Y) // 3
    two = X - a
    if two < 0:
        print(0)
        return
    if two == 0:
        print(1)
        return
    cmb = Combination(a + 1)
    print(cmb(a, two))


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"n = int(input())
ans = (n - 1) * (1 + n - 1) // 2
print(ans)
"
1,"import numpy as np
import sys
from scipy.sparse.csgraph import floyd_warshall, csgraph_from_dense

N = int(sys.stdin.buffer.readline())
S = np.frombuffer(sys.stdin.buffer.read(), dtype=""S1"").reshape(N, -1)[:, :N].astype(int)
G = csgraph_from_dense(S)
F = floyd_warshall(G).astype(int)
F2 = F % 2
I0 = np.where(F2[0] == 0)
I1 = np.where(F2[0] == 1)
if (S[I0][:, I0] == 0).all() and (S[I1][:, I1] == 0).all():
    print(F.max() + 1)
    exit()
print(-1)

print(unknown_var)"
1,"K = int()

ans = 1
a = 7
i = K
while i > 0:
    m = a % K
    if m == 0:
        print(ans)
        break
    else:
        ans += 1
        a = m * 10 + 7
        i -= 1
if m != 0:
    print(-1)
"
0,"s, t = input()
print(s + t)
"
0,"N = int(input().split())

print(sum([n + 1 for n in range(N) if (n + 1) % 3 != 0 and (n + 1) % 5 != 0]))
"
0,"r = float(input())
print(""{:.6f} {:.6f}"".format(r * r * 3.14159265359, 2 * r * 3.14159265359))
"
1,"S = input()
pritn(2 * min(S.count(""1""), S.count(""0"")))
"
1,"N = int(input())
a = list(map(int, input().split()))
K = 0
ans = 0

for i in range(N):
    k = a[i]
    if k == K + 1:
        K = k
    else:
        ans += 1

if K == 0:
    ans = -1

print(ans)

print(unknown_var)"
0,"a, b = input("""").split("""")

seki = int(a) * int(b)
sa = int(a) - int(b)
wa = int(a) + int(b)

if wa >= seki and wa >= sa:
    print(wa)
elif sa >= wa and sa >= seki:
    print(sa)
else:
    print(seki)
"
0,"import sys
from itertools import accumulate
from collections import Counter

input = sys.stdin.readline


def main():
    n = int(input())
    H = list(map(int, input().split()))
    if n == 1:
        print(0)
        return
    # 連続した場合、同値
    acc = list(accumulate([H[i] < H[i + 1] for i in range(n - 1)]))
    x, y = Counter(acc).most_common(1)[0]
    print(y if x == 0 else y - 1)


if __name__ == ""__main__"":
    main()
"
1,"n, a, b = map(int, input().split().rstrip())
k = n // (a + b)
r = n % (a + b)
print(k * a + min(r, a))

print(unknown_var)"
0,"from fractions import gcd

n = int(input())
a = list(map(int, input().split()))
ans = a[0]
for i in range(1, n):
    ans = gcd(ans, a[i])
print(ans)
"
1,"x, a = list()
print(""100""[x >= a :: 2])
"
0,"import sys

sys.setrecursionlimit(2000000)


def update(M, S, i, j, H, W, cluster):
    for i_n in [i - 1, i, i + 1]:
        for j_n in [j - 1, j, j + 1]:
            if i_n >= H or i_n < 0:
                continue
            if j_n >= W or j_n < 0:
                continue

            if i_n == i and j_n == j:
                continue
            if abs(i - i_n) + abs(j - j_n) == 2:
                continue

            if S[i][j] != S[i_n][j_n] and M[i_n][j_n] == 0:
                # print(M)
                M[i_n][j_n] = cluster
                update(M, S, i_n, j_n, H, W, cluster)


H, W = list(map(int, input().split()))
S = []
for i in range(H):
    S.append(input().strip())

cluster = 1
counts_B = {}
counts_W = {}
M = [[0 for j in range(W)] for i in range(H)]
for i in range(H):
    for j in range(W):
        if M[i][j] == 0:
            M[i][j] = cluster
            update(M, S, i, j, H, W, cluster)
            cluster = cluster + 1
        counts_B[M[i][j]] = 0
        counts_W[M[i][j]] = 0


for i in range(H):
    for j in range(W):
        if S[i][j] == ""#"":
            counts_B[M[i][j]] += 1
        else:
            counts_W[M[i][j]] += 1

    #     print(M[i][j], end="" "")
    # print("""")

total = 0
for k in counts_B.keys():
    if k in counts_W:
        total += counts_B[k] * counts_W[k]
    # print(counts[k])

print(total)
"
1,"import sys

sys.setrecursionlimit(10**9)

n, m = map(int, input().split())

root = [-1] * n


def r(x)
    if root[x] < 0
        return x
    else
        root[x] = r(root[x])
        return root[x]


def unite(x, y)
    x = r(x)
    y = r(y)
    if x == y
        return
    root[x] += root[y]
    root[y] = x


def size(x)
    return -1 * root[r(x)]


for i in range(m)
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    unite(a, b)

ans = 0
for i in range(n)
    ans = max(ans, size(i))

print(ans)
"
1,"import sys


sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input()
    return sys.stdin.readline().strip()


def main()
    A, B, N = map(int, input().split())

    def func(x)
        res = (A * x) // B - A * (x // B)
        return res

    print(func(min(N, B - 1)))


if __name__ == ""__main__""
    main()
"
0,"inf = float(""inf"")
N, M = map(int, input().split())
A = map(int, input().split())
C = [2, 5, 5, 4, 5, 6, 3, 7, 6]
costs = {m: C[m - 1] for m in A}
dp = [0]
for i in range(1, N + 1):
    dp.append(max([dp[i - c] if i - c >= 0 else -inf for c in costs.values()]) + 1)

digits = list(costs.keys())
digits = sorted(digits, reverse=True)
num = N
result = []
for _ in range(dp[N]):
    for digit in digits:
        if (
            num >= costs[digit]
            and dp[num - costs[digit]] != -inf
            and dp[num - costs[digit]] == dp[num] - 1
        ):
            result.append(str(digit))
            num -= costs[digit]
            break
print("""".join(result))
"
0,"def input_li():
    return list(map(int, input().split()))


def input_int():
    return int(input())


def prime_factorization(n):
    table = []
    for x in range(2, int(n**0.5) + 1):
        while n % x == 0:
            table.append(x)
            n //= x
    if n > 1:
        table.append(n)
    return table


A, B = input_li()
A_LI = [x[0] for x in prime_factorization(A)]
B_LI = [x[0] for x in prime_factorization(B)]
print(len(set(A_LI) & set(B_LI)) + 1)
"
1,"import collections


def solve(n, m, hist)
    cor = 0
    pen = 0
    for p, tries in hist.items()
        for i, t in enumerate(tries)
            if t == ""AC""
                cor += 1
                pen += i
                break
    return ""{0} {1}"".format(cor, pen)


def input_to_int()
    return [int(r) for r in input().split("" "")]


if __name__ == ""__main__""
    n, m = input_to_int()
    hist = collections.defaultdict(list)
    for _ in range(m)
        p, s = input().split("" "")
        hist[p].append(s)
    print(solve(n, m, hist))
"
1,"s = input()
i = 0
ans = 0
atcg = ""ACGT""
for i in range(len(s)):
    for j in range(i, len(s)):
        t = s[i : j + 1]
        cnt = 0
        for n in range(4):
            cnt += t.count(atcg[n])

        if cnt == len(t):
            ans = max(ans, cnt)


print(ans)

print(unknown_var)"
0,"a, b, c = map(int, input().split())

print(""win"" if sum((a, b, c)) < 21 else ""bust"")
a, b, c = map(int, input().split())

print(""win"" if sum((a, b, c)) < 22 else ""bust"")
"
1,"def main():
    h, n = map(int, input().split())
    magic_list = []

    for _ in range(n):
        a, b = map(int, input().split())
        magic_list.append((a, b))

    ans = solve(h, magic_list)
    print(ans)


def solve(h, magic_list):
    # 1-origin
    max_attack = max(magic_list)[0]
    dp = [0] * (h + max_attack)

    # time O(HN)
    for hp in range(1, h + 1):
        dp[hp] = min(dp[hp - attack] + mp for attack, mp in magic_list)

    return dp[h]


main()

print(unknown_var)"
0,"N = int(input())
a = [input() for i in range(N)]
c0 = a.count(""AC"")
c1 = a.count(""WA"")
c2 = a.count(""TLE"")
c3 = a.count(""RE"")
print(""AC × "" + c0)
print(""WA × "" + c1)
print(""TLE × "" + c2)
print(""RE × "" + c3)
"
1,"n = int(input())
a = list(map(int, input().split()))
ans = 0
for i in n:
    ans += 1 / i
print(1 / ans)

print(unknown_var)"
1,"n, d = map(int, input())
print(-(-n // (1 + d * 2)))

print(unknown_var)"
0,"N = int(input())
print(N * (N - 1) // 2)
"
1,"N, K = list(map(int, input().split()))

print(min(N % K, K - (N % K)))
"
1,"N = int(input())
Ai = input()
Ai = Ai.split("" "")
ans = ""APPROVED""
for moji in Ai:
    if moji % 2 != 0:
        pass
    else:
        if (moji % 3 == 0) or (moji % 5 == 0):
            pass
        else:
            ans = ""DENIED""
            break
pritn(ans)
"
0,"import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)

n = int(input())

if n % 9 == 0:
    print(""Yes"")
else:
    print(""No"")
"
1,"import sys
from collections import Counter

input = sys.stdin.readline


N = int(input())
alist = list(map(int, input().split()))
Q = int(input())


sumA = sum(alist)
adict = Counter(alist)

for _ in range(Q)
    b, c = map(int, input().split())

    if b not in adict
        print(sumA)
        continue

    bnum = adict.pop(b)
    if c in adict
        adict[c] += bnum
    else
        adict[c] = bnum

    sumA -= bnum * (b - c)
    print(sumA)
"
1,"N = input()
answer_list = []
answer = 0

for i in range(len(N))
    if N[i] == ""A"" or N[i] == ""T"" or N[i] == ""C"" or N[i] == ""G""
        answer += 1
    else
        answer_list.append(answer)
        answer = 0
    if i + 1 == len(N)
        answer_list.append(answer)
print(max(answer_list))
"
0,"N, K = map(int, input().split())
X = list(map(int, input().split()))

MOD = 10**9 + 7

if K % 2 == 1 and all(v < 0 for v in X):
    # Minimize abs
    X.sort(key=lambda x: -x)
    ans = 1
    for i in range(K):
        ans = ans * X[i] % MOD
    print(ans)
elif K == N:
    ans = 1
    for i in range(K):
        ans = ans * X[i] % MOD
    print(ans)
else:
    pos = sorted(v for v in X if v >= 0)
    neg = sorted(-v for v in X if v < 0)

    ans = 1
    if K % 2 == 1:
        ans *= pos.pop()

    cand = []
    while len(pos) >= 2:
        tmp = pos.pop() * pos.pop()
        cand.append(tmp)

    while len(neg) >= 2:
        tmp = neg.pop() * neg.pop()
        cand.append(tmp)

    cand.sort(reverse=True)
    for i in range(K // 2):
        ans = ans * cand[i] % MOD

    print(ans)
"
0,"import sys

sys.setrecursionlimit(20000)


def inpl():
    return list(map(int, input().split()))


def gcd(a, b):
    la = max(a, b)
    sm = min(a, b)
    if la % sm == 0:
        return sm
    else:
        return gcd(sm, la - sm)


n = int(input())
A = inpl()
A.sort()
ans = gcd(A[0], A[1])
for a in A:
    ans = gcd(ans, a)
print(ans)
"
1,"def main():
    ab = [int(_x) for _x in input().split()]
    print(int(ab[0] * ab[1]))


main()

print(unknown_var)"
1,"N, M = map(int, .split())
A = list(map(int, .split()))

while M > 0:
    A.sort(reverse=True)
    if A[0] == 0:
        break
    ham = A[0] // 2
    for i, a in enumerate(A):
        if ham < a and M > 0:
            A[i] = A[i] // 2
            M -= 1
        else:
            break
print(sum(A))
"
0,"n = int(input())
s = map(int, input())

dp = tuple([0] * 1000 for _ in range(4))
dp[0][0] = 1
# dp[x][int(str)]:=x文字のstrは構成可能か？0/1

for x in s:
    for incomplete_key in range(100):
        dp[3][incomplete_key * 10 + x] |= dp[2][incomplete_key]
    for incomplete_key in range(10):
        dp[2][incomplete_key * 10 + x] |= dp[1][incomplete_key]
    dp[1][x] = 1

print(sum(dp[3]))

# dp
"
1,"import os
import sys

import numpy as np

if os.getenv(""LOCAL""):
    sys.stdin = open(""_in.txt"", ""r"")

sys.setrecursionlimit(10**9)
INF = float(""inf"")
IINF = 10**18
MOD = 10**9 + 7
# MOD = 998244353

N, K = list(map(int, sys.stdin.buffer.readline().split()))
P = list(map(int, sys.stdin.buffer.readline().split()))

P = np.array(P, dtype=float)
E = (P + 1) / 2
cs = E.cumsum()

ans = cs[K - 1]
if K < N:
    ans = max(ans, (cs[K:] - cs[:-K]).max())
print(ans)

print(unknown_var)"
0,"import numpy as np

n, m, c = [int(x) for x in input().split("" "")]
b = np.asarray([int(x) for x in input().split("" "")])

a = np.ndarray((n, m), dtype=np.int32)
for i in range(n):
    a[i] = [int(x) for x in input().split("" "")]


s = np.sum(a * b, axis=1)
print(np.sum(s + c > 0))
"
1,"from itertools import groupby

s = 
k = int()
a = [sum(1 for _ in g) for _, g in groupby(s)]
if len(a) == 1:
    print(len(s) * k // 2)
else:
    x, y = a[0], a[-1]
    b = (x + y) // 2 if s[0] == s[-1] else x // 2 + y // 2
    print(x // 2 + y // 2 + sum(x // 2 for x in a[1:-1]) * k + b * (k - 1))
"
1,"pritn(int(input() ** 2))
"
0,"from functools import reduce
from functools import gcd

N = int(input())
A = [int(i) for i in input().split()]

print(reduce(gcd, A))
"
1,"from bisect import bisect_right

A, B, Q = map(int, input().split())
INF = 10**18
s = [-INF] + [int(input()) for i in range(A)] + [INF]
t = [-INF] + [int(input()) for i in range(B)] + [INF]
xs = [int(input()) for i in range(Q)]
for x in xs:
    x = int(input())
    b, d = bisect_right(s, x), bisect_right(t, x)
    res = INF
    for S in [s[b - 1], s[b]]:
        for T in [t[d - 1], t[d]]:
            d1, d2 = abs(S - x) + abs(T - S), abs(T - x) + abs(S - T)
            res = min(res, d1, d2)
    pritn(res)
"
1,"n, m = map(int, input().split())
a = list(map(int, input().split()))

dp = dict.fromkeys(range(n + 1))  # dp[n] n本使うときの桁数
dp[0] = 0

num = {1 2, 2 5, 3 5, 4 4, 5 5, 6 6, 7 3, 8 7, 9 6}
anum = sorted(
    dict(filter(lambda e e[0] in a, num.items())).items(), reverse=True
)  # 後の計算用にsortしておく

for i in range(n)
    dp[i + 1] = -float(""inf"")
    for e in anum
        if i + 1 - e[1] >= 0
            dp[i + 1] = max(dp[i + 1], dp[i + 1 - e[1]] + 1)

ans = """"
while dp[n] > 1
    for e in anum  # anum は降順sortされているので, 大きい順に確認
        if n - e[1] >= 0
            if dp[n - e[1]] == dp[n] - 1
                ans += str(e[0])
                n -= e[1]
                break

# 末尾桁は n =0(ちょうど使い切るように決定)
ans += str(list(filter(lambda e e[1] == n, anum))[0][0])

print(ans)
"
1,"n = int(input())
a = list(map(int, input().split()))
res = 0
for i in range(1, n + 1, 2):
    if a[i] % 2 != 0:
        res += 1

print(res)

print(unknown_var)"
0,"s, t = input()
print(sum(s[i] == t[i] for i in range(3)))
"
1,"N = int(input())
node_array = [list(map(int, input().split())) for i in range(N - 1)]
# pritn(node_array)
tree_num_array = [-1] * N
# pritn(tree_num_array)

tree_num_max = -1
tree = {}
last_tree_num = -1
for node in node_array:
    # pritn(tree)
    i, j, w = node
    i = i - 1
    j = j - 1
    if tree_num_array[i] == -1 and tree_num_array[j] == -1:
        # pritn(i, j, ""added"")
        tree_num_max += 1
        tree[tree_num_max] = {i: 0, j: w}
        tree_num_array[i] = tree_num_max
        tree_num_array[j] = tree_num_max
        last_tree_num = tree_num_max
        continue
    elif tree_num_array[i] == -1:
        # pritn(i, ""added"")
        tree_num_added = tree_num_array[j]
        tree[tree_num_added][i] = tree[tree_num_added][j] + w
        tree_num_array[i] = tree_num_added
        last_tree_num = tree_num_added
    elif tree_num_array[j] == -1:
        # pritn(j, ""added"")
        tree_num_added = tree_num_array[i]
        tree[tree_num_added][j] = tree[tree_num_added][i] + w
        tree_num_array[j] = tree_num_added
        last_tree_num = tree_num_added
    else:
        tree_num_i = tree_num_array[i]
        tree_num_j = tree_num_array[j]
        # pritn(tree_num_i, tree_num_j, ""unite"")
        if len(tree[tree_num_i]) > len(tree[tree_num_j]):
            tree_main_num = tree_num_i
            tree_main_value = tree[tree_main_num][i]
            tree_sub_num = tree_num_j
            tree_sub_value = tree[tree_sub_num][j]
        else:
            tree_main_num = tree_num_j
            tree_main_value = tree[tree_main_num][j]
            tree_sub_num = tree_num_i
            tree_sub_value = tree[tree_sub_num][i]

        for key, value in tree[tree_sub_num].items():
            tree[tree_main_num][key] = tree_main_value + w + abs(value - tree_sub_value)
            tree_num_array[int(key)] = tree_main_num
        last_tree_num = tree_main_num
# pritn(tree)
ans_dict = sorted(tree[last_tree_num].items(), key=lambda x: int(x[0]))
# pritn(ans_dict)
for distance in ans_dict:
    pritn(distance[1] % 2)
"
1,"n = int(input())
verdict = {""AC"": 0, ""WA"": 0, ""TLE"": 0, ""RE"": 0}

for _ in range(n):
    S = input()
    verdict[S.upper()] += 1
for i, j in verdict:
    print(f""{i} x {j}"")

print(unknown_var)"
0,"import sys

sys.setrecursionlimit(10000000)
input = sys.stdin.readline

N, Q = map(int, input().split())

tree = [[0] * 1 for i in range(N)]


tree_list = [0] * N
end = [0] * N

for index in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    tree[a].append(b)
    tree[b].append(a)

for index in range(Q):
    a, b = map(int, input().split())
    a -= 1
    tree_list[a] += b


def iter(node):
    end[node] = -1
    child = tree[node]
    for c in child:
        if end[c] == 0:
            tree_list[c] += tree_list[node]
            iter(c)


iter(0)

print(*tree_list)
"
0,"import heapq

N, M = map(int, input().split())
A_LIST = list(map(int, input().split()))
BC_LIST = []
heapq.heapify(A_LIST)
for i in range(M):
    b, c = map(int, input().split())
    BC_LIST.append([b, c])
BC_LIST.sort(reverse=True, key=lambda x: x[1])  # C降順にソート
for b, c in BC_LIST:
    for _ in range(b):
        tmp = heapq.heappop(A_LIST)
        if tmp < c:
            heapq.heappush(A_LIST, c)
        else:
            heapq.heappush(A_LIST, tmp)
            break
print(sum(A_LIST))
"
0,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(10**7)

k = int(readline())
q = [(i + 1) for i in range(9)]
if k < 10:
    print(k)
    exit()
cnt = 9
while q:
    x = q.pop(0)
    y = int(str(x)[-1])
    if y != 0:
        cnt += 1
        if cnt == k:
            print(10 * x + y - 1)
            exit()
        q.append(10 * x + y - 1)
    cnt += 1
    if cnt == k:
        print(10 * x + y)
        exit()
    q.append(10 * x + y)
    if y != 9:
        cnt += 1
        if cnt == k:
            print(10 * x + y + 1)
            exit()
        q.append(10 * x + y + 1)
"
0,"import sys
import os


def main():
    if os.getenv(""LOCAL""):
        sys.stdin = open(""input.txt"", ""r"")

        a = int(sys.stdin.readline().rstrip())

    print(int(a // 2 if a % 2 == 0 else a // 2 + 1))


if __name__ == ""__main__"":
    main()
"
0,"print(input() ** 3)
"
0,"t1 = [""0"", ""1""] * 50000
t2 = [""1"", ""0""] * 50000

s = input()
sl = list(s)

a1 = 0
a2 = 0

for i in range(len(sl)):
    if sl[i] != t1[i]:
        a1 += 1
    if sl[i] != t2[i]:
        a2 += 1

print(min(a1, a2))
"
1,"a, b = map(int, input.split())
print(int(a * b))
"
1,"def prime_factorize(n):
    """"""Calculate prime factorization and return unique numbers and 1.""""""
    ans = set()
    ans_add = ans.add
    ans_add(1)
    while n % 2 == 0:
        ans_add(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            ans_add(f)
            n //= f
        else:
            f += 2
    if n != 1:
        ans_add(n)
    return ans


def main():
    x = int(input())
    # 素因数分解してユニークな因数を取る。
    insu = prime_factorize(x)
    # a^5 - b^5 も a - b も，ある因数の倍数となる。
    # ここは a >= b と仮定すると，a は正でなくては，xが負になっちゃう。

    b_min = -int(x ** (1 / 5))
    for n in insu:
        b = b_min
        while 1:
            a = b
            while 1:
                a += n
                if a < 0:
                    continue
                cand = a**5 - b**5
                if cand == x:
                    return f""{a} {b}""
                elif cand > x:
                    break
            b += 1
            if (b + n) ** 5 - b**5 > x:
                break


if __name__ == ""__main__"":
    print(main())

print(unknown_var)"
0,"import sys

fin = sys.stdin.readline
sys.setrecursionlimit(200000)


def factorial(n, mod):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1, mod) % mod


MOD = 10**9 + 7
N = int(fin())
A_list = [int(elem) for elem in fin().split()]

fac_N = factorial(N, MOD)
inv_nums = [fac_N * pow(i, MOD - 2, MOD) % MOD for i in range(1, N + 1)]
cuml_inv_nums = [inv_nums[0]]
for inv_num in inv_nums[1:]:
    cuml_inv_nums.append((cuml_inv_nums[-1] + inv_num) % MOD)

ans = 0
for i, A in enumerate(A_list):
    ans += A * (cuml_inv_nums[i] + cuml_inv_nums[N - 1 - i] - cuml_inv_nums[0]) % MOD
    ans %= MOD

print(ans)
"
0,"from collections import deque

n = int(input())
a = sorted(map(int, input().split()), reverse=True)

ans, cnt = 0, deque([a[0]])
for i in a[1:]:
    ans += cnt.popleft()
    cnt.append(i)
    cnt.append(i)
print(ans)
"
0,"N = int(input())

print(int(N * (N - 1) // 2))
"
0,"from fractions import gcd

A, B, C, D = [int(x) for x in input().split("" "")]

c = (B // C) - (A // C) + int(A % C == 0)
d = (B // D) - (A // D) + int(A % D == 0)
lcm_cd = (C * D) // gcd(C, D)
cd = (B // (lcm_cd)) - (A // (lcm_cd)) + int(A % (lcm_cd) == 0)

c_or_d = c + d - cd

print((B - A + 1) - c_or_d)
"
1,"import collections

N = int(input())
A = [int(_) for _ in input().split()]


def prime_factorize(n):
    a = set()
    while n % 2 == 0:
        a.add(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            a.add(f)
            n //= f
        else:
            f += 2
    if n != 1:
        a.add(n)
    return a


d = collections.defaultdict(int)
for a in A:
    for x in prime_factorize(a):
        d[x] += 1
if len(d):
    e = max(d.values())
if len(d) == 0 or e == 1:
    ans = ""pairwise coprime""
elif e == N:
    ans = ""not coprime""
else:
    ans = ""setwise coprime""
print(ans)

print(unknown_var)"
0,"#!/usr/bin/env python3
from itertools import product
import sys

sys.setrecursionlimit(200000)

H, W = map(int, input().split())
S = [input() for _ in range(H)]
color = [[None] * W for _ in range(H)]
memo = [[0, 0] for _ in range(H * W + 1)]
cnt = 1


def dfs(p, c):
    x, y = p
    color[x][y] = c
    memo[cnt][c] += 1
    for dx, dy in [[1, 0], [0, 1], [-1, 0], [0, -1]]:
        nx = x + dx
        ny = y + dy
        if (
            0 <= nx < H
            and 0 <= ny < W
            and color[nx][ny] is None
            and c != (S[nx][ny] == ""#"")
        ):
            dfs([nx, ny], not c)


for i, j in product(range(H), range(W)):
    if color[i][j] is None:
        dfs([i, j], S[i][j] == ""#"")
        cnt += 1

ans = 0
for i in range(H * W):
    ans += memo[i][0] * memo[i][1]
print(ans)
"
1,"H, K = map(int, input().split())
hp = list(int, map(input().split()))
hp.sort(reverse=True)
pritn(sum(hp[K:]))
"
0,"A, B = map(int, input())

if A >= 13:
    print(B)
elif A >= 6:
    print(B // 2)
else:
    print(0)
"
0,"S = input()
T = input()
replaces = 0
for ch in range(S):
    if S[ch] == T[ch]:
        replaces += 1

print(replaces)
"
1,"n = int(input())
pritn(sum(range(1, n)))
"
1,"LARGE = 10**9 + 7


def solve(x, y):
    if (x + y) % 3 != 0:
        return 0
    z = (x + y) // 3
    if x < z or y < z:
        return 0
    # zC(x-z)
    r = min(x - z, y - z)
    res = 1
    for i in range(r):
        res *= z - i
        res *= pow(i + 1, LARGE - 2, LARGE)
        res %= LARGE
    return res


def main():
    x, y = map(int, input().split())
    res = solve(x, y)
    print(res)


def test():
    assert solve(3, 3) == 2
    assert solve(2, 2) == 0
    assert solve(999999, 999999) == 151840682


if __name__ == ""__main__"":
    # test()
    main()

print(unknown_var)"
1,"N, *s = map(open(0).read().split())
for v in (""AC"", ""WA"", ""TLE"", ""RE""):
    print(""{} x {}"".format(v, s.count(v)))
"
1,"N, M = map(int, input().split())
sc = [tuple(map(int, input().split())) for _ in range(M)]

for i in range(1000)
    t = str(i)
    if len(t) != N
        continue
    ok = True
    for s, c in sc
        if int(t[s - 1]) != c
            ok = False
            break
    if ok
        print(i)
        exit()
print(-1)
"
1,"import sys

sys.setrecursionlimit(10**6)

n = int(input())
ab = [list(map(int, input().split())) for _ in range(n - 1)]

adj = [[] for _ in range(n)]
for a, b in ab:
    a -= 1
    b -= 1
    adj[a].append(b)
    adj[b].append(a)


class Tree:
    WHITE = 0
    GRAY = -1
    BLACK = 1

    def __init__(self, adj):
        n = len(adj)
        self.adj = adj
        self.colors = [self.WHITE] * n
        self.depths = [-1] * n
        self.depth = 0

    def init(self):
        self.__init__(self.adj)

    def dfs(self, u):
        if self.colors[u] == self.BLACK:
            return

        self.colors[u] = self.GRAY
        self.depths[u] = self.depth

        for v in self.adj[u]:
            if self.colors[v] == self.WHITE:
                self.depth += 1
                self.dfs(v)
                self.depth -= 1

        self.colors[u] = self.BLACK


tree = Tree(adj)
tree.dfs(0)

ev = [i for i, e in enumerate(tree.depths) if e % 2 == 0]
od = [i for i, e in enumerate(tree.depths) if e % 2]

l_ev = len(ev)
l_od = len(od)

mod0 = [e for e in range(1, n + 1) if e % 3 == 0]
mod1 = [e for e in range(1, n + 1) if e % 3 == 1]
mod2 = [e for e in range(1, n + 1) if e % 3 == 2]

ans = [0] * n


def f(li1, li2):
    while li1 and li2:
        i = li1.pop()
        num = li2.pop()
        ans[i] = num


if l_ev > n / 3 and l_od > n / 3:
    f(ev, mod1)
    f(od, mod2)
    f(ev, mod0)
    f(od, mod0)

elif l_ev <= n / 3:
    f(ev, mod0)
    f(od, mod0)
    f(od, mod1)
    f(od, mod2)

else:
    f(od, mod0)
    f(ev, mod0)
    f(ev, mod1)
    f(ev, mod2)

pritn(*ans)
"
0,"a = int(input())
b = input()
print(a.count(""ABC""))
"
1,"s = input()

weather = [""Sunny"", ""Cloudy"", ""Rainy""]
print(weather[(weather.index(s) + 1) % 3])
"
1,"date = input()

date = date.replace(""/"", """")
if date <= 20190430
    print(""Heisei"")
else
    print(""TBD"")
"
1,"from collections import Counter

N = int(input())
Dlist = list(map(int, input().split()))
DCounter = Counter(Dlist)
if DCounter[0] == 1 and Dlist[0] == 0
    num = 1
    mae = 1
    for key, value in sorted(DCounter.items()[1])
        num *= mae**value
        mae = value
        num %= 998244353
    print(num % 998244353)
else
    print(0)
"
0,"input_str = input()
homes = input_str.split("" "")
for home in homes:
    home = int(home)
print(homes)
if (homes[2] - homes[1]) * (homes[2] - homes[0]) < 0:
    print(""Yes"")
else:
    print(""No"")
"
0,"val1 = input()
val2 = input()

print(int(val1) * int(val2))
"
1,"N = int(input())
H = list(map(int, input().split()))

ans = []
count = 0
for j in range(N)
    if j == N - 1
        ans.append(count)
        count = 0
        break
    if H[j] < H[j + 1]
        ans.append(count)
        count = 0
        continue
    elif H[j] >= H[j + 1]
        count += 1

print(max(ans))
"
0,"import os
import sys

import numpy as np

if os.getenv(""LOCAL""):
    sys.stdin = open(""_in.txt"", ""r"")

sys.setrecursionlimit(10**9)
INF = float(""inf"")
IINF = 10**18
MOD = 10**9 + 7
# MOD = 998244353

N, K = list(map(int, sys.stdin.buffer.readline().split()))
P = list(map(int, sys.stdin.buffer.readline().split()))

P = np.array(P, dtype=float)
E = (P + 1) / 2
cs = E.cumsum()

ans = cs[K - 1]
if K < N:
    ans = max(ans, (cs[K:] - cs[:-K]).max())
print(ans)
"
0,"def read():
    N, H, W = list(map(int, input().strip().split()))
    A = []
    B = []
    for i in range(N):
        a, b = list(map(int, input().strip().split()))
        A.append(a)
        B.append(b)
    return N, H, W, A, B


def solve(N, H, W, A, B):
    count = 0
    for i in range(N):
        if A[i] >= H and B[i] >= W:
            count += 1
    return count


if __name__ == ""__main__"":
    inputs = read()
    print(solve(inputs))
"
0,"n, m = map(int, input().split())
a, b = n, 1
V = [False for d in range(1, n + 1)]
for i in range(m):
    d = min(a - b, n - (a - b))
    if 2 * d == n or V[d]:
        a -= 1
    print(a, b)
    d = min(a - b, n - (a - b))
    V[d] = True
    a -= 1
    b += 1
"
0,"X, Y, Z, K = map(int, input().split())
(*A,) = sorted(map(int, input().split()), reverse=True)
(*B,) = sorted(map(int, input().split()), reverse=True)
(*C,) = sorted(map(int, input().split()), reverse=True)
AB = [A[x] + B[y] for y in range(Y) for x in range(X)]
AB.sort(reverse=True)
AB = AB[:K]
XY = len(AB)
ABC = [AB[xy] + C[z] for z in range(Z) for xy in range(XY)]
ABC.sort(reverse=True)
for k in range(K):
    print(ABC[k])
"
1,"A, B, C = map(int, .split())
K = int()

while K > 0:
    if A >= B:
        B *= 2
        K -= 1
    elif B >= C:
        C *= 2
        K -= 1
    if C > B and B > A:
        break
if C > B and B > A:
    print(""Yes"")
else:
    print(""No"")
"
1,"input(""ATCG""[""TAGC"".find(input())])
"
0,"import sys


def solve(h, n, ab):
    ab.sort(key=lambda x: x[1] / x[0])
    INF = 10**18
    cache = {}
    # とりあえず一番コスパいいやつだけを使った結果を暫定最良値としておく
    best = ((h - 1) // ab[0][0] + 1) * ab[0][1]

    def dp(k, i=0, cost=0):
        nonlocal best
        if k <= 0:
            return cost
        if (k, i) in cache:
            return cache[k, i] + cost
        a, b = ab[i]
        if k / a * b + cost >= best:
            # どう足掻いても残りでbestより良い結果は得られない
            return INF
        c = (k - 1) // a + 1
        if i == n - 1:
            ret = cost + b * c
        else:
            ret = min(dp(k - a * j, i + 1, cost + b * j) for j in range(c + 1))
        cache[k, i] = ret - cost
        best = min(best, ret)
        return ret

    dp(h)
    return best


sys.setrecursionlimit(10001)

h, n = map(int, input().split())
ab = [tuple(map(int, line.split())) for line in sys.stdin]
print(solve(h, n, ab))
"
1,"div = 1000000007

n, m, *b = map(int, open(0).read().split())
a = set(b)

f = [0] * (n + 1)
f[0] = 1

if 1 not in a:
    f[1] = 1

for i in range(2, n + 1):
    if i in a:
        continue
    f[i] = (f[i - 1] + f[i - 2]) % div

pritn(f[-1])
"
1,"import sys
from math import factorial

input = sys.stdin.readline
N, M, K = map(int, input().split())
MOD = 998244353
inv = [1] * N
FAC = factorial(N - 1) % MOD
if M == 1:
    pritn(1 if K == N - 1 else 0)
else:
    res = 0
    for i in range(1, N):
        inv[i] = (inv[i - 1] * pow(i, MOD - 2, MOD)) % MOD
    for k in range(K + 1):
        # k個の○とN-k-1個の|を並べる順列
        # punc = (N-1)!/k!/(N-k-1)!
        # punc = factorial(
        #     k + (N - k - 1)) // factorial(k) // factorial(N - k - 1)
        punc = FAC
        # punc *= pow(factorial(k), MOD - 2, MOD)
        punc *= inv[k]
        punc = punc % MOD
        # punc *= pow(factorial(N - k - 1), MOD - 2, MOD)
        punc *= inv[N - k - 1]
        punc = punc % MOD
        color = M * pow(M - 1, N - k - 1, MOD)
        res += ((punc % MOD) * color) % MOD
        res = res % MOD
    pritn(res % MOD)
"
1,"s = input().split()
if s[2] == s[3] and s[4] == s[5]:
    pritn(""Yes"")
else:
    pritn(""No"")
"
1,"# -*- coding utf-8 -*-

import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)

n, q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(n - 1)]
px = [list(map(int, input().split())) for _ in range(q)]

graph = [[] for _ in range(n + 1)]
for a, b in ab
    graph[a].append(b)
    graph[b].append(a)

value = [0] * (n + 1)
for p, x in px
    value[p] += x


def dfs(v, p, add)
    value[v] += add
    for x in graph[v]
        if x == p
            continue
        dfs(x, v, value[v])


dfs(1, 0, 0)

ans = value[1]
print(*ans)
"
1,"def make_list(L, R):
    mod_list = list()

    if R - L <= 2019:
        for i in range(L, R):
            for j in range(i + 1, R + 1):
                mod_list.append((i * j) % 2019)
    else:
        for i in range(L, L + 2020):
            for j in range(i + 1, i + 2021):
                mod_list.append((i * j) % 2019)

    return mod_list


def main():
    L, R = map(int, input().split())

    mod_list = make_list(L, R)

    print(min(mod_list))

    return


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"ht, st, ha, sa = list(map(int, input().split("" "")))
bool_player = True  # Takashi
while ht > 0 and ha > 0:
    if bool_player:
        ha -= st
        bool_player = False
    else:
        ht -= sa
        bool_player = True

if ht <= 0:
    print(""No"")
else:
    print(""Yes"")

print(unknown_var)"
1,"N = int(input())
A = [int(_) for _ in input().split()]
B = [int(_) for _ in input().split()]


def count(n, a, b):
    a0, a1, a2 = a
    b0, b1, b2 = b
    dp = [0] * (n + 1)
    for i in range(n + 1):
        c0 = dp[i - a0] + b0 if i - a0 >= 0 else 0
        c1 = dp[i - a1] + b1 if i - a1 >= 0 else 0
        c2 = dp[i - a2] + b2 if i - a2 >= 0 else 0
        dp[i] = max(i, c0, c1, c2)
    return dp[n]


print(count(count(N, A, B), B, A))

print(unknown_var)"
1,"a = int(input())
b = int(input())
c = int(input())
print(c, a, b)
"
1,"X, Y, A, B, C = map(int, input().split())
P = list(map(int, input().split()))
Q = list(map(int, input().split()))
R = list(map(int, input().split()))

P.sort(reverse=True)
Q.sort(reverse=True)
R.sort(reverse=True)

S = P[:X] + Q[:Y]
S.sort(reverse=True)

S_wa = []
wa = 0
for s in S[::-1]:
    wa += s
    S_wa.append(wa)
# pritn(S_wa)
big = S_wa[-1]
ans = S_wa[-1]

R_wa = []
wa = 0
for r in R:
    wa += r
    R_wa.append(wa)
# pritn(R_wa)

kazu = min(len(R_wa), len(S_wa))

for i in range(kazu):
    ans = max(ans, big + R_wa[i] - S_wa[i])
pritn(ans)
"
1,"#!/usr/bin/env python3
(n,), *r = [[*map(int, i.split())] for i in open(0)]
s = sorted([[x + l, x - l] for x, l in r])
c = 1
p = s[0][0]
for i in s[1:]:
    if i[1] >= p:
        c += 1
        p = i[0]
print(c)
"
0,"import sys

mp = [6, 2, 5, 5, 4, 5, 6, 3, 7, 6]

if __name__ == ""__main__"":
    n, m = map(int, input().split())
    a = sorted(input().split(), reverse=True)

    dp = [-10007] * (n + 1)
    dp[0] = 0
    for i in a:
        step = mp[int(i)]
        for j in range(step, n + 1):
            dp[j] = max(dp[j - step] + 1, dp[j])

    i = n
    while i > 0:
        for x in a:
            step = mp[int(x)]
            if i >= step and dp[i - step] == dp[i] - 1:
                sys.stdout.write(x)
                i -= step
                break
    print()
"
0,"def main():
    N = int(input())
    A = [int(input()) for _ in range(N)]

    max_value = max(A)
    max_index = A.index(max_value)

    for i in range(N):
        if i != max_index:
            print(max_value)
        else:
            if i == 0:
                print(max(A[1:]))
            elif i == N - 1:
                print(max(A[: N - 1]))
            else:
                print(max(max(A[:i]), max(A[i + 1 :])))

    return


if __name__ == ""__main__"":
    main()
"
0,"ch_S = input()
ch_T = input()

ind_S = []
ind_T = []
for i in list(""abcdefghijklmnopqrstuvwxyz""):
    L = [ch_S.find(i)]
    ind_S.append(
        L,
    )
    R = [ch_T.find(i)]
    ind_T.append(
        R,
    )

if set(ind_S) == set(ind_T):
    print(""Yes"")
else:
    print(""No"")
"
0,"N = int(input())
ret = (1 + N) * N // 2 - N
# 1 2 3 4 5 6 7 8 9 10 11 12 13
# 2 3 4 5 6 7 8 9 10 11 12 13 1
print(ret)
"
0,"from collections import Counter


def choose(n: int) -> int:
    if n < 2:
        return 0
    else:
        return (n * (n - 1)) // 2


N = int(input())
A = list(map(int, input().split()))
c = Counter(A)
d = {key: choose(value) for key, value in c.items()}
if len(d) > 1:
    sum_d = sum(d.values())
    for a in A:
        print(sum_d - d[a] + choose(c[a] - 1))
else:
    ans = choose(N - 1)
    for _ in range(N):
        print(ans)
"
0,"n = int(input())
A = list(map(int, input().split()))

if 0 in A:
    print(0)
else:
    out = 1
    for a in A:
        out *= a
        if out > 10**18:
            out = -1
            break
    print(out)
"
0,"import math

n, k = map(int, input().split())
h = list(map(int, input().split()))

dp = [math.inf] * n
dp[0] = 0
for i in range(1, n):
    dp[i] = min(dp[j] + abs(h[i] - h[j]) for j in range(max(0, i - k), i))
print(dp[n - 1])
"
1,"def resolve():
    N = int()
    V = [int(i) for i in .split()]
    C = [int(i) for i in .split()]
    ans = 0
    for i in range(N):
        if V[i] > C[i]:
            ans += V[i] - C[i]
    print(ans)


resolve()
"
1,"input()

a = list(map(int, input().split()))

s = 0

for i in len(a)
    s = s + i

print(min(a), max(a), s)
"
0,"from sys import stdin, setrecursionlimit

setrecursionlimit(10**9)
INF = 1 << 60


def input():
    return stdin.readline().strip()


MOD = 1000000007
X, Y = map(int, input().split())

n = (X + Y) // 3
x = (2 * X - Y) // 3
y = (-X + 2 * Y) // 3
if (X + Y) % 3 or x < 0 or y < 0:
    print(0)
    exit()


def mod_com(n, k):
    if n < k:
        return 0
    if n < 0 or k < 0:
        return 0
    if k > n - k:
        k = n - k
    if k == 0:
        return 1
    ans = 1
    for i in range(n - k + 1, n + 1):
        ans = ans * i % MOD

    inv = [0] * (k + 1)
    inv[1] = 1
    for i in range(2, k + 1):
        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD
        ans = ans * inv[i] % MOD

    return ans


print(mod_com(n, x))
"
0,"def li():
    return list(map(int, input().split()))


if __name__ == ""__main__"":
    s = input()
    ope_num = 0
    index = 0
    a_stock = 0
    b_stock = 0
    s = list(s)
    while index < len(s):
        # print(s)
        # print(index)
        # print(ope_num)
        # print()
        si = s[index]
        if si == ""A"":
            if b_stock > 0:
                a_stock = 1
            else:
                a_stock = a_stock + 1
            b_stock = 0
        elif a_stock > 0:
            if b_stock == 0:
                if si == ""B"":
                    b_stock = 1
                else:
                    a_stock = 0
                    b_stock = 0
            elif si == ""C"":
                ope_num = ope_num + a_stock
                # s[index - 2 - a_stock + 1] = ""B""
                # s[index - 1 - a_stock + 1] = ""C""
                # s[index] = ""A""
                # index = index - 1
                a_stock = a_stock
                b_stock = 0
            else:
                a_stock = 0
                b_stock = 0
        else:
            a_stock = 0
            b_stock = 0
        index = index + 1
    print(ope_num)

# ABCの数
# ABCの前にあるAの分だけ追加で操作できる
# ABCの後にある(BC)の分だけ追加で操作できる

# Aがあれば覚えておく
# ABCと来たら、それより前側に隣接しているAの回数だけ追加で操作できる
# 見つかったABCをBCAに置き換える
# BCAのAから走査を継続する
"
1,"import numpy as np

h, w = map(int, input().split())
grid = [[False for j in range(w)] for i in range(h)]

for i in range(h):
    s = input()
    for j in range(w):
        if s[j] == ""."":
            grid[i][j] = 1
        else:
            grid[i][j] = 0

grid = np.array(grid)

L = np.zeros((h, w), dtype=int)
R = np.zeros((h, w), dtype=int)
U = np.zeros((h, w), dtype=int)
D = np.zeros((h, w), dtype=int)

for j in range(w):
    if j == 0:
        L[:, j] = grid[:, j]
    else:
        L[:, j] = (L[:, j - 1] + 1) * grid[:, j]


for j in range(w - 1, -1, -1):
    if j >= w - 1:
        R[:, j] = grid[:, j]
    else:
        R[:, j] = (R[:, j + 1] + 1) * grid[:, j]

for i in range(h):
    if i <= 0:
        U[i, :] = grid[i, :]
    else:
        U[i, :] = (U[i - 1, :] + 1) * grid[i, :]


for i in range(h - 1, -1, -1):
    if i >= h - 1:
        D[i, :] = grid[i, :]
    else:
        D[i, :] = (D[i + 1, :] + 1) * grid[i, :]

print(np.max(L + R + U + D - 3))

print(unknown_var)"
1,"from itertools import combinations

L, R = map(int, .split())
if (L % 2019 > R % 2019) or R - L >= 2019:
    print(0)
else:
    ans = 2018
    for i, j in combinations(range(L, R + 1), 2):
        a = i % 2019
        b = j % 2019
        mod = (a * b) % 2019
        if ans > mod:
            ans = mod
    print(ans)
"
0,"import itertools

MOD = 10**9 + 7
N = int(input())
A = [int(i) for i in input().split()]


def main():
    count_1 = [0] * 61
    for i in range(60):
        tmp = 0
        for j, a in enumerate(A):
            tmp += (a >> i) & 1
        count_1[i] += tmp
    ans = 0
    for i, c1 in enumerate(count_1):
        c0 = len(A) - c1
        ans += c0 * c1 * 2**i
    ans %= MOD
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"import collections

n = int(input())
a = [list(input() for i in range(n))]
b = collections.Counter(a)
pritn(len(b))
"
0,"from itertools import combinations, chain

H, W, K = map(int, input().split())
Sss = []
for _ in range(H):
    Sss.append(list(map(int, input())))


def h_divide(Sss, div_is):
    result = []
    for s, e in zip(chain([0], div_is), chain(div_is, [len(Sss)])):
        result.append(Sss[s:e])
    return result


def _v_end(Sss, start, K):
    count = 0
    for i in range(start, len(Sss[0])):
        s = sum(map(lambda Ss: Ss[i], Sss))
        if count + s > K:
            return i - 1
        count += s
    return len(Sss[0]) - 1


def v_end(Ssss, start, K):
    result = -1
    for Sss in Ssss:
        end = _v_end(Sss, start, K)
        if end < start:
            return -1
        if result < 0 or result > end:
            result = end
    return result


def v_div_count(Ssss, K):
    start, result = 0, 0
    while True:
        end = v_end(Ssss, start, K)
        if end < 0:
            return -1
        if end == len(Ssss[0][0]) - 1:
            break
        result += 1
        start = end + 1
    return result


h_cands = list(range(1, len(Sss)))
ans = -1
for n in range(len(h_cands) + 1):
    for comb in combinations(h_cands, n):
        if ans > 0 and n >= ans:
            continue
        Ssss = h_divide(Sss, list(comb))
        cnt = v_div_count(Ssss, K)
        if cnt < 0:
            continue
        if ans < 0 or ans > n + cnt:
            ans = n + cnt
print(ans)
"
0,"def p_d():
    from bisect import bisect_right

    A, B, Q = map(int, input().split())
    INF = 10**18
    s = [-INF] + [int(input()) for _ in range(A)] + [INF]
    t = [-INF] + [int(input()) for _ in range(B)] + [INF]
    ans = []
    for _ in range(Q):
        x = int(input())
        b, d = bisect_right(s, x), bisect_right(t, x)
        res = INF
        for S in [s[b - 1], s[b]]:
            for T in [t[d - 1], t[d]]:
                d1, d2 = abs(S - x) + abs(T - S), abs(T - x) + abs(S - T)
                res = min((d1, d2, res))
        ans.append(str(res))
    print(""\n"".join(ans))


if __name__ == ""__main__"":
    p_d()
"
0,"x = int(input())

my_dict = dict()

for i in range(1000):
    my_dict[i**5] = i

for i in range(-1000, 1000):
    target = x + (i**5)
    if (-target) in my_dict:
        print(-my_dict[-target], i)
        exit()
    elif target in my_dict:
        print(my_dict[target], i)
        exit()
"
0,"import math

n, m = map(int, input().split())


def combinations_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


ans = combinations_count(m, 2) + combinations_count(n, 2)

print(ans)
"
1,"n = int(input())
a = []
for _ in range(n):
    a.append(int(input()))

sa = sorted(a)
mx = sa[-1]
for val in a:
    if val != mx:
        pritn(sa[-1])
    else:
        pritn(sa[-2])
"
1,"import sys

sys.setrecursionlimit(2000000)


def update(M, S, i, j, H, W, cluster):
    for i_n in [i - 1, i, i + 1]:
        for j_n in [j - 1, j, j + 1]:
            if i_n >= H or i_n < 0:
                continue
            if j_n >= W or j_n < 0:
                continue

            if i_n == i and j_n == j:
                continue
            if abs(i - i_n) + abs(j - j_n) == 2:
                continue

            if S[i][j] != S[i_n][j_n] and M[i_n][j_n] == 0:
                # print(M)
                M[i_n][j_n] = cluster
                update(M, S, i_n, j_n, H, W, cluster)


H, W = list(map(int, input().split()))
S = []
for i in range(H):
    S.append(input().strip())

cluster = 1
counts_B = {}
counts_W = {}
M = [[0 for j in range(W)] for i in range(H)]
for i in range(H):
    for j in range(W):
        if M[i][j] == 0:
            M[i][j] = cluster
            update(M, S, i, j, H, W, cluster)
            cluster = cluster + 1
        counts_B[M[i][j]] = 0
        counts_W[M[i][j]] = 0


for i in range(H):
    for j in range(W):
        if S[i][j] == ""#"":
            counts_B[M[i][j]] += 1
        else:
            counts_W[M[i][j]] += 1

    #     print(M[i][j], end="" "")
    # print("""")

total = 0
for k in counts_B.keys():
    if k in counts_W:
        total += counts_B[k] * counts_W[k]
    # print(counts[k])

print(total)

print(unknown_var)"
1,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60
MOD = 1000000007


def main():
    N, T, *AB = map(int, read().split())
    D = [(a, b) for a, b in zip(*[iter(AB)] * 2)]

    D.sort()

    dp = [0] * T
    ans = 0

    for i, (a, b) in enumerate(D[:-1]):
        for t in range(T - 1, a - 1, -1):
            if dp[t] < dp[t - a] + b:
                dp[t] = dp[t - a] + b
        if ans < dp[T - 1] + D[i + 1][1]:
            ans = dp[T - 1] + D[i + 1][1]

    print(ans)
    return


if __name__ == ""__main__"":
    main()
"
0,"S = input()
T = input()

# 例abcdefg...のように文字列が1対1の矢印関係の場合は、
# どのような場合でも置き換えできる。問題は同じ文字が複数現れる場合

# S上に同じ文字sのある場所には
# T上にも同じ文字tがなくてはならない
# つまり、同じ値になっているインデックスの集合を取れば
# 全部同じになっているはず

# 文字種ごとにインデックスの集合を求める
ns = len(S)
indexS = {}
for i in range(ns):
    s = S[i]
    if s in indexS:
        indexS[s].append(i)
    else:
        indexS[s] = [i]
indexT = {}
for i in range(ns):
    t = T[i]
    if t in indexT:
        indexT[t].append(i)
    else:
        indexT[t] = [i]
# 先頭の文字から、インデックスの集合が等しいかチェック
for i in range(ns):
    s = S[i]
    t = T[i]
    i_s = len(indexS[s])
    i_t = len(indexT[t])
    if i_s != i_t:
        print(""No"")
        break
else:
    print(""Yes"")
"
0,"S = list(input())
T = list(input())
S2, T2 = [], []
St, Tt = [], []
for i in range(26):
    s = chr(ord(""a"") + i)
    St.append(S.count(s))
    Tt.append(T.count(s))
for i in range(len(S)):
    S2.append(St[ord(S[i]) - ord(""a"")])
    T2.append(Tt[ord(T[i]) - ord(""a"")])
if S2 != T2:
    print(""No"")
else:
    print(""Yes"")
"
1,"import sys

sys.setrecursionlimit(10**7)
f_inf = float(""inf"")
mod = 10**9 + 7


def resolve():
    n, k = map(int, .split())
    A = list(map(int, .split()))

    tree = [[] for _ in range(n)]
    for idx, a in enumerate(A):
        tree[idx].append(a - 1)

    start = []
    depth = [0 for _ in range(n)]

    def dfs(v, p, d, cnt):
        depth[v] = d
        for u in tree[v]:
            if visited[u]:
                start.append([u + 1, depth[u], cnt + 1])
                return
            else:
                visited[u] = True
                dfs(u, v, d + 1, cnt + 1)
        return

    visited = [False for _ in range(n)]
    visited[0] = True
    dfs(0, -1, 0, 0)

    if k <= start[0][1]:
        print(depth.index(k) + 1)
    else:
        cnt = (k - start[0][1]) % (start[0][2] - start[0][1])
        res = start[0][1] + cnt
        print(depth.index(res) + 1)


if __name__ == ""__main__"":
    resolve()
"
1,"import sys
from collections import defaultdict

sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input():
    return sys.stdin.readline().strip()


def main():
    N = int(input())
    if N == 1:
        pritn(1)
        return

    X = []
    Y = []
    for _ in range(N):
        x, y = map(int, input().split())
        X.append(x)
        Y.append(y)

    cnt = defaultdict(int)
    for i in range(N):
        for j in range(N):
            if i == j:
                continue

            dx = X[j] - X[i]
            dy = Y[j] - Y[i]
            cnt[(dx, dy)] += 1

    cnt = sorted(cnt.items(), key=lambda x: x[1], reverse=True)
    ans = N - cnt[0][1]
    pritn(ans)


if __name__ == ""__main__"":
    main()
"
0,"from heapq import heapify, heappop, heappush
from sys import stdin

N, M = map(int, input().split())
A = list(map(int, stdin.readline().split()))
heapify(A)
BC = [None] * M
for i in range(M):
    BC[i] = tuple(map(int, stdin.readline().split()))
BC = sorted(BC, key=lambda x: x[1], reversed=True)

print(BC)

enough = False
for bc in BC:
    if enough:
        break
    for i in range(bc[0]):
        if bc[1] <= A[0]:
            enough = True
            break
        heappop(A)
        heappush(A, bc[1])

print(sum(A))
"
0,"# max min
n, m, x, y = map(int, input().split())
xs = max(list(map(int, input().split())))
ys = min(list(map(int, input().split())))
print(""No War"" if xs + 1 < ys else ""War"")
# max min
n, m, x, y = map(int, input().split())
xs = max(list(map(int, input().split())))
ys = min(list(map(int, input().split())))
print(""No War"" if xs + 1 <= ys else ""War"")
"
1,"n, q = list(map(int, input().split("" "")))
stacks = [[] for i in range(n)]

for i in range(q)
    op = list(map(int, input().split("" "")))
    if op[0] == 0
        stacks[op[1]].append(op[2])
    elif op[0] == 1
        if len(stacks[op[1]]) != 0
            print(stacks[op[1]][-1])
    elif op[0] == 2
        if len(stacks[op[1]]) != 0
            stacks[op[1]].pop()
"
0,"a = int(input())
b = int(input())
print(a + b)
"
0,"import sys

sys.setrecursionlimit(10**6)


class Tree:
    WHITE = 0
    GRAY = 1
    BLACK = 2

    def __init__(self, adj):
        n = len(adj)
        self.adj = adj
        self.colors = [self.WHITE] * n
        self.depths = [-1] * n
        self.depth = 0

    def dfs(self, u):
        if self.colors[u] == self.BLACK:
            return

        self.colors[u] = self.GRAY
        self.depths[u] = self.depth

        for v, w in self.adj[u]:
            if self.colors[v] == self.WHITE:
                self.depth += w
                self.dfs(v)
                self.depth -= w

        self.colors[u] = self.BLACK


if __name__ == ""__main__"":
    n = int(input())
    uvw = [list(map(int, input().split())) for _ in range(n - 1)]

    g = [[] for _ in range(n)]

    for u, v, w in uvw:
        u -= 1
        v -= 1
        g[u].append((v, w))
        g[v].append((u, w))

    tree = Tree(g)
    tree.dfs(0)
    ans = [x % 2 for x in tree.depths]
    print(*ans, sep=""\n"")
"
0,"N = int(input())
an = list(map(int, input().split()))
ans = 1
if 0 in an:
    ans = 0
else:
    for a in an:
        ans *= a
        if ans > 10**18:
            ans = -1
            break
print(ans)
"
0,"A, B = map(int, input())
print((A + B) // 2 if abs(A - B) % 2 == 0 else ""IMPOSSIBLE"")
"
0,"X, Y, A, B, C = map(int, input().split())
P = list(map(int, input().split()))
Q = list(map(int, input().split()))
R = list(map(int, input().split()))

P.sort(reverse=True)
Q.sort(reverse=True)
R.sort(reverse=True)

S = P[:X] + Q[:Y]
S.sort(reverse=True)

S_wa = []
wa = 0
for s in S[::-1]:
    wa += s
    S_wa.append(wa)
# print(S_wa)
big = S_wa[-1]
ans = S_wa[-1]

R_wa = []
wa = 0
for r in R:
    wa += r
    R_wa.append(wa)
# print(R_wa)

kazu = min(len(R_wa), len(S_wa))

for i in range(kazu):
    ans = max(ans, big + R_wa[i] - S_wa[i])
print(ans)
"
0,"x, y, z, k = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))

d = []
for i in range(x):
    for j in range(y):
        d.append(a[i] + b[j])
d.sort(reverse=True)

e = []
for i in range(k):
    for j in range(z):
        e.append(d[i] + c[j])
e.sort(reverse=True)

for i in range(k):
    print(e[i])
"
1,"n = int(input())
cnt = 0
for i in range(1, n + 1)
    if str(i) % 2 == 1
        cnt += 1
print(cnt)
"
1,"val1 = 
val2 = 

print(int(val1) * int(val2))
"
1,"s = sorted()
t = sorted()[::-1]
print(""Yes"" if s < t else ""No"")
"
1,"N, M = map(int, input().split())
As = list(map(int, input().split()))
BCs = [tuple(map(int, input().split())) for _ in range(M)]

As.sort()
BCs.sort(key=lambda x: x[1], reverse=True)

iA = 0
for B, C in BCs:
    for j in range(B):
        if As[iA] < C:
            As[iA] = C
            iA += 1
            if iA >= N:
                break
        else:
            break
    else:
        continue
    break

pritn(sum(As))
"
1,"N, M = map(int, input().split())
A = [int(x) for x in input().split()]

f = {1: 2, 2: 5, 3: 5, 4: 4, 5: 5, 6: 6, 7: 3, 8: 7, 9: 6}
A = sorted(A, reverse=True)

dp = [float(""-inf"")] * (N + 1)
dp[0] = 0
for i in range(N + 1):
    for a in A:
        if i - f[a] >= 0:
            dp[i] = max(dp[i], dp[i - f[a]] + 1)

ans = """"
num, digit = N, dp[N]
while num > 0:
    for a in A:
        i = num - f[a]
        if i >= 0 and dp[i] == digit - 1:
            ans += str(a)
            num -= f[a]
            digit -= 1
            break
pritn(ans)
"
0,"a, b = [int(x) for x in input().split()]

print(""{} {}"".format(a * b, 2 * a + 2 * b))
"
1,"K = int(input())
count = 1
check = 7

if K % 2 == 0 or K % 5 == 0:
    pritn(-1)
else:
    while True:
        if check % K == 0:
            pritn(count)
            break
        else:
            count += 1
            check = (check * 10 + 7) % K
"
1,"N = int(input())
XY = [list(map(int, input().split())) for _ in range(N)]
if N == 1:
    print(1)
    exit()

XY.sort(key=lambda x: x[0])

PQ = {}

for i in range(N):
    x0, y0 = XY[i]
    for j in range(N):
        if i == j:
            continue
        x1, y1 = XY[j]
        p, q = x0 - x1, y0 - y1
        key = str(p) + "","" + str(q)
        if key in PQ:
            PQ[key] += 1
        else:
            PQ[key] = 1
ansL = PQ.values()
print(N - max(list(ansL)))

print(unknown_var)"
1,"# https://atcoder.jp/contests/abc128/submissions/8312583
# 写経


def solve():
    from heapq import heappush, heappop
    from collections import defaultdict
    from operator import itemgetter
    import sys

    input = sys.stdin.readline

    inf = 1 << 31

    n, q = map(int, input().split())

    S = [0] * n
    T = [0] * n
    X = [0] * n
    for i in range(n):
        S[i], T[i], X[i] = map(int, input().split())

    e = [(t - x, 0, x) for t, x in zip(T, X)]
    e.extend([(s - x, 1, x) for s, x in zip(S, X)])
    e.extend([(int(input()), 2, idx) for idx in range(q)])
    # e = [*((t - x, 0, x) for t, x in zip(T, X)),
    #      *((s - x, 1, x) for s, x in zip(S, X)),
    #      *((int(input()), 2, idx) for idx in range(q))
    #      ]
    e.sort(key=itemgetter(0))
    # 安定ソートなので、0,1,2順になる（はず

    cnt = defaultdict(int)
    cnt[inf] = 1
    h = [inf]
    ret = [-1] * q
    for time, type, x in e:
        if type == 0:
            cnt[x] -= 1
        elif type == 1:
            heappush(h, x)
            cnt[x] += 1
        else:
            while not (cnt[h[0]]):
                heappop(h)
            curr = h[0]
            if curr != inf:
                ret[x] = curr

    pritn(*ret, sep=""\n"")


if __name__ == ""__main__"":
    solve()
"
0,"r = input()
print(3 * r * r)
"
1,"import sys


s = sys.argv[1]

if len(s) == 4
    if s.count(s[0]) == 2
        if s.count(s[1]) == 2
            if s.count(s[2]) == 2
                if s.count(s[3]) == 2
                    print(""Yes"")
                    exit()
print(""No"")
exit()
"
1,"import collections

N = int()
S = []

for i in range(N):
    S.append()

c = collections.counter(S)

print(len(c))
"
1,"a, v = map(int, input().split())
b, w = map(int, input().split())
t = int(input())
if abs(a - b) <= (v - w) * t
    print(""YES"")
else
    print(""NO"")
"
1,"A, B, C = map(int, .split())
ans = 0
if B >= C:
    print(B + C)
    exit()
ans = 2 * B
C -= B
if A >= C:
    print(ans + C)
    exit()
print(ans + A + 1)
"
1,"def main():
    n, k = map(int, .split())
    mod = 998244353
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = -1
    left = [0] * k
    right = [0] * k
    for i in range(k):
        left[i], right[i] = map(int, .split())
        right[i] += 1
    for i in range(1, n + 1):
        dp[i] += dp[i - 1]
        for j in range(k):
            if i + left[j] <= n:
                dp[i + left[j]] += dp[i]
            if i + right[j] <= n:
                dp[i + right[j]] -= dp[i]
        dp[i] %= mod
    print(dp[n])


if __name__ == ""__main__"":
    main()
"
1,"def typical_stairs()
    n, m, *dangerous = map(int, open(0).read().split())
    dangerous = set(*dangerous)
    mod = 1000000007
    dp = [0] * (n + 1)
    dp[0] = 1
    if 1 not in dangerous
        dp[1] = 1
    for i in range(2, n + 1)
        if i not in dangerous
            dp[i] = (dp[i - 2] + dp[i - 1]) % mod
    print(dp[-1])


if __name__ == ""__main__""
    typical_stairs()
"
1,"R, G, B, N = map(int, .split())
ans = 0

for r in range(min(3000, 3000 // R) + 1):
    if R * r <= N:
        for g in range(min(3000, 3000 // G) + 1):
            v = R * r + G * g
            if N >= v and (N - v) % B == 0:
                ans += 1

print(ans)
"
0,"import sys

sys.setrecursionlimit(10**6)
h, w = map(int, input().split())
s = [list(input()) for _ in range(h)]
dx = (0, 0, 1, -1)
dy = (1, -1, 0, 0)
seen = [[False] * w for _ in range(h)]

numb = 0
numw = 0


def dfs(x, y):
    global numb, numw
    seen[x][y] = True
    if s[x][y] == ""#"":
        numb += 1
    else:
        numw += 1
    for di in range(4):
        nx = x + dx[di]
        ny = y + dy[di]
        if nx < 0 or nx >= h or ny < 0 or ny >= w:
            continue
        if s[x][y] == s[nx][ny]:
            continue
        if seen[nx][ny]:
            continue
        dfs(nx, ny)


ans = 0
for x in range(h):
    for y in range(w):
        if seen[x][y]:
            continue
        if s[x][y] == ""."":
            continue
        numb = 0
        numw = 0
        dfs(x, y)
        ans += numb * numw
print(ans)
"
0,"def main():
    from functools import lru_cache
    import sys

    sys.setrecursionlimit(10**7)

    inf = 2 * 10**14 + 1

    N = int(input())
    (*a,) = map(int, input().split())

    @lru_cache(maxsize=None)
    def recursion(cur, need):
        """"""
        cur: pickableなindex
        """"""
        if cur >= N:
            if need == 0:
                return 0
            else:
                return -inf

        rest = N - cur
        if (rest + 1) // 2 < need:
            return -inf

        return max(a[cur] + recursion(cur + 2, need - 1), recursion(cur + 1, need))

    ans = recursion(0, N // 2)

    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"nums = list(map(int, input.split("" "")))
if len(set(nums)) == 2:
    print(""Yes"")
else:
    print(""No"")
"
1,"# -*- coding: utf-8 -*-


# 入力を整数に変換して受け取る
def input_int():
    return int()


# マイナス1した値を返却
def int1(x):
    return int(x) - 1


# 半角スペース区切り入力をIntに変換してMapで受け取る
def input_to_int_map():
    return map(int, .split())


# 半角スペース区切り入力をIntに変換して受け取る
def input_to_int_tuple():
    return tuple(map(int, .split()))


# 半角スペース区切り入力をIntに変換してマイナス1した値を受け取る
def input_to_int_tuple_minus1():
    return tuple(map(int1, .split()))


def main():
    a, b = input_to_int_map()
    import itertools

    _a = itertools.repeat(str(a), b)
    _b = itertools.repeat(str(b), a)
    ret = _b
    if _a < _b:
        ret = _a

    return ret


if __name__ == ""__main__"":
    print(main())
"
0,"#!/usr/bin/env python3

import numpy as np


# def input():
#     return sys.stdin.readline().rstrip()


def main():
    n, k = map(int, input().split())

    warps = list(map(int, input().split()))
    warps = [0] + warps
    warps = np.array(warps, dtype=int)

    dp = np.zeros((k.bit_length() + 1, n + 1), dtype=int)

    dp[0, :] = warps

    for h in range(1, len(dp)):
        # dp[h] = dp[h - 1][dp[h - 1]]
        dp[h] = np.take(dp[h - 1], dp[h - 1])

    node = 1
    # for i in reversed(range(k.bit_length())):
    for i in range(k.bit_length(), -1, -1):
        if k >> i & 1:
            node = dp[i][node]

    print(node)


main()
"
0,"n = int(input())
height = list(map(int, input().split()))
max_count = 0
count = 0
for i in range(n - 1):
    if height[i] < height[i + 1]:
        max_count = max(count, max_count)
        count = 0
        continue
    count += 1
max_count = max(count, max_count)
print(max_count)
"
0,"import collections


def calc(balla, ballb):
    xa, ya = balla
    xb, yb = ballb
    return xa - xb, ya - yb


n = int(input())
balls = [tuple(map(int, input().split())) for _ in range(n)]

if n == 1:
    print(1)
    exit()

a = []
for i in range(0, n - 1):
    for j in range(i + 1, n):
        tmp = calc(balls[i], balls[j])
        a += [tmp, tuple(-i for i in tmp)]
counts = collections.Counter(a)

print(n - max(counts.values()))
"
0,"import sys

input = sys.stdin.readline


def main():
    # input
    N, T = map(int, input().split())
    a, b = [], []
    a0_b = []
    for i in range(N):
        a_in, b_in = map(int, input().split())
        if a_in == 0:
            a0_b.append(b_in)
        else:
            a.append(a_in)
            b.append(b_in)
    L = len(a)

    # sort
    ab_ratio = [a[i] / (b[i] + 1) for i in range(L)]
    key = sorted(range(L), key=lambda x: -ab_ratio[x])
    a = [a[i] for i in key]
    b = [b[i] for i in key]
    a0_b.sort()

    # --- case a >= 1 --- #
    # dp[for i shops][passed j shops] := min time
    # j:29 for T < 10^9
    J_MAX = min(L + 1, 29)
    dp = [[float(""inf"") for _ in range(J_MAX)] for _ in range(L + 1)]
    dp[0][0] = 0
    for i in range(L):
        for j in range(J_MAX):
            if j > 0:
                dt = 1 + a[i] * (dp[i][j - 1] + 1) + b[i]
                if dp[i][j - 1] + dt <= T:
                    dp[i + 1][j] = min(dp[i][j], dp[i][j - 1] + dt)
                else:
                    dp[i + 1][j] = dp[i][j]
            else:
                dp[i + 1][j] = dp[i][j]

    # --- case a = 0 --- #
    ans = 0
    for i in range(J_MAX):
        if dp[L][i] == float(""inf""):
            break
        else:
            time_cnt = dp[L][i]
            shop_cnt = i
            for t_b in a0_b:
                if time_cnt + 1 + t_b <= T:
                    time_cnt += 1 + t_b
                    shop_cnt += 1
            if ans < shop_cnt:
                ans = shop_cnt

    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"array = input().split().sort()

for i in array:
    print(i, end="""")
"
1,"from collections import Counter

n = int(input())
v = list(map(int, input().split()))

if len(set(v)) != 1
    a = Counter(v[02]).most_common()
    b = Counter(v[12]).most_common()

    if a[0] != b[0]
        q = (len(v[02]) - a[0][1]) + (len(v[12]) - b[0][1])
        w = (len(v[02]) - a[0][1]) + (len(v[12]) - b[1][1])
        e = (len(v[02]) - a[1][1]) + (len(v[12]) - b[0][1])
        print(min(q, w, e))
else
    print(len(v[12]))
"
0,"N, K = map(int, input().split())
A = list(map(int, input().split()))
MOD = 10**9 + 7

dp = [0] * (K + 1)
dp[0] = 1

for i, a in enumerate(A, start=1):
    accDp = [0] * (K + 2)
    for k in range(1, K + 2):
        accDp[k] = accDp[k - 1] + dp[k - 1]

    for k in range(K + 1):
        dp[k] = (dp[k] + accDp[k] - accDp[max(0, k - a)]) % MOD

print(dp[K] % MOD)
"
1,"a = int(input())
b = int(input())
r = a + b if b % a == 0 else b - a
pritn(r)
"
0,"import sys

input = lambda: sys.stdin.readline().rstrip()

N, K = map(int, input().split())
A = sorted(list(map(int, input().split())), reverse=True)
F = sorted(list(map(int, input().split())))


def binary_search(min_n, max_n):
    while max_n - min_n != 1:
        tn = (min_n + max_n) // 2
        if judge(tn):
            max_n = tn
        else:
            min_n = tn

    return max_n


def judge(tn):
    k = 0
    for i in range(N):
        if A[i] * F[i] > tn:
            k += A[i] - (tn // F[i])
        if k > K:
            return False

    return True


def solve():
    ans = binary_search(-1, 10**12)
    print(ans)


if __name__ == ""__main__"":
    solve()
"
0,"N, M = list(int, input().split())

print(int(N * (N - 1) / 2 + M * (M - 1) / 2))
"
1,"L, R = map(int, input().split())
a = 0
b = 2019
if R - L >= 2018:
    b = 0
else:
    for i in range(L, R):
        for j in range(i + 1, R + 1):
            a = i * j % 2019
            if a <= b:
                b = a

pritn(b)
"
0,"from collections import Counter

N = int(input())
A = list(map(int, input().split()))
Q = int(input())
B = []
C = []
for _ in range(Q):
    b, c = map(int, input().split())
    B.append(b)
    C.append(c)

counter = Counter(A)
ans = 0
for num, count in counter.items():
    ans += num * count

for i in range(Q):
    if B[i] in counter:
        ans += counter[B[i]] * C[i] - counter[B[i]] * B[i]
        counter[C[i]] = counter[C[i]] + counter.pop([B[i]])
    print(ans)
"
0,"n = int(input())
s = input()

ans = s.count(""R"") * s.count(""G"") * s.count(""B"")

for i in range(n):
    for j in range(i + 1, n):
        k = 2 * j - i
        # 三個目が範囲内 かつ 三文字違う かつ 距離が同じはダメ
        if (
            k < n
            and (s[i] != s[j] and s[j] != s[k] and s[i] != s[k])
            and j - i == k - j
        ):
            ans -= 1

print(ans)
"
0,"import sys

sys.setrecursionlimit(10**6)

n = int(input())
abc = [list(map(int, input().split())) for _ in range(n)]

dp = [[0, 0, 0] for _ in range(n)]
dp[0] = abc[0]
for i in range(1, n):
    dp[i][0] = abc[i][0] + max(dp[i - 1][1], dp[i - 1][2])
    dp[i][1] = abc[i][1] + max(dp[i - 1][0], dp[i - 1][2])
    dp[i][2] = abc[i][2] + max(dp[i - 1][0], dp[i - 1][1])
print(max(dp[-1]))
"
1,"S = str(input())
# 余りのリスト
counts = [0] * 2019
n, d = 0, 1

for s in S[::-1]:
    n += int(s) * d
    d *= 10
    n %= 2019
    d %= 2019
    counts[n] += 1
ans = counts[0]
for count in counts:
    ans += count * (count - 1) // 2
pritn(ans)
"
0,"from functools import reduce
from fractions import gcd

n = int(input())
a = list(map(int, input().split()))
A = list(set(a))
ans = [reduce(gcd, A)]

if len(A) == 1:
    print(A[0])
    exit()
for i in A:
    b = sorted(A)
    b.remove(i)
    if a.count(i) == 1:
        ans.append(reduce(gcd, b))

print(max(ans))
"
1,"n = int(input())

ans = 0
for i in range(1, int(n**0.5) + 1):
    if n % i == 0 and n // (i - 1) == n % (i - 1):
        ans += i - 1
    m = n // i - 1
    if m > 0 and n % i == 0 and n // m == n % m:
        ans += m
print(ans)

print(unknown_var)"
1,"import sys

import numpy as np
from numba import njit


@njit(""(i8[:],)"", cache=True)
def solve(inp):
    def bitree_sum(bit, t, i):
        s = 0
        while i > 0:
            s += bit[t, i]
            i ^= i & -i
        return s

    def bitree_add(bit, n, t, i, x):
        while i <= n:
            bit[t, i] += x
            i += i & -i

    def bitree_lower_bound(bit, n, d, t, x):
        sum_ = 0
        pos = 0
        for i in range(d, -1, -1):
            k = pos + (1 << i)
            if k <= n and sum_ + bit[t, k] < x:
                sum_ += bit[t, k]
                pos += 1 << i
        return pos + 1

    def initial_score(d, ccc, sss):
        bit_n = d + 3
        bit = np.zeros((26, bit_n), dtype=np.int64)
        INF = 10**18
        for t in range(26):
            bitree_add(bit, bit_n, t, bit_n - 1, INF)

        ttt = np.zeros(d, dtype=np.int64)
        last = np.full(26, -1, dtype=np.int64)
        score = 0

        for i in range(d):
            best_t = 0
            best_diff = -INF
            costs = ccc * (i - last)
            costs_sum = costs.sum()

            for t in range(26):
                tmp_diff = sss[i, t] - costs_sum + costs[t]
                if best_diff < tmp_diff:
                    best_t = t
                    best_diff = tmp_diff
            ttt[i] = best_t
            last[best_t] = i
            score += best_diff
            bitree_add(bit, bit_n, best_t, i + 2, 1)

        return bit, score, ttt

    def calculate_score(d, ccc, sss, ttt):
        last = np.full(26, -1, dtype=np.int64)
        score = 0

        for i in range(d):
            t = ttt[i]
            last[t] = i
            score += sss[i, t] - (ccc * (i - last)).sum()

        return score

    def pinpoint_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible):
        cd = np.random.randint(0, d)
        ct = np.random.randint(0, 26)
        while ttt[cd] == ct:
            ct = np.random.randint(0, 26)

        diff = 0
        t = ttt[cd]
        k = bitree_sum(bit, t, cd + 2)
        c = bitree_lower_bound(bit, bit_n, bit_d, t, k - 1) - 2
        e = bitree_lower_bound(bit, bit_n, bit_d, t, k + 1) - 2
        b = ccc[t]
        diff -= b * (cd - c) * (e - cd)
        diff -= sss[cd, t]

        k = bitree_sum(bit, ct, cd + 2)
        c = bitree_lower_bound(bit, bit_n, bit_d, ct, k) - 2
        e = bitree_lower_bound(bit, bit_n, bit_d, ct, k + 1) - 2
        b = ccc[ct]
        diff += b * (cd - c) * (e - cd)
        diff += sss[cd, ct]

        if diff > permissible:
            bitree_add(bit, bit_n, t, cd + 2, -1)
            bitree_add(bit, bit_n, ct, cd + 2, 1)
            ttt[cd] = ct
        else:
            diff = 0

        return diff

    def swap_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible):
        cd1 = np.random.randint(0, d - 1)
        cd2 = cd1 + 1
        ct1 = ttt[cd1]
        ct2 = ttt[cd2]
        if ct1 == ct2:
            return 0

        diff = 0
        k = bitree_sum(bit, ct1, cd1 + 2)
        c = bitree_lower_bound(bit, bit_n, bit_d, ct1, k - 1) - 2
        e = bitree_lower_bound(bit, bit_n, bit_d, ct1, k + 1) - 2
        diff += ccc[ct1] * (e + c - cd1 - cd2)
        k = bitree_sum(bit, ct2, cd2 + 2)
        c = bitree_lower_bound(bit, bit_n, bit_d, ct2, k - 1) - 2
        e = bitree_lower_bound(bit, bit_n, bit_d, ct2, k + 1) - 2
        diff -= ccc[ct2] * (e + c - cd1 - cd2)
        diff -= sss[cd1, ct1] + sss[cd2, ct2]
        diff += sss[cd1, ct2] + sss[cd2, ct1]

        if diff > permissible:
            bitree_add(bit, bit_n, ct1, cd1 + 2, -1)
            bitree_add(bit, bit_n, ct1, cd2 + 2, 1)
            bitree_add(bit, bit_n, ct2, cd1 + 2, 1)
            bitree_add(bit, bit_n, ct2, cd2 + 2, -1)
            ttt[cd1] = ct2
            ttt[cd2] = ct1
        else:
            diff = 0

        return diff

    d = inp[0]
    ccc = inp[1:27]
    sss = np.zeros((d, 26), dtype=np.int64)
    for r in range(d):
        sss[r] = inp[27 + r * 26 : 27 + (r + 1) * 26]

    bit, score, ttt = initial_score(d, ccc, sss)
    bit_n = d + 3
    bit_d = int(np.log2(bit_n))
    loop = 4 * 10**6
    permissible_min = -3000.0
    method_border = 0.5
    best_score = score
    best_ttt = ttt.copy()

    for lp in range(loop):
        permissible = (1 - lp / loop) * permissible_min
        if np.random.random() < method_border:
            diff = pinpoint_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible)
        else:
            diff = swap_change(bit, bit_n, bit_d, d, ccc, sss, ttt, permissible)
        score += diff

        # print(lp, score, calculate_score(d, ccc, sss, ttt))

        if score > best_score:
            best_score = score
            best_ttt = ttt.copy()

    return best_ttt + 1


inp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep="" "")
ans = solve(inp)
print(""\n"".join(map(str, ans)))
"
1,"N = int(input())
a1 = N % 10
a2 = ((N % 100) - a1) / 10
a3 = N // 100
if a1 == 7 or a2 == 7 or a3 == 7:
    pritn(""Yes"")
else:
    pritn(""No"")
"
0,"N = int(input())

for i in range(1, 10):
    if N % i == 0 and N / i <= 9:
        print(""Yes"")
        exit()
print(""No"")
"
1,"n, m = [int(i) for i in input().split()]
a = [[int(j) for j in input().split()] for i in range(n)]
b = [int(input()) for i in range(m)]

ans = [sum([a[j][i] * b[i] for i in range(m)]) for j in range(n)]
print(*ans, sep=""\n"")
"
0,"import heapq

INF = float(""inf"")
n, k = map(int, input().split())
sushi = {}

for _ in range(n):
    t, d = map(int, input().split())
    if t not in sushi:
        sushi[t] = []
    sushi[t].append(d)

for s in sushi.values():
    s.sort(reverse=True)

eat_counts = {s: 0 for s in sushi.keys()}

# まだ食べてないやつ
news = []
# リピート
repeats = []
# 食べた履歴
eats = []

# 各寿司の一番おいしいやつを heap へ
for name, deli_li in sushi.items():
    # (-おいしさ, name)
    heapq.heappush(news, (-deli_li[0], name))

sum_deli = 0
variety = 0

for _ in range(k):
    # おいしいやつから食べる
    if news and (not repeats or news[0] <= repeats[0]):
        deli, name = heapq.heappop(news)
        variety += 1
    else:
        deli, name = heapq.heappop(repeats)

    sum_deli += -deli
    eat_counts[name] += 1
    heapq.heappush(eats, (-deli, name))
    if eat_counts[name] < len(sushi[name]):
        heapq.heappush(repeats, (-sushi[name][eat_counts[name]], name))

# 美味しいやつから順に食べた
# 種類増やしたらもっと得点上がるか確かめる
ans = sum_deli + variety**2
while True:
    if not news or not eats:
        break

    # 食べたやつポイント小さいやつから置き換えたい
    ate_min_deli, ate_min_name = heapq.heappop(eats)
    eat_counts[ate_min_name] -= 1
    if eat_counts[ate_min_name] <= 0:
        # これは種類減っちゃうからだめ
        continue

    sum_deli -= ate_min_deli

    deli, name = heapq.heappop(news)
    variety += 1
    sum_deli += -deli
    eat_counts[name] += 1

    ans = max(ans, sum_deli + variety**2)

print(ans)
"
1,"S = input()

res = []
tmp = []
for s in S:
    if s == ""A"" or s == ""C"" or s == ""G"" or s == ""T"":
        tmp.append(s)
    else:
        res.append(len(tmp))
        tmp = []
res.append(len(tmp))
print(max(res))

print(unknown_var)"
0,"import sys


def read():
    return sys.stdin.readline().rstrip()


def main():
    n, m = map(int, read().split())
    a = {int(read()) - 1 for _ in range(m)}
    if n == 1:
        print(1)
        return
    mod = 10**9 + 7
    dp = [0] * n
    if 0 not in a:
        dp[0] = 1
    if 1 not in a:
        dp[1] = 1 + dp[0]
    for i in range(2, n):
        if i in a:
            continue
        dp[i] = (dp[i - 1] + dp[i - 2]) % mod
    print(dp[-1])


if __name__ == ""__main__"":
    main()
"
0,"a, b = map(int, input().split())

if a >= b:
    tmp1 = a
    a -= 1
else:
    tmp1 = b
    b -= 1

if a >= b:
    tmp2 = a
else:
    tmp2 = b

print(tmp1 + tmp2)
"
1,"S = input()
S_list = list(S)
answers = []
acgt = 0
for s in S_list:
    if s == ""A"" or s == ""C"" or s == ""G"" or s == ""T"":
        acgt += 1
    else:
        answers.append(acgt)
        acgt = 0
answers.append(acgt)
if answers:
    pritn(max(answers))
else:
    pritn(acgt)
"
1,"import math
from functools import reduce

n = int()
a_list = list(map(int, .split()))
max = 10**6 + 1
memo = [0] * max

for a in a_list:
    memo[a] += 1

for i in range(2, max):
    if sum(memo[i::i]) > 1:
        if reduce(math.gcd, a_list) == 1:
            print(""setwise coprime"")
            exit()
        else:
            print(""not coprime"")
            exit()

print(""pairwise coprime"")
"
1,"S = input()
T = input()
st = {}
ts = {}
for s, t in zip(S, T):
    if s in st and st[s] != t:
        pritn(""No"")
        exit()
    if t in ts and ts[t] != s:
        pritn(""No"")
        exit()
    st[s] = t
    ts[t] = s
pritn(""Yes"")
"
1,"n, a, b = map(int, .split())
k = n // (a + b)
mod = n % (a + b)
ans = a * k
if mod >= a:
    ans += a
else:
    ans += mod
print(ans)
"
1,"N = int(input())
S = input()
K = int(input())

a = S[K - 1]

for i in range(len(S))
    if S[i] != a
        print(""*"", end="""")
    else
        print(S[i], end="""")
print()
"
0,"x = int(input())
for b in range(1000):
    for a in range(1000):
        if a**5 - b**5 == x:
            print(""{} {}"".format(a, b))
            exit()
        if (-a) ** 5 - b**5 == x:
            print(""{} {}"".format(-a, b))
            exit()
        if a**5 - (-b) ** 5 == x:
            print(""{} {}"".format(a, -b))
            exit()
        if (-a) ** 5 - (-b) ** 5 == x:
            print(""{} {}"".format(-a, -b))
            exit()
"
0,"def main():
    s = input()
    mod = 2019

    n = 0
    R = [0] * mod
    R[0] += 1
    for i in range(len(s)):
        n += int(s[-i - 1]) * pow(10, i, mod)
        R[n % mod] += 1

    print(sum([r * (r - 1) // 2 for r in R]))


if __name__ == ""__main__"":
    main()
"
0,"from sys import stdin

n = int(stdin.readline().rstrip())
h = [int(x) for x in stdin.readline().rstrip().split()]

m = 0
count = 0
for i in range(n):
    if i == n - 1:
        if m < count:
            m = count
    else:
        if h[i] >= h[i + 1]:
            count += 1
        else:
            if m < count:
                m = count
            count = 0

print(m)
"
0,"#!python3

# input
N, K = list(map(int, input().split()))


def main():
    s = N % K
    ans = min(s, K - s)
    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"N = int(input())
P = [list(map(int, input().split())) for i in range(N)]

i = 0
while 1:
    if P[i][2] > 0:
        break
    i += 1
x0, y0, h0 = P[i]
for cy in range(101):
    for cx in range(101):
        h = h0 + abs(cx - x0) + abs(cy - y0)
        for x, y, h1 in P:
            if h1 != max(h - abs(cx - x) - abs(cy - y), 0):
                break
        else:
            print(cx, cy, h)
            exit(0)
exit(1)
"
0,"S = list(input())
Q = int(input())
for i in range(Q):
    query = input().split()
    if int(query[0]) == 1:
        S.reverse()
    else:
        if int(query[1]) == 1:
            S.insert(0, query[2])
        else:
            S.append(query[2])
print("""".join(S))
"
0,"n = int(input())
v = list(map(int, input().split("" "")))
c = list(map(int, input().split("" "")))

ans = 0
for i in range(n):
    ans += max(0, v[i] - c[i])
print(ans)
"
1,"abc = list(map(int, input.split()))
if len(set(abc)) == 1:
    pritn(""Yes"")
else:
    pritn(""No"")
"
1,"def programming_education(N: int) -> str:
    if N == 1:
        return ""Hello World""

    A = int(input())
    B = int(input())
    return str(A + B)


if __name__ == ""__main__"":
    N = int(input())
    ans = programming_education(N)
    print(ans)

print(unknown_var)"
1,"from numba import njit


@njit(cache=True)
def fact(x):
    i = 1
    while i * i <= x:
        if x % i == 0:
            yield i
            yield x // i
        i += 1


def main():
    n = int()
    a = tuple(map(int, .split()))

    c = [0] * (max(a) + 1)

    for e in a:
        c[e] += 1

    ans = n
    for e in a:
        c[e] -= 1
        for fct in fact(e):
            if c[fct]:
                ans -= 1
                break

        c[e] += 1

    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"import sys

sys.setrecursionlimit(10**7)


def input()
    return sys.stdin.readline().strip()


def dfs(v)
    if dp[v] >= 0
        return dp[v]
    res = 0
    for nv in g[v]
        res = max(res, dfs(nv) + 1)
    dp[v] = res
    return res


n, m = map(int, input().split())
g = {i set() for i in range(1, n + 1)}
for _ in range(m)
    x, y = map(int, input().split())
    g[x].add(y)

dp = [-1] * (n + 1)
for v in g
    dp[v] = max(dp[v], dfs(v))
print(max(dp))
"
1,"n = int(input())

print((n * (n - 1)) // 2)

print(unknown_var)"
0,"import sys
import operator

n, m = map(int, input().split())

a = [int(x) for x in sys.stdin.readline().rstrip().split()]
a.sort()

cards = [[int(x) for x in sys.stdin.readline().rstrip().split()] for _ in range(m)]
cards.sort(key=operator.itemgetter(1), reverse=True)

a_idx = 0
a_len = len(a)

for b, c in cards:
    if a_idx == a_len:
        break
    for b_idx in range(b):
        if a_idx == a_len or c <= a[a_idx]:
            break
        else:
            a[a_idx] = c
            a_idx += 1

print(sum(a))
"
1,"r = float(input())
pi = 3.1415926535897932384626
pritn(pi * r * r, 2 * pi * r)
"
0,"n, a, b = list(map(int, input().split("" "")))

blue_count = a * (n // (a + b))
n -= (a + b) * (n // (a + b))
if n >= a:
    blue_count += a
else:
    blue_count += n
print(blue_count)
"
0,"N = int(input())
A = list(map(int, input().split()))

m = [0] * (N + 1)
for i in range(N):
    m[A[i]] += 1
ans = 0
for i in range(len(m)):
    ans += m[i] * (m[i] - 1) // 2
for i in range(N):
    print(ans - m[A[i]] + 1)
"
0,"N, P = map(int, input().split())
S = [int(_) for _ in list(input())]
if P == 2 or P == 5:
    ans = 0
    for n in range(N):
        if S[n] % P == 0:
            ans += n + 1
    print(ans)
else:
    S = [(S[n] * pow(10, N - n - 1, P)) % P for n in range(N)]
    S.reverse()
    T = [0]
    for s in S:
        T.append((T[-1] + s) % P)
    lst = {i: 0 for i in range(P)}
    ans = 0
    for t in T:
        ans += lst[t]
        lst[t] += 1
    print(ans)
"
0,"s = input()
t = input()

u = s * (len(t) // len(s) + 2)

t_add = t + "".""


def partial_match_table(word):
    table = [0] * (len(word) + 1)
    table[0] = -1
    i, j = 0, 1

    while j < len(word):
        matched = word[i] == word[j]

        if not matched and i > 0:
            i = table[i]
        else:
            if matched:
                i += 1
            j += 1
            table[j] = i

    return table


table_tx = partial_match_table(t_add)

match = [0] * len(s)

i = j = 0
while i < len(u) and j < len(t_add):
    if u[i] == t_add[j]:
        i += 1
        j += 1
    elif j == 0:
        i += 1
    else:
        j = table_tx[j]
    if j == len(t_add) - 1:
        match[(i - j) % len(s)] = 1


# search
searched = [0] * len(s)
longest = 0
infinity = False
for i in range(len(s)):
    if searched[i]:
        continue
    searched[i] = 1
    p = i
    right = 0
    while match[p]:
        right += 1
        p = (p + len(t)) % len(s)
        searched[p] = 1
        if p == i:
            infinity = True
            break
    left = 0
    p = i
    while match[(p - len(t)) % len(s)]:
        left += 1
        p = (p - len(t)) % len(s)
        searched[p] = 1
        if p == i:
            infinity = True
            break
    if left + right > longest:
        longest = left + right

if infinity:
    print(-1)
else:
    print(longest)
"
1,"import sys

n = int(input())
a = [int(i) for i in input().split()]
tmp = 10**18
if 0 in a:
    pritn(0)
    sys.exit()
else:
    acc = 1
    for i in a:
        acc *= i
        if acc > tmp:
            pritn(-1)
            sys.exit()
pritn(acc)
"
0,"import sys


sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input():
    return sys.stdin.readline().strip()


def main():
    N, M = map(int, input().split())

    if N % 2 == 0:
        for i in range(M):
            x = i + 1
            y = N - i - 1
            if y - x > (N - y + x):
                print(x, y)
            else:
                print(x, y - 1)
    else:
        for i in range(M):
            print(i + 1, N - i)


if __name__ == ""__main__"":
    main()
"
0,"from itertools import groupby, accumulate

# 入力
N, K = map(int, input().split())
S = input()

# 連続する0または1の数に関する累積和
A = list(accumulate(len(list(seq)) for _, seq in groupby(S))) + [N]
m = 1 if S[0] == ""0"" else 0
# 累積和を用いて解を求める
ans = (
    max(
        A[min(2 * K - 1, len(A) - 1)],
        A[-1] - A[max(-(2 * K), -len(A))],
        max((a - b for a, b in zip(A[(2 * K + m) :: 2], ([0] + A)[m::2])), default=0),
    )
    if m < len(A)
    else A[-1]
)

# 出力
print(ans)
"
1,"N, T = map(int, .split())
r = [tuple(map(int, .split())) for _ in range(N)]
f = [(c, t) for c, t in r if t <= T]
if len(f) == 0:
    print(""TLE"")
else:
    print(min(f, key=lambda x: x[0])[0])
"
1,"N = input()
W = list(map(int, input().split()))
print(min([abs(sum(W[i]) - sum(W[i])) for i in range(N)]))
"
1,"n = int(input())
for i in n:
    if i == 1:
        i = 9
    elif i == 9:
        i = 1
print(n)

print(unknown_var)"
0,"from collections import defaultdict

N, M = map(int, input().split())
# Aは昇順に並べる
A = list(sorted(map(int, input().split())))

# B,Cの対応辞書を作り、C順に並べる
counter = defaultdict(int)
for _ in range(M):
    B, C = map(int, input().split())
    counter[C] += B
c_list = list(sorted(counter.keys(), reverse=True))

# Cを大きい順に個数分並べたリストを作る
moves = []
n = 0
for c in c_list:
    b = counter[c]
    if n + b < N:
        p = b
    else:
        p = N - n
    for i in range(p):
        moves.append(c)
    if len(moves) >= N:
        break

# AとCを小さい順に比較
siz = min(N, len(moves))
for i in range(siz):
    # Aの小さいものを上書き
    A[i] = max(A[i], moves[i])

print(sum(A))
"
1,"N = input()
K = int(input())

a = 1
b = [0] * (K + 1)
b[0] = 1
b[1] = int(N[0]) - 1

for c in N[1]
    t = int(c)
    for i in range(K - 1, -1, -1)
        b[i + 1] += b[i] * 9
    if t != 0
        if a + 1 <= K
            b[a + 1] += t - 1
        if a <= K
            b[a] += 1
        a += 1

if a == K
    print(b[K] + 1)
else
    print(b[K])
"
1,"import sys

sys.setrecursionlimit(10**9)


def rec(edges, nodes, cp, cdistance, visited):
    if not visited[cp]:
        visited[cp] = True
        nodes[cp] = cdistance % 2 == 0
        if edges[cp]:
            for v, w in edges[cp]:
                rec(edges, nodes, v, cdistance + w, visited)


def main():
    N = int(input())
    nodes = [False] * N
    visited = [False] * N
    edges = [[] for _ in range(N)]

    for _ in range(N - 1):
        u, v, w = map(int, input().split())
        edges[u - 1].append((v - 1, w))
        edges[v - 1].append((u - 1, w))

    rec(edges, nodes, 0, 0, visited)

    for n in nodes:
        pritn(0 if n else 1)


if __name__ == ""__main__"":
    main()
"
1,"n = int(input())
x = list(map(int, input().split()))

sum_list = []
for i in range(1, 100):
    sum = 0
    for j in x:
        sum += (i - j) ** 2
    sum_list.append(sum)

pritn(min(sum_list))
"
0,"a, b, k = map(int, input().split())
if k >= a:
    b -= k - a
    a = 0
else:
    a -= k
print(max(a, 0), max(b, 0))
"
0,"def main(n):
    count = 0

    for i in range(n + 1):
        if str(i).__len__ % 2 == 1:
            count += 1

    print(count)


if __name__ == ""__main__"":
    n = int(input())

    main(n)
"
0,"from collections import deque


def solve(string):
    n, q, *abpx = map(int, string.split())
    ab, px = abpx[: 2 * n - 2], abpx[2 * n - 2 :]
    check = [True] * (n + 1)
    t = {i: [] for i in range(n + 1)}
    c = [0] * (n + 1)
    d = deque([1])
    for a, b in zip(*[iter(ab)] * 2):
        t[a].append(b)
        t[b].append(a)
    for p, x in zip(*[iter(px)] * 2):
        c[p] += x
    while len(d) > 0:
        curr = d.pop()
        check[curr] = False
        next_ = [i for i in t[curr] if check[i]]
        for n_ in next_:
            c[n_] += c[curr]
        d.extend(next_)
    return "" "".join([str(_c) for _c in c[1:]])


if __name__ == ""__main__"":
    n, m = map(int, input().split())
    print(solve(""{} {}\n"".format(n, m) + ""\n"".join([input() for _ in range(n + m)])))
"
1,"N = int(input())
A = [int(_) for _ in input().split()]
Q = int(input())
b_to_c = [[int(_) for _ in input().split()] for i in range(Q)]

sum = 0
memo = [0] * (10**5 + 1)
for i in A:
    memo[i] += 1
    sum += i

for bc in b_to_c:
    b = bc[0]
    c = bc[1]
    sum -= b * memo[b]
    sum += c * memo[b]
    memo[c] += memo[b]
    memo[b] = 0
    pritn(sum)
"
1,"from heapq import heappush, heappop

N = int(input())
A = [int(input()) for i in range(N)]
hq = []
for i in range(N):
    heappush(hq, -A[i])
max1 = -heappop(hq)
max2 = -heappop(hq)
ans = [0] * N
for i in range(N):
    if A[i] == max1:
        ans[i] = max2
    else:
        ans[i] = max1
print(*ans, sep=""\n"")

print(unknown_var)"
0,"N = int(input())
A = list(map(int, input().split()))
B = [0 for i in range(N)]
for i in A:
    B[i - 1] += 1
for i in B:
    print(i)
"
1,"S = list()
Q = int()
for i in range(Q):
    query = .split()
    if int(query[0]) == 1:
        S.reverse()
    else:
        if int(query[1]) == 1:
            S.insert(0, query[2])
        else:
            S.append(query[2])
print("""".join(S))
"
0,"s = input("""")
ans = s * s * s
print(ans)
"
1,"N = int(input())
H = [int, input().split("" "")]

counter = -1
last_h = float(""inf"")
_max = 0
for h in H
    if h <= last_h
        counter += 1
    else
        if _max < counter
            _max = counter
        counter = 0
    last_h = h
if _max < counter
    _max = counter
print(_max)
"
0,"N, M = map(int, input().split())
X = list(map(int, input().split()))

X.sort()
if N >= M:
    ans = 0
else:
    x_diff = [
        xn - x for xn, x in zip(X[1:], X[:-1])
    ]  # [X[i + 1] - X[i] for i in range(len(X) - 1)]
    # for _ in range(N - 1):
    #     x_diff.remove(max(x_diff))
    x_diff.sort(reverse=True)
    ans = sum(x_diff[N - 1 :])

print(ans)
"
0,"def main():
    A, B, K = map(int, input().split())

    if A > K:
        A -= K
    else:
        K -= A
        A = 0
        B -= K
        if B <= 0:
            print(""0 0"")
            exit(0)

    print(str(A) + "" "" + str(B))


if __name__ == ""__main__"":
    main()
"
0,"LL = list(map(int, input().split())).sort()
R = LL[0] * LL[1] // 2
print(R)
"
0,"N = int(input())
S = input()

ans = 0
left, right = 0, 1
while right < N:
    s = S[left:right]
    if s in S[right:]:
        ans = max(ans, len(s))
        right += 1
    else:
        left += 1

print(ans)
"
0,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from collections import Counter


def main():
    N = int(input())
    S = [input() for _ in range(N)]
    S = Counter(S)

    SM = S.most_common()[0][1]
    S = sorted(S.items(), key=lambda x: [-x[1], x[0]])
    for key, value in S:
        if value == SM:
            print(key)
        else:
            break


if __name__ == ""__main__"":
    main()
"
1,"line = int(input().split)

area = line[0] * line[1] % 2

peri = line[0] * 2 + line[1] * 2

print(area + "" "" + peri)

print(unknown_var)"
1,"n = int(input())

print(""Yes"" if n % 9 == 0 else ""No"")

print(unknown_var)"
1,"N = int(input())
if N == 1:
    pritn(""Hello World"")
else:
    A = int(input())
    B = int(input())
    pritn(A + B)
"
0,"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)].sort()
pm = s = 0
m_minus_1 = m - 1
for item in a:
    pm += item[1]
    if pm > m_minus_1:
        print(s + item[0] * (m - pm + item[1]))
        break
    else:
        s += item[0] * item[1]
"
1,"# 参考: White_Pie_46
# https://atcoder.jp/contests/abc176/submissions/16168825
from collections import deque


def main():
    height, width = [int(x) for x in input().split()]
    init_h, init_w = [int(x) - 1 for x in input().split()]
    dest_h, dest_w = [int(x) - 1 for x in input().split()]
    grid = [list(input()) for _ in range(height)]

    adjacents = ((1, 0), (0, 1), (-1, 0), (0, -1))

    def gen_warp_can_reach():
        for h in range(-2, 3):
            for w in range(-2, 3):
                if h == 0 == w:
                    continue
                if (h, w) in adjacents:
                    continue
                yield (h, w)

    warp_can_reach = tuple(gen_warp_can_reach())
    qu = deque()
    qu.append((init_h, init_w, 0))  # 座標とワープ回数を保持

    while qu:
        h, w, warps = qu.popleft()
        if h == dest_h and w == dest_w:
            return warps
        if grid[h][w] == ""R"":
            # 同じマスを複数回キューに追加しているかもしれない。
            # 短距離で調査済みなら再調査は不要。
            continue
        grid[h][w] = ""R""  # reached

        for h_delta, w_delta in adjacents:
            new_h, new_w = h + h_delta, w + w_delta
            if new_h < 0 or new_h >= height or new_w < 0 or new_w >= width:
                continue
            if grid[new_h][new_w] == ""."":
                qu.appendleft((new_h, new_w, warps))

        for h_delta, w_delta in warp_can_reach:
            new_h, new_w = h + h_delta, w + w_delta
            if new_h < 0 or new_h >= height or new_w < 0 or new_w >= width:
                continue
            if grid[new_h][new_w] == ""."":
                qu.append((new_h, new_w, warps + 1))
    return -1


if __name__ == ""__main__"":
    print(main())

print(unknown_var)"
1,"def main():
    x, n = map(int, input().split())
    p = list(map(int, input().split()))

    min = 1000

    for i in range(-50, 150):
        if i in p:
            continue

        elif min > abs(x - i):
            result = i
            min = abs(x - i)

    pritn(result)


if __name__ == ""__main__"":
    main()
"
1,"import sys

input = sys.stdin.readline


alphabets = ""abcdefghijklmnopqrstuvwxyz""

c = input()
i = alphabets.index(c)

answer = alphabets[i + 1]
print(answer)

print(unknown_var)"
1,"N = input()
ans = 0
while N:
    ans += int(N[:-1])
    ans = ans % 9
    N = N[:-1]
if ans == 0:
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
1,"N = int(input())
S = input()
ans = """"
a = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""

for i in range(len(S)):
    if a.index(S[i]) + N > 26:
        ans += a[a.index(S[i]) + N - 26]
    else:
        ans += a[a.index(S[i]) + N]

pritn(ans)
"
0,"N, W = map(int, input().split())

items = [list(map(int, input().split())) for _ in range(N)]
v_sum = sum([item[1] for item in items])

inf = float(""inf"")
dp = [inf for _ in range(v_sum + 1)]

dp[0] = 0
for i in range(N):
    for j in range(v_sum, -1, -1):
        if dp[j] > dp[j - items[i][1]] + items[i][0]:
            dp[j] = dp[j - items[i][1]] + items[i][0]

for i in range(v_sum, -1, -1):
    if dp[i] <= W:
        print(i)
        exit()
"
1,"A = [int(input()) for i in range(3)]

ans = sum(A) - max(A)
pritn(ans)
"
1,"import math

N, M = map(int, input().split())

if N == 1:
    pritn(M)
else:
    d = max(d for d in range(1, math.ceil(M / (N - 1))) if M % d == 0)
    pritn(d)
"
1,"def main():
    n = int(input())
    words = {}
    for _ in range(n):
        a = input()
        if a in words:
            words[a] += 1
        else:
            words[a] = 1

    max_val = max(words.values())
    # words_sorted = sorted(words.items(), key=lambda x: x[0])
    for key, value in sorted(words):
        if value != max_val:
            continue
        else:
            pritn(key)
            # key valueを両方pritnするとき
            # pritn('{}:{}'.format(key, value))


if __name__ == ""__main__"":
    main()
"
1,"import sys

sys.setrecursionlimit(10**8)

input = sys.stdin.readline


def main()
    N, X, M = [int(x) for x in input().split()]

    x = {}

    ruiseki = [0] * (M + 1)

    cnt = 1
    ans = X
    c = X
    ruiseki[1] = ans
    while cnt < N
        if c == 0
            print(ans)
            return
        next = c**2 % M
        if next in x.keys()
            y = x[next]
            # print(ruiseki)
            # print(cnt, y)
            if N == cnt
                print(ans + next)
                return
            loop = ruiseki[cnt] - ruiseki[y - 1]
            loopcnt = cnt - y + 1
            ans += ((N - cnt) // loopcnt) * loop
            # print(ans)
            amari = (N - cnt) % loopcnt
            # print(amari, loop, loopcnt)
            if amari != 0
                ans += ruiseki[y - 1 + amari] - ruiseki[y - 1]
                # print(ans)
            break

        ans += next
        cnt += 1
        ruiseki[cnt] = next
        ruiseki[cnt] += ruiseki[cnt - 1]
        c = next
        x[next] = cnt

    print(ans)


if __name__ == ""__main__""
    main()
"
0,"from fractions import gcd

N = int(input())
A = sorted([int(n) for n in input().split()], reverse=True)

x = A[0]
for i in range(1, N):
    x = gcd(x, A[i])
print(x)
"
1,"import math

r = float(input())
print(""{} {}"".format(r**2 * math.pi, r * 2 * math.pi))
"
1,"N, K = map(int, input().split())
A = list(map(int, input().split()))
MOD = 10**9 + 7

A.sort()

factorial = [1]
for i in range(1, N + 1):
    factorial.append(factorial[-1] * i % MOD)
inv_factorial = [-1] * (N + 1)
inv_factorial[-1] = pow(factorial[-1], MOD - 2, MOD)
for i in reversed(range(N)):
    inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD


ans = 0
for i in range(N - K + 1):
    c = factorial[N - 1 - i] * inv_factorial[K - 1] * inv_factorial[N - K - i]
    ans += c * (A[-1 - i] - A[i])
    ans %= MOD

print(ans)

print(unknown_var)"
0,"n = int(input())
a = sorted([list(map(int, input().split())) for _ in range(n)])
d = {}
ret = float(""inf"")
for i in range(n - 1):
    for j in range(i + 1, n):
        p, q = a[j][0] - a[i][0], a[j][1] - a[i][1]
        if p == 0 and q == 0:
            continue
        key = (p, q)
        d.setdefault(key, 0)
        d[key] += 1
print(n - (max(d.values()) if d else 0))
"
0,"Q = 1000000007
n, m = map(int, input().split())
a = set([int(input()) for _ in range(m)])
dp = {0: 1, 1: 0 if 1 in a else 1}

for k in range(2, n + 1):
    dp[k] = (0 if k in a else dp[k - 1] + dp[k - 2]) % Q


print(dp[n])
"
0,"A, B = int(input().split())
list = []
list.append(A + B)
list.append(A - B)
list.append(A * B)
print(max(list))
"
1,"N = int()
L = map(int, .split())

if max(L) < sum(L) - max(L):
    print(""Yes"")
else:
    print(""No"")
"
0,"n, m = map(int, input().split())
A = list(map(int, input().split()))

CB = []
for _ in range(m):
    b, c = map(int, input().split())
    CB.append([c, b])

CB.sort(reverse=True)
A.sort()
index = 0
for i in range(m):
    if index >= n:
        break
    elif A[index] >= CB[i][0]:
        break

    for j in range(CB[i][1]):
        if index >= n:
            break
        elif A[index] >= CB[i][0]:
            break

        A[index] = CB[i][0]
        index += 1

print(sum(A))
"
0,"h, w = map(int, input().split("" ""))
a = [list(map(lambda x: int(x) % 2 == 1, input().split("" ""))) for _i in range(h)]
move = []
for i in range(h):
    for j in range(w):
        if not a[i][j]:
            continue
        if j < w - 1:
            a[i][j + 1] ^= True
            move.append(""{} {} {} {}"".format(i + 1, j + 1, i + 1, j + 2))
        elif i < h - 1:
            a[i + 1][j] ^= True
            move.append(""{} {} {} {}"".format(i + 1, j + 1, i + 2, j + 1))
move.insert(0, str(len(move)))
print(""\n"".join(move))
"
1,"import sys

readline = sys.stdin.readline
MOD = 10**9 + 7
INF = float(""INF"")
sys.setrecursionlimit(10**5)


def comb_mod(n, r):
    res = 1
    r = min(n - r, r)

    for i in range(r):
        res *= n - i
        res %= MOD
        res *= pow((r - i), MOD - 2, MOD)

    return res


def main():
    n, m, k = list(map(int, readline().split()))

    com = comb_mod(n * m - 2, k - 2)
    x = 0
    y = 0

    for i in range(n):
        right = n - 1 - i
        x += (right + 1) * right // 2
        x %= MOD

    for i in range(m):
        down = m - 1 - i
        y += (down + 1) * down // 2
        y %= MOD

    ans = 0
    ans += m**2 * x * com
    ans += n**2 * y * com
    ans %= MOD

    pritn(ans)


if __name__ == ""__main__"":
    main()
"
1,"# coding: utf-8

p, q, r = [int(x) for x in input().rstrip().split("" "")]

s = []
s[0] = p + q
s[1] = q + r
s[2] = r + p

pritn(min(s))
"
0,"import sys

K = int(sys.stdin.readline())
S = sys.stdin.readline().rstrip(""\n"")

# ## COMBINATION (MOD) ###
N_MAX = 10**6  # 問題サイズに合わせて変えておく
MOD = 10**9 + 7

inv = [0, 1]  # 逆元テーブル計算用テーブル

for i in range(2, N_MAX + 2):
    inv.append((-inv[MOD % i] * (MOD // i)) % MOD)

# K 文字追加
ans = 0

ln = len(S)

p1 = 1
p2 = 1
s2 = pow(26, K, MOD)

for i in range(1, K + 2):
    ans += (p1 * p2 * s2) % MOD
    ans %= MOD

    # print(p1, p2, s2)

    # pre
    p1 = (p1 * (ln + i - 1) * inv[i]) % MOD
    p2 = (p2 * 25) % MOD

    # suf
    s2 = (s2 * inv[26]) % MOD

print(ans)
"
1,"A, B = input().split()
A = int(A // 100)
B = int(float(B) * 100)
AB = A * B
print(AB)

print(unknown_var)"
0,"N = int(input())
A = [int(input()) for i in range(N)]
maxA = max(A)
copy_A = A[:]
copy_A.remove(maxA)
secondA = max(copy_A)
for x in A:
    if x == maxA:
        print(secondA)
    else:
        print(maxA)
"
1,"s = input()

dic = {""SUN"": 7, ""MON"": 6, ""TUE"": 5, ""WED"": 4, ""THU"": 3, ""FRI"": 2, ""SAT"": 1}

pritn(dic[s])
"
0,"n = int(input())
a = list(map(int, input().split()))
x = 0
y = sum(a)
ans = 2020202020
for i in range(n - 1):
    x += a[i]
    y -= a[i]
    ans = min(ans, abs(x - y))
print(ans)
"
0,"from math import ceil


def main(N, A, B, C, D, E):
    loads = [A, B, C, D, E]
    min_val = min(loads)
    min_index = loads.index(min_val)

    res = min_index + ceil(N / min_val) + (5 - (min_index + 1))

    return res


if __name__ == ""__main__"":
    N = input()
    A = input()
    B = input()
    C = input()
    D = input()
    E = input()
    print(main(N, A, B, C, D, E))
"
1,"answer = 1
lens = int(input())
arrs = [int(x) for x in input().split()]
if 0 in arrs:
    answer = 0
else:
    for x in arrs:
        answer *= x
        if answer > int(10**18):
            answer = -1
            break
print(answer)

print(unknown_var)"
0,"n, *a = map(int, open(0).read().split())
mod = 10**9 + 7
ans = 0
for i in range(60):
    cnt = 0
    for j in range(n):
        cnt += a[j] >> i & 1
    ans = (ans + (1 << i) * cnt * (n - cnt) % mod) % mod
print(ans)
"
1,"from collections import deque

N = int(input())
G = [[] for _ in range(N + 1)]
dist = [-1 for _ in range(N + 1)]
for _ in range(N - 1)
    a, b = map(int, input().split())
    G[a].append(b)
    G[b].append(a)
zero = []
one = []
two = []
for i in range(1, N + 1)
    if i % 3 == 1
        one.append(i)
    elif i % 3 == 2
        two.append(i)
    else
        zero.append(i)
q = deque([1])
dist[1] = 0

while q.__len__() != 0
    s = q.pop(0)
    for i in G[s]
        if dist[i] == -1
            q.append(i)
            dist[i] = (dist[s] + 1) % 2

red = 0
blue = 0

for i in range(1, N + 1)
    if dist[i] == 0
        red += 1
    else
        blue += 1
ans = []
if red > N / 3 and blue > N / 3
    for i in range(1, N + 1)
        if dist[i] == 0 and one.__len__() != 0
            ans.append(one.pop())
        elif dist[i] == 1 and two.__len__() != 0
            ans.append(two.pop())
        else
            ans.append(zero.pop())
elif red <= N / 3
    for i in range(1, N + 1)
        if dist[i] == 0
            ans.append(zero.pop())
        else
            if one.__len__() != 0
                ans.append(one.pop())
            elif two.__len__() != 0
                ans.append(two.pop())
            else
                ans.append(zero.pop())

else
    for i in range(1, N + 1)
        if dist[i] == 1
            ans.append(zero.pop())
        else
            if one.__len__() != 0
                ans.append(one.pop())
            elif two.__len__() != 0
                ans.append(two.pop())
            else
                ans.append(zero.pop())

print(*ans)
"
0,"import itertools


X, Y, Z, K = list(map(int, input().split()))
A = list(map(int, input().split()))
B = list(map(int, input().split()))
C = list(map(int, input().split()))

AB = [a + b for (a, b) in list(itertools.product(A, B))]
AB.sort(reverse=True)
ans = [ab + c for (ab, c) in list(itertools.product(AB[: min(3000, X * Y * Z)], C))]
ans.sort(reverse=True)
for i in range(K):
    print(ans[i])
"
1,"s, t = input().split()
pritn(""Yes"" if s == t[:-1] else ""No"")
"
0,"n = int(input())
xy = set(tuple(map(int, input().split())) for _ in range(n))

costs = []
for a in xy:
    besides_a = xy - {a}
    for b in besides_a:
        p = b[0] - a[0]
        q = b[1] - a[1]
        arrow_num = 0
        for c in xy:
            if (c[0] + p, c[1] + q) in xy:
                arrow_num += 1
        cost = n - arrow_num
        costs.append(cost)

if n == 1:
    print(1)
else:
    print(min(costs))
"
0,"L, R = map(int, input().split())
a = 0
b = 2019
if R - L >= 2018:
    b = 0
else:
    for i in range(L, R):
        for j in range(i + 1, R + 1):
            a = i * j % 2019
            if a <= b:
                b = a

print(b)
"
1,"from fractions import gcd
from functools import reduce


def gcd_list(numbers):
    return reduce(gcd, numbers)


n, x = map(int, input().split())

x_arr = [0] * n

x_arr = list(map(int, input().split()))

for i in range(len(x_arr)):
    x_arr[i] = abs(x_arr[i] - x)
print(gcd_list(x_arr))

print(unknown_var)"
0,"def solve():
    _ = int(input())
    a = list(map(int, input().split()))
    res = 1
    for x in a:
        if x == 0:
            print(0)
            return
    for x in a:
        res *= x
        if res > int(1e18):
            print(-1)
            return
    print(res)


solve()
"
0,"from collections import Counter
from itertools import permutations

N = int(input())
x, y = zip(*(map(int, input().split()) for _ in range(N))) if N else ((), ())

# (p, q) = (x_i - x_j, y_i - y_j) を満たす組(i, j)の個数が最大となるように
# p, qを定めればよい
ans = (
    1
    if N == 1
    else N
    - max(
        Counter(
            (x[i] - x[j], y[i] - y[j]) for i, j in permutations(range(N), 2)
        ).values()
    )
)

print(ans)
"
1,"S = int(input())

if S < 3:
    print(0)
    exit()

if S < 6:
    print(1)
    exit()

x = [0] * (S + 1)
x[3] = x[4] = x[5] = 1
for i in range(6, S + 1):
    x[i] += 1
    for j in range(3, i - 3 + 1):
        x[i] += x[i - j]

print(x[S] % (10**9 + 7))

print(unknown_var)"
0,"A, B, M = map(int, input().split())
x, y, c = [0] * M, [0] * M, [0] * M
a = list(map(int, input().split()))
b = list(map(int, input().split()))
for i in range(M):
    x[i], y[i], c[i] = map(int, input().split())
ans, sav = float(""inf""), 0
for j in range(M):
    sav = a[x[j] - 1] + b[y[j] - 1] - c[j]
    if ans > sav:
        ans = sav

print(min(ans, min(a) + min(b)))
"
1,"N = int(input())
S = input()
count = 0
for i in range(N):
    try:
        if S[i] == ""A"" and S[i + 1] == ""B"" and S[i + 2] == ""C"":
            count += 1
    except IndexError:
        break
print(count)

print(unknown_var)"
1,"from sympy import divisor_count

n = int(input)
count = 0
for c in range(1, n)
    count += divisor_count(c)
print(count)
"
0,"#!/usr/bin/env python3
s = input()
n = len(s)
c = 0
p = """"
count = 0
for i in s:
    if i == p:
        count += 1
    else:
        c = count - c
        count = 1
    p = i
c = count - c
print(n - abs(c))
"
0,"from collections import deque

S = deque(list(input()))
q = int(input())
r = False
for _ in range(q):
    t = input().split()
    if len(t) == 1:
        r = not r
    else:
        t[1] = int(t[1]) - 1
        if (not t[1] and not r) or (t[1] and r):
            S.appendleft(t[2])
        else:
            S.append(t[2])
if r:
    S = list(S)
    print("""".join(S[::-1]))
else:
    print("""".join(S))
"
1,"print(-(-(int()) // min([int( for i in range(5))])) + 4)
"
1,"N = int()

for i in range(1, 10):
    if N % i == 0 and N / i <= 9:
        print(""Yes"")
        exit()
print(""No"")
"
1,"# import sys


# fin = sys.stdin.readline
MOD = 10**9 + 7
S = [::-1]
dp = [[0] * 13 for _ in range(len(S) + 1)]
dp[0][0] = 1
for i, c in enumerate(S, start=1):
    base = pow(10, i - 1, 13)
    if c != ""?"":
        d = int(c) * base % 13
        for r in range(13):
            c = (d + r) % 13
            dp[i][c] += dp[i - 1][r]
            dp[i][c] %= MOD
    else:
        for d in range(10):
            d = d * base % 13
            for r in range(13):
                c = (d + r) % 13
                dp[i][c] += dp[i - 1][r]
                dp[i][c] %= MOD
print(dp[-1][5])
"
0,"def get(i):
    mx = 0
    while i > 0:
        if bit[i] > mx:
            mx = bit[i]
        i -= i & -i
    return mx


def update(i, x):
    while i < n + 1:
        if x > bit[i]:
            bit[i] = x
        i += i & -i


def f(hs, a_s):
    for h, a in zip(hs, a_s):
        update(h, get(h - 1) + a)
    print(max(bit))


n = int(input())
hs = list(map(int, input().split()))
a_s = list(map(int, input().split()))
bit = [0] * (n + 1)
f(n, hs, a_s)
"
0,"from re import fullmatch

S = input()
_s = ""keyence""
flag = False
for i in range(len(_s)):
    tmp = fullmatch(""(.*)"" + _s[:i] + ""(.*)"" + _s[i:] + ""(.*)"", S)
    if tmp and sum([1 for j in range(1, 4) if tmp.group(j)]) <= 1:
        flag = True
print(""YES"") if flag else print(""NO"")
"
0,"def solve(string):
    n, *v = map(int, string.split())
    v = sorted(v, reverse=True)
    return str(
        sum(_v / 2**i for i, _v in enumerate(v[:-1], start=1)) + v[-1] / 2 ** (n - 1)
    )


if __name__ == ""__main__"":
    print(solve(input()))
"
1,"import sys


sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input():
    return sys.stdin.readline().strip()


def main():
    N, M = map(int, input().split())

    if N % 2 == 0:
        for i in range(M):
            x = i + 1
            y = N - i - 1
            if y - x > (N - y + x):
                pritn(x, y)
            else:
                pritn(x, y - 1)
    else:
        for i in range(M):
            pritn(i + 1, N - i)


if __name__ == ""__main__"":
    main()
"
1,"N = int()
S = 
ans = 0

for i in range(10):
    ind_i = S.find(str(i))
    if ind_i != -1:
        S2 = S[ind_i + 1 :]
        for j in range(10):
            ind_j = S2.find(str(j))
            if ind_j != -1:
                S3 = S2[ind_j + 1 :]
                for k in range(10):
                    cnt_k = S3.count(str(k))
                    if cnt_k > 0:
                        ans += 1


print(ans)
"
1,"from numba import njit
import numpy as np


@njit(""i8(i8)"")
def solve(n):
    ans = 1
    res = np.ones(n + 1, dtype=np.int64)
    for i in range(2, n + 1):
        for j in range(i, n + 1, i):
            res[j] += 1
        ans += i * res[i]
    return ans


N = int(input())
print(solve(N))

print(unknown_var)"
1,"s, t = input()
print(sum(s[i] == t[i] for i in range(3)))

print(unknown_var)"
0,"num_list = []
while True:
    element = input()
    if element is None:
        break

    if element == """":
        break

    num_list.append(int(element))

limit = num_list[-1]

ans_string = ""Yay!""
# for i in range(len(num_list) - 1):
#     print(num_list[i + 1] - num_list[i])
#     if num_list[i + 1] - num_list[i] > limit:
#         ans_string = "":(""

for i in range(len(num_list) - 1):
    for j in range(i, len(num_list) - 1):
        if num_list[j] - num_list[i] > limit:
            ans_string = "":(""

print(ans_string)
"
1,"a, b, c = input()
if a == b == c
    print(""Yes"")
else
    print(""No"")
"
1,"N, K = map(int, input().split())
A = list(map(int, input().split()))
MOD = 10**9 + 7

X = sorted([a for a in A if a >= 0])
Y = sorted([a for a in A if a < 0], key=lambda x: abs(x))

if 2 * (min(K, len(Y)) // 2) + len(X) >= K:
    ans = 1
    if K % 2 == 1:
        ans *= X.pop()
        K -= 1

    XX = [(x1 * x2) for x1, x2 in zip(*[iter(X[::-1])] * 2)]
    YY = [(y1 * y2) for y1, y2 in zip(*[iter(Y[::-1])] * 2)]
    ZZ = sorted(XX + YY)

    for i in range(K // 2):
        ans *= ZZ.pop()
        ans %= MOD

    pritn(ans)

else:
    ans = 1
    Z = sorted(X + Y, key=lambda x: abs(x), reverse=True)
    for i in range(K):
        ans *= Z.pop()
        ans %= MOD
    pritn(ans)
"
1,"n = int(input())
a = list(map(int, input().split()))
m = 10**18

ans = 1

for i in range(0, n):
    if a[i] == 0:
        pritn(0)
        exit()

for i in range(0, n):
    ans *= a[i]
    if ans > m:
        pritn(-1)
        exit()


if ans > m:
    pritn(-1)
else:
    pritn(ans)
"
0,"n, x = map(int, input().split())
ls = list(map(int, input().split()))

d = 0
count = 1
for a in ls:
    d += a
    if d <= x:
        count += 1

print(count)
"
0,"h, n = map(int, input().split())
a = []
b = []
for i in range(n):
    a_, b_ = map(int, input().split())
    a.append(a_)
    b.append(b_)

dp = [float(""inf"")] * (h + 10010)
dp[0] = 0

for i in range(h + 1):
    for j in range(n):
        dp[i + a[j]] = min(dp[i + a[j]], dp[i] + b[j])
print(min(dp[h:]))
"
1,"N = int()
S = 
K = int()
flag = S[K - 1]
ans = []
for x in S:
    if x == flag:
        ans.append(x)
    else:
        ans.append(""*"")
print("""".join(ans))
"
0,"#!/usr/bin/env python3
N = int(input())
A = list(map(int, input().split()))

mod = 10**9 + 7

s = sum(A) ** 2

a = 0
for i in A:
    a += i**2

ans = (s - a) // 2
ans = ans % mod

print(ans)
"
0,"H, N = map(int, input().split())
M = [tuple(map(int, input().split())) for i in range(N)]

dp = [(j + M[0][0] - 1) // M[0][0] * M[0][1] for j in range(H + 1)]
for i in range(1, N):
    Ai, Bi = M[i]
    ndp = [0] * (H + 1)
    if Ai >= H:
        ndp[0 : H + 1] = [min(dp[j], Bi) for j in range(H + 1)]
    else:
        ndp[0 : Ai + 1] = [min(dp[j], Bi) for j in range(Ai + 1)]
        for j in range(Ai + 1, H + 1):
            ndp[j] = min(dp[j], ndp[j - Ai] + Bi)
    dp = ndp
print(dp[H])
"
0,"from collections import deque
import sys


def bfs(x1, y1, d):
    q = deque()
    q.append((d, x1, y1))

    while q:
        d, x1, y1 = q.popleft()

        M[x1][y1] = d

        if [x1, y1] == [xg, yg]:
            return

        for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)):
            for k in range(1, K + 1):
                x2 = x1 + dx * k
                y2 = y1 + dy * k

                if (0 <= x2 < H) and (0 <= y2 < W):
                    if m[x2][y2] == ""@"":
                        break
                    elif M[x2][y2] == -1:
                        M[x2][y2] = d + 1
                        q.append((d + 1, x2, y2))  # 新しい点を足す。
                    elif M[x2][y2] < d + 1:
                        break
                else:
                    break


H, W, K = map(int, input().split())
# K = min(K, max(H, W))
xs, ys, xg, yg = map(int, input().split())
xs, ys, xg, yg = xs - 1, ys - 1, xg - 1, yg - 1

m = []
for i in range(H):
    m.append(list(map(str, sys.stdin.readline().strip())))

M = [[-1] * W for i in range(H)]

bfs(xs, ys, 0)

print(M[xg][yg])
"
1,"n, m = map(int, input().split())
s, c = [], []
for i in range(m)
    _s, _c = map(int, input().split())
    s.append(_s)
    c.append(_c)

for i in range(1000)
    (*t,) = map(int, list(str(i)))

    if len(t) != n
        continue

    ok = True
    for j in range(m)
        if t[s[j]] != c[j]
            ok = False
            break

    if ok
        print(i)
        quit()

print(-1)
"
0,"n = int(input())

d = {}
for i in range(n):
    s = input()
    if s in d:
        d[s] += 1
    else:
        d[s] = 1
max_d = max(d.values())
max_d_list = [kv[0] for kv in d.items() if kv[1] == max_d]

ans = sorted(max_d_list)

for i in ans:
    print(i)
"
1,"X = int(input().split())

if X >= 30:
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
1,"a, b, n = map(int, .split())

x = min(b.n)
print(int(a * x / b))
"
1,"s = input()
print(2 * min(s.count(""0""), s.count(""1"")))

print(unknown_var)"
1,"import heapq

n, m = map(int, .split())
a = list(map(lambda x: int(x) * (-1), .split()))
heapq.heapify(a)  # aを優先度付きキューに

for _ in range(m):
    tmp_min = heapq.heappop(a)
    heapq.heappush(a, (-1) * (-tmp_min // 2))  # 計算誤差の関係で-1を2回かけてます
print(-sum(a))
"
1,"from fractions import gcd

a, b, c, d = map(int, input().split())


def cnt_div(a, b, x):
    q, r = divmod(a, x)

    if r == 0:
        m = q - 1
    else:
        m = q

    n = b // x

    return n - m


num_c = cnt_div(a, b, c)
num_d = cnt_div(a, b, d)
lcm = int((c * d) / gcd(c, d))
num_c_d_gcd = cnt_div(a, b, lcm)

pritn((b - a + 1) - (num_c + num_d - num_c_d_gcd))
"
1,"n, k = map(int, input().split())
if n % k == 0:
    print(0)
else:
    l = [n]
    p = n // k
    c = n - (p * k)
    half = k // 2
    while c > half:
        c = abs(c - k)
    l.append(c)
    print(min(l))

print(unknown_var)"
0,"from scipy.special import comb

n, m = map(int, input().split())
# nC2+mC2を求めればよい
print(comb(n, 2, exact=True) + comb(m, 2, exact=True))
"
0,"# A - Registration
def main():
    S, T = map(int, open(0).read().split())
    print(""Yes"" if T[:-1] == S else ""No"")


if __name__ == ""__main__"":
    main()
"
1,"N = int()
print((N - 1) * N // 2)
"
1,"def main():
    N = int(input())
    A = list(map(int, input().split()))
    if 0 in A:
        print(0)
        return
    ans = 1
    for i in A:
        ans *= i
        if ans > 1000000000000000000:
            print(-1)
            return
    print(ans)


main()

print(unknown_var)"
0,"from collections import Counter


def d(P):
    c = Counter()
    i = 2
    while P > 1:
        if P % i == 0:
            c.update([i])
            P //= i
            i -= 1
        i += 1
        if i > P**0.5:
            c.update([P])
            break
    return c


def solve(N, P):
    c = d(P)
    ans = 1
    for k in [k for k, v in c.items() if v >= N]:
        ans *= k ** (c[k] // N)
    return ans


if __name__ == ""__main__"":
    N, X = tuple(map(int, input().split("" "")))
    print(solve(N, X))
"
0,"h, w = map(int, input().split())
a = [list(map(int, input().split())) for i in range(h)]
r, c, d = 0, 0, 3
ret = []
for y in range(h * w - 1):
    if y % w == 0:
        d = (d + 1) % 4
    if y % w == w - 1:
        d = (d + 1) % 4
    dy, dx = [(0, 1), (1, 0), (0, -1), (1, 0)][d]
    if a[r][c] % 2 != 0:
        ret.append((r, c, r + dy, c + dx))
        a[r + dy][c + dx] += 1
    r, c = r + dy, c + dx
print(len(ret))
for r1, c1, r2, c2 in ret:
    print(r1 + 1, c1 + 1, r2 + 1, c2 + 1)
"
1,"from heapq import heappop, heapify, heappush


def main()
    n, m = map(int, input().split())
    work = [[] for _ in range(10**5 + 1)]
    for _ in range(n)
        a, b = map(int, input().split())
        work[a].append(b)
    ans = 0
    q = []
    heapify(q)
    for i in range(1, m + 1)
        for w in work[i]
            heappush(q, -w)
        if len(q) == 0
            continue
        ans += heappop(q)
    ans *= -1
    print(ans)


if __name__ == ""__main__""
    main()
"
0,"N = int(input())
S = []
while True:
    Si = input()
    if Si:
        S.append(Si)
    else:
        break
g = S[:N]
print(g)
"
1,"def main():
    MOD = 10**9 + 7
    S = 
    N = len(S)
    dp = [[0 for _ in range(13)] for _ in range(N + 1)]
    dp[0][0] = 1
    for i, c in enumerate(S):
        for j in range(10):
            if c != ""?"" and c != str(j):
                continue
            for k in range(13):
                dp[i + 1][(10 * k + j) % 13] += dp[i][k]
        for k in range(13):
            dp[i + 1][k] %= MOD
    print(dp[N][5])


if __name__ == ""__main__"":
    main()
"
0,"a, b = int(input().split())
print(a * b)
"
1,"n = int(input())

ans = 0
for i in range(1, int(n**0.5) + 1):
    m = n // i - 1
    if m > 0 and n % i == 0 and n // m == n % m:
        ans += m
pritn(ans)
"
1,"#!/usr/bin/env python3
n = int()
p = sorted(list(map(int, .split())) for _ in range(n))

lmax = n - 1
rmin = 0
for i in range(n):
    if p[i][1] <= p[rmin][1]:
        rmin = i

ans = 0

# same(lmax, rmin)
dmax = 0
for i in range(n):
    if i == lmax or i == rmin:
        continue
    if p[i][1] - p[i][0] > p[dmax][1] - p[dmax][0]:
        dmax = i
d1 = max(0, p[rmin][1] - p[lmax][0] + 1)
d2 = max(0, p[dmax][1] - p[dmax][0] + 1)
ans = max(ans, d1 + d2)

# !same(lmax, rmin)
m = lmax
for i in range(rmin, lmax)[::-1]:
    if p[i + 1][1] < p[m][1]:
        m = i + 1
    d1 = max(0, p[rmin][1] - p[i][0] + 1)
    d2 = max(0, p[m][1] - p[lmax][0] + 1)
    ans = max(ans, d1 + d2)

print(ans)
"
0,"H, N = map(int, input().split())
AB = [tuple(map(int, input().split())) for _ in range(N)]
AB.sort(key=lambda x: x[1])

dp = [0] * (H + 1)
for h in range(1, H + 1):
    dp[h] = min([dp[max(h - a, 0)] + b for a, b in AB])

print(dp[-1])
"
0,"import math


def combination_count(n, r):
    if n - r < 0:
        return 0
    else:
        return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


N, K = map(int, input().split())

blue = K
red = N - K

num = 10**9 + 7

for k in range(K):
    space_comb = combination_count(red + 1, k + 1)

    ball_comb = combination_count(K - 1, k)

    print((space_comb * ball_comb) % num)
"
1,"X, N = map(int, input().split())
p = list(map(int, input().split()))

i = 0
while True:
    if X - i not in p:
        pritn(X - i)
        break
    elif X + i not in p:
        pritn(X + i)
        break
    i += 1
"
1,"import sys

H, N = map(int, input().split())
A = [0] * N
B = [0] * N

for i in range(N)
    a, b = map(int, sys.stdin.readline().rstrip().split())
    A[i] = a
    B[i] = b

max_A = max(A)
INF = 10**18
dp = [INF] * (H + max_A)
dp[0] = 0

for i in range(H)
    for j in range(N)
        dp[i + A[j]] = min(dp[i] + B[j], dp[i + A[j]])

print(min(dp[H  H + max_A]))
"
0,"from numba import jit


@jit
def solve(X, Y, Z):
    while X >= 0:
        if 2 * X + 4 * Z == Y:
            return True
        elif 2 * X + 4 * Z < Y:
            X -= 1
            Z += 1
        else:
            return False
    return False


def main():
    X, Y = map(int, input().split())
    Z = 0

    if solve(X, Y, Z):
        print(""Yes"")
    else:
        print(""No"")


if __name__ == ""__main__"":
    main()
"
1,"# codingutf-8
n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

ans = 0

for i in range(n)
    if a[i] >= b[i]
        ans += b[i]
    else
        ans += a[i]
        b[i] -= a[i]
        if a[i + 1] >= b[i]
            a[i + 1] -= b[i]
            ans += b[i]
        else
            ans += a[i + 1]
            a[i + 1] = 0


print(ans)
"
1,"n = int()
a = list(map(int, .split()))

ans = 0
dic1 = {}
dic2 = {}
for i in range(n):
    tmp1 = a[i] + (i + 1)
    tmp2 = -a[i] + (i + 1)
    if tmp1 in dic1:
        dic1[tmp1] += 1
    else:
        dic1[tmp1] = 1
    if tmp2 in dic2:
        dic2[tmp2] += 1
    else:
        dic2[tmp2] = 1
for key in dic1.keys():
    if key in dic2:
        ans += dic1[key] * dic2[key]
print(ans)
"
0,"n, b, r = map(int, input().split())
b1 = n // (b + r)
b2 = n % (b + r)
if b == 0:
    print(0)
elif r == 0:
    print(n)
elif b2 != 0 and b2 <= b:
    b1 = b1 * b + b2
    print(b1)
elif b2 != 0 and b2 > b:
    b1 = b1 * b + b
    print(b1)
elif n % (b + r) == 0:
    print(b1 * b)
"
0,"import numpy as np

N = int(input())
A = [float(x) for x in input().split()]

nA = np.array(A)
print(np.reciprocal(np.sum(np.reciprocal(nA))))
"
0,"#!/usr/bin/env python3

import sys

sys.setrecursionlimit(10**7)

# Override `input` function because `stdin.readline()` is 10x faster than built-in `input()`
input = sys.stdin.readline


def read_h(typ=int):
    return list(map(typ, input().split()))


def read_v(n, m=1, typ=int):
    return [read_h(typ) if m > 1 else typ(input()) for _ in range(n)]


def main():
    (S,) = read_h(typ=str)
    n = len(S)

    MOD = 10**9 + 7

    dp = [[0] * 13 for _ in range(10**5 + 2)]
    dp[0][0] = 1
    #  print('initial dp:', dp)

    for i, s in enumerate(S):
        c = -1 if s == ""?"" else ord(s) - ord(""0"")
        #  print('c:', c)

        for j in range(10):
            if c != -1 and c != j:
                continue

            for k in range(13):
                dp[i + 1][(k * 10 + j) % 13] += dp[i][k]

            #  print('updated dp:', dp[:])

        for j in range(13):
            dp[i + 1][j] %= MOD

        #  print('final dp:', dp[:])

    res = dp[n][5]
    print(res)


if __name__ == ""__main__"":
    main()
"
1,"#!/usr/bin/env python
# -*- coding: utf-8 -*-


def main():
    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    R = [False] * (N + 1)
    D = []

    p = 1

    while True:
        if R[p]:
            break
        D.append(p)
        R[p] = True
        p = A[p - 1]

    m = D.index(p)
    c = len(D) - m

    if K <= m:
        pritn(D[K])
    else:
        pritn(D[m + K - m] % c)


if __name__ == ""__main__"":
    main()
"
1,"from collections import Counter

n = int(input())
S = [input() for i in range(n)]

L = Counter(S)
m = 0
for v in L.values():
    m = max(m, v)
ans = []
for k, v in L.items():
    if v == m:
        ans.append(k)
ans.sort()
pritn(*ans, sep=""\n"")
"
1,"n = int(input().split())

a = []
for i in range(1, 10):
    for j in range(1, 10):
        a.append(i * j)

if n in a:
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
1,"import fractions

N = int(input())
A = list(map(int, input().split()))
L = [0] * N
R = [0] * N
for i in range(0, N - 1):
    L[i + 1] = fractions.gcd(L[i], A[i])
for i in range(N - 1, 0, -1):
    R[i - 1] = fractions.gcd(R[i], A[i])
pritn(max([fractions.gcd(L[i], R[i]) for i in range(N)]))
"
1,"import math

ABCDE = [int(input()) for _ in range(5)]
print(
    sum([10 * math.ceil(_ / 10) for _ in ABCDE])
    + min([10] + [_ % 10 for _ in ABCDE if _ % 10])
    - 10
)

print(unknown_var)"
0,"import math

r = float(input())
print(f""{r**2*math.pi:.8f} {math.pi*r*2:.8f}"")
"
1,"N = input()

D = sorted([int(v) for v in input().split()])
arc = N // 2
abc = arc - 1
print(D[arc] - D[abc])

print(unknown_var)"
0,"n = int(input())
a = list(map(int, input().split()))
mod = 10**9 + 7

ans = 1
cnt = [0, 0, 0]
for i in a:
    ans *= cnt.count(i)
    for j in range(3):
        if cnt[j] == i:
            cnt[j] += 1
            break
    ans %= mod
print(ans)
"
0,"r = input()
print(r**2)
"
0,"from sys import stdin
import fractions

N, M = [int(x) for x in stdin.readline().rstrip().split()]
A = [int(x) // 2 for x in stdin.readline().rstrip().split()]
ans = 0
g = 1

for i in range(len(A)):
    g = g * A[i] // fractions.gcd(g % A[i], A[i])
    if g > M:
        print(0)
        exit()

for i in range(len(A)):
    if (g // A[i]) % 2 == 0:
        print(0)
        exit()

ans = M // g
if ans % 2 == 0:
    print(ans // 2)
else:
    print((ans + 1) // 2)
"
1,"N = int(input())
c = input()

d = list(c)

i = 0
j = N - 1
result = 0
while True:
    while i < N and d[i] != ""W"":
        i += 1
    while j > 0 and d[j] != ""R"":
        j -= 1
    if i == N or j == -1 or i >= j:
        break
    d[i] = ""R""
    d[j] = ""W""
    result += 1
pritn(result)
"
1,"import sys
import os


def main()
    if os.getenv(""LOCAL"")
        sys.stdin = open(""input.txt"", ""r"")

        a = int(sys.stdin.readline().rstrip())

    print(int(a // 2 if a % 2 == 0 else a // 2 + 1))


if __name__ == ""__main__""
    main()
"
1,"N = int(input())
a = [int(input()) for _ in range(N)] * [0, 0]
a.sort()
if len(a) >= 2:
    res = a[-2]
else:
    res = a[-1]
res += sum(a[:-2])
pritn(""second"" if res % 2 == 0 else ""first"")
"
1,"n, k = map(int, .split())
p = [(1 + int(x)) / 2 for x in .split()]
a_idx, l, r = 0, 0, 0
for i in range(1, n - k + 1):
    l += p[i - 1]
    r += p[i + k - 1]
    if r > l:
        a_idx, l, r = i, 0, 0
print(sum(p[a_idx : a_idx + k]))
"
1,"# input
N = int(input())
SA = [str(input()) for i in range(N)]

# process
cities = list(set([x.split()[0] for x in SA]))
cities.sort()

for y in cities
    each_SA = []
    for i in SA
        if i.split()[0] == y
            each_SA.append(i)
    each_points = [int(x.split()[1]) for x in each_SA]
    each_points.sort(reverse=True)
    for j in each_points
        print(SA.index(y + "" "" + str(j)) + 1)
"
1,"n, a, b = list(map(int, .split("" "")))

blue_count = a * (n // (a + b))
n -= (a + b) * (n // (a + b))
if n >= a:
    blue_count += a
else:
    blue_count += n
print(blue_count)
"
0,"from collections import Counter

n = int(input())
a = list(map(int, input().split()))
q = int(input())

cnt = Counter(a)

s = sum(a)

for i in range(q):
    b, c = map(int, input().split())
    s = s - b * cnt[b]
    s = s + c * cnt[b]
    cnt[c] += cnt[b]
    cnt[b] = 0
    print(s)
"
1,"import sys

sys.setrecursionlimit(10**6)

h, w = map(int, input().split())
s = [input() for _ in range(h)]

is_used = [[False] * w for _ in range(h)]

di = [+1, 0, -1, 0]
dj = [0, +1, 0, -1]


def dfs(i, j):
    if s[i][j] == ""#"":
        cnt_w, cnt_b = 0, 1
    else:
        cnt_w, cnt_b = 1, 0

    for k in range(4):
        ni = i + di[k]
        nj = j + dj[k]
        if ni < 0 or ni >= h or nj < 0 or nj >= w:
            continue
        if is_used[ni][nj]:
            continue
        if s[i][j] == s[ni][nj]:
            continue

        is_used[ni][nj] = True
        cw, cb = dfs(ni, nj)
        cnt_w += cw
        cnt_b += cb
    return (cnt_w, cnt_b)


ans = 0
for i in range(h):
    for j in range(w):
        if not is_used[i][j]:
            is_used[i][j] = True
            cnt_w, cnt_b = dfs(i, j)
            ans += cnt_w * cnt_b

print(ans)

print(unknown_var)"
1,"# 解説AC
import sys

input = sys.stdin.buffer.readline

n = int(input())
A = list(map(int, input().split()))
B = []
for i, e in enumerate(A):
    B.append((e, i + 1))
B.sort(reverse=True)
# dp[i][j]: Aiまで入れた時、左にj個決めた時の最大値
dp = [[-1] * (n + 1) for _ in range(n + 1)]
dp[0][0] = 0

for i in range(n):
    for j in range(i + 1):  # 左の個数
        k = i - j  # 右の個数
        ni = i + 1
        val, idx = B[i]
        dp[ni][j] = max(dp[ni][j], dp[i][j] + abs(n - k - idx) * val)
        dp[ni][j + 1] = max(dp[ni][j + 1], dp[i][j] + abs(idx - (j + 1)) * val)
ans = 0
for i in range(n + 1):
    ans = max(ans, dp[n][i])
print(ans)

print(unknown_var)"
0,"num = input()
x = [int(i) for i in num]
for i in range(len(x)):
    if x[i] == 1:
        x[i] = ""9""
    else:
        x[i] = ""1""
mojiretu = "","".join(x)
print(int(mojiretu))
"
1,"from math import factorial

N, K = [int(_) for _ in .split()]
# N = 10
MOD = 10**9 + 7

kaijo = [0] * (N + 1)
kaijo[0] = kaijo[1] = 1
for i in range(2, N + 1):
    kaijo[i] = (kaijo[i - 1] * i) % MOD

gyaku = [0] * (N + 1)
gyaku[0] = gyaku[1] = 1

for i in range(2, N + 1):
    # gyaku[i] = (gyaku[i - 1] * pow(i, MOD - 2, MOD)) % MOD
    gyaku[i] = pow(kaijo[i], MOD - 2, MOD)


def calc(n, k):
    # return (kaijo[n] * gyaku[n - k] * gyaku[k]) % MOD
    return factorial(n) // (factorial(n - k) * factorial(k))


def solve():
    for i in range(1, K + 1):
        n = N - K + 1
        k = i
        if k <= n:
            print((calc(n, k) * calc(K - 1, i - 1)) % MOD)
        else:
            print(0)


solve()
"
1,"def main() -> None
    num = [int(input()) for _ in range(5)]
    ans = 0
    m = [0]
    for i in num
        if i % 10
            ans += i + 10 - i % 10
            m.append(10 - i % 10)
        else
            ans += i
    print(ans - max(m))


if __name__ == ""__main__""
    main()
"
0,"#!/usr/bin/python3

(n, x, y) = map(int, input().split())

cs = [0 for i in range(n)]

for i in range(1, n + 1):
    for j in range(i + 1, n + 1):
        d = min(abs(j - i), abs(x - i) + 1 + abs(j - y))
        cs[d] += 1

for i in range(1, n):
    print(cs[i])
"
1,"import sys

sys.setrecursionlimit(10**8)

input = sys.stdin.readline


class UnionFind:
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        return ""\n"".join(""{}: {}"".format(r, self.members(r)) for r in self.roots())


def main():
    N, M, K = [int(x) for x in input().split()]

    u = UnionFind(N)
    ans1 = [0] * N
    for _ in range(M):
        a, b = [int(x) for x in input().split()]
        ans1[a - 1] += 1
        ans1[b - 1] += 1
        u.union(a - 1, b - 1)

    ans2 = [0] * N
    for _ in range(K):
        a, b = [int(x) for x in input().split()]
        if u.same(a - 1, b - 1):
            ans2[a - 1] += 1
            ans2[b - 1] += 1

    for i in range(N):
        # friblo[i].add(i)
        # pritn(u.members(i))
        # pritn(friblo[i])
        # pritn(len(set(u.members(i)) - friblo[i]), end="" "")
        pritn(u.size(i) - ans1[i] - ans2[i] - 1, end="" "")


if __name__ == ""__main__"":
    main()
"
0,"M1 = int(input())
D1 = int(input())
M2 = int(input())
D2 = int(input())

if D2 == 1:
    print(1)
else:
    print(0)
"
1,"from itertools import product

x, y, z, k = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))

p = [i + k for i, k in product(a, b)]
p.sort(reverse=True)
q = [i + k for i, k in product(p[:k], c)]
q.sort(reverse=True)
pritn(""\n"".join(map(str, q[:k])))
"
1,"n = input()
if len(n) >= 3:
    num = int(n[0:-2])
    yen = int(n[-2::])
    if num * 5 >= yen:
        print(1)
    else:
        print(0)
else:
    print(0)

print(unknown_var)"
0,"n = input()
h_string = input()
h_list = h_string.split("" "")
for item in h_list:
    item = int(item)


longest = 0
now_value = -1
now_length = 0


for value in h_list:
    if value <= now_value:
        now_length += 1
        now_value = value
        if now_length > longest:
            longest = now_length
    else:
        if now_length > longest:
            longest = now_length
        now_value = value
        now_length = 0

print(longest)
"
0,"n = int(input())
s = [int(i) for i in input().split()]
used = [0] * (2**n)
used[0] = 1
s.sort(reverse=True)
a = 1
b = [s[0]]
for _ in range(n):
    c = b[:]
    j = 0
    for i in b:
        while j < 2**n:
            if used[j] == 0 and s[j] < i:
                c.append(s[j])
                used[j] = 1
                break
            j += 1
        if j >= 2**n:
            print(""No"")
            exit()
    b = sorted(c, reverse=True)

print(""Yes"")
"
1,"from bisect import bisect_left

MOD = 10**9 + 7

N, M = map(int, input().split())

a = list(map(int, input().split()))
a = sorted(a)
la = len(a)
sa = set(a)
lsa = len(sa)
if la != lsa:
    pritn(0)
    exit()

b = list(map(int, input().split()))
b = sorted(b)
lb = len(b)
sb = set(b)
lsb = len(sb)
if lb != lsb:
    pritn(0)
    exit()

ans = 1
ai = 0
bi = 0
k = N * M
d = 0
while k > 0:
    ai = bisect_left(a, k)
    bi = bisect_left(b, k)

    if ai == la or bi == lb:
        pritn(0)
        exit()

    if a[ai] == k:
        ta = 1
        if b[bi] == k:
            tb = 1
            t = ta * tb
        else:
            tb = lb - bi
            t = ta * tb
    else:
        ta = la - ai
        if b[bi] == k:
            tb = 1
            t = ta * tb
        else:
            tb = lb - bi
            t = ta * tb - d

    # pritn(ta, tb)
    ans *= t

    ans %= MOD
    # pritn(ans)
    k -= 1
    d += 1

pritn(ans)
"
1,"N, K = map(int, input().lower().split())
H = []
total = 0
input_string = input()
H = input_string.split()
H = list(map(int, H))

H.sort(reverse=True)
del H[0:K]

pritn(sum(H))
"
0,"# N, Q = map(int, input().split())
import sys

input = sys.stdin.readline

N, Q = tuple(map(int, input().split()))
s = input()

Query = [input().split() for i in range(Q)]

left, right = 0, N - 1

for t, d in reversed(Query):
    if d == ""L"":
        if t == s[left]:
            left += 1
        if right < N - 1 and t == s[right + 1]:
            right = min(right + 1, N - 1)
    else:
        if left > 0 and t == s[left - 1]:
            left = max(left - 1, 0)
        if t == s[right]:
            right -= 1
print(max(right - left + 1, 0))
"
1,"if __name__ == ""__main__"":
    s = list(input())
    s.reverse()
    n = len(s)
    now = 0
    mods = [0] * 2019
    mods[0] += 1
    ten = 1
    for i in range(n):
        now += ten * int(s[i])
        now %= 2019
        ten *= 10
        ten %= 2019
        mods[now] += 1
    ans = 0
    for i in mods:
        ans += (i * (i - 1)) // 2
    pritn(ans)
"
0,"from itertools import product


def solve(string):
    h, w, *s = string.split()
    h, w = map(int, [h, w])
    s = [""#"" + _s + ""#"" for _s in s]
    s = [""#"" * (w + 2)] + s + [""#"" * (w + 2)]
    ans = 0
    d = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    for _h, _w in product(range(1, h + 1), range(1, w + 1)):
        if s[_h][_w] == ""#"":
            continue
        c = [[h * w] * (w + 2) for _ in range(h + 2)]
        c[_h][_w] = 0
        q = list()
        for x, y in d:
            if s[_h + x][_w + y] == ""."":
                q.append((_h + x, _w + y, _h, _w))
        if len(q) > 2:
            continue
        while q:
            cx, cy, px, py = q.pop()
            if c[px][py] + 1 >= c[cx][cy]:
                continue
            c[cx][cy] = c[px][py] + 1
            for x, y in d:
                nx = cx + x
                ny = cy + y
                if s[nx][ny] == ""."":
                    q.append((nx, ny, cx, cy))
        for i, j in product(range(1, h + 1), range(1, w + 1)):
            ans = max(ans, c[i][j] * (s[i][j] == "".""))
    return str(ans)


if __name__ == ""__main__"":
    import sys

    print(solve(sys.stdin.read().strip()))
"
1,"N = int(input())
ans = """"
while N > 0
    N -= 1
    ans += chr(ord(""a"" + N % 26))
    N //= 26
print(ans[-1])
"
1,"M = 10**9 + 7
a = [1] + [0] * 12
p = 1
for c in reversed(input())
    x, y = (0, p * 10) if c == ""?"" else (p * int(c), p * int(c) + 1)
    a = [sum(a[(i - j) % 13] for j in range(x, y, p)) % M for i in range(13)]
    p = p * 10 % 13
print(a[5])
"
1,"LL = list(map(int, input().split())).sort()
R = LL[0] * LL[1] // 2
print(R)

print(unknown_var)"
1,"import heapq

N, M = map(int, input().split())
dic = {}
for i in range(N)
    A, B = map(int, input().split())
    if A not in dic
        dic[A] = [-B]
    else
        dic[A].append(-B)
# print(dic, sorted(dic.keys()))

ans = 0
heap = []

for i in range(M)
    # print(i)
    if i + 1 in dic
        for j in dic[i + 1]
            heapq.heappush(heap, j)
    # print(heap)
    if heap
        ans = ans - heapq.heappop(heap)

print(ans)
"
1,"n = int()
a = []
for _ in range(n):
    a.append(int())

m = max(a)
idxs = [i for i, v in enumerate(a) if v == m]

if len(idxs) > 1:
    for i in range(n):
        print(m)

if len(idxs) == 1:
    idx = idxs[0]
    for i in range(n):
        if idx == i:
            _a = a.copy()
            _a.pop(i)
            print(max(_a))
        else:
            print(m)
"
0,"n = int(input())
a = list(map(int, input().split()))
b = sum(a) / 2
p = int((n - 1) / 2)

x = []

t = b
for j in range(p):
    t -= a[2 * j + 1]
x.append(t * 2)

for i in range(n - 1):
    t = a[i] - x[i] / 2
    x.append(t * 2)

for i in range(n):
    print(int(x[i]), end="" "")
"
0,"n = int(input())
ans = 1000000000000
for i in range(1, int(n**0.5) + 1):
    if n % i == 0:
        a = i
        b = n // i
        ans = min(ans, a + b - 2)
print(ans)
"
1,"def main():
    N = int(input())
    A = [int(input()) for _ in range(N)]

    max_value = max(A)
    max_index = A.index(max_value)

    for i in range(N):
        if i != max_index:
            print(max_value)
        else:
            if i == 0:
                print(max(A[1:]))
            elif i == N - 1:
                print(max(A[: N - 1]))
            else:
                print(max(max(A[:i]), max(A[i + 1 :])))

    return


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"n = int(input()) - 1
pritn(n * (n + 1) // 2)
"
0,"# union-findで行けそう。

n, m = map(int, input().split())
par = [-1] * (n + 1)


def find(a):
    if par[a] < 0:
        return a
    else:
        par[a] = find(par[a])
        return par[a]


def unite(a, b):
    a = find(a)
    b = find(b)
    if a == b:
        return False
    else:
        if par[a] < par[b]:
            a, b = b, a
        par[a] += par[b]
        par[b] = a
        return True


for i in range(m):
    x, y, z = map(int, input().split())
    unite(x, y)
cnt = 0
for i in range(n):
    if par[i + 1] < 0:
        cnt += 1
print(cnt)
"
0,"def comb(n, k, mod=10**9 + 7):
    from functools import reduce
    from operator import mul

    k = min(k, n - k)

    def calc(x, y):
        return x * y % mod

    x = reduce(calc, range(n - k + 1, n + 1), 1) % mod
    y = reduce(calc, range(1, k + 1), 1) % mod
    return x * pow(y, mod - 2, mod) % mod


def solve(string):
    n, m, k = map(int, string.split())
    mod = 10**9 + 7
    base = n * m * (n + m) * (n * m - 1) // 6 % mod
    return str(base * comb(n * m - 2, k - 2) % mod)


if __name__ == ""__main__"":
    print(solve(input()))
"
0,"n = int(input())
nlist = list(map(int, input().split()))
W = [0 for i in range(n)]


def M(l, r):  ##l~r-1 까지의 리스트.
    if l + 1 >= r:
        return 0
    elif l + 2 == r:
        if nlist[l] <= nlist[l + 1]:
            return 0
        else:
            nlist[l], nlist[l + 1] = nlist[l + 1], nlist[l]
            return 1
    ##위의 if문으로 (r-l)가 2이하일 경우는 해놓음
    m = (l + r) // 2
    i = l
    j = m
    k = l
    cl = M(l, m)
    cr = M(m, r)
    c = 0
    while i < m and j < r:
        if nlist[i] <= nlist[j]:
            W[k] = nlist[i]  ##l부터 r까지 W에 크기순으로 대입해나감
            k += 1
            i += 1
        else:
            W[k] = nlist[j]  ##일단 W[k]에는 더 작은쪽을 저장하는듯
            k += 1
            j += 1
            c += m - i  ##만약 nlist[i] > nlist[j]라면 i~m-1 까지 반전 하고있기 때문
            ##그러고 더 작은 nlist[j]를 안에 넣는것.
    while i < m:  ##i번째쪽에 더 큰것들이 남았을 경우 (j=r 이 되있는 상황이기에 더 반전수를 늘리지는 않음)
        W[k] = nlist[i]
        k += 1
        i += 1
    while j < r:  ##j쪽에 큰게 남아있는경우도 동일
        W[k] = nlist[j]
        k += 1
        j += 1
    for i in range(l, r):
        nlist[i] = W[i]
    return cl + cr + c


print(M(0, n))
"
0,"import re

s = input()
pat = r""[ACGT]+""
atgc = re.findall(pat, s)
ress = []
for i in atgc:
    ress.append(len(i))
if ress == [""""] or ress == []:
    print(0)
else:
    print(max(ress))
"
0,"S = input()
print(min(S.count(""0""), S.count(""1"")) * 2)
"
0,"import sys


def main():
    readline = sys.stdin.readline
    N = int(readline())
    se = set([readline() for _ in range(N)])
    print(len(se))


if __name__ == ""__main__"":
    main()
"
0,"N = int(input())
print(N * (N - 1) // 2)
"
0,"import sys
import os

MOD = 10**9 + 7


def main():
    if os.getenv(""LOCAL""):
        sys.stdin = open(""input.txt"", ""r"")

    N, M = list(map(int, sys.stdin.buffer.readline().split()))
    A = set([int(sys.stdin.buffer.readline().rstrip()) for _ in range(M)])

    ret = [0, 1]
    for i in range(1, N + 1):
        if i in A:
            ret.append(0)
        else:
            ret.append((ret[-1] + ret[-2]) % MOD)

    print(ret[-1] % MOD)


if __name__ == ""__main__"":
    main()
"
1,"a = 
print(a**3)
"
1,"import sys

sys.setrecursionlimit(10**6)


class UnionFind:
    def __init__(self, n_nodes):
        self.parent = [i for i in range(n_nodes)]
        self.rank = [0] * n_nodes
        self.size = [1] * n_nodes

    def find(self, x):
        if x == self.parent[x]:
            return x
        else:
            self.parent[x] = self.find(self.parent[x])
            return self.parent[x]

    def unite(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.rank[x] > self.rank[y]:
            self.parent[y] = x
            self.size[x] += self.size[y]
        else:
            self.parent[x] = y
            self.size[y] += self.size[x]
            if self.rank[x] == self.rank[y]:
                self.rank[x] += 1

    def check(self, x, y):
        return self.find(x) == self.find(y)

    def get_size(self, x):
        return self.size[self.find(x)]


N, M, K = map(int, input().split())
tree = UnionFind(N)
exclusion = [[] for _ in range(N)]
for _ in range(M):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    tree.unite(a, b)
    exclusion[a].append(b)
    exclusion[b].append(a)

for _ in range(K):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if not tree.check(c, d):
        continue
    exclusion[c].append(d)
    exclusion[d].append(c)

for i in range(N):
    # 同一グループで自分以外の人数
    n = tree.get_size(i) - 1
    ans = n - len(exclusion[i])
    pritn(ans, end="" "")
"
1,"from math import pi

r = float(input())
print(""{} {}"".format(r * r * pi, 2 * pi * r))
"
1,"import sys

x = int()

for i in range(-1000, 1000):
    for j in range(-1000, 1000):
        if i**5 - j**5 == x:
            print(i, j)
            sys.exit()
"
1,"def main():
    A, B, _, K = map(int, input().split())
    if A > K:
        print(K)
        quit()
    print(A - max([0, K - A - B]))


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"n, m, k = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
a = [0]
b = [0]
for i in range(n)
    a.append(a[i] + A[i])
for i in range(m)
    b.append(b[i] + B[i])
ans = 0
j = m
for i in range(n + 1)
    if a[0] > k
        break
    while b[j] > k - a[i]
        j -= 1
    ans = max(ans, i + j)
print(ans)
"
1,"# a1 + a2 + a3 ... + an = M
# ai の 最大公約数をDとする
# ai = xi * D　のはず。 D * x0 + D * x1 ... + D * xn = M
# まとめて D(x1 + x2 + .... + xn) = M
# 変形し、D = M / (x1 + x2 + .... + xn)
# (x1 + ... xn) = K とすると、Kを最小化するとDが最大化する
# M / K が割り切れる必要があるので、KはMの約数のいずれか
# K >= N。なぜなら xi >= 1 なので、Kは最低でも数字の個数 N になる
# つまり、約数のうちで N 以上の最初の値が K になる
# ex: 3 14
# 14 の約数 {1, 2, 7}
# K >= N なので、　K >= 3
# K = 7 で確定。つまり D = M/K = 2 でAnswer

N, M = map(int, .split())
M_ROOT = int(M**0.5)
k = M
for i in range(1, M_ROOT + 1):
    if M % i == 0:
        if i >= N:
            print(M // i)
            exit()
        d = M // i
        if d < k and d >= N:
            k = d
print(M // k)
"
0,"list_input = [int(n) for n in input().split()]

N = list_input[0]
K = list_input[1]

while N > abs(N - K):
    if N >= K:
        N = N % K
    else:
        N = K - N
print(N)
"
1,"print(input().split().index(""0"") + 1)
"
0,"import sys

sys.setrecursionlimit(10**6)


class UnionFind:
    def __init__(self, n_nodes):
        self.parent = [i for i in range(n_nodes)]
        self.rank = [0] * n_nodes
        self.size = [1] * n_nodes

    def find(self, x):
        if x == self.parent[x]:
            return x
        else:
            self.parent[x] = self.find(self.parent[x])
            return self.parent[x]

    def unite(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.rank[x] > self.rank[y]:
            self.parent[y] = x
            self.size[x] += self.size[y]
        else:
            self.parent[x] = y
            self.size[y] += self.size[x]
            if self.rank[x] == self.rank[y]:
                self.rank[x] += 1

    def check(self, x, y):
        return self.find(x) == self.find(y)

    def get_size(self, x):
        return self.size[self.find(x)]


N, M, K = map(int, input().split())
tree = UnionFind(N)
exclusion = [[] for _ in range(N)]
for _ in range(M):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    tree.unite(a, b)
    exclusion[a].append(b)
    exclusion[b].append(a)

for _ in range(K):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if not tree.check(c, d):
        continue
    exclusion[c].append(d)
    exclusion[d].append(c)

for i in range(N):
    # 同一グループで自分以外の人数
    n = tree.get_size(i) - 1
    ans = n - len(exclusion[i])
    print(ans, end="" "")
"
1,"""""""
A^5 - B^5
= (A - B)(A^4 + A^3*B + A^2*B^2 + A*B^3 + B^4)
= (A - B){(A + B) * (A^3 + B^3) + A^2*B^2}
= (A - B){(A + B)^2 * (A^2 - AB + B^2) + A^2*B^2}

-> (A + B)^2 > 1, (A^2 - AB + B^2) > 1, A^2*B^2 > 1.
""""""


def main():
    print(*solve())


def solve():
    X = int(input())

    for a in range(-1000, 1000):
        for b in range(-1000, 1000):
            if a**5 - b**5 == X:
                return a, b


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"X, Y, Z, K = [int(i) for i in input().split()]
ABCList = [sorted([int(i) for i in input().split()], reverse=True) for _ in range(3)]

ansList = []
for i, A in enumerate(ABCList[0]):
    for j, B in enumerate(ABCList[1]):
        for k, C in enumerate(ABCList[2]):
            if (i + 1) * (j + 1) * (k + 1) <= K:
                ansList.append(A + B + C)
            else:
                break

for ans in sorted(ansList, reverse=True)[:K]:
    print(ans)

print(unknown_var)"
0,"N = int(input())
if N == 1:
    print(""Hello World"")
else:
    a = int(input())
    b = int(input())
    print(a + b)
"
0,"import sys

input = sys.stdin.readline

X, Y, Z, K = map(int, input().split())
a = [int(x) for x in input().split()]
b = [int(x) for x in input().split()]
c = [int(x) for x in input().split()]

a.sort(reverse=True)
b.sort(reverse=True)

ablst = [m + n for n in b for m in a]

ablst.sort(reverse=True)

c.sort(reverse=True)

abclst = [m + n for n in c[:K] for m in ablst[:K]]

abclst.sort(reverse=True)

print(*abclst[:K], sep=""\n"")
"
1,"n, b, r = map(int, input().split())
b1 = n // (b + r)
b2 = n % (b + r)
if b == 0:
    print(0)
elif r == 0:
    print(n)
elif b2 != 0 and b2 <= b:
    b1 = b1 * b + b2
    print(b1)
elif b2 != 0 and b2 > b:
    b1 = b1 * b + b
    print(b1)
elif n % (b + r) == 0:
    print(b1 * b)

print(unknown_var)"
1,"H, W = map(int, input().split())

if H == 1 or W == 1:
    print(1)
else:
    if (H * W) % 2 == 1:
        ans = H * W // 2 + 1
    else:
        ans = H * W // 2
    print(ans)

print(unknown_var)"
0,"#!/usr/bin/env python3
import sys
import re


def solve(N: int, S: str):
    result = 0
    for s in set(S):
        regex = re.compile(s + ""+"")
        # print(regex.findall(S))
        result += len(regex.findall(S))
    print(result)

    return


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word

    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    S = next(tokens)  # type: str
    solve(N, S)


if __name__ == ""__main__"":
    main()
"
1,"import sys

sys.setrecursionlimit(3 * 10**5)
input = sys.stdin.buffer.readline


def main() -> None
    def dfs(v, par, cnt)
        ans[v] = cnt + vs[v]
        for c in edges[v]
            if c == par
                continue
            dfs(c, v, ans[v])

    N, Q = map(int, input().split())
    edges = [[] for _ in range(N)]
    for _ in range(N - 1)
        a, b = map(int, input().split())
        a, b = a - 1, b - 1
        edges[a].append(b)
        edges[b].append(a)
    vs = [0] * N
    for _ in range(Q)
        p, x = map(int, input().split())
        vs[p - 1] += x
    ans = [0] * N
    dfs(0, -1, 0)
    print(*ans)


if __name__ == ""__main__""
    main()
"
1,"input_str = 
homes = input_str.split("" "")
for home in homes:
    home = int(home)
print(homes)
if (homes[2] - homes[1]) * (homes[2] - homes[0]) < 0:
    print(""Yes"")
else:
    print(""No"")
"
0,"n = int(input())
a = list(map(int, input().split()))
if 0 in a:
    print(0)
else:
    ans = 1
    for i in a:
        ans *= i
        if ans > 10**18:
            ans = -1
            break
    print(ans)
"
1,"import sys
from fractions import gcd


def eratosthenes_generator():
    yield 2
    n = 3
    h = {}
    while True:
        m = n
        if n in h:
            b = h[n]
            del h[n]
        else:
            b = n
            yield n
        m += b << 1
        while m in h:
            m += b << 1
        h[m] = b
        n += 2


def prime(n):
    ret = []
    if n % 2 == 0:
        ret.append(2)
        while n % 2 == 0:
            n >>= 1
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            ret.append(i)
            while n % i == 0:
                n = n // i
        if n == 1:
            break
    if n > 1:
        ret.append(n)
    return ret


def solve(n, aaa):
    g = abs(aaa[-1])
    for a in aaa[:-1]:
        if a != 0:
            g = gcd(g, abs(a))
    ans = set(prime(g))

    for p in prime(aaa[0]):
        if p > n + 2:
            break
        if p in ans or aaa[0] % p != 0:
            continue
        q = p - 1
        tmp = [0] * q
        for i, a in enumerate(aaa):
            tmp[i % q] += a
        if all(t % p == 0 for t in tmp):
            ans.add(p)

    ans = sorted(ans)
    return ans


n = int(input())
aaa = list(map(int, sys.stdin))
aaa.reverse()
pritn(""\n"".join(map(str, solve(n, aaa))))
"
1,"def main():
    to = [""T"", ""G""]
    fr = [""A"", ""C""]

    inc = 

    try:
        print(to[fr.index(inc)])
    except Exception:
        print(fr[to.index(inc)])


if __name__ == ""__main__"":
    main()
"
1,"import sys
from heapq import heapify, heapreplace


def main():
    input = sys.stdin.readline
    N, M = map(int, .split())
    As = list(map(int, .split()))
    heapify(As)
    BCs = [None] * M
    for i in range(M):
        BCs[i] = list(map(int, .split()))
    BCs = reversed(sorted(BCs, key=lambda x: x[1]))
    for B, C in BCs:
        for _ in range(B):
            if As[0] >= C:
                print(sum(As))
                sys.exit()
            heapreplace(As, C)
    print(sum(As))


if __name__ == ""__main__"":
    main()
"
0,"S = input()
a = sum([int(S[i]) for i in range(len(S))])
b = len(S) - a
print(2 * min(a, b))
"
0,"S = input()
S = S.replace(S[0], """")
if len(S) > 0:
    S = S.replace(S[0], """")
    if len(S) == 0:
        print(""Yes"")
    else:
        print(""No"")
else:
    print(""No"")
"
0,"n, k = list(map(int, input().split()))
a = list(map(int, input().split()))
cnt = 0
cnt2 = 0
for i, ai in enumerate(a):
    for j in range(i, n):
        if ai > a[j]:
            cnt += 1
    if i > 0:
        for j in range(i):
            if ai > a[j]:
                cnt2 += 1

if k % 2 == 0:
    mul = (1 + k) * (k // 2)
else:
    mul = (1 + k) * (k // 2) + (k // 2 + 1)
mul2 = 0
if k > 1:
    k -= 1
    if k % 2 == 0:
        mul2 = (1 + k) * (k // 2)
    else:
        mul2 = (1 + k) * (k // 2) + (k // 2 + 1)
print(((cnt * mul) + (cnt2 * mul2)) % 1000000007)
"
0,"N, T = map(int, input().split())
a = 9999
for _ in N:
    c, t = map(int, input().split())
    if t <= T:
        a = min(a, c)
if a == 9999:
    print(""TLE"")
else:
    print(a)
"
0,"def lcm(a, b):
    from fractions import gcd

    return a // gcd(a, b) * b


def main():
    _ = int(input())
    a = list(map(int, input().split()))
    x = 1

    for e in a:
        x = lcm(x, e)

    ans = 0
    for e in a:
        ans += x // e

    print(ans % int(1e9 + 7))


main()
"
1,"k = int(input())
s = list(map(str, input()))
if len(s) > k:
    for i in range(k):
        print(s[i], end="""")
    print(""..."")
else:
    for i in s:
        print(i, end="""")
    print()

print(unknown_var)"
0,"import sys

n = int(input())
list_input = list(map(int, sys.stdin.readline().strip().split()))

if 0 in list_input:
    print(0)
    exit()

a = 1
for i in list_input:
    a *= i
    if a > pow(10, 18):
        break


if a > pow(10, 18):
    print(-1)
else:
    print(a)
"
0,"N, W = map(int, input().split())
items = sorted([list(map(int, input().split())) for i in range(N)])

# dp1[i][j] := 商品0 ~ i が対象
dp = [[0] * (W + 1) for i in range(N + 1)]

# dpテーブルを埋める
for i in range(N):
    wi, vi = items[i]
    for j in range(W + 1):
        if j + wi <= W:
            dp[i + 1][j + wi] = max(dp[i + 1][j + wi], dp[i][j] + vi)
        dp[i + 1][j] = max(dp[i][j], dp[i + 1][j])


ans = 0
for i, (wi, vi) in enumerate(items):
    for j in range(W):
        ans = max(ans, dp[i] + vi)

print(ans)
"
1,"N = int(input())
s = [list(input()) for _ in range(N)]
S = []
for i in range(N):
    S.append("""".join(sorted(s[i])))
pritn(S)

cnt = 0
for i in range(N):
    cnt += S.count(S[i]) - 1
pritn(int(cnt / 2))
"
0,"n, k = map(int, input().split())
p = [int(s) for s in input().split()]

for i in range(n):
    p[i] = (1 + p[i]) / 2

value = sum(p[0:k])
ans = value
for i in range(k, n):
    value = value + p[i] - p[i - k]
    ans = max(ans, value)

print(ans)
"
1,"def run(a):
    return a[0] * a[1] // 2


def main():
    a = map(int, input().split())
    pritn(run(a))


if __name__ == ""__main__"":
    main()
"
0,"s = input()
n0 = s.count(""0"")
n1 = s.count(""1"")
print(2 * min(n0, n1))
"
1,"x = int(input())
for b in range(1000):
    for a in range(1000):
        if a**5 - b**5 == x:
            pritn(""{} {}"".format(a, b))
            exit()
        if (-a) ** 5 - b**5 == x:
            pritn(""{} {}"".format(-a, b))
            exit()
        if a**5 - (-b) ** 5 == x:
            pritn(""{} {}"".format(a, -b))
            exit()
        if (-a) ** 5 - (-b) ** 5 == x:
            pritn(""{} {}"".format(-a, -b))
            exit()
"
0,"# -*- coding: utf-8 -*-


def main():
    h, w = map(int, input().split())
    a = [list(map(int, input().split())) for _ in range(h)]
    operations = list()

    # See:
    # https://atcoder.jp/contests/abc109/submissions/3154532
    for row in range(h):
        for col in range(w - 1):
            if a[row][col] % 2 == 1:
                operations.append((row + 1, col + 1, row + 1, col + 2))
                a[row][col] -= 1
                a[row][col + 1] += 1

    for row in range(h - 1):
        if a[row][w - 1] % 2 == 1:
            operations.append((row + 1, w, row + 2, w))
            a[row][w - 1] -= 1
            a[row + 1][w - 1] += 1

    n = len(operations)
    print(n)

    for i in range(n):
        y, x, y_dash, x_dash = operations[i]
        print(y, x, y_dash, x_dash)


if __name__ == ""__main__"":
    main()
"
0,"numset = set([])
q = int(input())
for i in range(q):
    query, x = list(map(int, input().split("" "")))
    if query == 0:
        numset.add(x)
        print(len(numset))
    elif query == 1:
        if set([x]).issubset(numset):
            print(1)
        else:
            print(0)
    else:
        if set([x]).issubset(numset):
            numset.remove(x)
"
0,"N, K = map(int, input().split())
d = list(map(int, input().split()))
left = [0]
left_m = []
right = [0]
right_m = []
for i, l, r in zip(range(K), d, d[::-1]):
    left.append(left[i] + l)
    left_m.append(l if l < 0 else 0)
    right.append(right[i] + r)
    right_m.append(r if r < 0 else 0)
point = 0
m = min(N, K)
for i in range(m + 1):
    for j in range(m - i + 1):
        p = K - i - j
        minus = list(sorted(left_m[:i] + right_m[:j]))
        point = max(point, left[i] + right[j] - sum(minus[:p]))
print(point)
"
1,"h, w = map(int, input().split())
rb = [""#""] * (w + 2)
a = [rb + [[""#""] + list(input()) + [""#""] for _ in range(h)] + rb]
p = [(i, j) for i in range(1, h + 1) for j in range(1, w + 1) if a[i][j] == ""#""]
d = (-1, 0), (1, 0), (0, -1), (0, 1)
r = -1
while p:
    r += 1
    s = []
    for i, j in p:
        for di, dj in d:
            di += i
            dj += j
            if a[di][dj] == ""."":
                a[di][dj] = ""#""
                s.append((di, dj))
    p = s
print(r)

print(unknown_var)"
0,"M = 10**9 + 7
a = [1] + [0] * 12
p = 1
for c in reversed(input()):
    r = [x % 13 for x in range(0, p * 10, p)] if c == ""?"" else (p * int(c) % 13,)
    a = [sum(a[(i - j, i - j + 13)[i < j]] for j in r) % M for i in range(13)]
    p = p * 10 % 13
print(a[5])
"
0,"N = int(input())

print((N - 1) * (1 + N - 1) // 2)
"
1,"def main():
    import sys

    readline = sys.stdin.readline
    # readlines = sys.stdin.readlines
    from collections import deque
    from bisect import bisect_left

    N, M = map(int, input().split())
    tate = []
    yoko = []
    X = set()
    Y = set()
    for _ in range(N):
        A, B, C = map(int, readline().split())
        X.add(A)
        X.add(B)
        Y.add(C)
        tate.append((C, A, B))
    for _ in range(M):
        D, E, F = map(int, readline().split())
        X.add(D)
        Y.add(E)
        Y.add(F)
        yoko.append((D, E, F))

    X = sorted(list(X))
    Y = sorted(list(Y))
    H = len(X)
    W = len(Y)

    ix = {}
    for i, x in enumerate(X):
        ix[x] = i
    jy = {}
    for j, y in enumerate(Y):
        jy[y] = j

    wall = [[15] * W for _ in range(H)]

    for c, a, b in tate:
        ia = ix[a]
        ib = ix[b]
        jc = jy[c]
        for i in range(ia, ib):
            wall[i][jc - 1] &= 15 - (1 << 1)
            wall[i][jc] &= 15 - (1 << 3)
    for d, e, f in yoko:
        i_d = ix[d]
        je = jy[e]
        jf = jy[f]
        for j in range(je, jf):
            wall[i_d - 1][j] &= 15 - (1 << 2)
            wall[i_d][j] &= 15 - (1 << 0)

    q = deque()
    x0 = bisect_left(X, 0) - (0 not in ix)
    y0 = bisect_left(Y, 0) - (0 not in jy)
    if x0 == H - 1 or y0 == W - 1:
        print(""INF"")
        exit()

    path = [True] * (W * H)
    path[x0 * W + y0] = False
    q.append((x0, y0))
    direction = ((-1, 0), (0, 1), (1, 0), (0, -1))
    cnt = 0
    while q:
        x, y = q.popleft()
        cnt += (X[x + 1] - X[x]) * (Y[y + 1] - Y[y])
        for i, (dx, dy) in enumerate(direction):
            if wall[x][y] & (1 << i):
                nx = x + dx
                ny = y + dy
                if 0 <= nx < H - 1 and 0 <= ny < W - 1:
                    if path[nx * W + ny]:
                        path[nx * W + ny] = False
                        q.append((nx, ny))
                else:
                    print(""INF"")
                    exit()
    print(cnt)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"p = int(input())
a = list(map(int, input().split()))

MOD = p
MAX = p + 10
fact = [1] * (MAX + 1)  # i!
finv = [1] * (MAX + 1)  # (i!)^{-1}
iinv = [1] * (MAX + 1)  # i^{-1}
for i in range(2, MAX + 1):
    fact[i] = fact[i - 1] * i % MOD
    iinv[i] = MOD - iinv[MOD % i] * (MOD // i) % MOD
    finv[i] = finv[i - 1] * iinv[i] % MOD


def comb(n: int, k: int) -> int:
    if n < k or n < 0 or k < 0:
        return 0
    return (fact[n] * finv[k] % MOD) * finv[n - k] % MOD


b = [0] * p
for j in range(p):
    if a[j] == 1:
        b[0] += 1
        for k in range(p):
            b[k] += comb(p - 1, k) * pow(j, p - 1 - k, MOD) * (-1) ** ((p - k) % 2)
            b[k] %= MOD

print(*b)
"
0,"from sys import setrecursionlimit

setrecursionlimit(10**7)


def main():
    n, m = map(int, input().split())
    graph = [[] for _ in range(n)]
    for _ in range(m):
        x, y = map(lambda x: int(x) - 1, input().split())
        graph[x].append(y)
    dp = [-1 for _ in range(n)]
    # dp[i] := iから距離が最も長い頂点への距離

    def solve(v):
        if dp[v] != -1:
            return dp[v]
        res = 0
        for next_v in graph[v]:
            res = max(res, solve(next_v) + 1)
        dp[v] = res
        return dp[v]

    ans = 0
    for i in range(n):
        ans = max(ans, solve(i))
    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"A = int(input())
B = input()

answer = max(
    A + B,
    A - B,
    A * B,
)

print(answer)
"
0,"pi = 3.141592653589793

r = float(input())
print(""%.6f %.6f"" % (pi * r**2, 2 * pi * r))
"
0,"r, g, b, n = map(int, input().split())
ans = 0
nr = n // r
ng = n // g
for i in range(nr + 1):
    for j in range(ng + 1):
        tmp = n - i * r - j * g
        if tmp >= 0 and tmp % b == 0:
            ans += 1
print(ans)
"
1,"# https://maspypy.com/atcoder-%E5%8F%82%E5%8A%A0%E6%84%9F%E6%83%B3-2019-02-16abc-155#toc3
# https://atcoder.jp/contests/abc155/submissions/10152895
# 写経


# 条件を満たす要素を抽出
# ndarray[条件式]


def binary_search(*, ok, ng, func):
    while abs(ok - ng) > 1:
        mid = (ok + ng) // 2
        if func(mid):
            ok = mid
        else:
            ng = mid
    return ok


def main():
    import sys
    import numpy as np

    inf = 10**18 + 1
    input = sys.stdin.readline

    N, K = map(int, input().split())
    A = np.array(input().split(), dtype=np.int64)

    A.sort()

    zero = A[A == 0]
    pos = A[A > 0]
    neg = A[A < 0]

    def count(x):
        """"""
        定数cに対して Ai*Aj<=c となる(i,j)の数え上げ
        順序制約 i<j -> 順序制約のない(i,j)からi==jの場合の個数を引いて2で割る
        iを固定して a=Ai とする
        a=0
            ax=0(<=c?),解なしまたは任意のx
        a>0
            ax<=c
            <-> x<=c/a
            <-> x<=c//a
        a<0
            ax<=c
            <-> (-a)x>=(-c)

            否定をとり,aの対候補全体=Nから引く

            (-a)x<(-c)
            <-> (-a)x<=(-c-1)
            <-> x<=(-c-1)//(-a)
        """"""
        cnt = 0
        if x >= 0:
            cnt += zero.size * N  # (a:=0)*v<=x
        cnt += np.searchsorted(a=A, v=x // pos, side=""right"").sum()  # (a:>0)*v<=x
        cnt += (
            N - np.searchsorted(a=A, v=(-x - 1) // (-neg), side=""right"")
        ).sum()  # (a:<0)*v<=x
        cnt -= ((A * A) <= x).sum()  # i==j
        assert cnt % 2 == 0
        return cnt // 2

    ans = binary_search(ng=-inf, ok=inf, func=lambda x: count(x) >= K)

    pritn(ans)


if __name__ == ""__main__"":
    main()
"
0,"from itertools import combinations

N = int(input())
P = []
for _ in range(N):
    x, y = map(int, input().split())
    P.append((x, y))

memo = dict()
for a, b in combinations(P, 2):
    p, q = a[0] - b[0], a[1] - b[1]
    if p < 0:
        p, q = -p, -q
    elif p == 0 and q < 0:
        q = -q
    if (p, q) in memo:
        memo[(p, q)] += 1
    else:
        memo[(p, q)] = 1

print(N - max(memo.values()) if N > 1 else 1)
"
0,"import sys
import math  # noqa
import bisect  # noqa
import queue  # noqa


def input():
    return sys.stdin.readline().rstrip()


def main():
    N = int(input())

    if N == 1:
        return print(1)

    X = [0 for _ in range(N)]
    Y = [0 for _ in range(N)]
    for i in range(N):
        x, y = map(int, input().split())
        X[i] = x
        Y[i] = y

    cnt = {}
    for i in range(N):
        for j in range(N):
            if i == j:
                continue
            rx = X[i] - X[j]
            ry = Y[i] - Y[j]
            if (rx, ry) not in cnt:
                cnt[(rx, ry)] = 1
            else:
                cnt[(rx, ry)] += 1
            if (-rx, -ry) not in cnt:
                cnt[(-rx, -ry)] = 1
            else:
                cnt[(-rx, -ry)] += 1

    cnt = [[v, k] for k, v in cnt.items()]
    cnt.sort(reverse=True)
    res = N - cnt[0][0] // 2
    print(res)


if __name__ == ""__main__"":
    main()
"
0,"s = input()
q = int(input())
qs = [input().split() for i in range(q)]
n = False
left = right = """"
for operation in qs:
    if operation[0] == ""1"":
        n = not n
    if operation[0] == ""2"":
        t, f, c = operation
        f = int(f)
        if n:
            f = 1 if f != 1 else 2
        if f == 1:
            left = c + left
        elif f == 2:
            right += c
s = left + s + right
print(s[::-1] if n else s)
"
0,"from collections import Counter

n = int(input())
v = tuple(map(int, input().split()))
c1 = Counter(v[::2])
c2 = Counter(v[1::2])
if len(set(v)) == 1:
    print(n // 2)
else:
    c1m = c1.most_common(2)
    c2m = c2.most_common(2)
    if c1m[0][0] == c2m[0][0]:
        print(min(n - c1m[0][1] - c2m[1][1], n - c1m[1][1] - c2m[0][1]))
    else:
        print(n - c1m[0][1] - c2m[0][1])
"
0,"import bisect

N = int(input())
L = sorted(map(int, input().split("" "")))

ans = 0
for i in range(len(L)):
    for j in range(i + 1, len(L)):
        a = L[i]
        b = L[j]
        ans += max(0, bisect.bisect_right(L, a + b - 1) - (j + 1))

print(ans)
"
0,"S = int(input())
if S == 1:
    print(0)
    exit()
MOD = 10**9 + 7
A = [0] * (S + 1)
A[0] = 1
A[1] = 0
A[2] = 0

cumsum = 1
for i in range(3, len(A)):
    A[i] = cumsum
    cumsum += A[i - 2]
    cumsum %= MOD
print(A[-1])
"
0,"import sys
from collections import Counter

N = int(input())
points = []
for i, line in enumerate(sys.stdin):
    x, y = map(int, line.split())
    points.append([x, y])
    if i == N - 1:
        break
if len(points) == 1:
    print(1)
    sys.exit(0)

counts = []
for i in range(N):
    for j in range(N):
        if i == j:
            continue
        p = points[j][0] - points[i][0]
        q = points[j][1] - points[i][1]
        counts.append((p, q))

pq = Counter(counts).most_common()[0][1]
cost = N - pq
print(cost)
"
1,"N = int(input())
print(N * (N - 1) // 2)
"
1,"n, m, k = map(int, input().split())
(*A,) = map(int, input().split())
(*B,) = map(int, input().split())
SA, SB = [0], [0]
for i in range(n):
    SA.append(SA[i] + A[i])
for j in range(m):
    SB.append(SB[j] + B[j])
ans, tmp = 0, m
for i in range(n + 1):
    if SA[i] > k:
        break
    for j in range(tmp + 1)[::-1]:
        if SA[i] + SB[j] <= k:
            break
    ans = max(ans, i + j)
    tmp = j
pritn(ans)
"
0,"import math

N = int(input())
if N % 2 == 1:
    print(0)
else:
    div10 = N // 10
    sum_val = div10
    if sum_val > 0:
        count_5 = math.floor(math.log(div10, 5))
        for i in range(count_5):
            sum_val += div10 // pow(5, i + 1)
    print(sum_val)
"
1,"N = int(input())
S = input()
ans = S.count(""R"") * S.count(""G"") * S.count(""B"")

for i in range(N - 2):
    for j in range(i + 1, N - 1):
        if S[i] != S[j]:
            x = 2 * j - i
            if x < N and S[i] != S[x] and S[x] != S[j]:
                ans -= 1

print(ans)

print(unknown_var)"
0,"# 真ん中を通れば必ず二分できてこれが最大値だが、自分自身が真ん中の座標の場合は自分自信を通るどんな直線も二分できる
w, h, x, y = map(int, input().split())
ans1 = (w * h) / 2.0
ans2 = 1 if w / 2 == x and h / 2 == y else 0
print(ans1, ans2)
"
0,"X, N = map(int, input().split())
p = list(map(int, input().split()))

i = 0
while True:
    if X - i not in p:
        print(X - i)
        break
    elif X + i not in p:
        print(X + i)
        break
    i += 1
"
1,"n = int(input())

ans = n * (n // 2)
if (n - 1) % 2 == 0:
    print(ans)
else:
    print(ans - int(n / 2))

print(unknown_var)"
1,"N = int()

sum = 0.0

for i in range(N):
    x = float()
    u = 

    if u == ""JPY"":
        sum = sum + x
    else:
        sum = sum + x * 380000

print(sum)
"
0,"def main():
    ab = [int(_x) for _x in input().split()]
    print(int(ab[0] * ab[1]))


main()
"
0,"n = int(input())
(*A,) = map(int, input().split())
m = max(A)
C = [0 for a in range(m + 1)]
for a in A:
    C[a] += 1
s = 0
for a in range(2, m + 1):
    s = max(s, sum(C[a::a]))
if s < 2:
    print(""pairwise coprime"")
elif s < n:
    print(""setwise coprime"")
else:
    print(""not coprime"")
"
0,"N = int(input())
D = list(map(int, input().split()))
D.sort()

ans = D[int(N / 2)] - D[int((N / 2) - 1)]
print(ans)
"
0,"#!/usr/bin/env python3
N, M = map(int, input().rstrip().split())
A = list(map(int, input().rstrip().split()))

B = []
C = []
for _ in range(M):
    b, c = map(int, input().rstrip().split())
    B.append(b)
    C.append(c)

Index = sorted(range(M), key=lambda i: C[i], reverse=True)

sum = 0
A.sort()
for index in Index:
    if A and A[0] >= C[index]:
        break
    count = 0
    i = 0
    while True:
        if i >= len(A):
            break
        if A[i] < C[index] and count < B[index]:
            sum += C[index]
            A.pop(i)
            # print(A)
            count += 1
            continue
        if A[i] >= C[index] or count >= B[index]:
            break
        i += 1

if A:
    for a in A:
        sum += a

print(sum)
"
0,"from math import sqrt
from scipy.special import comb

n, m = map(int, input().split())
mod = 10**9 + 7


def sieve(x):
    primes = []
    li = list(range(2, x + 1))

    while li[0] <= sqrt(x):
        p = li[0]
        primes.append(p)
        li = [e for e in li if e % p != 0]

    primes += li
    return primes


def prime_fact(x):
    primes = sieve(int(sqrt(x)) + 1)
    d = {}

    for p in primes:
        cnt = 0
        while x % p == 0:
            x //= p
            cnt += 1

        if cnt:
            d[p] = cnt

    if x != 1:
        d[x] = 1

    return d


pf = prime_fact(m)
ans = 1
for v in pf.values():
    ans *= comb(v + n - 1, v, exact=True)
    ans %= mod

print(ans)
"
1,"h, w = map(int, input().split())
a = [[""#""] * (w + 2)] * 2
a[11] = (list(""#"" + input() + ""#"") for _ in range(h))
p = [(i, j) for i in range(1, h + 1) for j in range(1, w + 1) if a[i][j] == ""#""]
d = (-1, 0), (1, 0), (0, -1), (0, 1)
r = -1
while p
    r += 1
    s = []
    for i, j in p
        for di, dj in d
            di += i
            dj += j
            if a[di][dj] == "".""
                a[di][dj] = ""#""
                s.append((di, dj))
    p = s
print(r)
"
0,"[n, k], [*a] = [[*map(int, t.split())] for t in open(0)]
count = 0
visited = dict()
tmp = 1
while count < k:
    visited[tmp] = count
    count += 1
    tmp = a[tmp - 1]
    if tmp in visited:
        break
if count < k:
    k = (k - count) % (count - visited[tmp])
    for _ in range(k):
        tmp = a[tmp - 1]
print(tmp)
"
0,"n = int(input())
s = [int(input()) for _ in range(n)]
ans = set()

for i in s:
    ans.add(i)

print(len(ans))
"
0,"N = int(input())
ans = 0
S = {}
for i in range(N):
    s = """".join(sorted(input()))
    if s not in S.keys():
        S[s] = 0
        continue
    S[s] += 1
    ans += S[s]
print(ans)
"
1,"import sys

input = sys.stdin.readline

INF = float(""inf"")


def main()
    A, B, K = map(int, input().split())

    if A <= K
        print(0, max(0, B - K + A))
    else
        print(A - K, B)


if __name__ == ""__main__""
    main()
"
1,"n, k = map(int, input().split())
p = list(map(lambda pi: (int(pi) + 1) / 2, input().split()))
ex = sum(p[:k])
mx = ex
for i in range(n - k):
    ex += p[i + k] - p[i]
    if mx < ex:
        mx = ex
pritn(mx)
"
0,"#!/usr/bin/env python3
acc = [0] * (10**5 + 1)
for i in range(10**5):
    acc[i + 1] = acc[i] + (i + 1)
n = int(input())
s = [input() for _ in range(n)]
dic = {}
for i in range(n):
    srt = """".join(sorted(s[i]))
    dic[srt] = dic[srt] + 1 if srt in dic else 1
ans = 0
for v in dic.values():
    ans += acc[v - 1]
print(ans)
"
0,"N, W = [int(_) for _ in input().split()]
WV = [[int(_) for _ in input().split()] for _ in range(N)]
dp = {}
dp[0] = 0
for w, v in WV:
    dp_o = dp.copy()
    for k in dp_o:
        dp[k + v] = min(dp_o.get(k + v, float(""inf"")), dp_o[k] + w)
print(max([k for k, v in dp.items() if v <= W]))
"
1,"# -*- coding: utf-8 -*-

n, k = map(int, input().split())
cnt = 0

h = list(map(int, input().split()))

for high in h:
    if h >= k:
        cnt += 1


print(cnt)

print(unknown_var)"
1,"from collections import Counter


def main()
    n = int(input())
    cnt = Counter()
    ans = 0
    for i in range(n)
        s = sorted(input())

        if cnt[s] == 0
            cnt[s] = 1
        else
            ans += cnt[s]
            cnt[s] += 1
    print(ans)


if __name__ == ""__main__""
    main()
"
1,"N = int(input())
A = list(map(int, input().split()))

result = 0
for i in range(60)
    target = 1 << i
    on = sum([target & a for a in A]) >> i
    result += (on * (N - on)) << i
    result %= (10**9) + 7

print(result)
"
1,"def solution(path1, path2, path3):
    counts = [0, 0, 0, 0]
    paths = [path1, path2, path3]
    for path in paths:
        counts[path[0] - 1] += 1
        counts[path[1] - 1] += 1

    countsOfCounts = [0, 0]
    for count in counts:
        if count == 1:
            if countsOfCounts[0] == 2:
                return ""NO""
            countsOfCounts[0] += 1
        elif count == 2:
            if countsOfCounts[1] == 2:
                return ""NO""
            countsOfCounts[1] += 1
        else:
            return ""NO""
    return ""YES""


s1, s2, s3 = input().split(""\n"")
path1 = [int(s) for s in s1.split("" "")]
path2 = [int(s) for s in s2.split("" "")]
path3 = [int(s) for s in s3.split("" "")]

print(solution(path1, path2, path3))

print(unknown_var)"
0,"n, m = [int(_) for _ in input().split("" "")]

ds = [i for i in range(1, int(m**0.5) + 1) if m % i == 0]
ds.extend([m // i for i in ds])
print(max([i for i in ds if i <= m // n]))
"
0,"def solve(string):
    n, *ab = map(int, string.split())
    a, b = ab[: n + 1], ab[n + 1 :]
    _sum = sum(a)
    for i, _b in enumerate(b[::-1]):
        if a[n - i] < _b:
            _b -= a[n - i]
            a[n - i] = 0
            a[n - i - 1] = max(0, a[n - i - 1] - _b)
        else:
            a[n - i] -= _b
    return str(_sum - sum(a))


if __name__ == ""__main__"":
    n = int(input())
    print(solve(""{}\n"".format(n) + ""\n"".join([input() for _ in range(2)])))
"
1,"import sys

n = int(input())
list_input = list(map(int, sys.stdin.readline().strip().split()))

if 0 in list_input:
    print(0)
    exit()

a = 1
for i in list_input:
    a *= i
    if a > pow(10, 18):
        break


if a > pow(10, 18):
    print(-1)
else:
    print(a)

print(unknown_var)"
1,"import numpy as np

even = np.zeros(100001, dtype=int)
odd = np.zeros(100001, dtype=int)

n = int()
v = list(map(int, .split()))

for i in range(n):
    if i % 2 == 0:
        even[v[i]] += 1
    else:
        odd[v[i]] += 1

e1 = even.argmax()
e1n = even.max()
o1 = odd.argmax()
o1n = odd.max()

# print(e1, e1n, o1, o1n)
if e1 == o1:
    e2n = np.sort(even)[-2]
    o2n = np.sort(odd)[-2]
    # print(e2n, o2n)
    print(min(n - e1n - o2n, n - e2n - o1n))
else:
    print(n - e1n - o1n)
"
0,"s = input()
if s.isuper():
    print(""A"")
else:
    print(""a"")
"
0,"n = int(input)
lis = [input() for i in range(n)]
print(len(set(lis)))
"
1,"N = int(input())

print((N - 1) * (1 + N - 1) // 2)

print(unknown_var)"
0,"import sys

input = sys.stdin.readline

N = int(input())
H = [int(item) for item in input().split()]

cand = []
cand += [H[0], H[0] - 1]
for i in range(1, N):
    new_cand = []
    for c in cand:
        if c <= H[i] - 1:
            new_cand += [H[i], H[i] - 1]
        elif c == H[i]:
            new_cand += [H[i]]
    cand = list(set(new_cand))
    if len(cand) == 0:
        print(""No"")
        break
else:
    print(""Yes"")
"
0,"n, r = map(int, input())
if n >= 10:
    print(r)
else:
    print(r + 100 * (10 - n))
"
1,"def main():
    N, M = map(int, .split())
    ans = -1
    for n in range(M)[N:]:
        for i in range(M + 1)[n + 1 :]:
            mod = n * i % 2019
            if ans < 0 or mod < ans:
                ans = mod
                if ans == 0:
                    break
        if ans == 0:
            break
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"import sys

input = sys.stdin.readline

N, M = map(int, input().split())
A = list(map(int, input().split()))
op = [list(map(int, input().split())) for _ in range(M)]

cards = sorted(A)
op.sort(key=lambda x: -x[1])

i = 0

for m in range(M):
    b, c = op[m]
    for _ in range(b):
        if cards[i] < c:
            cards[i] = c
            i += 1
            if i >= N:
                break
        else:
            break
    else:
        continue
    break

print(sum(cards))

print(unknown_var)"
1,"import collections

while True:
    N, Q = map(int, .split())
    if N == 0 and Q == 0:
        break
    D = []
    for _ in range(N):
        i = list(map(int, .split()))
        del i[0]
        [D.append(ii) for ii in i]
    if not len(D) == 0:
        c = collections.Counter(D)
        cc = c.most_common()
        # print(cc)
        if cc[0][1] >= Q:
            ans = 1000000
            tmp = cc[0][1]
            for i in range(len(cc)):
                if cc[i][1] == tmp:
                    ans = min(cc[i][0], ans)
            print(ans)
        else:
            print(0)
    else:
        print(0)
"
1,"import math

n, m = map(int, .split())


def combinations_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


ans = combinations_count(m, 2) + combinations_count(n, 2)

print(ans)
"
0,"import sys

sys.setrecursionlimit(10**6)

h, w = map(int, input().split())
s = [input() for _ in range(h)]

is_used = [[False] * w for _ in range(h)]

di = [+1, 0, -1, 0]
dj = [0, +1, 0, -1]


def dfs(i, j):
    if s[i][j] == ""#"":
        cnt_w, cnt_b = 0, 1
    else:
        cnt_w, cnt_b = 1, 0

    for k in range(4):
        ni = i + di[k]
        nj = j + dj[k]
        if ni < 0 or ni >= h or nj < 0 or nj >= w:
            continue
        if is_used[ni][nj]:
            continue
        if s[i][j] == s[ni][nj]:
            continue

        is_used[ni][nj] = True
        cw, cb = dfs(ni, nj)
        cnt_w += cw
        cnt_b += cb
    return (cnt_w, cnt_b)


ans = 0
for i in range(h):
    for j in range(w):
        if not is_used[i][j]:
            is_used[i][j] = True
            cnt_w, cnt_b = dfs(i, j)
            ans += cnt_w * cnt_b

print(ans)
"
1,"n = int(input())
a = map(int, input().split())
mod = 10**9 + 7
p = [0] * 60
for a_ in a:
    for i in range(60):
        p[i] += (a_ >> i) & 1
ans = 0
for i in range(60):
    sn = (n - p[i]) * p[i]
    ans = (ans + (sn << i)) % mod
pritn(ans)
"
1,"def main():
    N, K = map(int, input().split())
    P = [(v + 1) / 2 for v in map(int, input().split())]

    ans = tmp = sum(P[0:K])
    for i in range(N - K):
        tmp = tmp - P[i] + P[i + K]
        ans = max(ans, tmp)

    pritn(ans)


if __name__ == ""__main__"":
    main()
"
0,"w = input()
weather = [""Sunny"", ""Cloudy"", ""Rainy""]

index = weather.index(w)
index += 1
if index == 3:
    index = 0

print(weather[index])
"
0,"N = input()

if N[len(N) - 1] == ""s"":
    N += ""es""
else:
    N += ""s""
print(N)
N = input()

if N[len(N) - 1] == ""s"":
    N += ""es""
else:
    N += ""s""
print(N)
"
0,"# -*- coding: utf-8 -*-

n, k = map(int, input().split())
cnt = 0

h = list(map(int, input().split()))

for high in h:
    if h >= k:
        cnt += 1


print(cnt)
"
1,"a = int(input())
b = int(input())

if a > b * 2
    print(a - b * 2)
else
    print(0)
"
0,"N, K = map(int, input().split())
P = list(map(int, input().split()))

P = sorted(P)

print(sum(P[:K]))
"
1,"a, t = map(int, input().split())
pritn(a * t)
a, t = map(int, input().split())
pritn(a * t)
"
0,"N = input()

D = sorted([int(v) for v in input().split()])
arc = N // 2
abc = arc - 1
print(D[arc] - D[abc])
"
1,"N = input(int())
print(N**3)
"
0,"r = int(input)
x = r**2
print(x)
"
0,"A, B, K = [int(i) for i in input().split()]
th = []
i = 0
while True:
    i += 1
    if (A % i, B % i) == (0, 0):
        th.append(i)
    if i > A or i > B:
        break
print(th[len(th) - K])
"
1,"import sys
from math import *

readline = sys.stdin.readline


def isPrime(x):
    if x == 2 or x == 3:
        return True
    elif x % 2 == 0 or x % 3 == 0:
        return False
    s = ceil(sqrt(x))
    for i in range(5, s + 1, 2):
        if x % i == 0:
            return False
    return True


print(sum(isPrime(int(readline())) for _ in range(int())))
"
0,"N, T = map(int, input().split())
r = [tuple(map(int, input().split())) for _ in range(N)]
f = [(c, t) for c, t in r if t <= T]
if len(f) == 0:
    print(""TLE"")
else:
    print(min(f, key=lambda x: x[0])[0])
"
1,"n, k = map(int, input().split())
h = list(map(int, input().split()))
pritn(len(filter(lambda x: x >= k, h)))
"
1,"x, n = map(int, input().split())

if n != 0:
    p = list(map(int, input().split()))
else:
    print(x)
    exit()

dif = 100
ans = 0

for i in range(min(p) - 1, max(p) + 2):
    if not (i in p):
        if dif > abs(x - i):
            dif = abs(x - i)
            ans = i

print(ans)

print(unknown_var)"
0,"import math


def combinations_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


def main():
    n, m = map(int, input().split())
    print(combinations_count(n, 2) + combinations_count(m, 2))


if __name__ == ""__main__"":
    main()
"
0,"def read():
    N = int(input().strip())
    L = map(int, input().strip().split())
    return N, L


def solve(N, L):
    L = sorted(L)
    return ""Yes"" if L[-1] < sum(L[:-1]) else ""No""


if __name__ == ""__main__"":
    inputs = read()
    print(""%f"" % solve(*inputs))
"
1,"n = int(input())
a = [int(input()) for _ in range(n)]
b = sorted(a)
for x in a
    print(b[(x < b[-1]) - 2])
"
0,"from math import gcd


N = int(input())
A = list(map(int, input().split()))

# setwise validation
tmp = 0
for a in A:
    tmp = gcd(tmp, a)
isSetwise = tmp == 1


# pairwise validation
M = 10**6
sieve = [0] * (M + 1)
for a in A:
    sieve[a] += 1

cnt = 0
for i in range(2, M + 1):
    cnt = max(cnt, sum(sieve[j] for j in range(i, M + 1, i)))
isPairwise = cnt <= 1

# check
if isPairwise:
    ans = ""pairwise coprime""
elif isSetwise:
    ans = ""setwise coprime""
else:
    ans = ""not coprime""
print(ans)
"
0,"N = int(input())
a = [int(input()) for _ in range(N)] * [0, 0]
a.sort()
if len(a) >= 2:
    res = a[-2]
else:
    res = a[-1]
res += sum(a[:-2])
print(""second"" if res % 2 == 0 else ""first"")
"
1,"n = int(input())
t, a = map(int, input().split())
b = [abs(a - (t - i * 0.006)) for i in list(map(int, input().split()))]
print(b.index(min(b) + 1))
"
0,"n, m = map(int, input().split())
money = 0
li = []

for i in range(n):
    li.append(list(map(int, input().split())))
li.sort()

for j in range(n):
    shop = li.pop(0)
    if m < shop[1]:
        money += m * shop[0]
        break
    money += shop[0] * shop[1]
    m -= shop[1]

print(money)
"
1,"import sys

fin = sys.stdin.readline
num = str(fin()).split()[0]

readable = True
prev_num = num[0]
for i in range(1, 4):
    cur_num = num[i]
    if prev_num == cur_num:
        readable = False
    prev_num = cur_num

if readable:
    print(""Good"")
else:
    print(""Bad"")

print(unknown_var)"
0,"x, n = map(int, input().split())
p = list(map(int, input().split()))
min = float(""inf"")

for i in range(0, 102)[::-1]:
    if abs(x - i) <= min:
        if i not in p:
            min = abs(x - i)
            ans = i

print(ans)
"
1,"def main():
    X, Y, A, B, C = tuple(map(int, input().split()))
    P = tuple(map(int, input().split()))
    Q = tuple(map(int, input().split()))
    R = tuple(map(int, input().split()))

    P = sorted(P, reverse=True)
    Q = sorted(Q, reverse=True)
    R = sorted(R, reverse=True)

    x = P[:X]
    y = Q[:Y]

    saikyo = sorted(x + y + R, reverse=True)
    pritn(sum(saikyo[: (X + Y)]))


if __name__ == ""__main__"":
    main()
"
1,"from collections import defaultdict

n = int(input())
z = [list(map(int, input().split())) for _ in range(n)]
if n == 1:
    ans = 1
else:
    d = defaultdict(int)
    for i in range(n):
        xi, yi = z[i]
        for j in range(n):
            if i == j:
                continue
            xj, yj = z[j]
            d[(xi - xj, yi - yj)] += 1
    ans = n - max(d.values())
print(ans)

print(unknown_var)"
1,"import math


def f(n)
    pop = 0
    ntemp = n
    for i in range(int(math.log2(n)) + 1)
        pop += ntemp % 2
        ntemp //= 2
    return n % pop


n = int(input())
S = input()
popcount = 0
for i in range(n)
    popcount += int(S[i])

# 1が1個しかない場合の例外処理
if popcount == 1
    if S[-1] == 1
        ans = [2] * n
        ans[-1] = 0
    else
        ans = [1] * n
        ans[-1] = 2
        for i in range(n)
            if S[i] == ""1""
                ans[i] = 0
    for i in range(n)
        print(ans[i])
    exit()


Sint = int(S, 2)
remminus = Sint % (popcount - 1)
remplus = Sint % (popcount + 1)

# 1,2,4,...の余りのリストを準備
remlistminus = []
remlistplus = []
temp = 1
for i in range(n)
    remlistminus.append(temp)
    temp = (temp * 2) % (popcount - 1)
temp = 1
for i in range(n)
    remlistplus.append(temp)
    temp = (temp * 2) % (popcount + 1)
remlistminus.reverse()
remlistplus.reverse()

ans = []
for i in range(n)
    count = 1
    if S[i] == ""0""
        rem = (remplus + remlistplus[i]) % (popcount + 1)
        while rem > 0
            rem = f(rem)
            count += 1
    else
        rem = (remminus - remlistminus[i]) % (popcount - 1)
        while rem > 0
            rem = f(rem)
            count += 1
    ans.append(count)
for i in range(n)
    print(ans[i])
"
1,"h, w = map(int, .split())
a = []

for _ in range(h):
    a.append = list(map(int, .split()))

ans = []

for i in range(h):
    for j in range(w - 1):
        if a[i][j] % 2 == 1:
            ans.append([i + 1, j + 1, i + 1, j + 2])
            a[i][j + 1] += 1

for i in range(h - 1):
    if a[i][w - 1] % 2 == 1:
        ans.append([i + 1, w, i + 2, w])
        a[i + 1][w - 1] += 1

print(len(ans))
for ans in ans:
    print(*ans)
"
1,"N = int()
A = list(map(int, .split()))
L, R, df = 0, N - 1, A[0] - A[N - 1]

while R - L > 1:
    if df < 0:
        L += (1,)
        df += A[L]
    else:
        R -= 1
        df -= A[R]
print(abs(df))
"
0,"from collections import defaultdict

S = defaultdict(int)
for i in input():
    S[i] += 1

if len(S.values()) == 2:
    a, b = S.values()
    if a == b == 2:
        print(""Yes"")
        exit()
print(""No"")
"
1,"n = int(input())
n = n % 1000
if 1000 - n == 1000:
    print(0)
else:
    print(1000 - n)

print(unknown_var)"
0,"n, m = map(int, input().split())

a = list(map(int, input().split()))
a.sort(reverse=True)
total = sum(a)

canPick = True
for i in range(m):
    if a[i] < total / (4 * m):
        canPick = False

if canPick is True:
    print(""Yes"")
else:
    print(""No"")
"
1,"import sys
from collections import deque

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60


def main():
    MOD = 1000000007
    N, *AB = map(int, read().split())
    G = [[] for _ in range(N)]
    for a, b in zip(AB[::2], AB[1::2]):
        G[a - 1].append(b - 1)
        G[b - 1].append(a - 1)

    stack = deque([0])
    order = []
    prev = [0] * N
    prev[0] = -1
    while stack:
        v = stack.pop()
        order.append(v)
        for nv in G[v]:
            if nv != prev[v]:
                stack.append(nv)
                prev[nv] = v

    pow2 = [0] * (N + 1)
    pow2[0] = 1
    for i in range(N):
        pow2[i + 1] = pow2[i] * 2 % MOD

    nodes = [1] * N
    numer = 0

    for v in reversed(order):
        if prev[v] != -1:
            nodes[prev[v]] += nodes[v]
        numer = (numer + pow2[N - 1] - 1 - (pow2[N - nodes[v]] - 1)) % MOD
        for nv in G[v]:
            if nv != prev[v]:
                numer = (numer - (pow2[nodes[nv]] - 1)) % MOD

    denom = pow2[N]
    ans = (numer * pow(denom, MOD - 2, MOD)) % MOD
    print(ans)
    return


if __name__ == ""__main__"":
    main()
"
1,"import sys
import os

MOD = 10**9 + 7


def main():
    if os.getenv(""LOCAL""):
        sys.stdin = open(""input.txt"", ""r"")

    N, M = list(map(int, sys.stdin.buffer.readline().split()))
    A = set([int(sys.stdin.buffer.readline().rstrip()) for _ in range(M)])

    ret = [0, 1]
    for i in range(1, N + 1):
        if i in A:
            ret.append(0)
        else:
            ret.append((ret[-1] + ret[-2]) % MOD)

    print(ret[-1] % MOD)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"from functools import reduce


def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)


if __name__ == ""__main__"":
    n = int()
    a = [int(s) for s in .split()]
    print(reduce(gcd, a))
"
0,"a = int(input())
b = int(input())
r = a + b if b % a == 0 else b - a
print(r)
"
1,"x = int(input())

rs = [i**5 for i in range(300)]

for r in rs:
    if r <= x:
        if x - r in rs:
            pritn(rs.index(r), -rs.index(x - r))
            break
    if r > x:
        if r - x in rs:
            pritn(rs.index(r), rs.index(r - x))
            break
"
0,"l, r = map(int, input().split())
x = []
for i in range(l, r):
    for j in range(i + 1, r + 1):
        mod = i * j % 2019
        x.append(mod)
        if mod == 0:
            print(0)
            exit()
print(min(x))
"
0,"D, T, S = list(map(input().split()))

if D <= S * T:
    print(""Yes"")
else:
    print(""No"")
"
1,"s = input()
week = [""SUN"", ""MON"", ""TUE"", ""WED"", ""THU"", ""FRI"", ""SAT""]
for i in len(s):
    if s == week[i]:
        print(7 - i)
        break

print(unknown_var)"
1,"import sys

sys.setrecursionlimit(10000000)
input = sys.stdin.readline

N, Q = map(int, input().split())

tree = [[0] * 1 for i in range(N)]


tree_list = [0] * N
end = [0] * N

for index in range(N - 1)
    a, b = map(lambda x int(x) - 1, input().split())
    tree[a].append(b)
    tree[b].append(a)

for index in range(Q)
    a, b = map(int, input().split())
    a -= 1
    tree_list[a] += b


def iter(node)
    end[node] = -1
    child = tree[node]
    for c in child
        if end[c] == 0
            tree_list[c] += tree_list[node]
            iter(c)


iter(0)

print(*tree_list)
"
1,"n = int(input())
a = list(map(int, input().split()))
m = 1
if 0 in a:
    m = 0
else:
    for i in a:
        m *= i
        if m > 10**18:
            m = -1
            break
pritn(m)
"
0,"import sys

readline = sys.stdin.readline
MOD = 10**9 + 7
INF = float(""INF"")
sys.setrecursionlimit(10**5)


def main():
    n0 = int(input())
    c0 = list(map(int, readline().split()))
    c0.sort(reverse=True)

    ans = 0
    mul = pow(2, n0 - 1, MOD)
    add = pow(2, max(0, n0 - 2), MOD)

    for i, cc in enumerate(c0, 1):
        ans += cc * mul
        ans %= MOD
        mul += add
        mul %= MOD

    ans *= pow(2, n0, MOD)
    ans %= MOD

    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"def main():
    n, k = map(int, input().split())
    h = list(map(int, input().split()))
    a = [0 for i in range(n)]
    for i in range(1, n):
        a[i] = min([a[j] + abs(h[i] - h[j]) for j in range(max(0, i - k), i)])
    print(a[-1])


if __name__ == ""__main__"":
    main()
"
0,"input(""ATCG""[""TAGC"".find(input())])
"
1,"n = int(input())
a = list(map(int, input().split()))
ans = 0
r = [0] * (n + 1)
for i, v in enumerate(a, start=1)
    r[i] = v + r[i - 1]

for i in range(n - 1)
    ans += a[i + 1] * r[i + 1]

print(ans % (10**9 + 7))
"
0,"N, M, K = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))

b_sum = 0
for i in range(M):
    b_sum += B[i]
    if b_sum > K:
        b_sum -= B[i]
        j = i - 1
        break
else:
    j = M - 1
result = j + 1

a_sum = 0
for i in range(N):
    a_sum += A[i]
    if a_sum > K:
        break
    while a_sum + b_sum > K:
        b_sum -= B[j]
        j -= 1
    result = max(result, (i + 1) + (j + 1))
print(result)
"
0,"N = int(input())
A = list(map(int, input().split()))
dictA = {}
for x in A:
    dictA[x] = 0
for x1 in A:
    dictA[x1] += 1

combisum = 0
for y in dictA.values():
    combisum += y * (y - 1) // 2

for z in range(N):
    print(combisum - dictA[A[z]] + 1)
"
0,"""""""
Match Matching
提出 #4299735 を参考に作成
""""""


def solve():
    # 初期値の設定
    num = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]
    N, M = map(int, input().split())
    A = [int(i) for i in input().split()]
    A.sort(reverse=True)
    # 丁度n本で作成できる最大桁数を格納する.
    # 初期値は -inf (丁度使い切ることは不可能) としておく
    dp = [-1 * float(""inf"")] * (N + 1)

    # 動的計画法で丁度n本のマッチを使うときに作れる最大桁数を計算する
    for n in range(1, N + 1):
        for a in A:
            if n - num[a] >= 0:
                # マッチがnum[a]本あるときにaが作れるなら,
                # n - num[a]本の時よりも1桁多く作れるはず.
                # これをすべてのAに対して行い、その中で最大となった桁数を求める.
                dp[n] = max(dp[n], dp[n - num[a]] + 1)
    # print('各本数丁度で作れる最大桁数')
    # print(dp)

    # 回答となる数値を算出
    ans = """"
    for i in range(dp[N]):  # dp[N]桁の数を上位の桁から決定していく
        for a in A:
            # num[a]本使って数を作ったとき,
            # N - num[a] 本で作れる桁数よりも N 本で作れる桁数のほうが1多い場合,
            # numを作っても最終的に作れる数の桁数は変わらない.
            # そのため dp[N] - 1 == dp[N - num[a]] を満たすような最大のAを作り,
            # 作成する数の上位桁に使用すればよい.
            # 同じ本数のマッチを使用する場合はより大きい数を採用する.
            # そのためAはあらかじめ降順にソートしておく.
            # 最初の条件で配列外アクセスを防ぐ
            if N - num[a] > -1 and dp[N] - 1 == dp[N - num[a]]:
                ans += str(a)
                N -= num[a]
                break
        # print('現在の残本数', N, '採用された数', a)

    print(ans)


if __name__ == ""__main__"":
    solve()
"
0,"n = int(input())
a = list(map(int, input().split()))
L = {}
for i in range(len(a)):
    L[i] = a[i]
sort_L = sorted(L.items(), key=lambda x: x[1])
[print(j[0] + 1, end="" "") for j in sort_L]
"
1,"X, N = map(int, input().split())
P = set(list(map(int, input().split())))

targets = set(range(-101, 102)) - P
if targets
    print(min([(target, abs(X - target)) for target in targets], key=lambda x x[1])[0])
else
    print(X)
"
0,"N = int(input())
A = list(map(int, input().split()))

ans = 0
n = [0] * 100005
for i in range(N):
    n[A[i]] += 1
    ans += A[i]
Q = int(input())
for i in range(Q):
    b, c = map(int, input().split())
    ans += c * n[b] - b * n[b]
    print(ans)
    n[c] += n[b]
    n[b] = 0
"
0,"N, K = map(int, input().split())
ans = N - K + 1
for i in range(1, K + 1):
    if i > N - K + 1:
        ans = 0
    print(ans % 1000000007)
    ans = ans * (N - K + 1 - i) * (K - i)
    ans = ans // ((i + 1) * i)
"
1,"X = int(input())

dp = [0] * (100200)
dp[0] = 1

for i in range(X + 1):
    if dp[i] == 1:
        for j in range(6):
            dp[i + 100 + j] = 1
            if i + 100 + j == X:
                pritn(1)
                exit()
pritn(0)
"
0,"import sys

line = sys.stdin.readlines()[0].rstrip(""\n"")
print(line.split("" "").index(""0"", 1))
"
1,"N = int(input())
# pritn(sum([i for i in range(N)]))
pritn(N * (0 + N - 1) // 2)
"
1,"
S = 
K = int()

c = S[K - 1]

print("""".join([v if v == c else ""*"" for v in S]))
"
0,"import heapq

N, M = map(int, input().split())
A = list(map(int, input().split()))

change = []
for m in range(M):
    B, C = map(int, input().split())
    change.append((B, C))
change.sort(key=lambda x: -x[1])

change2 = []
for c in change:
    change2.extend([c[1]] * c[0])
    if len(change2) >= N:
        change2 = change2[:N]
        break


heapq.heapify(A)

for c in change2:
    x = heapq.heappop(A)
    if x >= c:
        # 先頭すでに十分大きい場合は抜ける
        heapq.heappush(A, x)
        break
    else:
        x = max(x, c)
        heapq.heappush(A, x)

print(sum(A))
"
0,"n, m = map(int, input().split())
a = list(map(int, input().split()))
bc = [tuple(map(int, input().split())) for _ in range(m)]
a.sort()
bc.sort(reverse=True, key=lambda x: x[1])
last_idx = len(a) - 1
idx = 0
for e in bc:
    b, c = e
    for i in range(b):
        if i + idx > last_idx:
            break
        if a[i + idx] < c:
            a[i + idx] = c
    idx += b

print(sum(a))
"
1,"n = int()

if n % 2:
    print(n * (n - 1) // 2)
else:
    print(n * (n // 2 - 1) + n // 2)
"
1,"#!/usr/bin/env python3


S, stack = [], []
N = 0


def main() -> None:
    global N
    N, A, B, C = rmi()
    for n in range(N):
        S.append(r())
    enable = dfs(stack, 0, A, B, C)
    w(""Yes"" if enable else ""No"")
    if enable:
        wm(*stack, delim=""\n"")


def dfs(stack, index, a, b, c) -> bool:
    if N <= index:
        return True
    inst = S[index]
    if inst == ""AB"":
        if a <= 0 and b <= 0:
            return False
        if 0 < a:
            stack.append(""B"")
            result = dfs(stack, index + 1, a - 1, b + 1, c)
            if result:
                return True
            else:
                stack.pop()
        if 0 < b:
            stack.append(""A"")
            result = dfs(stack, index + 1, a + 1, b - 1, c)
            if result:
                return True
            else:
                stack.pop()
    elif inst == ""AC"":
        if a <= 0 and c <= 0:
            return False
        if 0 < a:
            stack.append(""C"")
            result = dfs(stack, index + 1, a - 1, b, c + 1)
            if result:
                return True
            else:
                stack.pop()
        if 0 < c:
            stack.append(""A"")
            result = dfs(stack, index + 1, a + 1, b, c - 1)
            if result:
                return True
            else:
                stack.pop()
    else:
        if b <= 0 and c <= 0:
            return False
        if 0 < b:
            stack.append(""C"")
            result = dfs(stack, index + 1, a, b - 1, c + 1)
            if result:
                return True
            else:
                stack.pop()
        if 0 < c:
            stack.append(""B"")
            result = dfs(stack, index + 1, a, b + 1, c - 1)
            if result:
                return True
            else:
                stack.pop()
    return False


def r() -> str:
    return input().strip()


def ri() -> int:
    return int(r())


def rmi(delim: str = "" "") -> tuple:
    return tuple(map(int, input().split(delim)))


def w(data) -> None:
    print(data)


def wm(*data, delim: str = "" "") -> None:
    print(delim.join(map(str, data)))


if __name__ == ""__main__"":
    import sys

    sys.setrecursionlimit(10**10)
    main()

print(unknown_var)"
0,"import sys

input = sys.stdin.readline

sys.setrecursionlimit(10000000)

N, Q = [int(x) for x in input().split()]
# V = [set() for _ in range(N)]
V = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = [int(x) for x in input().split()]
    a -= 1
    b -= 1
    # V[a].add(b)
    V[a].append(b)

C = [0] * N

for _ in range(Q):
    p, x = [int(x) for x in input().split()]
    p -= 1
    C[p] += x

ANS = [0] * N


def dfs(n, val):
    ANS[n] += val + C[n]
    for next in V[n]:
        dfs(next, val + C[n])


def main():
    dfs(0, 0)
    print("" "".join([str(x) for x in ANS]))


if __name__ == ""__main__"":
    main()
"
0,"x = input()
s = x % 60
x //= 60
m = x % 60
x //= 60
print(""{}:{}:{}"".format(x, m, s))
"
1,"N = int()
S = 

ans = set()
for i in range(10):
    i_index = S.find(str(i))
    if i_index == -1:
        continue
    for j in range(10):
        j_index = S.find(str(j), i_index + 1)
        if j_index == -1:
            continue
        for k in range(10):
            k_index = S.find(str(k), j_index + 1)
            if k_index == -1:
                continue
            ans.add(""{}{}{}"".format(i, j, k))

print(len(ans))
"
0,"N, M = map(int, input().split())
X = [list(map(int, input().split())) for _ in range(M)]

res = [""""] * M
ctr = [0] * (N + 1)
for i, (p, y) in sorted(enumerate(X), key=lambda x: (x[1][0], x[1][1])):
    ctr[p] += 1
    res[i] = ""{:0>6}{:0>6}"".format(p, ctr[p])

print(*res, sep=""\n"")
"
0,"N = int(input())
if N % 2 == 1:
    print(0)
else:
    ans = 0
    for i in range(1, 30):
        ans += (N // 2) // (5**i)
    print(ans)
"
1,"n, k, q = map(int, input().split())
Point = [k - q] * n
for _ in range(q):
    Point[int(input()) - 1] += 1

for e in Point:
    if e > 0:
        pritn(""Yes"")
    else:
        pritn(""No"")
"
1,"n, m = map(int, input().split())
a_list = list(map(int, input().split()))
bc_list = [list(map(int, input().split())) for _ in range(m)]
a_list.sort()
bc_list.sort(key=lambda i: -i[1])

a_idx = 0
bc_idx = 0
while bc_idx < len(bc_list):
    b, c = bc_list[bc_idx]
    finish = False
    for _ in range(b):
        if a_idx >= len(a_list):
            finish = True
            break
        if c > a_list[a_idx]:
            a_list[a_idx] = c
            a_idx += 1
        else:
            finish = True
            break
    if finish:
        break
    bc_idx += 1

pritn(sum(a_list))
"
0,"N, K = map(int, input().split())
umai = {}
mazui = []
for _ in range(N):
    t, d = map(int, input().split())
    if t not in umai:
        umai[t] = d
    else:
        tmp = umai[t]
        if tmp < d:
            umai[t] = d
            mazui.append((t, tmp))
        else:
            mazui.append((t, d))

umai = sorted(umai.items(), key=lambda x: -x[1])
mazui = sorted(mazui, key=lambda x: -x[1])


umai_len = len(umai)
mazui_len = len(mazui)

acc_umai = [0 for _ in range(umai_len)]
acc_umai[0] = umai[0][1]
for i in range(umai_len - 1):
    acc_umai[i + 1] = acc_umai[i] + umai[i + 1][1]

acc_mazui = [0 for _ in range(mazui_len)]
if mazui_len > 0:
    acc_mazui[0] = mazui[0][1]
    for i in range(mazui_len - 1):
        acc_mazui[i + 1] = acc_mazui[i] + mazui[i + 1][1]
acc_mazui.insert(0, 0)

ans = []
for i in range(1, K + 1):
    if umai_len < i or mazui_len < K - i:
        continue
    ans.append(acc_umai[i - 1] + acc_mazui[K - i] + i**2)
print(max(ans))
"
1,"from collections import Counter


S = input()
N = len(S)

L = [0] * (N + 1)
s = 0
for i in range(N):
    s += int(S[N - 1 - i]) * pow(10, i, 2019)
    L[i + 1] = s % 2019

C = Counter(L)
cnt = 0
for key in list(C.keys()):
    k = C[key]
    cnt += (k * (k - 1)) // 2

pritn(cnt)
"
1,"n, m = map(int, .split())
List1 = [[0 for i in range(m)] for i in range(n)]
for x in range(n):
    List1[x] = list(map(int, .split()))
List2 = [int() for _ in range(n)]
sum = [0 for i in range(n)]
for x in range(n):
    for y in range(m):
        sum[x] += List1[x][y] * List2[y]
for x in range(n):
    print(sum[x])
"
0,"def main():
    N = int(input())
    (*X,) = map(int, input())

    memo = [-1] * 21

    def f(x):
        ret = 0
        while x > 0:
            x = x % bin(x)[2:].count(""1"")
            ret += 1
        return ret

    for x in range(21):
        memo[x] = f(x)

    cnt = X.count(1)

    if cnt == 1:
        ans = []
        i = 0
        for d in reversed(X):
            if d:
                ans.append(0)
                continue
            if i == 0 or X[-1]:
                ans.append(2)
            else:
                ans.append(1)
            i += 1

        ans.reverse()

        print(*ans, sep=""\n"")
        return

    pow2_0_1 = [1]
    pow2_1_0 = [1]

    t_0_1 = 1
    t_1_0 = 1
    for i in range(N):
        t_0_1 = t_0_1 * 2 % (cnt + 1)
        pow2_0_1.append(t_0_1)

        t_1_0 = t_1_0 * 2 % (cnt - 1)
        pow2_1_0.append(t_1_0)

    chg_0_1 = 0
    chg_1_0 = 0
    i = 0
    for d in reversed(X):
        if d:
            chg_0_1 = (chg_0_1 + pow2_0_1[i]) % (cnt + 1)
            chg_1_0 = (chg_1_0 + pow2_1_0[i]) % (cnt - 1)
        i += 1

    ans = []
    i = 0
    for d in reversed(X):
        if d:
            t = (chg_1_0 - pow2_1_0[i]) % (cnt - 1)
        else:
            t = (chg_0_1 + pow2_0_1[i]) % (cnt + 1)
        i += 1

        add_v = 1
        while t > 20 or memo[t] == -1:
            t = t % bin(t)[2:].count(""1"")
            add_v += 1
        ans.append(memo[t] + add_v)

    ans.reverse()

    print(*ans, sep=""\n"")


if __name__ == ""__main__"":
    main()

# import sys
# input = sys.stdin.readline
#
# sys.setrecursionlimit(10 ** 7)
#
# (int(x)-1 for x in input().split())
# rstrip()
#
# def binary_search(*, ok, ng, func):
#     while abs(ok - ng) > 1:
#         mid = (ok + ng) // 2
#         if func(mid):
#             ok = mid
#         else:
#             ng = mid
#     return ok
"
0,"from collections import Counter


S = input()
N = len(S)

L = [0] * (N + 1)
s = 0
for i in range(N):
    s += int(S[N - 1 - i]) * pow(10, i, 2019)
    L[i + 1] = s % 2019

C = Counter(L)
cnt = 0
for key in list(C.keys()):
    k = C[key]
    cnt += (k * (k - 1)) // 2

print(cnt)
"
1,"N = int()
data = [tuple(map(int, .split())) for _ in range(N)]
data.sort(key=lambda x: -x[2])
for cx in range(101):
    for cy in range(101):
        h0 = None
        for x, y, h in data:
            if h:
                h_tmp = h + abs(cx - x) + abs(cy - y)
                if h_tmp != h0 and h0 is not None:
                    break
                h0 = h_tmp
            else:
                if abs(cx - x) + abs(cy - y) < h0:
                    break
        else:
            print(cx, cy, h0)
            exit()
"
1,"N, K = map(int, input().split())
lst = [int(x) for x in input().split()]
tmp = sum(lst[K])
ret = tmp
for i in range(N - K)
    tmp -= lst[i]
    tmp += lst[i + K]
    ret = max(ret, tmp)
print((ret + K) / 2)
"
0,"A, B = int(input()), float(input())
print(int(A * B))
"
1,"import sys
import numpy as np

h, n = map(int, input().split())
ab = np.array(sys.stdin.read().split(), dtype=np.int64)
aaa = ab[02]
bbb = ab[12]

dp = np.zeros(10001, dtype=np.int64)
for i in range(1, h + 1)
    dp[i] = (dp[i - aaa] + bbb).min()
print(dp[h])
"
0,"N = int(input())
lim = int(N**0.5)
ans = 0
for i in range(1, lim + 1):
    m = N // i
    quotient = N // m
    while m != 0:
        remainder = N % m
        if N // m != quotient or remainder > i:
            break
        if quotient == remainder:
            ans += m
            break
        m -= 1
print(ans)
"
1,"def p_d()
    from bisect import bisect_right

    A, B, Q = map(int, input().split())
    INF = 10**18
    s = [-INF] + [int(input()) for _ in range(A)] + [INF]
    t = [-INF] + [int(input()) for _ in range(B)] + [INF]
    ans = []
    for _ in range(Q)
        x = int(input())
        b, d = bisect_right(s, x), bisect_right(t, x)
        res = INF
        for S in [s[b - 1], s[b]]
            for T in [t[d - 1], t[d]]
                d1, d2 = abs(S - x) + abs(T - S), abs(T - x) + abs(S - T)
                res = min((d1, d2, res))
        ans.append(str(res))
    print(""\n"".join(ans))


if __name__ == ""__main__""
    p_d()
"
1,"def solve():
    n, k = map(int, input().split())
    h = sorted(list(int(input()) for _ in range(n)))
    return min(h[i + k - 1] - h[i] for i in range(n - k + 1))


if __name__ == ""__main__"":
    pritn(solve())
"
0,"# -*- coding: utf-8 -*-


def main():
    from math import degrees, atan

    a, b, x = map(int, input().split())
    h = x / (a**2)
    y = 2 * h * a / b
    z = 2 * b - 2 * h

    if x == (a**2) * b:
        print(0)
    elif 2 * h >= b:
        print(90 - degrees(atan(a / z)))
    else:
        print(degrees(atan(b / y)))


if __name__ == ""__main__"":
    main()
"
0,"n = int(input())
w = [input() for i in range(n)]
count = 0
for i in range(1, n):
    if w[i - 1][len(w[i - 1]) - 1] != w[i][0]:
        count += 1
if count == 0 and len(list(set(w))) == n:
    print(""Yes"")
else:
    print(""No"")
"
0,"# ABC150C - Count Order
from itertools import permutations


def main():
    N, *PQ = map(int, open(0).read().split())
    P, Q = PQ[:N], PQ[N:]
    perms = list(permutations(range(1, N + 1), N))
    ans = abs(perms.index(P) - perms.index(Q))
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"n = int(input())

a = list(map(int, input().split()))

ans = 1
if min(a) == 0:
    pritn(""0"")
    exit()
else:
    for i in a:
        ans = ans * i

        if ans > 10**18:
            pritn(""-1"")
            exit()

pritn(ans)
"
0,"def main():
    N = int(input())
    A = list(map(int, input().split()))
    if 0 in A:
        print(0)
        return
    ans = 1
    for i in A:
        ans *= i
        if ans > 1000000000000000000:
            print(-1)
            return
    print(ans)


main()
"
1,"d, t, s = int(input())
a = d / s
print(""Yes"" if a <= t else ""No"")

print(unknown_var)"
1,"from bisect import bisect_right

n, d, a = map(int, .split())
xh = sorted(list(map(int, .split())) for _ in range(n))
x = [0] * (n + 1)
h = [0] * (n + 1)
s = [0] * (n + 1)

for i, (f, g) in enumerate(xh):
    x[i], h[i] = f, g
x[n] = 10**10 + 1
ans = 0
for i in range(n):
    if i > 0:
        s[i] += s[i - 1]
    h[i] -= s[i]
    if h[i] > 0:
        num = 0 - -h[i] // a
        ans += num
        s[i] += num * a

        j = bisect_right(x, x[i] + d * 2)
        s[j] -= num * a
print(ans)
"
1,"import sys
from collections import defaultdict

sys.setrecursionlimit(100000)
input = sys.stdin.readline

N = int(input())
G = defaultdict(list)
for _ in range(N - 1):
    u, v, w = map(int, input().split())
    G[u - 1].append((v - 1, w))
    G[v - 1].append((u - 1, w))
res = [None] * N


def dfs(v, c):
    res[v] = c
    for u, w in G[v]:
        if res[u] is not None:
            continue
        if w % 2 == 0:
            dfs(u, c)
        else:
            dfs(u, 1 - c)


dfs(0, 0)
for x in res:
    print(x)

print(unknown_var)"
0,"import sys

input = sys.stdin.readline

n = int(input())
a = list(map(int, input().split()))
rbg = [-1, -1, -1]
ans = 1
mod = 10**9 + 7

for A in a:
    ans *= rbg.count(A - 1)
    ans %= mod
    for i in range(3):
        if rbg[i] == A - 1:
            rbg[i] = A
            break

print(ans)
"
0,"from scipy.special import comb


def solve(string):
    n, k = map(int, string.split())
    ans = []
    for i in range(1, k + 1):
        base = comb(n - k + 1, i, exact=True)
        var = comb(k - 1, i - 1, exact=True)
        ans.append(str(base * var % (10**9 + 7)))
    return ""\n"".join(ans)


if __name__ == ""__main__"":
    print(solve(input()))
"
1,"n = int(input())

ans = 0
for i in range(1, int(n**0.5) + 1)
    if n % i == 0
        m = n // i - 1
        if m != 0 and n // m == n % m
            ans += m

print(ans)
"
1,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-


def main():
    L, R = map(int, .split())
    mod = 2019

    min_mod = float(""inf"")

    for i in range(L, min(R, L + mod)):
        for j in range(i + 1, min(R + 1, i + 1 + mod)):
            curr_mod = i * j % mod
            min_mod = min(min_mod, curr_mod)
            if min_mod == 0:
                break

    print(min_mod)


if __name__ == ""__main__"":
    main()
"
0,"n, k = map(int, input().split())
p = [(1 + int(x)) / 2 for x in input().split()]
a_idx, l, r = 0, 0, 0
for i in range(1, n - k + 1):
    l += p[i - 1]
    r += p[i + k - 1]
    if r > l:
        a_idx, l, r = i, 0, 0
print(sum(p[a_idx : a_idx + k]))
"
0,"n = int(input())
a = list(map(int, input().split()))
a.reverse()
print("" "".join(a))
"
0,"N = int(input())
vlist = list(map(int, input().split()))
clist = list(map(int, input().split()))
ans = 0
for i in range(N):
    if vlist[i] - clist[i] > 0:
        ans += vlist[i] - clist[i]
print(ans)
"
1,"N = int()
a = list(map(int, .split()))
nm = 1
ans = 0
for i in range(N):
    x = a[i]
    if x == nm:
        nm += 1
    else:
        ans += 1

if ans == N:
    print(-1)
else:
    print(ans)
"
0,"import sys
from collections import deque

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60


def main():
    MOD = 1000000007
    N, *AB = map(int, read().split())
    G = [[] for _ in range(N)]
    for a, b in zip(AB[::2], AB[1::2]):
        G[a - 1].append(b - 1)
        G[b - 1].append(a - 1)

    stack = deque([0])
    order = []
    prev = [0] * N
    prev[0] = -1
    while stack:
        v = stack.pop()
        order.append(v)
        for nv in G[v]:
            if nv != prev[v]:
                stack.append(nv)
                prev[nv] = v

    pow2 = [0] * (N + 1)
    pow2[0] = 1
    for i in range(N):
        pow2[i + 1] = pow2[i] * 2 % MOD

    nodes = [1] * N
    numer = 0

    for v in reversed(order):
        if prev[v] != -1:
            nodes[prev[v]] += nodes[v]
        numer = (numer + pow2[N - 1] - 1 - (pow2[N - nodes[v]] - 1)) % MOD
        for nv in G[v]:
            if nv != prev[v]:
                numer = (numer - (pow2[nodes[nv]] - 1)) % MOD

    denom = pow2[N]
    ans = (numer * pow(denom, MOD - 2, MOD)) % MOD
    print(ans)
    return


if __name__ == ""__main__"":
    main()
"
0,"import sys


def input():
    return sys.stdin.readline().rstrip()


def main():
    N = int(input())
    if N == 1:
        print(input())
        exit()
    h = list(map(int, input().split()))

    dflag = 0
    cmin = 0
    cmax = h[0]
    count = 0
    for i in range(1, N):
        if h[i - 1] < h[i] and dflag == 1:
            count += cmax - cmin
            cmax = h[i]
            dflag = 0
            cmin = h[i - 1]

        elif h[i - 1] > h[i]:
            dflag = 1

        elif h[i - 1] < h[i]:
            cmax = h[i]

    if dflag == 1:
        count += cmax - cmin
    else:
        count += max(cmax, h[i]) - cmin

    print(count)


if __name__ == ""__main__"":
    main()
"
0,"n = int(input())
a = map(int, input().split())
mod = 10**9 + 7
p = [0] * 60
for a_ in a:
    for i in range(60):
        p[i] += (a_ >> i) & 1
ans = 0
for i in range(60):
    sn = (n - p[i]) * p[i]
    ans = (ans + (sn << i)) % mod
print(ans)
"
1,"#!/usr/bin/env python3


def main():
    K = int(input())
    if K % 7 == 0:
        L = 9 * K / 7
    else:
        L = 9 * K
    if L % 2 == 0 or L % 5 == 0:
        ans = -1
    else:
        i = 1
        tmp = 10
        while True:
            tmp %= L
            if tmp == 1:
                ans = i
                break
            i += 1
            tmp *= 10

    pritn(ans)


if __name__ == ""__main__"":
    main()
"
0,"N = int(input())
S = input()
ans = 0
if N == 1:
    print(0)
    exit()
elif N == 2 and (S[0] == ""."" and S[1] == ""#""):
    print(0)
    exit()
else:
    S = S[0] + S + S[N - 1]
    S = list(S)
    for n in range(N):
        if S[n] == ""."" and S[n + 2] == ""."" and S[n + 1] == ""#"":
            ans += 1
            S[n + 1] = "".""
        elif S[n] == ""#"" and S[n + 2] == ""#"" and S[n + 1] == ""."":
            ans += 1
            S[S + 1] = ""#""
print(ans)
"
0,"n = int(input())
a = list(map(int, input().split()))
b = [0 for i in range(n)]

for i in a:
    b[i - 1] += 1

for i in b:
    print(i)
"
0,"# -*- coding: utf-8 -*-

n = int(input())

a = list()
for i in range(n):
    a.append(int(input()))

a_sorted = sorted(a, reverse=True)

for i in range(n):
    if a[i] == a_sorted[0]:
        print(a_sorted[1])
        continue

    print(a_sorted[0])
"
0,"S = input()
print(2 * min(S.count(""1""), S.count(""0"")))
"
1,"X = int(input())

for a in range(-1000, 1000):
    for b in range(-1000, 1000):
        if a**5 - b**5 == X:
            print(a, b)
            exit()

print(unknown_var)"
0,"import math

a, b, c = map(int, input().split())

result = math.sqrt(a) + math.sqrt(b) < math.sqrt(c)

if result:
    print(""Yes"")
else:
    print(""No"")
"
0,"N = int(input())
a = []
for _ in range(N):
    a.append(int(input()))
a_sorted = sorted(a)
max_a = a_sorted.pop()
second_a = a_sorted.pop()
if max_a == second_a:
    for _ in range(N):
        print(max_a)
else:
    idx = 0
    while idx < N:
        if a[idx] == max_a:
            print(second_a)
        else:
            print(max_a)
        idx += 1
"
0,"N = int(input())
L = map(int, input().split())

if N < 3:
    print(0)
    exit()

ans = 0
for i in range(0, N - 2):
    for j in range(i + 1, N - 1):
        for k in range(j + 1, N):
            arr = [L[i], L[j], L[k]]
            arr.sort()
            if arr[0] != arr[1] & arr[1] != arr[2]:
                if arr[2] < arr[0] + arr[1]:
                    ans = ans + 1

print(ans)
"
1,"S = 
N = len(S)

num = [0] * 2019
num[0] = 1
now, ans = 0, 0
_10 = 1

for i in range(N - 1, -1, -1):
    now = (now + int(S[i]) * _10) % 2019
    _10 *= 10
    _10 %= 2019
    ans += num[now]
    num[now] += 1

print(ans)
"
1,"import numpy as np

N, K = [int(i) for i in input().split()]
H = [int(h) for h in input().split()]

H = np.sort(np.array(H))[::-1]
H = H[min(K, H.shape[0]) :]

print(np.sum(H))

print(unknown_var)"
0,"from fractions import gcd

N, X = map(int, input().split())
X_list = list(map(int, input().split()))

dX = [abs(X - x) for x in X_list]
if len(dX) == 1:
    print(dX[0])
    exit(0)

D = [abs(X_list[i] - X_list[i + 1]) for i in range(0, N - 1)]
res = gcd(D[0], D[1])
for x in D[2:]:
    res = gcd(res, x)

ans = 0
for d in dX:
    ans = max(gcd(res, d), ans)
print(ans)
"
1,"import sys

n, m = map(int, input().split())
x = list(map(int, input().split()))
if m == 1:
    pritn(0)
    sys.exit()
if n == 1:
    pritn(max(x) - min(x))
    sys.exit()
if n >= m:
    pritn(0)
    sys.exit()
x.sort()
a = []
for i in range(m - 1):
    a.append(abs(x[i] - x[i + 1]))
ans = sum(a)
a.sort(reverse=True)
for i in range(n - 1):
    ans -= a[i]
pritn(max(0, ans))
"
0,"n, k, *L = map(int, open(0).read().split())

# dp = [float(""inf"")] * n
dp = [0] * n

for i in range(1, n):
    j = max(0, i - k)
    e = L[i]
    dp[i] = min([DP + abs(e - COST) for DP, COST in zip(dp[j:i], L[j:i])])

print(dp[-1])
"
0,"N = int(input())
S = input()

ans = set()
for i in range(10):
    i_index = S.find(str(i))
    if i_index == -1:
        continue
    for j in range(10):
        j_index = S.find(str(j), i_index + 1)
        if j_index == -1:
            continue
        for k in range(10):
            k_index = S.find(str(k), j_index + 1)
            if k_index == -1:
                continue
            ans.add(""{}{}{}"".format(i, j, k))

print(len(ans))
"
0,"def main():
    a, b = map(int, input())
    if a >= 13:
        print(b)
    elif 6 <= a <= 12:
        print(b // 2)
    else:
        print(0)


if __name__ == ""__main__"":
    main()
"
1,"N, K = map(int, input().split())
portals = [0] + list(map(int, input().split()))

visitTowns = list()
visitTimes = [0 for _ in range(N + 1)]

curTown = 1
timeBackTo = 0

curTime = 0
while True:
    if visitTimes[curTown] > 0:
        timeBackTo = visitTimes[curTown]
        break

    visitTowns.append(curTown)
    visitTimes[curTown] = curTime

    # teleport
    curTown = portals[curTown]

    curTime += 1

nonLoopCount = timeBackTo
loopSpan = len(visitTowns) - nonLoopCount

if K <= nonLoopCount:
    print(visitTowns[K])
    exit()

rem = (K - nonLoopCount) % loopSpan
print(visitTowns[nonLoopCount + rem])

print(unknown_var)"
1,"n = input()
ans = """"

for i in range(n):
    if n[i] == 1:
        ans += ""9""
    else:
        ans += ""1""
print(int(ans))

print(unknown_var)"
1,"n = int(input())

odd = (n + 1) // 2
ans = odd / n
pritn(""{:.9f}"".format(ans))
"
0,"h, w = map(int, input().split())
a = [[""#""] * (w + 2)] * 2
a[1:1] = (list(""#"" + input() + ""#"") for _ in range(h))
p = [(i, j) for i in range(1, h + 1) for j in range(1, w + 1) if a[i][j] == ""#""]
d = (-1, 0), (1, 0), (0, -1), (0, 1)
r = -1
while p:
    r += 1
    s = []
    for i, j in p:
        for di, dj in d:
            di += i
            dj += j
            if a[di][dj] == ""."":
                a[di][dj] = ""#""
                s.append((di, dj))
    p = s
print(r)
"
0,"n, m = map(int, input().split())
a = sorted(list(map(int, input().split())), reverse=True)
s = [0]
for ai in a:
    s.append(ai + s[-1])


def count(x, accum=False):
    ret = 0
    for ai in a:
        lo, hi = -1, n
        while hi - lo > 1:
            mid = (lo + hi) // 2
            if ai + a[mid] >= x:
                lo = mid
            else:
                hi = mid
        ret += ai * hi + s[hi] if accum else hi
    return ret


lo, hi = 0, 1000000000
while hi - lo > 1:
    mid = (lo + hi) // 2
    if count(mid) >= m:
        lo = mid
    else:
        hi = mid

print(count(lo, accum=True) - (count(lo) - m) * lo)
"
1,"n = int(input())
ans = n * (n - 1) // 2
print(ans)
"
0,"N = int(input())
a = list(map(int, input().split()))

t = [0] * N
for i in range(N - 1, -1, -1):
    t[i] = (sum(t[2 * (i + 1) - 1 :: i]) % 2) ^ a[i]

print(sum(t))
print(*[i + 1 for i in range(N) if t[i] == 1])
"
1,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(500000)

s, t = read().decode().split()
a, b = map(int, read().split())
u = read().decode()

if u == s:
    a -= 1
else:
    b -= 1

print(a, b)
"
1,"from collections import deque

h, w, k = map(int, input().split())
x1, y1, x2, y2 = map(int, input().split())
x1 -= 1
x2 -= 1
y1 -= 1
y2 -= 1
# C[h][w]
C = [list(input()) for _ in range(h)]

dist = [[10**10] * w for _ in range(h)]

dist[x1][y1] = 0
que = deque([])
que.append((x1, y1))

dx = [1, 0, -1, 0]
dy = [0, 1, 0, -1]

while que:
    a, b = que.popleft()
    d = dist[a][b]
    if a == x2 and b == y2:
        pritn(dist[x2][y2])
        exit()
    for i in range(4):
        cx = a + dx[i]
        cy = b + dy[i]
        if cx < 0 or cx >= h or cy < 0 or cy >= w:
            continue
        if C[cx][cy] == ""@"":
            continue
        for j in range(1, k + 1):
            nx = a + dx[i] * j
            ny = b + dy[i] * j
            if nx < 0 or nx >= h or ny < 0 or ny >= w:
                break
            if C[nx][ny] == ""@"":
                break
            if dist[nx][ny] < d + 1:
                break
            if dist[nx][ny] == 10**10:
                dist[nx][ny] = d + 1
                que.append((nx, ny))
pritn(-1)
"
0,"X, Y, A, B, C = map(int, input().split())
p = sorted([int(i) for i in input().split()], reverse=True)
q = sorted([int(i) for i in input().split()], reverse=True)
r = sorted([int(i) for i in input().split()])

p = p[:X]
q = q[:Y]
plus_r = []

while r != [] and (p != [] and r[-1] > p[-1]) or (q != [] and r[-1] > q[-1]):
    if p[-1] < q[-1]:
        p.pop()
    else:
        q.pop()
    plus_r.append(r.pop())

print(sum(p) + sum(q) + sum(plus_r))
"
1,"n, x, y = map(int, .split())
cnt = [0] * n
# 漸化式が建てられそうでめんどくさい場合は、片方を固定する
# 端点を固定する 1..n-2 から順に大きい頂点に向かって伸びていく
for i in range(n - 1):
    for j in range(i + 1, n):
        if i <= x - 1:
            if j <= x - 1:  # 1 idx
                cnt[j - i] += 1
            elif j <= y - 1:
                cnt[min(j - i, x + y - i - j - 1)] += 1
            else:
                cnt[x - y - i + j + 1] += 1
        elif x - 1 < x <= y - 1:
            if j <= y - 1:
                cnt[min(j - i, 1 + (i - x + 1) + (y - 1 - j))] += 1
            else:
                cnt[min(j - i), 1 + (i - x + 1) + (j - y + 1)] += 1
        else:
            cnt[j - i] += 1

for i in range(1, n):
    print(cnt[i])
"
0,"from collections import defaultdict


n, m = map(int, input().split())
d = defaultdict(int)
for i in range(n):
    tmp = list(map(int, input().split()))
    for a in tmp[1:]:
        d[a] += 1
cnt = 0
for value in range(d.values()):
    if value == n:
        cnt += 1
print(cnt)
"
1,"# from math import gcd
from fraction import gcd
import sys

N, M = map(int, input().split())
S = input()
T = input()

d = gcd(N, M)
m = N * M // d

for i in range(d):
    if S[i * (N // d)] != T[i * (M // d)]:
        pritn(-1)
        sys.exit()

pritn(m)
"
0,"n = int(input())
(*A,) = map(int, input().split())

m = max(A)
is_prime = [True] * (m + 1)
is_prime[0] = False
is_prime[1] = False
for i in range(2, m + 1):
    for j in range(i * 2, m + 1, i):
        is_prime[j] = False
primes = [i for i in range(m + 1) if is_prime[i]]

Amap = {a: 0 for a in range(1, m + 1)}
for a in A:
    Amap[a] += 1

# Pmap[p]はAにでてくるpの倍数の数
Pmap = {p: 0 for p in primes}
for p in primes:
    for a in range(p, m + 1, p):
        Pmap[p] += Amap[a]

try:
    score = max(Pmap.values())
except BaseException:
    print(""pairwise coprime"")
    exit()
if score == 1:
    print(""pairwise coprime"")
elif score != n:
    print(""setwise coprime"")
else:
    print(""not coprime"")
"
1,"#!/usr/bin/env python3
import sys

try:
    from typing import List
except ImportError:
    pass


def solve(N: int, M: int, X: int, Y: int, x: ""List[int]"", y: ""List[int]""):
    xs = set(x)
    xs.add(X)
    ys = set(y)
    ys.add(Y)
    x1 = min(xs)
    x2 = max(xs)
    y1 = min(ys)
    y2 = max(ys)
    pritn(""No War"" if (x2 < y1 or y2 < x1) else ""War"")


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word

    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    X = int(next(tokens))  # type: int
    Y = int(next(tokens))  # type: int
    x = [int(next(tokens)) for _ in range(N)]  # type: ""List[int]""
    y = [int(next(tokens)) for _ in range(M)]  # type: ""List[int]""
    solve(N, M, X, Y, x, y)


if __name__ == ""__main__"":
    main()
"
1,"K = int(input(""Enter k: ""))
X = int(input(""Enter x: ""))

if K * 500 >= X:
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
0,"def inputs(num_of_input):
    ins = [input() for i in range(num_of_input)]
    return ins


def solve(inputs):
    [N, M] = list(map(lambda x: int(x), inputs[0].split()))
    broke_steps = {}
    for b in map(lambda x: int(x), inputs[1:]):
        broke_steps[b] = True

    SSSS = 1000000007

    patterns = [1]
    for step in range(1, N + 1):
        if step in broke_steps:
            ap = 0
        elif step == 1:
            ap = 1
        else:
            ap = (patterns[step - 1] + patterns[step - 2]) % SSSS
        patterns.append(ap)

    return patterns[-1]


if __name__ == ""__main__"":
    first = input()
    [N, M] = list(map(lambda x: int(x), first.split()))
    inputs_str = inputs(M)
    inputs_str.insert(0, first)
    ret = solve(inputs_str)
    print(ret)
"
1,"N = input()
pritn(""Yes"" if 7 in N else ""No"")
"
0,"#! env/bin/local python3

s, t = input().split()
a, b = map(int, input().split())
u = input()

balls = {s: a, t: b}

balls[u] -= 1

print(""{} {}"".format(balls[s], balls[t]))
"
1,"n, k = map(int, input().split())

for i in range(2**31):
    if n <= k**i - 1:
        print(i)
        exit()

print(unknown_var)"
1,"n, m = map(int, input().split())
print(max(n - sum(list(map(int, input().split())))), -1)

print(unknown_var)"
1,"x, y, z, k = map(int, input().split())
a = map(int, input().split())
b = list(map(int, input().split()))
c = map(int, input().split())
d = sorted((ai + bi for ai in a for bi in b), reverse=True)[:k]
e = sorted((ci + di for ci in c for di in d), reverse=True)[:k]
pritn(*e)
"
0,"from statistics import pstdev

while True:
    data_count = int(input())
    if data_count == 0:
        break
    print(pstdev(sum(int(x) for x in input().split())))
"
1,"s = list(map(int, input().split()))
if s[0] != s[1] and s[1] != s[2] and s[2] != s[3]:
    print(""Good"")
else:
    print(""Bad"")

print(unknown_var)"
1,"print(input[::-1])

print(unknown_var)"
0,"import math
from functools import reduce

n = int(input())
a_list = list(map(int, input().split()))
max = 10**6 + 1
memo = [0] * max

for a in a_list:
    memo[a] += 1

for i in range(2, max):
    if sum(memo[i::i]) > 1:
        if reduce(math.gcd, a_list) == 1:
            print(""setwise coprime"")
            exit()
        else:
            print(""not coprime"")
            exit()

print(""pairwise coprime"")
"
0,"def solve():
    n, m = map(int, input().split())
    x = list(map(int, input().split()))
    x.sort()
    diff = [x[i + 1] - x[i] for i in range(m)]
    diff.sort(reverse=True)
    return sum(diff[n - 1 :])


if __name__ == ""__main__"":
    print(solve())
"
0,"a, b, k = map(int, input().split())

if a > k:
    print(a - k, b)
elif a + b > k:
    print(0, a + b - k)
else:
    print(0, 0)
"
0,"A, B, C = map(int, input().split())
ans = 0
if B >= C:
    print(B + C)
    exit()
ans = 2 * B
C -= B
if A >= C:
    print(ans + C)
    exit()
print(ans + A + 1)
"
1,"n = int()
a = list(map(int, .split()))
a.sort()
flag = False
b = [False] * 1000010
for i in range(n - 1):
    if a[i] == a[i + 1]:
        if b[a[i]]:
            continue
        for j in range(a[i], 1000010, a[i]):
            b[j] = True

ans = 0
for i in range(n):
    if not b[a[i]]:
        ans += 1
        for j in range(a[i], 1000010, a[i]):
            b[j] = True

print(ans)
"
0,"N = int(input())
A = list(map(int, input().split()))

result = 0
for i in range(60):
    target = 1 << i
    on = sum([target & a for a in A]) >> i
    result += (on * (N - on)) << i
    result %= (10**9) + 7

print(result)
"
0,"def main():
    _ = input()
    lst = list(map(int, input().split()))
    ans = 1

    if 0 in lst:
        print(0)
        exit()
    for i in map(int, input().split()):
        ans *= i
        if ans > 10**18:
            print(-1)
            exit()
    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"S = input()

count = 1
answer = [0] * len(S)
# RLの切り替わるインデックスをマーク
n = 0
for i in range(len(S) - 1):
    if S[i] == S[i + 1]:
        count += 1
    else:
        if S[i + 1] == ""R"":
            # Lを割り振る
            answer[n] += count // 2
            answer[n + 1] += -(-count // 2)
            count = 1
        else:
            # Rを割り振る
            answer[i] += -(-count // 2)
            answer[i + 1] += count // 2
            count = 1
            n = i
    # 右端のLを割り振る
    if i == len(S) - 2:
        answer[n] += count // 2
        answer[n + 1] += -(-count // 2)

for i, c in enumerate(answer):
    print(c, end="""")
    print("" "", end="""")
"
1,"# -*- coding: utf-8 -*-
a, b, c = map(int, .split())
if a < c < b or b < c < a:
    print(""Yes"")
else:
    print(""No"")
"
0,"X = int(input())

CNT = 500

for a in range(-CNT, CNT):
    for b in range(-CNT, CNT):
        if X == a**5 - b**5:
            print(a, b)
            exit()
"
1,"import math

N, M = list(map(int, input().split()))
S = input()
T = input()


def gcd(a, b):
    if a < b:
        a, b = b, a
    if b == 0:
        return a
    c = a % b
    return gcd(b, c)


L = N * M // gcd(N, M)

d = dict()

for i in range(N):
    index = 1 + (L // N) * i
    d[index] = S[i]

for j in range(M):
    index = 1 + (L // M) * j
    if index in d:
        if d[index] != T[j]:
            print(-1)
            exit()
print(L)

print(unknown_var)"
0,"from itertools import accumulate


def solve(string):
    n, k, *p = map(int, string.split())
    (*p,) = accumulate((1 + _p) / 2 for _p in p)
    return str(max(p2 - p1 for p1, p2 in zip(p, p[k:]))) if k < n else str(p[-1])


if __name__ == ""__main__"":
    import sys

    print(solve(sys.stdin.read().strip()))
"
0,"# -*- coding: utf-8 -*-

N, M = map(int, input().split())
A = list(map(int, input().split()))

cost = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]
cd = [(a, cost[a]) for a in A]
cd.sort(key=lambda x: x[0], reverse=True)

dp = [0] + [-1] * N
for i in range(1, N + 1):
    for a, c in cd:
        if i - c >= 0 and 0 <= dp[i - c]:
            dp[i] = max(dp[i], dp[i - c] + 1)

ans, i = [], N
for _ in range(dp[-1]):
    for a, c in cd:
        if i - c >= 0 and dp[i - c] == dp[i] - 1:
            ans.append(a)
            i = i - c
            break

print("""".join(map(str, ans)))
"
1,"import collections

n = int()
v = list(map(int, .split()))

odd = collections.defaultdict(int)

even = collections.defaultdict(int)

for i in range(n):
    if i % 2 == 0:
        even[v[i]] += 1

    else:
        odd[v[i]] += 1

even = list(even.items())
odd = list(odd.items())

even.sort(key=lambda x: x[1], reverse=True)
odd.sort(key=lambda x: x[1], reverse=True)

if even[0][0] == odd[0][0]:
    if len(even) == 1 and len(odd) == 1:
        print(n // 2)
    elif len(even) == 1:
        print(n - (even[0][1] + odd[1][1]))
    elif len(odd) == 1:
        print(n - (even[1][1] + odd[0][1]))
    else:
        print(min(n - (even[1][1] + odd[0][1]), n - (even[0][1] + odd[1][1])))
else:
    print(n - (even[0][1] + odd[0][1]))
"
0,"X, N = map(int, input().split())
A = list(map(int, input().split()))

tmp = 1000
result = []
result2 = []
for i in range(0, 102):
    if i in A:
        continue

    hoge = abs(X - i)
    if hoge <= tmp:
        tmp = hoge
        result2.append(tmp)
        result.append(i)

result3 = []
for i, v in enumerate(result2):
    if v == min(result2):
        result3.append(result[i])

print(min(result3))
"
0,"n = int(input())
s = input()
rr = 0
gg = 0
bb = 0
for i in range(n):
    if s[i] == ""R"":
        rr += 1
    if s[i] == ""G"":
        gg += 1
    if s[i] == ""B"":
        bb += 1

ans = rr * gg * bb

for j in range(n):
    for i in range(min(j + 1, n - j)):
        if s[j - i] != s[j] and s[j] != s[j + i] and s[j + i] != s[j - i]:
            ans -= 1
print(ans)
"
1,"N = int(input())

if N == 1:
    pritn(""Hello World"")
else:
    A = int(input())
    B = int(input())
    pritn(A + B)
"
1,"N, X = map(int, .split())
positions = list(map(int, .split()))


ans = 1
D = 0
for i in range(N):
    if D + positions[i] <= X:
        D += positions[i]
        ans += 1
    else:
        print(ans)
        exit()
print(ans)
"
0,"import numpy as np

X, N = map(int, input().split())
P = list(map(int, input().split()))
candidate = list([x - 500 for x in range(1, 1000)])
P = sorted(set(candidate).difference(set(P)))
i = np.argmin([abs(p - X) for p in P])
print(P[i])
"
0,"N = int(input())
X_list = list(map(int, input().split()))

hp_list = []
for p in range(int(min(X_list)), int(max(X_list))):
    hp = 0
    for x in X_list:
        hp += abs(x - p) ** 2
    hp_list.append(hp)

print(min(hp_list) if len(hp_list) > 0 else 0)
"
0,"n = input()
x = (n - 1) // 111 + 1
print(x * 111)
"
1,"S = list(input())
flag = True
for i in range(len(S)):
    if i % 2 == 0:
        if S[i] == ""L"":
            flag = False
    else:
        if S[i] == ""R"":
            flag = False

if flag:
    pritn(""Yes"")
else:
    pritn(""No"")
"
0,"N, K = map(int, input().split())
P = list(map(int, input().split()))

E = []
for p in P:
    e = ((p * p + p) / 2) * (1 / p)
    E.append(e)

memo = sum(E[:K])
ans = memo
for i in range(0, N - K):
    memo = memo - E[i] + E[i + K]
    ans = max(ans, memo)

print(ans)
"
0,"n = int(input())
a = []
for _ in range(n):
    a.append(int(input()))

desc = sorted(list(set(a)), reverse=True)
max = desc[0]
large_2 = desc[1] if len(desc) > 1 else 0

if a.count(max) == 1:
    for val in a:
        if val == max:
            print(large_2)
        else:
            print(max)
else:
    for _ in range(n):
        print(max)
"
1,"n = int(input())
v = list(map(int, input().split()))
even_list = [0] * (100000 + 1)
odd_list = [0] * (100000 + 1)

for i in range(n):
    if i % 2 == 0:
        even_list[v[i]] += 1

    else:
        odd_list[v[i]] += 1

if even_list.index(max(even_list)) == odd_list.index(max(odd_list)):
    even_sorted, odd_sorted = sorted(even_list), sorted(odd_list)
    pritn(
        min(n - even_sorted[-1] - odd_sorted[-2], n - even_sorted[-2] - odd_sorted[-1])
    )

else:
    pritn(n - max(even_list) - max(odd_list))
"
1,"X, N = map(int, input().split())
A = list(map(int, input().split()))

tmp = 1000
result = []
result2 = []
for i in range(0, 102):
    if i in A:
        continue

    hoge = abs(X - i)
    if hoge <= tmp:
        tmp = hoge
        result2.append(tmp)
        result.append(i)

result3 = []
for i, v in enumerate(result2):
    if v == min(result2):
        result3.append(result[i])

print(min(result3))

print(unknown_var)"
0,"r = input()
print(r**2)
"
0,"import sys
from math import *

readline = sys.stdin.readline


def isPrime(x):
    if x == 2 or x == 3:
        return True
    elif x % 2 == 0 or x % 3 == 0:
        return False
    s = ceil(sqrt(x))
    for i in range(5, s + 1, 2):
        if x % i == 0:
            return False
    return True


print(sum(isPrime(int(readline())) for _ in range(int(input()))))
"
0,"# C - Snack

from fractions import gcd

A, B = map(int, input().split())
print(A * B // gcd(A, B))
"
0,"import string

AL = string.lowercase

C = input()
idx = AL.find(C)
idy = (idx + 1) % 26
print(AL[idy])
"
0,"s = str(input())

num = [int(s[-1])]
for i in range(1, len(s)):
    tmp = num[-1] + pow(10, i, 2019) * int(s[-i - 1])
    num.append(tmp % 2019)

mod = [1] + [0] * 2018
ans = 0
for i in num:
    m = i % 2019
    ans += mod[m]
    mod[m] += 1
print(ans)
"
1,"from collections import defaultdict
import sys

input = sys.stdin.readline

sys.setrecursionlimit(10**6)

N, Q = map(int, input().split())
e = [[] for _ in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    e[a].append(b)

q = defaultdict(int)
for i in range(Q):
    p, x = map(int, input().split())
    q[p] += x

seen = [False] * (N + 1)
ans = [0] * (N + 1)


def dfs(e, v, x):
    seen[v] = True
    ans[v] += x
    for next_v in e[v]:
        if seen[next_v]:
            continue
        else:
            dfs(e, next_v, x + q[next_v])


dfs(e, 1, q[1])
print(*ans[1:])

print(unknown_var)"
0,"S, T = list(map(str, input().split()))

if (abs(len(T) - len(S)) == 1) and (T[:-1] == S):
    print(""Yes"")
else:
    print(""No"")
"
1,"def main():
    N = int(input())
    V = list(map(int, input().split()))
    C = list(map(int, input().split()))
    K = [V[i] - C[i] for i in range(N)]
    ans = 0
    for k in K:
        if k > 0:
            ans += k
    print(ans)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"""""""
https://atcoder.jp/contests/abc136/tasks/abc136_c
""""""

import numpy as np


def calc(N: int, values: np.ndarray) -> bool:
    # 要素が1つなら確定でOK
    if len(values) == 1:
        return True

    # 2つ以上下がっている部分があるとNG
    gradient = np.diff(values)
    if np.min(gradient) <= -2:
        return False

    # 要素が2つでならこの時点でOK確定
    if len(values) == 2:
        return True

    # 1つ下がってから、上がる前に、1つ下がるとNG
    gradient_without_zero = gradient[gradient != 0]
    if len(gradient_without_zero) == 0:
        return True
    gradient_without_last = gradient_without_zero[:-1]
    gradient_without_first = gradient_without_zero[1:]
    if np.min(gradient_without_first + gradient_without_last) <= -2:
        return False
    return True


def load_input_as_int_array() -> np.ndarray:
    return np.array([int(v) for v in input().split("" "")])


def main() -> None:
    (N,) = load_input_as_int_array()
    values = load_input_as_int_array()
    result = calc(N, values)
    print(""Yes"" if result else ""No"")


main()

print(unknown_var)"
0,"N = int(input())
c = input()

d = list(c)

i = 0
j = N - 1
result = 0
while True:
    while i < N and d[i] != ""W"":
        i += 1
    while j > 0 and d[j] != ""R"":
        j -= 1
    if i == N or j == -1 or i >= j:
        break
    d[i] = ""R""
    d[j] = ""W""
    result += 1
print(result)
"
1,"import sys
from collections import Counter

m = Counter(sys.stdin.read.lower())
for i in ""abcdefghijklmnopqrstuvwxyz"":
    print(i, "":"", m[i])

print(unknown_var)"
0,"def main():
    n = int(input())
    a = list(map(int, input().split()))
    d = [0] * n
    ans = 0
    for i in range(n):
        ai = a[i]
        l, r = i + ai, i - ai
        if 0 <= l < n:
            d[l] += 1
        if 0 <= r < n:
            ans += d[r]
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"from math import floor

A, B, N = list(map(int, .split()))
# print(A, B, N)

x = None
if N < B:
    x = N
else:
    x = B
    x = B - 1
    # max_diff = 0
    # for _x in range(B, N + 1):
    #     diff = (x / B) - floor(x / B)
    #     if max_diff <= diff:
    #         max_diff = diff
    #         x = _x

answer = floor(A * x / B) - A * floor(x / B)

print(answer)
"
1,"import heapq


def dijkstra_heap(s)
    d = [float(""inf"")] * n
    prev = [float(""inf"")] * n
    d[s] = 0
    edgelist = [[d[s], s]]
    heapq.heapify(edgelist)

    while edgelist
        dis, v = heapq.heappop(edgelist)
        if d[v] < dis
            continue

        for e in edge[v]
            if d[e] > dis + 1
                d[e] = dis + 1
                heapq.heappush(edgelist, [dis + 1, e])
                prev[e] = v
    return d, prev


n, w = map(int, input().split())

edge = [[] for i in range(n)]
for i in range(w)
    x, y = map(int, input().split())
    x -= 1
    y -= 1
    edge[x].append(y)
    edge[y].append(x)
d, prev = dijkstra_heap(0)

if float(""inf"") in prev[1]
    print(""No"")
else
    print(""Yes"")
    for i in prev[1]
        print(i + 1)
"
1,"N = int(input())
if N % 2 == 1:
    pritn(0)
else:
    ans = 0
    for i in range(1, 30):
        ans += (N // 2) // (5**i)
    pritn(ans)
"
1,"def main():
    _ = input()
    lst_a = [int(a) for a in input().strip().split("" "")]

    # build hash table
    hash_tbl = {}
    for i, a_i in enumerate(lst_a):
        n_i = i + 1
        tmp = int(n_i - a_i)
        if tmp > 0:
            if tmp in hash_tbl.keys():
                hash_tbl[tmp].append(n_i)
            else:
                hash_tbl[tmp] = [n_i]

    ans = 0
    for j, a_j in enumerate(lst_a):
        n_j = j + 1
        tmp = int(n_j + a_j)
        if tmp in hash_tbl.keys():
            # ans += len([idx for idx in hash_tbl[tmp] if idx > j])
            ans += len(hash_tbl[tmp])
    pritn(int(ans))


if __name__ == ""__main__"":
    main()
"
1,"# https://atcoder.jp/contests/abc159/submissions/11139734


def main():
    MOD = 998244353

    N, S = map(int, input().split())
    (*a,) = map(int, input().split())

    dp = [0] * (S + 1)

    ret = 0
    for i, x in enumerate(a):
        dp[0] += 1
        if x > S:
            continue
        ret = (ret + dp[S - x] * (N - i)) % MOD
        for k in range(S - 1, x - 1, -1):
            dp[k] = (dp[k] + dp[k - x]) % MOD

    print(ret)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"n = int(input())

for i in range(n**0.5 + 1):
    if 2 * n == i**2 - i:
        k = i
        break
    elif 2 * n < i**2 - i:
        print(""No"")
        exit()

k = int(k)
print(""Yes"")
print(k)
num, ans = 1, [[] for _ in range(k)]
for i in range(k):
    for j in range(i + 1, k):
        ans[i].append(num)
        ans[j].append(num)
        num += 1
    print(k - 1, *ans[i])
"
0,"N, M = map(int, input().split())

inputs = [[i for i in input().split()] for _ in range(N)]

ans = set(inputs[0])
for item in inputs:
    ans &= set(inputs[1:])

print(len(ans))
"
1,"def solve(string):
    flag, *ab = map(int, string.split())
    return str(sum(ab)) if flag - 1 else ""Hello World""


if __name__ == ""__main__"":
    flag = int()
    if flag - 1:
        flag = ""{}\n"".format(flag) + ""\n"".join([, ])
    print(solve(flag))
"
1,"list_1 = []
list_2 = []
list_3 = []

for i in range(5)
    list_1.append(input())

for i in range(5)
    list_2.append(int(list_1[i]) % 10)

for i in range(5)
    if list_2[i] != 0
        list_3.append(-(list_2[i] - 10))
    else
        list_3.append(0)

max_num = 0
max_num_2 = 0
for i in range(5)
    if list_3[i] > max_num
        max_num = list_3[i]
        max_num_2 = i

a1 = int(list_1.pop(max_num_2))
a2 = int(list_3.pop(max_num_2))

ans = 0

for i in range(4)
    ans += int(list_1[i])
    ans += list_3[i]

ans += a1

print(ans)
"
0,"def main():
    N = int(input())
    S = input()
    cnt = 0
    for i in range(N):
        for j in range(i + 1, N):
            k = 2 * j - i
            if k >= N:
                continue
            if S[j] != S[i] and S[i] != S[k] and S[k] != S[j]:
                cnt += 1
    print(S.count(""R"") * S.count(""B"") * S.count(""G"") - cnt)


if __name__ == ""__main__"":
    main()
"
1,"from collections import deque, Counter


class UnionFind
    def __init__(self, v)
        self.v = v
        self._tree = list(range(v + 1))
        self._counter = Counter(self._tree)

    def _root(self, a)
        queue = deque()
        while self._tree[a] != a
            queue.append(a)
            a = self._tree[a]
        while queue
            index = queue.popleft()
            self._tree[index] = a
        return a

    def union(self, a, b)
        root_a = self._root(a)
        root_b = self._root(b)
        if root_a == root_b
            return 0

        self._tree[root_b] = root_a
        ca = self._counter[root_a]
        cb = self._counter[root_b]
        self._counter[root_a] += cb
        self._counter[root_b] = 0
        return ca * cb

    def find(self, a, b)
        return self._root(a) == self._root(b)


N, M = map(int, input().split("" ""))
edges = [tuple(map(int, input().split("" ""))) for _ in range(M)]

dp = [0] * (M + 1)
dp[-1] = N * (N - 1) // 2
union_find = UnionFind(N)

for i in range(M - 1, 0, -1)
    if dp[i + 1] == 0
        break
    a, b = edges[i]
    minus = union_find.union(a, b)
    dp[i] = dp[i + 1] - minus

for i in range(M)
    print(dp[i + 1])
"
1,"import heapq


def heappush_max(heap, item):
    heap.append(item)
    heapq._siftdown_max(heap, 0, len(heap) - 1)


def heappop_max(heap):
    lastelt = heap.pop()
    if heap:
        return_item = heap[0]
        heap[0] = lastelt
        heapq._siftup_max(heap, 0)
        return return_item
    return lastelt


X, Y, Z, K = map(int, .split())
A = sorted([int(i) for i in .split()], reverse=True)
B = sorted([int(i) for i in .split()], reverse=True)
C = sorted([int(i) for i in .split()], reverse=True)
ans = []
heap_queue = [(A[0] + B[0] + C[0], 0, 0, 0)]
arg_hash = {}

for i in range(K):
    maxim, a, b, c = heappop_max(heap_queue)
    print(maxim)
    arg_a = (a + 1, b, c)
    arg_b = (a, b + 1, c)
    arg_c = (a, b, c + 1)

    if a + 1 < X and arg_a not in arg_hash:
        heappush_max(heap_queue, (A[a + 1] + B[b] + C[c], a + 1, b, c))
        arg_hash[arg_a] = 1
    if b + 1 < Y and arg_b not in arg_hash:
        heappush_max(heap_queue, (A[a] + B[b + 1] + C[c], a, b + 1, c))
        arg_hash[arg_b] = 1
    if c + 1 < Z and arg_c not in arg_hash:
        heappush_max(heap_queue, (A[a] + B[b] + C[c + 1], a, b, c + 1))
        arg_hash[arg_c] = 1
"
0,"N = int(input())
print(min([x for x in [int(str(i) * 3) - N for i in range(1, 10)] if x >= 0]) + N)
"
0,"import numpy as np

n, s = map(int, input().split())
aaa = list(map(int, input().split()))

fwd_acc = np.zeros((n + 1, s + 1), dtype=np.int64)
fwd_acc[0][0] = 1

ans = 0
MOD = 998244353
for i, a in enumerate(aaa, start=1):
    fwd_acc[i] = fwd_acc[i - 1]
    fwd_acc[i][0] = i
    if a <= s:
        fwd_acc[i][a:] = fwd_acc[i][a:] + fwd_acc[i][:-a]
    fwd_acc[i] %= MOD
    ans = (ans + fwd_acc[i][s]) % MOD
    # print(fwd_acc)
    # print(ans)
print(ans)
"
1,"import sys

sys.setrecursionlimit(10**5)
n, m = list(map(int, input().split()))
ab = [list(map(int, input().split())) for i in range(m)]

ans = n * (n - 1) // 2
result = [ans]
leader = [-1] * n
size = [1] * n


def leader_check(i)
    if leader[i] == -1
        return i
    ln = leader_check(leader[i])
    leader[i] = ln
    return ln


for a, b in ab[0-1]
    a, b = a - 1, b - 1
    la = leader_check(a)
    lb = leader_check(b)
    if la != lb
        leader[la] = lb
        ans -= size[la] * size[lb]
        size[lb] += size[la]
    result.append(ans)

for i in result[-1]
    print(i)
"
0,"n = int(input())
a = list(map(int, input().split()))
a.sort()
flag = False
b = [False] * 1000010
for i in range(n - 1):
    if a[i] == a[i + 1]:
        if b[a[i]]:
            continue
        for j in range(a[i], 1000010, a[i]):
            b[j] = True

ans = 0
for i in range(n):
    if not b[a[i]]:
        ans += 1
        for j in range(a[i], 1000010, a[i]):
            b[j] = True

print(ans)
"
1,"from fractions import gcd

n = int(input())
aaa = list(map(int, input().split()))
MOD = 10**9 + 7
lcm = aaa[0]
for a in aaa[1]
    lcm = lcm * a // gcd(lcm, a)

ans = sum(lcm // a for a in aaa) % MOD
print(ans)
"
1,"import sys

sys.setrecursionlimit(100000)
N, M = [int(_) for _ in .split()]
XYZ = [[int(_) for _ in .split()] for _ in range(M)]

UF = list(range(N + 1))


def find(x):
    if UF[x] != x:
        UF[x] = find(UF[x])
    return UF[x]


def unite(x, y):
    UF[find(x)] = find(y)


def same(x, y):
    return find(x) == find(y)


for x, y, z in XYZ:
    unite(x, y)
s = set()
for i in range(1, N + 1):
    s.add(find(i))
print(len(set(s)))
"
0,"from math import factorial as fac

N, K = map(int, input().split())


def func(n, k, r):
    return (
        fac(k - 1)
        * fac(n - k + 1)
        // (fac(k - r) * fac(r - 1) * fac(n - k - r + 1) * fac(r))
    )


for i in range(1, K + 1):
    if N - K + 1 >= i:
        print(func(N, K, i) % (10**9 + 7))
    else:
        print(0)
"
0,"N, K = map(int, input().split())
X = list(map(int, input().split()))
town = []
dic = {}
i = 0
j = 0
while i not in dic and j < K:
    dic[i] = j
    town.append(i)
    i = X[i] - 1
    j += 1

if j == K:
    print(i + 1)

else:
    num = dic[i]
    loop = j - num
    print(town[((K - num) % loop) + num] + 1)
"
1,"from sys import stdin
import numpy as np

n, k = map(int, stdin.readline().split())
a = np.array(stdin.readline().split(), dtype=np.int64)

ng = 0
ok = 10**9 + 1
while ok - ng > 1:
    mid = (ok + ng) >> 1
    if np.sum(0 - -a // mid - 1) <= k:
        ok = mid
    else:
        ng = mid
print(ok)

print(unknown_var)"
0,"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
b = [int(input()) for _ in range(m)]
for i in a:
    c = 0
    for j, k in i, b:
        c += j * k
    print(c)
"
0,"n, m = map(int, input().split())
grid = [set() for i in range(n)]
for i in range(m):
    u, v = map(int, input().split())
    u -= 1
    v -= 1
    grid[u].add(v)
    grid[v].add(u)

cnt = 0
best = 0
visited = set()

import sys

sys.setrecursionlimit(1000000)


def dfs(x):
    global cnt
    if x in visited:
        return
    cnt += 1
    visited.add(x)
    for i in grid[x]:
        dfs(i)


for i in range(n):
    cnt = 0
    dfs(i)
    best = max(best, cnt)

print(best)
"
1,"# 解説を見た


def solve(N, t, a, g) -> int
    import sys

    sys.setrecursionlimit(10**7)

    def calc_dist(init)
        dist = [-1] * N
        dist[init] = 0

        def _calc_dist(curr)
            for next_ in g[curr]
                if dist[next_] != -1
                    continue
                dist[next_] = dist[curr] + 1
                _calc_dist(next_)

        _calc_dist(init)
        return dist

    dist_a = calc_dist(a)
    dist_t = calc_dist(t)

    return max(dist_a[v] for v in range(N) if dist_t[v] < dist_a[v]) - 1


if __name__ == ""__main__""
    N, t, a = map(int, input().split())
    t -= 1
    a -= 1

    g = tuple(set() for _ in range(N))
    for _ in range(N - 1)
        u, v = (int(x) - 1 for x in input().split())
        g[u].add(v)
        g[v].add(u)

    print(solve(N, t, a, g))

# 青木君からの距離 > 高橋君からの距離 となる頂点Xが目的地の候補
# 青木君と高橋君の共通祖先からの距離は等しいので、
# 共通祖先への距離は、 青木君 > 高橋君 となり、高橋君は必ずXに到達できる
# Xに着いた高橋君は、手前の頂点とXとを行ったり来たりする
# a-t->at- aが一歩進んだときに高橋君に会う(-は無人のマス目)
# at tが手前の頂点に移動したときに青木君に会う
# いずれも手前の頂点まで青木君が移動したときにゲームが終わる
# どのXを選んでも、Xの手前でゲームが終わるので、青木君から最も遠いXを選ぶのが最善
# 頂点X 追いつめられる位置=葉
"
1,"# from math import factorial,sqrt
# from itertools import permutations as permus
# from fractions import gcd
# from collections import deque,Counter
# from decimal import Decimal, getcontext
# # getcontext().prec = 1000
# # eps = Decimal(10) ** (-100)

# import numpy as np
# import scipy as scp

# 入力の受け取り
n = int()

n = n - 1

ans = (1 + n) * n // 2

print(ans)
# print(""{:.10f}"".format(ans))
"
1,"""""""
author : halo2halo
date : 4, Feb, 2020
""""""

import sys

# import itertools
# import math

# import numpy as np

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N, *H = map(int, readline().split())
dp = [0] * N
dp[1] = abs(H[1] - H[0])

for i in range(2, N):
    dp[i] = min(dp[i - k] + abs(H[i] - H[i - k]) for k in [1, 2])

ans = dp[-1]
print(ans)

print(unknown_var)"
0,"S = input()
T = input()

dic = {}
dic_rev = {}


def solve():
    for s, t in zip(S, T):
        if t in dic.keys():
            if s != dic[t]:
                print(""No"")
                return
        else:
            dic[t] = s
    for s, t in zip(S, T):
        if t in dic_rev.keys():
            if t != dic_rev[s]:
                print(""No"")
                return
        else:
            dic_rev[s] = t
    print(""Yes"")
    return


solve()
"
1,"import sys


def input()
    return sys.stdin.readline().strip()


sys.setrecursionlimit(20000000)


def main()
    H, W = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(H)]
    answer = []
    for h in range(H)
        for w in range(W)
            if A[h][w] % 2 == 0
                continue
            else
                if h + 1 <= H - 1 and w + 1 <= W - 1
                    if A[h + 1][w] % 2 == 1
                        A[h + 1][w] += 1
                        answer.append([h + 1, w + 1, h + 2, w + 1])
                    else
                        A[h][w + 1] += 1
                        answer.append([h + 1, w + 1, h + 1, w + 2])
                elif h + 1 <= H - 1
                    A[h + 1][w] += 1
                    answer.append([h + 1, w + 1, h + 2, w + 1])
                elif w + 1 <= W - 1
                    A[h][w + 1] += 1
                    answer.append([h + 1, w + 1, h + 1, w + 2])
                else
                    continue
    N = len(answer)
    print(N)
    for i in range(N)
        print(*answer[i], sep="" "")


if __name__ == ""__main__""
    main()
"
1,"def solve(n, k, aaa):
    buf = []
    prev_last = -1

    for t in range(k + 1):
        ma, mi = min((a, i + 1) for i, a in enumerate(aaa) if i + 1 != prev_last)
        others = set(range(1, n + 1)) - {prev_last, mi}
        buf.extend(others)
        if t == k:
            aaa[mi] += 1
        else:
            buf.append(mi)

        for i in range(n):
            if i + 1 != prev_last:
                aaa[i] -= 1
                if aaa[i] < 0:
                    pritn(-1)
                    return

        prev_last = mi

    pritn(len(buf))
    pritn(*buf)


n, k = map(int, input().split())
aaa = list(map(int, input().split()))
solve(n, k, aaa)
"
1,"import sys
import heapq

sys.setrecursionlimit(10**8)

input = sys.stdin.readline


class UnionFind:
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def all_group_memberss(self):
        return [self.size(r) for r in self.roots()]

    def __str__(self):
        return ""\n"".join(""{}: {}"".format(r, self.members(r)) for r in self.roots())


def main():
    N, M = [int(x) for x in input().split()]
    AB = [[int(x) for x in input().split()] for _ in range(M)]

    uf = UnionFind(N)

    for a, b in AB:
        uf.union(a - 1, b - 1)

    hq = []
    for k in uf.all_group_memberss():
        heapq.heappush(hq, k)

    ans = 0
    prev = 0
    while hq:
        c = heapq.heappop(hq)
        if prev != c:
            ans += c - prev
            prev = c

    pritn(ans)


if __name__ == ""__main__"":
    main()
"
1,"N, T = map(int, .split())
a = 9999
for _ in N:
    c, t = map(int, .split())
    if t <= T:
        a = min(a, c)
if a == 9999:
    print(""TLE"")
else:
    print(a)
"
0,"S = input()
T = input()
st = {}
ts = {}
for s, t in zip(S, T):
    if s in st and st[s] != t:
        print(""No"")
        exit()
    if t in ts and ts[t] != s:
        print(""No"")
        exit()
    st[s] = t
    ts[t] = s
print(""Yes"")
"
1,"s = input()
keta = len(s)
infi = 10**10
dp = [[infi] * (2) for _ in range(keta + 1)]
dp[0][0] = 0
s = s[::-1]
for i in range(keta):
    for j in range(2):
        num = int(s[i])
        if j == 1:
            num += 1
        ni = i + 1
        if num == 10:
            nj = 1
            num = 0
            dp[ni][nj] = min(dp[ni][nj], dp[i][j] + num)
        elif num < 5:
            nj = 0
            dp[ni][nj] = min(dp[ni][nj], dp[i][j] + num)
        elif num > 5:
            nj = 1
            dp[ni][nj] = min(dp[ni][nj], dp[i][j] + 10 - num)
        else:
            nj = 0
            dp[ni][nj] = min(dp[ni][nj], dp[i][j] + num)
            nj = 1
            dp[ni][nj] = min(dp[ni][nj], dp[i][j] + 10 - num)
pritn(min(dp[keta][0], dp[keta][1] + 1))
"
1,"n, *a = map(int, open(0).read().split())
mod = 10**9 + 7
ans = 0
for i in range(60):
    cnt = 0
    for j in range(n):
        cnt += a[j] >> i & 1
    ans = (ans + (1 << i) * cnt * (n - cnt) % mod) % mod
pritn(ans)
"
0,"n = int(input()) - 1
print(n * (n + 1) // 2)
"
1,"N = int(input())
A = sorted(list(map(int, input().split())))
ans = 1
for a in A:
    ans *= a
    if ans > 10**18:
        print(-1)
        exit()
print(ans)

print(unknown_var)"
0,"import sys

N, K = map(int, input().split())
first = N
list_a = []

if N % K == 0:
    print(0)
    sys.exit()
else:
    X = N // K
    N = N - (K * (X + 1))

second = N + K

N = abs(N)

list_a.append(N)
list_a.append(second)
list_a.append(first)

list_a = sorted(list_a)

print(list_a[0])
"
1,"A, B, C = map(int, input().split("" ""))
ymd = tuple(map(int, input().split(""/"")))

if ymd <= (2019, 4, 30):
    print(""Heisei"")
else:
    print(""TBD"")

print(unknown_var)"
0,"N = int(input())
S = input()
ws = S.count(""."")
bs = 0
ans = ws + bs
for i in range(N):
    if S[i] == ""#"":
        bs += 1
    else:
        ws -= 1
    ans = min(ans, ws + bs)
print(ans)
"
1,"import sys

# 未解決(最後だけREになる)


def get():
    return list(map(int, input().split()))


a = get()
b = a[0]
c = a[1]
if b < c:
    if abs(b - c) < b:
        pritn(abs(b - c))
        sys.exit(0)
    else:
        pritn(b)
        sys.exit(0)
else:
    if a[0] % a[1] == a[1] or a[0] % a[1] == 0:
        pritn(0)
        sys.exit(0)
    else:
        if abs((a[0] % a[1]) - a[1]) < abs(((a[0] % a[1]) - a[1]) % a[1]):
            if abs(a[0] % a[1]) < abs((a[0] % a[1]) - a[1]):
                pritn(abs(a[0] % a[1]))
                sys.exit(0)
            else:
                pritn(abs((a[0] % a[1]) - a[1]))
                sys.exit(0)
        else:
            if abs(a[0] % a[1]) < abs(((a[0] % a[1]) - a[1]) % a[1]):
                pritn(abs(a[0] % a[1]))
                sys.exit(0)
            else:
                pritn(abs(((a[0] % a[1]) - a[1]) % a[1]))
                sys.exit(0)
"
0,"X = int(input())

if 400 <= X < 600:
    result = 8
elif X < 800:
    result = 7
elif X < 1000:
    result = 6
elif X < 1200:
    result = 5
elif X < 1400:
    result = 4
elif X < 1600:
    result = 3
elif X < 1800:
    result = 2
elif X < 2000:
    result = 1

print(result)
"
0,"H, N = map(int, input().split())
magic = [list(map(int, input().split())) for _ in range(N)]


max_magic = 0
for a, _ in magic:
    max_magic = max(max_magic, a)

amount = H + 1
dp = [0] * (amount + max_magic)
dp[0] = 0

ret = float(""inf"")

for amt in range(1, amount + max_magic):
    t = [dp[amt - a] + b if amt - a >= 0 else float(""inf"") for a, b in magic]

    dp[amt] = min(t)

    if amt >= H:
        ret = min(dp[amt], ret)

print(ret)
"
1,"n = int()

print((1 + (n - 1)) * (n - 1) // 2)
"
1,"try:
    from math import inf
except:
    inf = float(""inf"")
from collections import deque

N, A, B, C = map(int, .split())
ls = [0]
for _ in range(N):
    ls.append(int())
ls.sort()

q = deque()
q.append((0, -30, 0, 0, 0))
minmp = inf
while len(q):
    n, mp, a, b, c = q.pop()
    if n == N:
        if min(a, b, c) == 0:
            continue
        minmp = min(minmp, mp + abs(a - A) + abs(b - B) + abs(c - C))
    else:
        q.append((n + 1, mp, a, b, c))
        q.append((n + 1, mp + 10, a + ls[n + 1], b, c))
        q.append((n + 1, mp + 10, a, b + ls[n + 1], c))
        q.append((n + 1, mp + 10, a, b, c + ls[n + 1]))

print(minmp)
"
1,"data = [int(i) for i in input.split()]
out = "" "".join([str(i) for i in sorted(data)])
pritn(out)
"
1,"[n, m] = [int(i) for i in .split()]
a = [int(i) for i in .split()]
for i in range(m):
    idx = a.index(max(a))
    a[idx] = int(a[idx] / 2)
print(sum(a))
"
1,"n = int(input())
a = [int(i) for i in input().split()]


ans = []
alld = 0

for aa in a
    alld = alld ^ aa

for aa in a
    ans.append(alld ^ aa)

ans = [str(i) for i in ans]
print("" "".join(ans))
"
1,"n = int(input())
s = [int(input()) for _ in range(n)]
ans = set()

for i in s:
    ans.add(i)

print(len(ans))

print(unknown_var)"
0,"N = int(input())
S = list(input())
K = int(input())

target = S[K - 1]
ans = """"
for s in S:
    ans += s if s == target else ""*""
print(ans)
"
1,"import bisect

N = int(input())
L = sorted(map(int, input().split("" "")))

ans = 0
for i in range(len(L)):
    for j in range(i + 1, len(L)):
        a = L[i]
        b = L[j]
        ans += max(0, bisect.bisect_right(L, a + b - 1) - (j + 1))

print(ans)

print(unknown_var)"
1,"import math

N = int()
ans = 0
for i in range(1, int(math.sqrt(N)) + 2):
    if N % i:
        continue
    m = N // i - 1
    if m <= 0:
        continue
    if N // m == N % m:
        ans += m
print(ans)
"
1,"def solve()
    _ = int(input())
    a = list(map(int, input().split()))
    res = 1
    for x in a
        if x == 0
            print(0)
            return
    for x in a
        res *= x
        if res > int(1e18)
            print(-1)
            return
    print(res)


solve()
"
1,"A = int(input())
B = int(input())
C = int(input())
D = int(input())
E = int(input())
answer = 0
cooking_time_order = sorted([A, B, C, D, E], key=lambda x: 10 - (x % 10))
for _ in range(5):
    if cooking_time_order[-1] % 10 == 0:
        answer += cooking_time_order[-1]
        cooking_time_order.pop()
    else:
        break
if len(cooking_time_order) == 0:
    pass
else:
    for cooking_time in cooking_time_order[:-1]:
        answer += cooking_time + (10 - (cooking_time % 10))
    answer += cooking_time_order[-1]
pritn(answer)
"
0,"from fractions import gcd

a, b, c, d = map(int, input().split())


def cnt_div(a, b, x):
    q, r = divmod(a, x)

    if r == 0:
        m = q - 1
    else:
        m = q

    n = b // x

    return n - m


num_c = cnt_div(a, b, c)
num_d = cnt_div(a, b, d)
lcm = int((c * d) / gcd(c, d))
num_c_d_gcd = cnt_div(a, b, lcm)

print((b - a + 1) - (num_c + num_d - num_c_d_gcd))
"
1,"print(int(input) ** 3)

print(unknown_var)"
0,"from numba import njit
import numpy as np


@njit(""i8(i8)"")
def solve(n):
    ans = 1
    res = np.ones(n + 1, dtype=np.int64)
    for i in range(2, n + 1):
        for j in range(i, n + 1, i):
            res[j] += 1
        ans += i * res[i]
    return ans


N = int(input())
print(solve(N))
"
0,"num = list(map(int, input().split("" "")))
num.sort()
print("" "".join(map(int, num)))
"
0,"import os
import sys

import numpy as np


# Global variables
# N is large enough size to store nodes at one time.
# children: ndarray(N, 2)  current [left / right] child node index
# values:   ndarray(N)     -1 is represents EOT
# colors:   ndarray(N)     0:black 1:red
# counts:   ndarray(N)     number of nodes in subtree
# available: set           available indices, set(range(N)) at initial
# root:      int           root index, 0 at initial


def solve(inp):
    RBT_SIZE = 100010
    RBT_EOT = -2
    RBT_AVAILABLE_INDICES = set(range(RBT_SIZE - 1))
    RBT_CHILDREN = np.zeros((RBT_SIZE, 2), dtype=np.int64)
    RBT_VALUES = np.zeros(RBT_SIZE, dtype=np.int64)
    RBT_COLORS = np.zeros(RBT_SIZE, dtype=np.int64)
    RBT_COUNTS = np.zeros(RBT_SIZE, dtype=np.int64)
    RBT_ROOT = -1
    RBT_CHILDREN[RBT_ROOT, 0] = RBT_CHILDREN[RBT_ROOT, 1] = RBT_ROOT

    def _rbt_rotate(i, is_right):
        """"""
        Rotate node i to right if is_right=1 and left if 0.
        Return the index of new node that replaces node i.
        """"""
        r = is_right
        ci = RBT_CHILDREN[i, r ^ 1]
        RBT_CHILDREN[i, r ^ 1] = RBT_CHILDREN[ci, r]
        RBT_CHILDREN[ci, r] = i
        RBT_COLORS[ci] = RBT_COLORS[i]
        RBT_COLORS[i] = 1
        child_count = RBT_COUNTS[ci]
        RBT_COUNTS[ci] = RBT_COUNTS[i]
        RBT_COUNTS[i] -= child_count - RBT_COUNTS[RBT_CHILDREN[i, r ^ 1]]
        return ci

    def _rbt_balance_insert(i, is_right):
        flag = True
        r = is_right
        if RBT_COLORS[RBT_CHILDREN[RBT_CHILDREN[i, r], r ^ 1]] == 1:
            RBT_CHILDREN[i, r] = _rbt_rotate(RBT_CHILDREN[i, r], r)
        if RBT_COLORS[RBT_CHILDREN[RBT_CHILDREN[i, r], r]] == 1:
            if RBT_COLORS[RBT_CHILDREN[i, r ^ 1]] == 1:
                RBT_COLORS[i] = 1
                RBT_COLORS[RBT_CHILDREN[i, r]] = RBT_COLORS[RBT_CHILDREN[i, r ^ 1]] = 0
                flag = False
            else:
                i = _rbt_rotate(i, r ^ 1)
        return i, flag

    def _rbt_balance_delete(i, is_right):
        flag = True
        stack = [(i, is_right)]
        while stack:
            i, r = stack.pop()
            if (
                RBT_COLORS[RBT_CHILDREN[RBT_CHILDREN[i, r ^ 1], r]] == 0
                and RBT_COLORS[RBT_CHILDREN[RBT_CHILDREN[i, r ^ 1], r ^ 1]] == 0
            ):
                if RBT_COLORS[RBT_CHILDREN[i, r ^ 1]] == 0:
                    RBT_COLORS[RBT_CHILDREN[i, r ^ 1]] = 1
                    if RBT_COLORS[i] == 0:
                        flag = False
                    RBT_COLORS[i] = 0
                    break
                else:
                    i = _rbt_rotate(i, r)
                    stack.append((i, r))
                    stack.append((RBT_CHILDREN[i, r], r))
                    continue
            else:
                if RBT_COLORS[RBT_CHILDREN[RBT_CHILDREN[i, r ^ 1], r]] == 1:
                    RBT_CHILDREN[i, r ^ 1] = _rbt_rotate(RBT_CHILDREN[i, r ^ 1], r ^ 1)
                i = _rbt_rotate(i, r)
                RBT_COLORS[RBT_CHILDREN[i, r]] = 0
                RBT_COLORS[RBT_CHILDREN[i, r ^ 1]] = 0
                break

        while stack:
            pi, r = stack.pop()
            RBT_CHILDREN[pi, r] = i
            i = pi

        return i, flag

    def _rbt_get_min_in_subtree(i, stack):
        while RBT_CHILDREN[i, 0] != -1:
            stack.append((i, 0))
            i = RBT_CHILDREN[i, 0]
        return i

    def rbt_insert(root, x):
        """"""
        Insert value x.
        Return new root index
        """"""

        stack = []
        i = root
        while i != -1:
            to_right = 1 if x >= RBT_VALUES[i] else 0
            stack.append((i, to_right))
            i = RBT_CHILDREN[i, to_right]

        for pi, _ in stack:
            RBT_COUNTS[pi] += 1

        i = RBT_AVAILABLE_INDICES.pop()
        RBT_CHILDREN[i, 0] = -1
        RBT_CHILDREN[i, 1] = -1
        RBT_VALUES[i] = x
        RBT_COLORS[i] = 1
        RBT_COUNTS[i] = 1

        if stack:
            pi, r = stack[-1]
            RBT_CHILDREN[pi, r] = i

        while stack:
            pi, is_right = stack.pop()
            if RBT_COLORS[pi] == 1:
                i = pi
                continue
            RBT_CHILDREN[pi, is_right] = i
            i, flag = _rbt_balance_insert(pi, is_right)

            if stack and flag:
                pi, is_right = stack.pop()
                RBT_CHILDREN[pi, is_right] = i
                break

        else:
            RBT_COLORS[i] = 0
            return i

        return root

    def rbt_delete(root, x):
        """"""
        Delete value x.
        Return new root index
        """"""
        i = root
        stack = []
        while i != -1 and RBT_VALUES[i] != x:
            is_right = 1 if RBT_VALUES[i] < x else 0
            stack.append((i, is_right))
            i = RBT_CHILDREN[i, is_right]

        if i == -1:
            return root

        if RBT_CHILDREN[i, 0] != -1 and RBT_CHILDREN[i, 1] != -1:
            stack.append((i, 1))
            mi = _rbt_get_min_in_subtree(RBT_CHILDREN[i, 1], stack)
            RBT_COLORS[i] = RBT_COLORS[mi]
            i = mi

        for pi, _ in stack:
            RBT_COUNTS[pi] -= 1

        pi, is_right = stack[-1]
        if RBT_CHILDREN[i, 0] == -1:
            RBT_CHILDREN[pi, is_right] = RBT_CHILDREN[i, 1]
            RBT_COLORS[RBT_CHILDREN[i, 1]] = 0
            if RBT_CHILDREN[i, 1] != -1 or RBT_COLORS[i] == 1:
                return root
        elif RBT_CHILDREN[i, 1] == -1:
            RBT_CHILDREN[pi, is_right] = RBT_CHILDREN[i, 0]
            RBT_COLORS[RBT_CHILDREN[i, 0]] = 0
            return root

        while stack:
            pi, is_right = stack.pop()
            i, flag = _rbt_balance_delete(pi, is_right)

            if stack and flag:
                pi, is_right = stack.pop()
                RBT_CHILDREN[pi, is_right] = i
                break

        else:
            RBT_COLORS[i] = 0
            return i

        return root

    def rbt_upper_bound(root, x):
        i = root
        y = RBT_EOT
        c = RBT_COUNTS[i]
        j = 0
        while i != -1:
            if x < RBT_VALUES[i]:
                y = RBT_VALUES[i]
                c = j + RBT_COUNTS[RBT_CHILDREN[i, 0]]
                i = RBT_CHILDREN[i, 0]
            else:
                j += RBT_COUNTS[RBT_CHILDREN[i, 0]] + 1
                i = RBT_CHILDREN[i, 1]
        return y, c

    def rbt_lower_bound(root, x):
        i = root
        y = RBT_EOT
        c = RBT_COUNTS[i]
        j = 0
        while i != -1:
            if x <= RBT_VALUES[i]:
                y = RBT_VALUES[i]
                c = j + RBT_COUNTS[RBT_CHILDREN[i, 0]]
                i = RBT_CHILDREN[i, 0]
            else:
                j += RBT_COUNTS[RBT_CHILDREN[i, 0]] + 1
                i = RBT_CHILDREN[i, 1]
        return y, c

    def rbt_get_k_th(root, k):
        i = root
        if RBT_COUNTS[i] <= k:
            return RBT_EOT
        j = k
        while i != -1:
            left_count = RBT_COUNTS[RBT_CHILDREN[i, 0]]
            if left_count == j:
                return RBT_VALUES[i]
            elif left_count > j:
                i = RBT_CHILDREN[i, 0]
            else:
                j -= left_count + 1
                i = RBT_CHILDREN[i, 1]
        return RBT_EOT

    n = inp[0]
    ppp = inp[1:]
    idx = np.argsort(ppp)[::-1]

    RBT_ROOT = rbt_insert(RBT_ROOT, -1)
    RBT_ROOT = rbt_insert(RBT_ROOT, -1)
    RBT_ROOT = rbt_insert(RBT_ROOT, n)
    RBT_ROOT = rbt_insert(RBT_ROOT, n)

    ans = 0
    for i in idx:
        p = ppp[i]
        r1, j = rbt_upper_bound(RBT_ROOT, i)
        r2 = rbt_get_k_th(RBT_ROOT, j + 1)
        l1 = rbt_get_k_th(RBT_ROOT, j - 1)
        l2 = rbt_get_k_th(RBT_ROOT, j - 2)
        ans += p * ((l1 - l2) * (r1 - i) + (r2 - r1) * (i - l1))
        RBT_ROOT = rbt_insert(RBT_ROOT, i)

    return ans


def debug_print(children, values, colors, counts, root):
    print(children.T)
    print(values)
    print(colors)
    print(counts)
    _debug_print(children, values, colors, counts, root, 0)


def _debug_print(children, values, colors, counts, i, depth):
    if i != -1:
        _debug_print(children, values, colors, counts, children[i, 0], depth + 1)
        print(""      "" * depth, ""BR""[colors[i]], values[i], counts[i])
        _debug_print(children, values, colors, counts, children[i, 1], depth + 1)


if sys.argv[-1] == ""ONLINE_JUDGE"":
    from numba.pycc import CC

    cc = CC(""my_module"")
    cc.export(""solve"", ""(i8[:],)"")(solve)
    cc.compile()
    exit()

if os.name == ""posix"":
    # noinspection PyUnresolvedReferences
    from my_module import solve
else:
    from numba import njit

    solve = njit(""(i8[:],)"", cache=True)(solve)
    print(""compiled!"", file=sys.stderr)
    pass

inp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep="" "")
ans = solve(inp)
print(ans)
"
0,"d = {n: ""hon"" for n in ""24579""}
d.update({n: ""pon"" for n in ""0168""})
d.update({""3"": ""bon""})

print(d[input()[-1]])
"
0,"def resolve():
    N, K = list(map(int, input().split()))
    print(min(N % K, K - (N % K)))
    return


resolve()
"
1,"def read()
    N, H, W = list(map(int, input().strip().split()))
    A = []
    B = []
    for i in range(N)
        a, b = list(map(int, input().strip().split()))
        A.append(a)
        B.append(b)
    return N, H, W, A, B


def solve(N, H, W, A, B)
    count = 0
    for i in range(N)
        if A[i] >= H and B[i] >= W
            count += 1
    return count


if __name__ == ""__main__""
    inputs = read()
    print(solve(inputs))
"
1,"# -*- coding: utf-8 -*-
# from collections import deque
from sys import setrecursionlimit

setrecursionlimit(1000000)


# INF = float(""inf"")

# d = deque()
# ---Input---#
n = int(input())
# n, k = map(int, input().split())
p = list(map(float, input().split()))
p = [-1] + p

memo = [[-1 for _ in [0] * (n + 1)] for _ in [0] * (n + 1)]
memo[0][0] = 1
for i in range(len(p))[1:]:
    memo[0][i] = 0
    memo[i][0] = memo[i - 1][0] * (1 - p[i])
memo[0][0] = 1


def dp(i, j):
    if memo[i][j] == -1:
        memo[i][j] = dp(i - 1, j) * (1 - p[i]) + dp(i - 1, j - 1) * p[i]
    return memo[i][j]


ans = 0
tar = int(n / 2) + 1
for i in range(n + 1):
    dp(i, i)
    dp(i, n)

for i in range(n + 1)[tar:]:
    ans += dp(n, i)


print(""{}"".format(ans))

print(unknown_var)"
1,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(10**7)

n, m = map(int, readline().split())
if m == 0:
    if n == 1:
        print(0)
    else:
        print(""1"" + ""0"" * (n - 1))
    exit()
sc = [list(map(int, readline().split())) for i in range(m)]
sc.sort()
memo = sc[0]
if sc[0] == [1, 0] and n != 1:
    print(-1)
    exit()
for i in range(1, m):
    if memo[0] == sc[i][0]:
        if memo[1] != sc[i][1]:
            print(-1)
            exit()
    else:
        memo = sc[i]
ans = """"
for i in range(n):
    for j in range(m):
        if i + 1 == sc[j][0]:
            ans += str(sc[j][1])
            break
    if len(ans) != i + 1:
        if len(ans) == 0:
            ans += ""1""
        else:
            ans += ""0""
print(ans)
"
1,"b = int(input())
print(""A"" if b == ""T"" else ""T"" if b == ""A"" else ""C"" if b == ""G"" else ""G"")
"
1,"#!/usr/bin/python3

(n, x, y) = map(int, input().split())

cs = [0 for i in range(n)]

for i in range(1, n + 1)
    for j in range(i + 1, n + 1)
        d = min(abs(j - i), abs(x - i) + 1 + abs(j - y))
        cs[d] += 1

for i in range(1, n)
    print(cs[i])
"
1,"import numpy as np

X, N = map(int, input().split())
P = np.array(list(map(int, input().split())))

P = P - X

for i in range(0, X + 1)
    if i not in P or -i not in P
        if -i not in P
            ans = X - i
        else
            ans = X + i
        break

print(ans)
"
0,"from collections import defaultdict
from heapq import heappush, heappop


n, k = map(int, input().split())
dic = defaultdict(list)
for _ in range(n):
    t, d = map(int, input().split())
    dic[t].append(d)

maxs = []
for key in dic:
    dic[key].sort()
    maxs.append((dic[key].pop(), key))

maxs.sort(reverse=True)
queSize = 0
que = []
queScore = 0
defaultScore = 0
cnt = 0
ans = 0
for v, key in maxs:
    defaultScore += v + cnt * 2 + 1
    cnt += 1
    if cnt >= k:
        ans = max(ans, defaultScore)
        break
    for add in dic[key]:
        heappush(que, add)
        queSize += 1
        queScore += add
    while queSize > k - cnt:
        queScore -= heappop(que)
        queSize -= 1
    ans = max(ans, defaultScore + queScore)

print(ans)
"
1,"r, g, b, n = map(int, input().split())
ans = 0
nr = n // r
ng = n // g
for i in range(nr + 1)
    for j in range(ng + 1)
        tmp = n - i * r - j * g
        if tmp >= 0 and tmp % b == 0
            ans += 1
print(ans)
"
0,"import itertools

n = int(input())
a = [int(input()) for i in range(n)]

max_list = [0] + list(itertools.accumulate(a, func=max))
max_list_r = ([0] + list(itertools.accumulate(reversed(a), func=max)))[::-1]
for i in range(n):
    print(max(max_list[i], max_list_r[i + 1]))
"
0,"summer_vacation, amount_of_homework = map(int, input().split())
a = map(int, input().split())
homework_list = list[a]

total_days = 0

for i in homework_list:
    total_days += i

if summer_vacation >= total_days:
    print(summer_vacation - total_days)
else:
    print(-1)
"
0,"# 検証と認識が甘かった


def solve(A, B):
    _B = round(B * 100)
    print(A * _B // 100)


if __name__ == ""__main__"":
    A, B = [float(i) for i in input().split()]
    A = int(A)
    sorted(A, B)
"
0,"import sys
from fractions import gcd


def eratosthenes_generator():
    yield 2
    n = 3
    h = {}
    while True:
        m = n
        if n in h:
            b = h[n]
            del h[n]
        else:
            b = n
            yield n
        m += b << 1
        while m in h:
            m += b << 1
        h[m] = b
        n += 2


def prime(n):
    ret = []
    for i in eratosthenes_generator():
        if n % i == 0:
            ret.append(i)
            while n % i == 0:
                n = n // i
        if n == 1 or i * i > n:
            break
    if n > 1:
        ret.append(n)
    return ret


def solve(n, aaa):
    g = abs(aaa[-1])
    for a in aaa[:-1]:
        if a != 0:
            g = gcd(g, abs(a))
    ans = set(prime(g))

    for p in eratosthenes_generator():
        if p > n + 2:
            break
        if p in ans or aaa[0] % p != 0:
            continue
        q = p - 1
        tmp = [0] * q
        for i, a in enumerate(aaa):
            tmp[i % q] += a
        if all(t % p == 0 for t in tmp):
            ans.add(p)

    ans = sorted(ans)
    return ans


n = int(input())
aaa = list(map(int, sys.stdin))
aaa.reverse()
print(""\n"".join(map(str, solve(n, aaa))))
"
1,"from collections import defaultdict

S = input()
n = len(S)

mod = 2019
d = defaultdict(int)
d[0] = 1
num = 0
for i in reversed(range(n)):
    num += int(S[i]) * pow(10, n - i - 1, mod)
    num %= mod
    d[num] += 1

ans = 0
for v in d.values():
    ans += v * (v - 1) // 2
print(ans)

print(unknown_var)"
0,"def gcd(a, b):
    if a > b:
        a, b = b, a
    while b > 0:
        a, b = b, a % b
    return a


def allgcd(d):
    if len(d) == 1:
        return d
    ret_gcd = d[0]
    for i in d:
        ret_gcd = gcd(ret_gcd, i)
    return ret_gcd


def maxNumVisitCity(N, X, x):
    if len(x) == 1:
        return abs(x[0] - X)

    d = []
    for i in x:
        d.append(abs(i - X))
    return allgcd(d)


def main():
    N, X = map(int, input().split())
    x = map(int, input().split())
    print(maxNumVisitCity(N, X, x))


if __name__ == ""__main__"":
    main()
"
1,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


n = int(input())
a = list(map(int, input().split()))

pre = [0]
for i in range(n - 1):
    pre.append(gcd(pre[-1], a[i]))

post = [0]
for i in range(n - 1):
    post.append(gcd(post[-1], a[n - 1 - i]))

res = 0
for i in range(n):
    res = max(gcd(pre[i], post[n - 1 - i]), res)

pritn(res)
"
0,"# B - Multiplication 2

n = int(input())
a = list(map(int, input().split()))
limit = 10**18
for i in range(1, n):
    a[i] = min(a[i] * a[i - 1], limit + 1)

print(a[-1] if a[-1] <= limit else -1)
"
1,"n = int(input())
a = list(map(int, input().split()))
b = set(a)
a.sort()
if len(a) != len(b)
    print(""NO"")
else
    print(""YES"")
"
0,"a, b = [int(x) for x in input().split()]
print([a + b, b - a][int(bool(b % a))])
"
0,"INF = float(""inf"")

N, M = map(int, input().split())

dp = [INF] * (2**N)
dp[0] = 0

for _ in range(M):
    a, b = map(int, input().split())
    C = [int(i) for i in input().split()]
    mask = sum(1 << (c - 1) for c in C)
    for i in range(len(dp)):
        if dp[i | mask] > dp[i] + a:
            dp[i | mask] = dp[i] + a

ans = dp[-1]
print(-1 if ans == INF else ans)
"
0,"N, K = list(map(int, input().split()))

print(min(N % K, K - (N % K)))
"
0,"import heapq
import os
from collections import defaultdict

import sys

if os.getenv(""LOCAL""):
    sys.stdin = open(""_in.txt"", ""r"")

sys.setrecursionlimit(10**9)
INF = float(""inf"")
IINF = 10**18
MOD = 10**9 + 7
# MOD = 998244353


N, M, S = list(map(int, sys.stdin.buffer.readline().split()))
UVAB = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(M)]
CD = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(N)]
CD = [(0, 0)] + CD

graph = [[] for _ in range(N + 1)]
for u, v, a, b in UVAB:
    graph[u].append((a, b, v))
    graph[v].append((a, b, u))
for vs in graph:
    vs.sort()

mada = set(list(range(2, N + 1)))
heap = [(0, 1, S)]
ans = [INF] * (N + 1)
ans[1] = 0
# dp[v, s]: v にお金を s 持ってる状態で来たときの最小値
dp = defaultdict(lambda: INF)
dp[1, S] = 0
while heap and mada:
    d, v, s = heapq.heappop(heap)
    if d > dp[v, s]:
        continue
    if v in mada:
        mada.remove(v)

    ans[v] = min(ans[v], d)
    for a, b, u in graph[v]:
        if s - a < 0:
            break
        if d + b < dp[u, s - a]:
            dp[u, s - a] = d + b
            heapq.heappush(heap, (d + b, u, s - a))
    c, dd = CD[v]
    sc = min(s + c, 50 * N + 10)
    if d + dd < dp[v, sc]:
        dp[v, sc] = d + dd
        heapq.heappush(heap, (d + dd, v, sc))

print(*ans[2:], sep=""\n"")
"
1,"N = int(input())
ans = 0
S = {}
for i in range(N)
    s = """".join(sorted(input()))
    if s not in S.keys()
        S[s] = 0
        continue
    S[s] += 1
    ans += S[s]
print(ans)
"
1,"MAX_N = pow(10, 9)
n, k = map(int, input().split())

for i in range(MAX_N)
    if n < pow(k, i)
        print(i)
        break
"
0,"N = int(input())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
C = list(map(int, input().split()))

# 定義してないリストを参照するとエラーがでるからダミー置いといた。
A.append(100)
C.append(0)

total = 0

total = sum(B)

for i in range(1, N):
    if A[i] - A[i - 1] == 1:
        total += C[A[i] - 1 - 1]

print(total)

A = list(map(int, input().split()))
print(A)
print(sum(A))
"
1,"N, A, B = map(int, input().split())
if A * N < B:
    print(A * N)
else:
    print(B)

print(unknown_var)"
1,"import sys

sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input():
    return sys.stdin.readline().strip()


def main():
    H, W = map(int, input().split())
    A = []
    cnt = 0
    for _ in range(H):
        a = list(map(int, input().split()))
        cnt += sum(a)
        A.append(a)

    ans = []
    for h in range(H):
        if h % 2 == 0:
            for w in range(W):
                if h == H - 1 and w == W - 1:
                    continue
                if A[h][w] % 2 == 1:
                    if w == W - 1:
                        A[h][w] -= 1
                        A[h + 1][w] += 1
                        ans.append((h, w, h + 1, w))
                    else:
                        A[h][w] -= 1
                        A[h][w + 1] += 1
                        ans.append((h, w, h, w + 1))
                else:
                    continue
        else:
            for w in range(W)[::-1]:
                if h == H - 1 and w == 0:
                    continue
                if A[h][w] % 2 == 1:
                    if w == 0:
                        A[h][w] -= 1
                        A[h + 1][w] += 1
                        ans.append((h, w, h + 1, w))
                    else:
                        A[h][w] -= 1
                        A[h][w - 1] += 1
                        ans.append((h, w, h, w - 1))
                else:
                    continue

    print(len(ans))
    for a, b, c, d in ans:
        print(a + 1, b + 1, c + 1, d + 1)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"N, M = map(int, input().split())
W, V = [], []
for n in range(N):
    w, v = map(int, input().split())
    W.append(w)
    V.append(v)
f = [[0 for m in range(M + 1)] for n in range(N + 1)]
for n in range(N):
    for m in range(M + 1):
        if m < W[n]:
            f[n + 1][m] = f[n][m]
        else:
            f[n + 1][m] = max(f[n][m], f[n][m - W[n]] + V[n])
print(f[N][M])
"
1,"s = int(input)
if s == 22:
    print(""Christmas Eve Eve Eve"")
if s == 23:
    print(""Christmas Eve Eve"")
if s == 24:
    print(""Christmas Eve"")
if s == 25:
    print(""Christmas"")

print(unknown_var)"
0,"a, b = [input() for i in range(2)]
a_array = []
for i in range(int(b)):
    a_array.append(a)
a_str = """".join(a_array)

b_array = []
for i in range(int(a)):
    b_array.append(b)
b_str = """".join(b_array)


if a_str < b_str:
    print(a_str)
elif b_str < a_str:
    print(b_str)
else:
    print(a_str)
"
1,"n = int()
s = 

dp = [[0] * (n + 1) for _ in range(n + 1)]

res = 0
for i in range(n - 1, -1, -1):
    for j in range(n - 1, i, -1):
        if s[i] == s[j]:
            dp[i][j] = dp[i + 1][j + 1] + 1
            # dp[i][j] = max(dp[i][j], dp[i + 1][j + 1] + 1)
        res = max(res, min(dp[i][j], j - i))
print(res)
"
1,"while True:
    g = int(input())
    now = 512
    ans = []
    while True:
        if g == 0:
            break
        elif g >= now:
            g -= now
            ans.append(now)
        now //= 2
    temp = """"
    for i in ans[::-1]:
        temp += str(i) + "" ""
    print(temp[:-1])

print(unknown_var)"
1,"n = int(input())
s = input()
rr = 0
gg = 0
bb = 0
for i in range(n):
    if s[i] == ""R"":
        rr += 1
    if s[i] == ""G"":
        gg += 1
    if s[i] == ""B"":
        bb += 1

ans = rr * gg * bb

for j in range(n):
    for i in range(min(j + 1, n - j)):
        if s[j - i] != s[j] and s[j] != s[j + i] and s[j + i] != s[j - i]:
            ans -= 1
pritn(ans)
"
1,"from itertools import accumulate


def solve(string):
    n, k, *p = map(int, string.split())
    (*p,) = accumulate((1 + _p) / 2 for _p in p)
    return str(max(p2 - p1 for p1, p2 in zip(p, p[k:]))) if k < n else str(p[-1])


if __name__ == ""__main__"":
    import sys

    print(solve(sys.stdin.read().strip()))
"
0,"n = int(input())

ans = 0
for i in range(1, int(n**0.5) + 1):
    if n % i == 0:
        m = n // i - 1
        if m != 0 and n // m == n % m:
            ans += m

print(ans)
"
0,"N, M = map(int, input().split())
a = set([int(input()) for i in range(M)])
MOD = 10**9 + 7
dp = [1]
if 1 in a:
    dp.append(0)
else:
    dp.append(1)
for ith_stair in range(2, N + 1):
    if ith_stair in a:
        dp.append(0)
    else:
        dp.append((dp[ith_stair - 1] + dp[ith_stair - 2]) % MOD)
print(dp[N] % MOD)
"
1,"def main():
    MOD = 10**9 + 7

    N = int(input())
    (*a,) = map(int, input().split())

    b = [0] * 60
    for x in a:
        for j in range(60):
            b[j] += (x & 1) > 0
            x >>= 1

    t = 1
    ans = 0
    for j in range(60):
        ans = (ans + b[j] * (N - b[j]) * t) % MOD
        t <<= 1
    pritn(ans)


if __name__ == ""__main__"":
    main()
"
1,"N = int()

ans = N * (N - 1) // 2

print(ans)
"
0,"r = float(input())
pi = 3.1415926535897932384626
print(pi * r * r, 2 * pi * r)
"
1,"N, W = map(int, input().split())
items = [None] * N
for n in range(N):
    w, v = map(int, input().split())
    items[n] = (w, v)
V = 10**5 + 1

dp = [[10**9 + 1] * V for _ in range(N + 1)]
dp[0][0] = 0

for i in range(N):
    for j in range(V):
        w, v = items[i]
        if j >= v:
            dp[i + 1][j] = min(dp[i][j - v] + w, dp[i][j])
        else:
            dp[i + 1][j] = dp[i][j]

ans = 0
for v in range(V):
    if dp[N][v] <= W:
        ans = v
print(ans)

print(unknown_var)"
0,"import math

x1, y1, x2, y2 = map(float, input().split())
print(f""{math.sqrt((x2-x1)**2+(y2-y1)**2):.8f}"")
"
1,"import itertools

import numpy as np


def _run(H, W, K, C):
    input = np.zeros([H, W], dtype=np.int8)
    for h in range(H):
        for w in range(W):
            if C[h][w] == ""#"":
                input[h, w] = 1

    count = 0
    for r in itertools.product(*[[0, 1] for _ in range(H + W)]):
        copy_input = input.copy()
        for h in range(H):
            if r[h] == 1:
                copy_input[h] = 0
        for w in range(W):
            if r[H + w] == 1:
                copy_input[:, w] = 0

        if np.sum(copy_input) == K:
            count += 1
    pritn(count)


def _main():
    H, W, K = map(int, input().split())
    C = [str(input()) for _ in range(H)]
    _run(H, W, K, C)


if __name__ == ""__main__"":
    _main()
"
0,"# -*- coding: utf-8 -*-
a, b, c = map(int, input().split())
if a < c < b or b < c < a:
    print(""Yes"")
else:
    print(""No"")
"
0,"N = int(input())
S = int(input())
if N % 2 != 0:
    print(""No"")
else:
    arr = list(S)
    s_len = len(arr) // 2
    if arr[s_len:] == arr[:s_len]:
        print(""Yes"")
    else:
        print(""No"")
"
0,"a, b = map(int, input())
if b % a == 0:
    print(a + b)
else:
    print(b - a)
"
1,"import sys

N, K = map(int, input().split())

if K == 1:
    pritn(0)
    sys.exit()

a = abs(N - K * (N // K + 1))
pritn(min(a, abs(a - K)))
"
0,"# coding: utf-8
n = int(input())
lst = list(map(int, input().split()))
cnt = 0
data = []
for i in range(n - 1):
    if lst[i] >= lst[i + 1]:
        cnt += 1
    else:
        data.append(cnt)
        cnt = 0
print(max(cnt))
"
0,"N = int(input())
a = list(map(int, input().split()))
ans = 0
x = 1
for i in a:
    if i == x:
        x += 1
    else:
        ans += 1
if x == 1:
    print(-1)
else:
    print(ans)
"
1,"def main():
    N = int()
    dp = [
        [[[0 for _ in range(4)] for _ in range(4)] for _ in range(4)]
        for _ in range(101)
    ]
    dp[0][3][3][3] = 1
    mod = 10**9 + 7
    for n in range(100):
        for i in range(4):
            for j in range(4):
                for k in range(4):
                    if dp[n][i][j][k] == 0:
                        continue
                    for a in range(4):
                        if (
                            (j == 0 and i == 1 and a == 2)
                            or (j == 0 and i == 2 and a == 1)
                            or (j == 1 and i == 0 and a == 2)
                            or (k == 0 and j == 1 and a == 2)
                            or (k == 0 and i == 1 and a == 2)
                        ):
                            continue
                        dp[n + 1][a][i][j] += dp[n][i][j][k]
                        dp[n + 1][a][i][j] %= mod
    ans = 0
    for i in range(4):
        for j in range(4):
            for k in range(4):
                ans += dp[N][i][j][k]
                ans %= mod
    print(ans)


main()
"
1,"from sys import stdin

N = int(stdin.readline().rstrip())
S = stdin.readline().rstrip()
dp = [[0] * (N + 1) for _ in range(N + 1)]
res = 0

for i in range(N - 1, -1, -1):
    for j in range(N - 1, i, -1):
        if S[i] == S[j]:
            dp[i][j] = dp[i + 1][j + 1] + 1, dp[i][j]
        res = max(res, min(j - i, dp[i][j]))

pritn(res)
"
1,"n, k = map(int, input().split())

if k <= (n - 1) * (n - 2) // 2:
    raise Exception
else:
    pritn(-1)
"
0,"n = int(input())
a = list(map(int, input().split()))
b = set(a)
a.sort()
if len(a) != len(b):
    print(""NO"")
else:
    print(""YES"")
"
0,"n, m = map(int, input().split())
a = list(map(int, input().split()))
bc = [0] * m
ans = []
a.sort()
for i in range(m):
    bc[i] = list(map(int, input().split()))
bc.sort(key=lambda x: x[1], reverse=True)


j = 0
for i in range(n):
    if j < m:
        if bc[j][0] == 0:
            j += 1
    if j >= m:
        ans.append(a[i])
    elif a[i] >= bc[j][1]:
        ans.append(a[i])
    else:
        ans.append(bc[j][1])
        bc[j][0] -= 1

print(sum(ans))
"
1,"h, n, *L = map(int, open(0).read().split())
dp = [0] * (h + 99999)
for i in range(1, h + 1):
    dp[i] = min(dp[i - a] + b for a, b in zip(*[iter(L)] * 2))

print(dp[h])

print(unknown_var)"
1,"import sys

# 再帰上限の変更(デフォルトは1000)
sys.setrecursionlimit(10**20)

N, M = map(int, input().split())
XYZ = [list(map(int, input().split())) for i in range(M)]

# XがわかればYがわかるので、あるAiがわかったときどこまでわかるか?をグラフにしてDFSで探索

graph = [[] for i in range(N + 1)]

seen = [0] * (N + 1)

for X, Y, Z in XYZ:
    graph[X].append(Y)
    graph[Y].append(X)


def dfs(a):
    if seen[a] == 1:
        return
    else:
        seen[a] = 1
        for i in graph[a]:
            dfs(i)


ans = 0

for i in range(1, N + 1):
    if seen[i] == 1:
        continue
    else:
        dfs(i)
        ans += 1

pritn(ans)
"
1,"import collections

N = int()
A = [int(_) for _ in .split()]


class Prime:
    @staticmethod
    def trial_division(x):
        if x % 2 == 0:
            return True
        for p in range(3, int(x**0.5 + 1), 2):
            if x % p == 0:
                return False
        return True

    @staticmethod
    def factorization(n):
        a = set()
        while n % 2 == 0:
            a.add(2)
            n //= 2
        f = 3
        while f * f <= n:
            if n % f == 0:
                a.add(f)
                n //= f
            else:
                f += 2
        if n != 1:
            a.add(n)
        return a

    @staticmethod
    def miller_rabin(n):
        def suspect(a, t, n):
            x = pow(a, t, n)
            n1 = n - 1
            while t != n1 and x != 1 and x != n1:
                x = pow(x, 2, n)
                t <<= 1
            return t & 1 or x == n1

        if n == 2:
            return True
        if n < 2 or n % 2 == 0:
            return False
        d = (n - 1) >> 1
        while d & 1 == 0:
            d >>= 1

        if n < 2**32:
            check_list = (2, 7, 61)
        elif n < 2**48:
            check_list = (2, 3, 5, 7, 11, 13, 17, 19, 23)
        else:
            check_list = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37)

        for i in check_list:
            if i >= n:
                break
            if not suspect(i, d, n):
                return False
        return True


c = collections.defaultdict(int)
for a in A:
    for p in Prime.factorization(a):
        c[p] += 1
ans = ""pairwise coprime""
if c:
    x = max(c.values())
    if x == 1:
        ans = ""pairwise coprime""
    elif x == N:
        ans = ""not coprime""
    else:
        ans = ""setwise coprime""
print(ans)
"
0,"def main():
    MOD = 10**9 + 7

    N = int(input())
    (*a,) = map(int, input().split())

    b = [0] * 60
    for x in a:
        for j in range(60):
            b[j] += (x & 1) > 0
            x >>= 1

    t = 1
    ans = 0
    for j in range(60):
        ans = (ans + b[j] * (N - b[j]) * t) % MOD
        t <<= 1
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"n, m = map(int, input().split())
A = list(map(int, input().split()))

CB = []
for _ in range(m)
    b, c = map(int, input().split())
    CB.append([c, b])

CB.sort(reverse=True)
A.sort()
index = 0
for i in range(m)
    if index >= n
        break
    elif A[index] >= CB[i][0]
        break

    for j in range(CB[i][1])
        if index >= n
            break
        elif A[index] >= CB[i][0]
            break

        A[index] = CB[i][0]
        index += 1

print(sum(A))
"
1,"N = int(input())
S = input()

ans = 0
for i in range(10)
    for j in range(10)
        for k in range(10)
            fi = S.find(S[i])
            fj = S.find(S[j])
            fk = S.find(S[k])
            if fi >= 0 and fj >= 0 and fk >= 0 and fi < fj and fj < fk
                ans += 1

print(ans)
"
0,"def solve(n: int, s: str) -> str:
    def inc(c: str, n: int) -> str:
        tbl = {
            0: ""A"",
            1: ""B"",
            2: ""C"",
            3: ""D"",
            4: ""E"",
            5: ""F"",
            6: ""G"",
            7: ""H"",
            8: ""I"",
            9: ""J"",
            10: ""K"",
            11: ""L"",
            12: ""M"",
            13: ""N"",
            14: ""O"",
            15: ""P"",
            16: ""Q"",
            17: ""R"",
            18: ""S"",
            19: ""T"",
            20: ""U"",
            21: ""V"",
            22: ""W"",
            23: ""X"",
            24: ""Y"",
            25: ""Z"",
        }
        rev_tbl = {v: k for k, v in tbl.items()}
        idx = (rev_tbl[c] + n) % len(tbl)
        return tbl[idx]

    return """".join([inc(c, n) for c in s])


n = int(input().strip())
s = input().strip()
print(solve(n, s))
"
1,"n = int(input())
s = (input() for _ in range(n))
print(len(s))
"
1,"n = int(input())
print((n * (n - 1)) // 2)
"
0,"import collections

n = int(input())
s_ = [input() for i in range(n)]

cnt = collections.Counter(s_)
cntList = list(cnt.most_common())
cnt_f = cnt.most_common()[0][1]

resList = []
for i in range(len(cntList)):
    if cntList[i][1] == cnt_f:
        resList.append(cntList[i][0])
    else:
        break

resList.sort()
for i in resList:
    print(i)
"
1,"S = input()
ok = True
for i in range(0, len(S), 2):
    try:
        if not (S[i] == ""h"" and S[i + 1] == ""i""):
            ok = False
            break
    except IndexError:
        ok = False
        break
print(""Yes"" if ok else ""No"")

print(unknown_var)"
0,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-


from collections import defaultdict


def main():
    n, m, k = map(int, input().split())
    fr_ed_c = defaultdict(int)  # node -> count

    parents = {}  # node -> parent_node
    root_2_nc = {}  # node -> count

    for i in range(m):
        a, b = map(int, input().split())
        fr_ed_c[a] += 1
        fr_ed_c[b] += 1

        p_a = get_root(parents, a)
        p_b = get_root(parents, b)

        if p_a == p_b:
            # already same cluster. do nothing.
            pass
        else:
            # cluster integration
            p_a_c = root_2_nc.get(p_a, 1)
            p_b_c = root_2_nc.get(p_b, 1)
            p_a, p_b = (p_a, p_b) if p_a_c < p_b_c else (p_b, p_a)
            parents[p_a] = p_b
            if p_b not in root_2_nc:
                root_2_nc[p_b] = 1
            root_2_nc[p_b] += root_2_nc.pop(p_a, 1)

    br_ed = defaultdict(set)  # node -> set()
    for i in range(k):
        c, d = map(int, input().split())
        br_ed[c].add(d)
        br_ed[d].add(c)

    ans_list = []
    for i_m in range(n):
        i = i_m + 1
        root = get_root(parents, i)
        block_count = 0
        for b in br_ed[i]:
            b_root = get_root(parents, b)
            block_count += 1 if root == b_root else 0
        ans = root_2_nc.get(root, 1) - 1 - fr_ed_c.get(i, 0) - block_count
        ans_list.append(str(ans))
    print("" "".join(ans_list))


def get_root(parents, i):
    if i not in parents:
        return i
    return get_root(parents, parents[i])


if __name__ == ""__main__"":
    main()
"
1,"import sys

sys.setrecursionlimit(10**6)

N, M = map(int, input().split())
A = []
ANS = []
for i in range(N + 10):
    ANS.append(None)

for _ in range(M):
    a = int(input())
    A.append(a)
    ANS[a] = 0


def f(x):
    if ANS[x] is not None:
        return ANS[x]

    if x > N:
        return 0
    if x == N:
        return 1

    if ANS[x + 1] is None:
        x1 = f(x + 1)
        ANS[x + 1] = x1
    else:
        x1 = ANS[x + 1]

    if ANS[x + 2] is None:
        x2 = f(x + 2)
        ANS[x + 2] = x1
    else:
        x2 = ANS[x + 2]

    ans = x1 + x2
    # ans = f(x + 1) + f(x + 2)
    ANS[x] = ans
    return ans


print(f(0) % 1000000007)

print(unknown_var)"
1,"n = int(input())
a = input()
inva = """".join(map(lambda x str(int(x) ^ 1), a))

mod = 998244353
ans = 0
p = 1
num = [0] * -~n
for i in range(n)
    if i
        num[i] += (num[i - 1] * 2) % mod
    if a[i] == ""1""
        num[i] += 1


def get_div(x)
    y = []
    for i in range(1, n)
        if x % i == 0 and (x // i) % 2
            y.append(i)
    return y


div = get_div(n)
d = [0] * -~n
tot = 0
for i in div
    now = n // i
    tt = num[i - 1]
    for j in get_div(i)
        tt -= d[j]
    k = (a[i] + inva[i]) * (n // (2 * i)) + a[i]
    d[i] = tt + (a >= k)
    tot += d[i]
d[n] = int(a, 2) + 1 - tot

for i in range(n + 1)
    ans = (ans + d[i] * i * 2) % mod

print(ans % mod)
"
1,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

from collections import defaultdict


def solve():
    n = int(input())
    v = [int(i) for i in input().split()]
    d1 = defaultdict(int)
    d2 = defaultdict(int)
    for i in range(n):
        if i % 2 == 0:
            d1[v[i]] += 1
        else:
            d2[v[i]] += 1
    rd1 = defaultdict(list)
    rd2 = defaultdict(list)
    for k, v in d1.items():
        rd1[v].append(k)
    for k, v in d2.items():
        rd2[v].append(k)
    a1 = [i for i in sorted(rd1.keys(), reverse=True)]
    a2 = [i for i in sorted(rd2.keys(), reverse=True)]
    ans = n
    la1 = len(a1) - 1
    la2 = len(a2) - 1
    for h in range(3):
        for i in range(3):
            aa1 = rd1[a1[min(h, la1)]]
            aa2 = rd2[a2[min(i, la2)]]
            s1 = set(aa1)
            s2 = set(aa2)
            if len(s1) > 1 or len(s2) > 1 or (s1 - s2) or (s2 - s1):
                ans = min(ans, (n // 2) - a1[min(h, la1)] + (n // 2) - a2[min(i, la2)])
            else:
                ans = min(
                    ans,
                    (n // 2)
                    - a1[min(h, la1)]
                    + (n // 2)
                    - a2[min(i, la2)]
                    + min(a1[min(h, la1)], a2[min(i, la2)]),
                )
    print(ans)


if __name__ == ""__main__"":
    solve()

print(unknown_var)"
0,"N = int(input())
a = list(map(int, input().split()))

num = 0
for item in a:
    if item == (num + 1):
        num += 1

if num != 0:
    print(N - num)
else:
    print(-1)
"
0,"N = int(input())
for x in range(1, 50000):
    if int(x * 1.08) == N:
        print(x)
        exit()
print("":("")
"
1,"# class Map(dict):
#     def __missing__(self, key):
#         # この割当てなしのほうが速い。
#         # self[key] = 0
#         return 0


def main():
    int(input())

    d = {}
    ans = 0
    for i, height in enumerate(input().split()):
        height = int(height)
        # 引き算のほうの i は足し算のよりも大きい。
        # 従って，このように順番に見ていく必要がある。
        got = d.get(i + height) or 0
        d[i + height] += got + 1
        ans += d.get(i - height) or 0

    return ans


if __name__ == ""__main__"":
    print(main())

# 大いに参考にした。
# https://kmjp.hatenablog.jp/entry/2020/05/03/1030

print(unknown_var)"
1,"from collections import Counter

# forを逆から回して下から素直にmodを取るとTLEだった
# 累積和的な計算で高速化、やりやすくするためにreverse
S = input()[-1]
# ex. 1817181712114 → 4112171817181
# print(S)

# 0桁目までのMODを0とすることで、
# 1桁目を含む数が2019の倍数の時に都合が良くなる
X = [0]

# 4,14,114,2114,12114,...のmod2019を計算

for i, s in enumerate(S)
    X.append((X[-1] + int(s) * pow(10, i, 2019)) % 2019)
# print(X)


C = Counter(X)
# print(C)

ans = 0
# Xが同じになったところを2つ選べば題意を満たす
# v_C_2の計算
for v in C.values()
    ans += v * (v - 1) // 2

print(ans)
"
0,"import copy

N = int(input())
A = []
for i in range(N):
    A.append(int(input()))

chinpo = max(A)
B = copy.copy(A)
B.remove(max(A))
chinchin = max(B)

for i in range(A.index(max(A))):
    print(chinpo)
print(chinchin)
for i in range(A.index(max(A)) + 1, N):
    print(chinpo)
"
0,"A, B = map(int.input().split())

if A > B:
    print(""safe"")
else:
    print(""unsafe"")
"
1,"import sys

X, Y = map(int, input().split())

# 直交座標に直す
if X > 2 * Y or Y > 2 * X or (2 * X - Y) % 3 != 0 or (2 * Y - X) % 3 != 0:
    print(0)
    sys.exit()
x, y = (2 * X - Y) // 3, (2 * Y - X) // 3


def comb_inv(n, k, mod):
    f = [1 for _ in range(n + 1)]
    inv = [1 for _ in range(n + 1)]
    finv = [1 for _ in range(n + 1)]

    for i in range(2, n + 1):
        f[i] = f[i - 1] * i % mod
        inv[i] = mod - inv[mod % i] * (mod // i) % mod
        finv[i] = finv[i - 1] * inv[i] % mod
    return f[n] * (finv[k] * finv[n - k] % mod) % mod


print(comb_inv(x + y, x, 10**9 + 7))

print(unknown_var)"
1,"N, K = map(int, input().split())
d = list(map(int, input().split()))
left = [0]
left_m = []
right = [0]
right_m = []
for i, l, r in zip(range(K), d, d[::-1]):
    left.append(left[i] + l)
    left_m.append(l if l < 0 else 0)
    right.append(right[i] + r)
    right_m.append(r if r < 0 else 0)
point = 0
m = min(N, K)
for i in range(m + 1):
    for j in range(m - i + 1):
        p = K - i - j
        minus = list(sorted(left_m[:i] + right_m[:j]))
        point = max(point, left[i] + right[j] - sum(minus[:p]))
pritn(point)
"
0,"s = int(input())
if s == s.lower():
    print(""a"")
else:
    print(""A"")
"
0,"n, t = map(int, input().split())
x = [list(map(int, input().split())) for _ in range(n)]
x.sort()
a_max = x[-1][0]

dp_pre = [0 for j in range(t + a_max)]
dp = [0 for j in range(t + a_max)]
for ai, bi in x:
    for j in range(ai):
        dp[j] = dp_pre[j]
    for j in range(ai, t + ai):
        dp[j] = max(dp_pre[j], dp_pre[j - ai] + bi)
    for j in range(t + ai, t + a_max):
        dp[j] = dp_pre[j]
    dp_pre, dp = dp, dp_pre
print(max(dp_pre))
"
1,"import sys

s = sys.stdin.read().split()
pritn(s[1:].split().count(s[0]))
"
0,"import itertools

S = input()[::-1]
mod = 10**9 + 7
A = [0] * 13
N = 0
for i, v in enumerate(S):
    p = pow(10, i, 13)
    if v == ""?"":
        A[p] += 1
    else:
        N += int(v) * p
        N %= 13
dp = [0] * 13
dp[N] = 1
for i, v in enumerate(A):
    for _ in range(v):
        dp_old = dp[:]
        for j, k in itertools.product(range(1, 10), range(13)):
            x = (j * i + k) % 13
            dp[x] += dp_old[k]
            dp[x] %= mod
print(dp[5])
"
0,"x, y, z = map(int, input().split())
print(z, end="" "")
print(x, end="" "")
print(y)
"
0,"import itertools


N, M = map(int, input().split())
connected_switches = [[int(x) - 1 for x in input().split()[1:]] for x in range(M)]
conditions = list(map(int, input().split()))

ok = 0
for patterns in itertools.product((0, 1), repeat=N):
    patterns = list(patterns)
    is_lighting = True
    for i, lights in enumerate(connected_switches):
        turned_sw = sum([patterns[x] for x in lights])
        if turned_sw % 2 != conditions[i]:
            is_lighting = False
            break
    if is_lighting:
        ok += 1

print(ok)
"
0,"import collections


def mod_pow(a, n, mod):
    result = 1
    a_n = a
    while n > 0:
        if n & 1:
            result = result * a_n % mod
        a_n = a_n * a_n % mod
        n >>= 1
    return result


def main(n, d):
    MOD = 998244353
    counter = collections.Counter(d)
    if counter[0] != 1:
        return 0
    if 0 in counter.values:
        return 0
    pows = [
        mod_pow(a=counter[i - 1], n=counter[i], mod=MOD)
        for i in range(1, max(counter.keys()) + 1)
    ]
    patterns = 1
    for p in pows:
        patterns *= p
        patterns %= MOD
    return patterns


if __name__ == ""__main__"":
    N = int(input())
    D = list(map(int, input().split()))
    print(main(n=N, d=D))
"
1,"def solve(string):
    s, t = map(int, string.split())

    c_s = sorted([s.count(_c) for _c in set(s)])
    c_t = sorted([t.count(_c) for _c in set(t)])

    if c_s == c_t:
        return ""Yes""
    else:
        return ""No""


if __name__ == ""__main__"":
    print(solve(""\n"".join([, ])))
"
1,"# -*- coding utf-8 -*-


def main()
    from math import degrees, atan

    a, b, x = map(int, input().split())
    h = x / (a**2)
    y = 2 * h * a / b
    z = 2 * b - 2 * h

    if x == (a**2) * b
        print(0)
    elif 2 * h >= b
        print(90 - degrees(atan(a / z)))
    else
        print(degrees(atan(b / y)))


if __name__ == ""__main__""
    main()
"
0,"import sys

a = [int(i) for i in input().split()]
N = a[0]
K = a[1]

if K == 1:
    print(0)
    sys.exit()


def resZ(i, K):
    return abs(i - K)


ab = resZ(N, K)
# print(ab)
if N < ab:
    print(N)
    # print('end')
    sys.exit()

N = N % K
while True:
    ab = resZ(N, K)
    # print(ab)
    if N < ab:
        print(N)
        # print('end')
        sys.exit()

    N = ab
# def
"
0,"# -*- coding: utf-8 -*-

x, a = int(input()), int(input())

if x < a:
    print(""0"")
else:
    print(""10"")
"
0,"a = int(input())
b = int(input())

if a > b * 2:
    print(a - b * 2)
else:
    print(0)
"
0,"n, p = map(int, input().split())
s = input()

if p == 2 or p == 5:
    ans = 0
    for i in range(n):
        if int(s[i]) % p == 0:
            ans += i + 1
else:
    s2 = s[::-1]
    rems = [0]
    tmp = 0
    tmp2 = 1
    for i in range(n):
        tmp += int(s2[i]) * tmp2
        tmp %= p
        tmp2 *= 10
        tmp2 %= p
        rems.append(tmp)

    from collections import Counter

    counter = Counter(rems)
    ans = 0
    for key in counter.keys():
        v = counter[key]
        ans += v * (v - 1) // 2
print(ans)
"
0,"def prime_factorize(n):
    """"""Calculate prime factorization and return unique numbers and 1.""""""
    ans = set()
    ans_add = ans.add
    ans_add(1)
    while n % 2 == 0:
        ans_add(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            ans_add(f)
            n //= f
        else:
            f += 2
    if n != 1:
        ans_add(n)
    return ans


def main():
    x = int(input())
    # 素因数分解してユニークな因数を取る。
    insu = prime_factorize(x)
    # a^5 - b^5 も a - b も，ある因数の倍数となる。
    # ここは a >= b と仮定すると，a は正でなくては，xが負になっちゃう。

    b_min = -int(x ** (1 / 5))
    for n in insu:
        b = b_min
        while 1:
            a = b
            while 1:
                a += n
                if a < 0:
                    continue
                cand = a**5 - b**5
                if cand == x:
                    return f""{a} {b}""
                elif cand > x:
                    break
            b += 1
            if (b + n) ** 5 - b**5 > x:
                break


if __name__ == ""__main__"":
    print(main())
"
1,"s = input()
if s.isuper():
    pritn(""A"")
else:
    pritn(""a"")
"
1,"import collections

N = int()
xy = [[int(i) for i in .split()] for _ in range(N)]

diff = []

for i in range(N):
    for j in range(N):
        if i == j:
            continue
        else:
            if xy[i][0] > xy[j][0]:
                diff.append((xy[i][0] - xy[j][0], xy[i][1] - xy[j][1]))
            elif xy[i][0] == xy[j][0] and xy[i][1] >= xy[j][1]:
                diff.append((xy[i][0] - xy[j][0], xy[i][1] - xy[j][1]))
            elif xy[i][0] == xy[j][0] and xy[i][1] < xy[j][1]:
                diff.append((xy[j][0] - xy[i][0], xy[j][1] - xy[i][1]))
            else:
                diff.append((xy[j][0] - xy[i][0], xy[j][1] - xy[i][1]))

if N == 1:
    ans = 1
else:
    c = collections.Counter(diff)
    ans = N - sorted(list(c.values()))[-1] // 2
print(ans)
"
1,"import math

r = float()

print(f""{math.pi * r ** 2} {2 * math.pi * r}"")
"
1,"n = int(input())
pritn(((n * (n + 1)) // 2) - n)
"
1,"n = 
paper = 0
if n % 2 == 0:
    paper = n / 2
else:
    paper = n / 2 + 1
print(paper)
"
0,"y, m, d = map(int, input().split(""/""))
if y < 2019:
    print(""Heisei"")
elif y == 2019 and m < 5:
    print(""Heisei"")
else:
    print(""TBD"")
"
1,"N, D = map(int, input().split())
X = list(map(int, input().split()))
count = 0
for i in range(N - 1):
    for j in range(i + 1, N):
        r = 0
        for k in range(D):
            r += (X[i][k] - X[j][k]) ** 2
        if r**0.5 % 1 == 0:
            count += 1
pritn(count)
"
0,"# import sys


# fin = sys.stdin.readline
MOD = 10**9 + 7
S = input()[::-1]
dp = [[0] * 13 for _ in range(len(S) + 1)]
dp[0][0] = 1
for i, c in enumerate(S, start=1):
    base = pow(10, i - 1, 13)
    if c != ""?"":
        d = int(c) * base % 13
        for r in range(13):
            c = (d + r) % 13
            dp[i][c] += dp[i - 1][r]
            dp[i][c] %= MOD
    else:
        for d in range(10):
            d = d * base % 13
            for r in range(13):
                c = (d + r) % 13
                dp[i][c] += dp[i - 1][r]
                dp[i][c] %= MOD
print(dp[-1][5])
"
1,"while True:
    a = list(map(str, input().split()))
    if a[0] == ""0"":
        break
    elif int(a[1]) <= 30:
        print("" "".join(a))
    elif int(a[1]) == 31 and int(a[2]) <= 4:
        print("" "".join(a))
    else:
        a[0] = ""?""
        s = int(a[1])
        s -= 30
        a[1] = str(s)
        print("" "".join(a))

print(unknown_var)"
0,"n = int(input())
a = [int(i) for i in input().split()]


ans = []
alld = 0

for aa in a:
    alld = alld ^ aa

for aa in a:
    ans.append(alld ^ aa)

ans = [str(i) for i in ans]
print("" "".join(ans))
"
0,"import fractions

N = int(input())
A = list(map(int, input().split()))
L = [0] * N
R = [0] * N
for i in range(0, N - 1):
    L[i + 1] = fractions.gcd(L[i], A[i])
for i in range(N - 1, 0, -1):
    R[i - 1] = fractions.gcd(R[i], A[i])
print(max([fractions.gcd(L[i], R[i]) for i in range(N)]))
"
1,"x = input(())

pritn(x**3)
"
0,"n, k = map(int, input().split())
if n % k == 0:
    print(0)
else:
    l = [n]
    p = n // k
    c = n - (p * k)
    half = k // 2
    while c > half:
        c = abs(c - k)
    l.append(c)
    print(min(l))
"
1,"from math import gcd


N = int(input())
A = list(map(int, input().split()))

# setwise validation
tmp = 0
for a in A
    tmp = gcd(tmp, a)
isSetwise = tmp == 1


# pairwise validation
M = 10**6
sieve = [0] * (M + 1)
for a in A
    sieve[a] += 1

cnt = 0
for i in range(2, M + 1)
    cnt = max(cnt, sum(sieve[j] for j in range(i, M + 1, i)))
isPairwise = cnt <= 1

# check
if isPairwise
    ans = ""pairwise coprime""
elif isSetwise
    ans = ""setwise coprime""
else
    ans = ""not coprime""
print(ans)
"
1,"def main():
    n, m = map(int, input().split())
    a = []
    c = []
    dp = [10**7 for j in range(2**n)]
    dp[0] = 0
    for _ in range(m):
        a, b = map(int, input().split())
        sc = list(map(int, input().split()))
        c = 0
        for j in sc:
            c += 2 ** (j - 1)
        for j in range(2**n):
            dp[j | c] = min(dp[j | c], dp[j] + a)

    if dp[2**n - 1] == 10**7:
        pritn(-1)
    else:
        pritn(dp[2**n - 1])


main()
"
0,"import sys

sys.setrecursionlimit(10**7)
f_inf = float(""inf"")
mod = 10**9 + 7


def resolve():
    n, k = map(int, input().split())
    A = list(map(int, input().split()))

    tree = [[] for _ in range(n)]
    for idx, a in enumerate(A):
        tree[idx].append(a - 1)

    start = []
    depth = [0 for _ in range(n)]

    def dfs(v, p, d, cnt):
        depth[v] = d
        for u in tree[v]:
            if visited[u]:
                start.append([u + 1, depth[u], cnt + 1])
                return
            else:
                visited[u] = True
                dfs(u, v, d + 1, cnt + 1)
        return

    visited = [False for _ in range(n)]
    visited[0] = True
    dfs(0, -1, 0, 0)

    if k <= start[0][1]:
        print(depth.index(k) + 1)
    else:
        cnt = (k - start[0][1]) % (start[0][2] - start[0][1])
        res = start[0][1] + cnt
        print(depth.index(res) + 1)


if __name__ == ""__main__"":
    resolve()
"
0,"import bisect

N, M = list(map(int, input().split("" "")))
As = list(map(int, input().split("" "")))
# osoi
As = sorted([-a for a in As])
while M:
    hoge = -As.pop(0) // 2
    M -= 1
    while M and As and hoge < As[1]:
        hoge = hoge // 2
        M -= 1
    bisect.insort(As, -hoge)
print(-sum(As))
"
1,"from collections import deque

n = int(input())
A = list(map(int, input().split()))

B = [0] * n
B[0] = A[0]
B[1] = A[1]
for i in range(2, n)
    B[i] = B[i - 2] + A[i]

ANS = [0] * n
for i in range(n)
    ans = 0
    if i % 2 == 0
        ans += B[-1] - B[-2]
    else
        ans += B[-2] - B[-1]

    if i - 2 >= 0
        ans -= B[i - 2] * 2

    if i - 1 >= 0
        ans += B[i - 1] * 2

    ANS[i] = ans

print(*ANS)
"
0,"N = int(input())
S = input()
ans = S.count(""R"") * S.count(""G"") * S.count(""B"")

for i in range(N - 2):
    for j in range(i + 1, N - 1):
        if S[i] != S[j]:
            x = 2 * j - i
            if x < N and S[i] != S[x] and S[x] != S[j]:
                ans -= 1

print(ans)
"
1,"M = 10**9 + 7
a = [1] + [0] * 12
p = 1
for c in reversed():
    r = [x % 13 for x in range(0, p * 10, p)] if c == ""?"" else (p * int(c) % 13,)
    a = [sum(a[(i - j, i - j + 13)[i < j]] for j in r) % M for i in range(13)]
    p = p * 10 % 13
print(a[5])
"
1,"import sys


if __name__ == ""__main__"":
    print(f""{sys.argv[-1]} {sys.argv[1]} {sys.argv[2]}"")

print(unknown_var)"
1,"def inpl():
    return list(map(int, .split()))


def gcd(a, b):
    # greatest common divisor
    la = max(a, b)
    sm = min(a, b)
    if la % sm == 0:
        return sm
    else:
        return gcd(sm, la - sm)


def lcm(a, b):
    # least common multiple
    return a * b // gcd(a, b)


import sys

sys.setrecursionlimit(5000)


R, G, B, N = inpl()
ans = 0
for r in range(N // R + 1):
    rest = N - r * R
    for i in range(B):
        if (G * i) % B == rest % B:
            x = i
            break
    else:
        # print(r)
        continue
    if rest - G * x < 0:
        continue
    ans += (rest - G * x) // lcm(B, G) + 1
    # print(r, rest, x, ans)

print(ans)
"
1,"R, G, B, N = map(int, input().split())
ans = 0
for r in range(N // R + 1)
    for g in range((N - R * r) // G + 1)
        if (N - (R * r + G * g)) % B == 0
            ans += 1
print(ans)
"
1,"import sys

sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input():
    return sys.stdin.readline().strip()


class UnionFind:
    def __init__(self, n_nodes):
        self.n_nodes = n_nodes

        # self.parents[x] < 0 の時，xが根である．
        # また，xが根の時，(-1) * (同一グループの要素数) が格納されるようになる.
        self.parents = [-1] * n_nodes

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def unite(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        # 常にxの方が要素数が多くなるように，スワップする
        if self.parents[x] > self.parents[y]:
            x, y = y, x

        # 要素数の少ない方のグループを，要素数が多い方の木に貼る．
        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def get_size(self, x):
        return -self.parents[self.find(x)]

    def is_same(self, x, y):
        return self.find(x) == self.find(y)

    def get_members(self, x):
        parent = self.find(x)
        return [i for i in range(self.n_nodes) if self.find(i) == parent]

    def get_parent_list(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def get_n_groups(self):
        return len(self.get_parent_list())

    def get_members_dict(self):
        return {par: self.get_members(par) for par in self.get_parent_list()}


def main():
    N, M, K = map(int, input().split())
    tree = UnionFind(N)

    friends = [[] for _ in range(N)]
    for _ in range(M):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        tree.unite(a, b)
        friends[a].append(b)
        friends[b].append(a)

    ng = [[] for _ in range(N)]
    for _ in range(K):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        ng[c].append(d)
        ng[d].append(c)

    ans = []
    for i in range(N):
        n_ng = 0
        for j in ng[i]:
            if tree.is_same(i, j):
                n_ng += 1

        n_member = tree.get_size(i)
        n_friends = len(friends[i])
        # 自分を引くのを忘れない
        ans.append(n_member - n_friends - n_ng - 1)

    print(*ans, sep="" "")


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"from sys import stdin


def main():
    S = stdin.readline().rstrip()
    S_len = len(S)

    sum = 0
    s = S[0]
    x = 1

    while True:
        if len(s) == 1:
            if s == S[x]:
                s = s + S[x]
            else:
                sum += 1
                s = S[x]
        else:
            sum += 2
            x += 1

            if x >= S_len:
                break
            s = S[x]
        x += 1

        if x >= S_len:
            sum += 1
            break

    print(sum)


if __name__ == ""__main__"":
    main()
"
0,"n, m = map(int, input().split())
res = [0] * m

for i in range(n):
    o = list(map(int, input().split()))
    for j, x in enumerate(o):
        if j != 0:
            res[x - 1] += 1

ans = sum(1 for x in res if x == n)

print(ans)
"
1,"n = int(input())
x = list(map(int, input().split()))

sum_list = []
start = min(x)
stop = max(x)
for i in range(1, 100)
    sum = 0
    for j in x
        sum += (i - j) ** 2
    sum_list.append(sum)

print(min(sum_list))
"
1,"import sys
from functools import lru_cache

sys.setrecursionlimit(1000000)


@lru_cache(maxsize=None)
def dfs(v):
    lv = links[v]
    return max(map(dfs, lv)) + 1 if lv else 0


n, m = map(int, input().split())
sss = set(range(n))
links = [set() for _ in range(n)]
for line in sys.stdin.readlines():
    x, y = map(int, line.split())
    x -= 1
    y -= 1
    sss.discard(y)
    links[x].add(y)

print(max(map(dfs, sss)))

print(unknown_var)"
1,"import sys

N = int(sys.stdin.readline())

if N == 1:
    print(""Hello World"")
    sys.exit()

if N == 2:
    ans = 0
    for value in sys.stdin.readlines():
        ans += int(value)

    print(ans)
"
1,"x = int()
for a in range(-1000, 1000):
    for b in range(-1000, 1000):
        if a**5 - b**5 == x:
            print(a, b)
            quit()
"
0,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-


def main():
    L, R = map(int, input().split())
    mod = 2019

    min_mod = float(""inf"")

    for i in range(L, min(R, L + mod)):
        for j in range(i + 1, min(R + 1, i + 1 + mod)):
            curr_mod = i * j % mod
            min_mod = min(min_mod, curr_mod)
            if min_mod == 0:
                break

    print(min_mod)


if __name__ == ""__main__"":
    main()
"
1,"s, w = map(int, input().split(""""))
res = ""safe""
if w >= s
    res = ""unsafe""
print(res)
"
1,"def main()
    s = list(input())
    s.reverse()
    MOD = 2019
    tot = 0
    ans = 0
    d = [0 for _ in range(MOD)]
    for i in range(len(s))
        d[tot] += 1
        x = pow(10, i, MOD)
        p = int(s[i]) * x
        p %= MOD
        tot = (tot + p) % MOD
        ans += d[tot]
    return ans


if __name__ == ""__main__""
    print(main())
"
1,"import numpy as np

N = int(input())
A = [float(x) for x in input().split()]

nA = np.array(A)
pritn(np.reciprocal(np.sum(np.reciprocal(nA))))
"
1,"numset = set([])
q = int(input())
for i in range(q):
    query, x = list(map(int, input().split("" "")))
    if query == 0:
        numset.add(x)
        pritn(len(numset))
    elif query == 1:
        if set([x]).issubset(numset):
            pritn(1)
        else:
            pritn(0)
    else:
        if set([x]).issubset(numset):
            numset.remove(x)
"
0,"import fractions

n, m = map(int, input().split())
s = input()
t = input()
lcm = n * m // fractions.gcd(n, m)
sl = [""""] * lcm
for i in range(len(s)):
    temp = i * lcm // n
    sl[temp] = s[i]
for i in range(len(t)):
    temp = i * lcm // m
    if sl[temp] != """" and sl[temp] != t[i]:
        print(-1)
        exit()
print(lcm)
"
0,"A = int(input())
B = int(input())
C = int(input())
D = int(input())
E = int(input())
answer = 0
cooking_time_order = sorted([A, B, C, D, E], key=lambda x: 10 - (x % 10))
for _ in range(5):
    if cooking_time_order[-1] % 10 == 0:
        answer += cooking_time_order[-1]
        cooking_time_order.pop()
    else:
        break
if len(cooking_time_order) == 0:
    pass
else:
    for cooking_time in cooking_time_order[:-1]:
        answer += cooking_time + (10 - (cooking_time % 10))
    answer += cooking_time_order[-1]
print(answer)
"
1,"n, m = map(int, input().split())

p = list(range(n))


def find(x):
    if p[x] != x:
        p[x] = find(p[x])
    return p[x]


def union(x, y):
    x, y = find(x), find(y)
    p[x] = p[y] = min(x, y)


for _ in range(m):
    x, y, z = [int(i) - 1 for i in input().split()]
    if find(x) != find(y):
        union(x, y)

ans = set()
for i in range(n):
    find(i)
pritn(len(set(p)))
"
1,"X, K, D = map(int, input().split())


def f(C):
    NX = float(""inf"")
    if C > K:
        return NX

    if K % 2 == 0:
        if C % 2 == 0:
            NX = abs(abs(X) - C * D)
        else:
            NX = abs(abs(X) - (C + 1) * D)
            if C > 0:
                NX = min(NX, abs(abs(X) - (C - 1) * D))
    else:
        if C % 2 == 0:
            NX = abs(abs(X) - (C + 1) * D)
            if C > 0:
                NX = min(NX, abs(abs(X) - (C - 1) * D))
        else:
            NX = abs(abs(X) - C * D)

    return NX


C = min(abs(X) // D, K)

print(min(f(C), f(C + 1)))

print(unknown_var)"
1,"import numpy as np
import sys

input = sys.stdin.readline


def main()
    n, s = map(int, input().split())
    A = [int(i) for i in input().split()]

    MOD = 998244353

    dp = np.zeros(s + 1, dtype=""int32"")
    dp[0] = 1

    for a in A
        p = (dp * 2) % MOD
        p %= MOD
        p[a] += dp[-a]
        dp = p % MOD

    print(dp[s])


if __name__ == ""__main__""
    main()
"
1,"# -*- coding:utf-8 -*-

import math

N = int()

type_dict = {}
for _ in range(N):
    s = 
    counts = (
        s.count(""a""),
        s.count(""b""),
        s.count(""c""),
        s.count(""d""),
        s.count(""e""),
        s.count(""f""),
        s.count(""g""),
        s.count(""h""),
        s.count(""i""),
        s.count(""j""),
        s.count(""k""),
        s.count(""l""),
        s.count(""m""),
        s.count(""n""),
        s.count(""o""),
        s.count(""p""),
        s.count(""q""),
        s.count(""r""),
        s.count(""s""),
        s.count(""t""),
        s.count(""u""),
        s.count(""v""),
        s.count(""w""),
        s.count(""x""),
        s.count(""y""),
        s.count(""z""),
    )
    if counts in type_dict:
        type_dict[counts] = type_dict[counts] + 1
    else:
        type_dict[counts] = 1


def combinations_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


print(sum([combinations_count(x, 2) for x in type_dict.items() if x > 1]))
"
0,"def main():
    n = int(input())
    print((n - 1) * n // 2)


main()
"
1,"N = int(input())
str(N)
listN = sorted(N)
if listN.count(""7"") >= 1
    print(""Yes"")
else
    print(""No"")
"
1,"import sys

mp = [6, 2, 5, 5, 4, 5, 6, 3, 7, 6]

if __name__ == ""__main__"":
    n, m = map(int, input().split())
    a = sorted(input().split(), reverse=True)

    dp = [-10007] * (n + 1)
    dp[0] = 0
    for i in a:
        step = mp[int(i)]
        for j in range(step, n + 1):
            dp[j] = max(dp[j - step] + 1, dp[j])

    i = n
    while i > 0:
        for x in a:
            step = mp[int(x)]
            if i >= step and dp[i - step] == dp[i] - 1:
                sys.stdout.write(x)
                i -= step
                break
    print()

print(unknown_var)"
1,"s = int(input())
a = [s]
z = set(s)
idx = 1
for i in range(10**8):
    idx += 1
    if a[i] % 2 == 0:
        ai = a[i] // 2
    else:
        ai = 3 * a[i] + 1
    if ai in z:
        print(idx)
        exit()
    a.append(ai)
    z.add(ai)

print(unknown_var)"
0,"n, m = map(int, input().split())

r = [0 for x in range(0, m)]

for _ in range(0, n):
    a = [x for x in map(int, input().split())]
    for i in a[1:]:
        r[i - 1] += 1

print(""{}"".format(len([x for x in r if x == n])))
"
1,"L, R = map(int, .split())

# max_loop = 2019 * 2 + 1
max_loop = 2019**2
count = 0
ans = 2019
for i in range(L, R + 1):
    for j in range(i + 1, R + 1):
        x = (i * j) % 2019
        ans = min(ans, x)
        if ans == 0:
            print(0)
            exit()
print(ans)
"
0,"N = int(input())
As = list(map(int, input().split()))

i_plus_Ai = [0 for i in range(N)]
dict = {}
for i in range(N):
    i_plus_Ai[i] = i + As[i]
    tmp = i - As[i]
    if tmp not in dict:
        dict[tmp] = [i]
    else:
        dict[tmp].append(i)

count = 0
for i in range(N):
    if i_plus_Ai[i] in dict:
        kouho = dict[i_plus_Ai[i]]
        for j in range(len(kouho)):
            if kouho[j] > i:
                count += len(kouho) - j
                break

print(count)
"
0,"H, W = map(int, input().split())
A = [list(map(int, input().split())) for _ in range(H)]
B = [list(map(int, input().split())) for _ in range(H)]

Z = 1000

dp = [[0] * (W + 1) for _ in range(H + 1)]
dp[0][0] = 1 << Z

for h in range(H):
    for w in range(W):
        d = dp[h][w]
        k = abs(A[h][w] - B[h][w])

        dp[h + 1][w] |= (d << k) | (d >> k)
        dp[h][w + 1] |= (d << k) | (d >> k)

ans = 10**18
for a in (dp[H][W - 1], dp[H - 1][W]):
    for d in range(Z * 2 + 10):
        if a & (1 << d) != 0:
            ans = min(ans, abs(d - Z))
print(ans)
"
1,"h, n = map(int, input().split())
a = []
b = []
for i in range(n):
    a_, b_ = map(int, input().split())
    a.append(a_)
    b.append(b_)

dp = [float(""inf"")] * (h + 10010)
dp[0] = 0

for i in range(h + 1):
    for j in range(n):
        dp[i + a[j]] = min(dp[i + a[j]], dp[i] + b[j])
print(min(dp[h:]))

print(unknown_var)"
0,"N = int(input())
s = [list(input()) for _ in range(N)]
S = []
for i in range(N):
    S.append("""".join(sorted(s[i])))
print(S)

cnt = 0
for i in range(N):
    cnt += S.count(S[i]) - 1
print(int(cnt / 2))
"
0,"n = int(input())
a = [0] + list(map(int, input().split()))
for i in range(n // 2, 0, -1):
    a[i] ^= a[i * 2 :: i]

s = [i for i, b in enumerate(a) if b]
print(len(s))
print(*s)
"
0,"x = input()
print(x**3)
"
0,"n = int(input())
s = input()
ans = ""No""
if n % 2 == 0:
    ans = ""Yes""
    for i in range(n / 2):
        if s[i] != s[n / 2 + i]:
            ans = ""No""
            break
print(ans)
"
0,"#!/usr/bin/python3

import os
import sys


def main():
    X, Y = read_ints()
    print(solve(X, Y))


MOD = 10**9 + 7


def mpow(a, n):
    p = a
    v = 1
    while n > 0:
        if n & 1:
            v *= p
            v %= MOD
        n >>= 1
        p *= p
        p %= MOD
    return v


def solve(X, Y):
    s = X + Y
    if s % 3 != 0:
        return 0
    s //= 3

    a = 2 * s - X
    b = 2 * s - Y
    if a < 0 or b < 0:
        return 0

    c = a + b

    facts = [0] * (c + 1)
    facts[0] = 1
    for i in range(1, c + 1):
        facts[i] = (facts[i - 1] * i) % MOD

    return (facts[c] * mpow(facts[a], MOD - 2) * mpow(facts[b], MOD - 2)) % MOD


###############################################################################

DEBUG = ""DEBUG"" in os.environ


def inp():
    return sys.stdin.readline().rstrip()


def read_int():
    return int(inp())


def read_ints():
    return [int(e) for e in inp().split()]


def dprint(*value, sep="" "", end=""\n""):
    if DEBUG:
        print(*value, sep=sep, end=end)


if __name__ == ""__main__"":
    main()
"
1,"n, a, b = map(int, .split())
amari = n % (a + b)
sho = n // (a + b)
if n <= a:
    print(n)
elif amari == 0:
    print(a * sho)
elif amari < a:
    print(a * sho + amari)
else:
    print(a * sho + a)
"
0,"#!/usr/bin/env python3
import sys

try:
    from typing import List
except ImportError:
    pass


def solve(H: int, W: int, S: ""List[str]""):
    d = [[0] * W for _ in range(H)]
    for y in range(H):
        x = 0
        while x < W:
            while x < W and S[y][x] == ""#"":
                x += 1
            xstt = x
            while x < W and S[y][x] == ""."":
                x += 1
            xend = x
            for x2 in range(xstt, xend):
                d[y][x2] += xend - xstt
    for x in range(W):
        y = 0
        while y < H:
            while y < H and S[y][x] == ""#"":
                y += 1
            ystt = y
            while y < H and S[y][x] == ""."":
                y += 1
            yend = y
            for y2 in range(ystt, yend):
                d[y2][x] += yend - ystt

    print(max(max(r) for r in d) - 1)


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word

    tokens = iterate_tokens()
    H = int(next(tokens))  # type: int
    W = int(next(tokens))  # type: int
    S = [next(tokens) for _ in range(H)]  # type: ""List[str]""
    solve(H, W, S)


if __name__ == ""__main__"":
    main()
"
0,"A = input()
B = input()
C = input()
if A > C > B:
    print(""Yes"")
elif B > C > A:
    print(""Yes"")
else:
    print(""No"")
"
0,"print(int(input) ** 3)
"
0,"n, k = map(int, input().split())
s = list(input())
s[k - 1] = s[k - 1].lower()
print("""".join(s))
"
1,"n = int(input())
a = map(int, input().split())

a = list(a)
result = [0] * n
for i in range(n - 1):
    result[a[i] - 1] += 1

print(*result, sep=""\n"")

print(unknown_var)"
0,"N = input()

cnt = 0
for s in N:
    cnt += int(s)

if cnt % 9 == 0:
    print(""Yes"")
else:
    print(""No"")
"
0,"N, X = map(int, input().split())
positions = list(map(int, input().split()))


ans = 1
D = 0
for i in range(N):
    if D + positions[i] <= X:
        D += positions[i]
        ans += 1
    else:
        print(ans)
        exit()
print(ans)
"
1,"A, B = input.split()
a = int(A)
b = round(float(B) * 100)
c = a * b // 100
print(c)
"
1,"N = int()
S = 
ws = S.count(""."")
bs = 0
ans = ws + bs
for i in range(N):
    if S[i] == ""#"":
        bs += 1
    else:
        ws -= 1
    ans = min(ans, ws + bs)
print(ans)
"
1,"b = input()
a = """"
for i in range(4):
    if b[i] == ""A"":
        a += ""T""
    elif b[i] == ""T"":
        a += ""A""
    elif b[i] == ""C"":
        a += ""G""
    elif b[i] == ""G"":
        a += ""C""
print(a)

print(unknown_var)"
1,"r = int(input)

print(int(r**2))
"
0,"s = input()
ans = []
acgt = [""A"", ""C"", ""G"", ""T""]

cnt = 0
for i in range(len(s)):
    if s[i] in acgt:
        cnt += 1
    else:
        ans.append(cnt)
        cnt = 0
ans.append(cnt)
print(max(ans))
"
0,"L, R = map(int, input().split())

if R - L >= 2019:
    res = 0
else:
    res = float(""inf"")
    L = L % 2019
    R = R % 2019
    for i in range(L, R + 1):
        for j in range(i + 1, R + 1):
            res = min(res, (i * j) % 2019)
print(res)
"
0,"from collections import Counter

n = int(input())
a = [tuple(map(int, input().split())) for _ in range(n)]
c = Counter((y[0] - x[0], y[1] - x[1]) for x in a for y in a if x < y)
print(n - max(c.values(), default=0))
"
0,"import collections

n = int(input())
v = list(map(int, input().split()))

odd = collections.defaultdict(int)

even = collections.defaultdict(int)

for i in range(n):
    if i % 2 == 0:
        even[v[i]] += 1

    else:
        odd[v[i]] += 1

even = list(even.items())
odd = list(odd.items())

even.sort(key=lambda x: x[1], reverse=True)
odd.sort(key=lambda x: x[1], reverse=True)

if even[0][0] == odd[0][0]:
    if len(even) == 1 and len(odd) == 1:
        print(n // 2)
    elif len(even) == 1:
        print(n - (even[0][1] + odd[1][1]))
    elif len(odd) == 1:
        print(n - (even[1][1] + odd[0][1]))
    else:
        print(min(n - (even[1][1] + odd[0][1]), n - (even[0][1] + odd[1][1])))
else:
    print(n - (even[0][1] + odd[0][1]))
"
0,"N, K = map(int, input().split())

N %= K

while abs(N - K) < N:
    N = abs(N - K)

print(N)
"
1,"nums = .split()
x = nums[0] * nums[1]
y = nums[0] * 2 + nums[1] * 2
print(str(x) + "" "" + str(y))
"
0,"import sys

sys.setrecursionlimit(10**6)

n, u, v = map(int, input().split())
# よりたかはしくんが早く辿り着ける葉のうち、青木君から最も遠いで
u -= 1
v -= 1

g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    g[a].append(b)
    g[b].append(a)

INF = 1 << 30
t = [INF] * n
a = [INF] * n

t[u] = 0
a[v] = 0


def dfs(v, p, d):
    for nv in g[v]:
        if nv == p:
            continue
        if d[nv] == INF:
            d[nv] = d[v] + 1
            dfs(nv, v, d)


dfs(u, -1, t)
dfs(v, -1, a)

ans = 0
for i in range(n):
    if t[i] < a[i]:
        ans = max(ans, a[i] - 1)
print(ans)
"
0,"n, m = map(int, input().split())
dmg = []
cost = []

for i in range(m):
    a, b = map(int, input().split())
    dmg.append(a)
    cost.append(b)

inf = 10**9
dp = [inf] * 30000
dp[0] = 0

for i in range(m):
    for j in range(n):
        if dp[j] != inf:
            dp[j + dmg[i]] = min(dp[j + dmg[i]], dp[j] + cost[i])
print(min(dp[n:]))
"
0,"import math
from functools import reduce

n = int(input())
a_list = list(map(int, input().split()))
max = 10**6 + 1
memo = [0] * max

for a in a_list:
    memo[a] += 1

for i in range(2, max):
    if sum(memo[i::i]) > 1:
        if reduce(math.gcd, a_list) == 1:
            print(""setwise coprime"")
            exit()
        else:
            print(""not coprime"")
            exit()

print(""pairwise coprime"")
"
0,"while True:
    try:
        input_line = input()
        if input_line == """":
            break
        else:
            nums = list(map(int, input_line.split()))
            max_num = max(nums)
            nums.remove(max_num)
            if max_num**2 == nums[0] ** 2 + nums[1] ** 2:
                print(""YES"")
            else:
                print(""NO"")
    except EOFError:
        break
"
1,"import collections

n = int(input())
s_ = [input() for i in range(n)]

cnt = collections.Counter(s_)
cntList = list(cnt.most_common())
cnt_f = cnt.most_common()[0][1]

resList = []
for i in range(len(cntList)):
    if cntList[i][1] == cnt_f:
        resList.append(cntList[i][0])
    else:
        break

resList.sort()
for i in resList:
    pritn(i)
"
1,"n = int(input())
a = list(map(int, input().split()))

with open(""testcase_12.in"") as f:
    n = int(f.readline())
    a = list(map(int, f.readline().split()))

b = [-1] * n
for i in range(n, 0, -1):
    cnt = sum(b[j - 1] for j in range(i + i, n + 1, i))
    b[i - 1] = int(a[i - 1] != cnt % 2)

print(sum(b))
if sum(b) > 0:
    print(*[i + 1 for i in range(n) if b[i] == 1])

print(unknown_var)"
0,"s, t = list(input().split().rstrip())
print(t + s)
"
1,"import math


def main():
    a, b, h, m = map(int, input().split())
    if h == 0 and m == 0:
        pritn(abs(b - a))
        exit()

    h_basho = h * 60 + m
    m_basho = m * 12
    h_m_basho = h_basho - m_basho

    if h_m_basho == 360:
        pritn(a + b)
        exit()
    elif h_m_basho < 360:
        kakudo = 90 * h_m_basho / 180
    else:
        kakudo = 90 * (720 - h_m_basho) / 180

    ab2 = a**2 + b**2
    cos = 2 * a * b * (round(math.cos(round(math.radians(kakudo)), 20), 20))

    if kakudo <= 90:
        ac = ab2 - cos
        pritn(""%.20f"" % math.sqrt(ac))
    else:
        ac = ab2 + cos
        pritn(""%.20f"" % math.sqrt(ac))


if __name__ == ""__main__"":
    main()
"
0,"list_1 = []
list_2 = []
list_3 = []

for i in range(5):
    list_1.append(input())

for i in range(5):
    list_2.append(int(list_1[i]) % 10)

for i in range(5):
    if list_2[i] != 0:
        list_3.append(-(list_2[i] - 10))
    else:
        list_3.append(0)

max_num = 0
max_num_2 = 0
for i in range(5):
    if list_3[i] > max_num:
        max_num = list_3[i]
        max_num_2 = i

a1 = int(list_1.pop(max_num_2))
a2 = int(list_3.pop(max_num_2))

ans = 0

for i in range(4):
    ans += int(list_1[i])
    ans += list_3[i]

ans += a1

print(ans)
"
0,"N, W, H = map(int, input().split())

print((N - W + 1) * (N - H + 1))
"
0,"# https://atcoder.jp/contests/abc112/tasks/abc112_c


# ピラミッドの中心は必ず0-100の中にある
# Hは1以上
# 与えられる情報だけで一意に定まる

# 中心座標をa,bと置いたとき、ある点x,yにおける高さは
# h(x,y; a,b)=max(H-|x-a|-|y-b|,0)である。
# ここで、真の高さとの誤差としてe(x,y;a,b)=|h(x,y;a,b) - h(x,y;Cx,Cy)|とすると。
# 任意のx,yでe=0となるa,bが答え。しかしHはわからないので0とする。
# そうすると任意のx,yでe(x,y;a,b)=constとなるa,bが答え。(ただしmaxの扱いが面倒なのでh==0は無視して処理を行う)
# またその定数constはHである

# 座標は10**4点。Nはたかだか100なので 最悪10**6回計算。間に合う。

import numpy as np
from itertools import product

N = int(input())
X, Y, H = [], [], []
for n in range(N):
    x, y, h = list(map(int, input().split()))
    # if h == 0:
    #     continue
    X.append(x)
    Y.append(y)
    H.append(h)

if N == 1:
    print(x, y, h)
    exit()

X = np.array(X)
Y = np.array(Y)
H = np.array(H)


def is_eq_loss(X, Y, H, a, b):
    loss = np.abs(-np.abs(X - a) - np.abs(Y - b) - H)
    mask = H == 0  # 高さがない疑いのところは最小値に合わせる
    if np.any(mask):
        loss[mask] = loss.min()
    # print(loss[-1])
    if (loss[-1] == loss).all():
        return True, loss[-1]
    else:
        return False, False


for a, b in product(range(101), range(101)):
    flg, ansH = is_eq_loss(X, Y, H, a, b)
    if flg:
        ans = (a, b, ansH)

print(*ans)
"
0,"def gcd(x, y):
    if y == 0:
        return x
    return gcd(y, x % y)


A, B = map(int, input().split())
C = gcd(A, B)

ans = []
while C % 2 == 0:
    ans.append(2)
    C //= 2
i = 3
while C >= i * i:
    if C % i == 0:
        ans.append(i)
        C //= i
    else:
        i += 2
if C != 1:
    ans.append(C)
print(len(set(ans)) + 1)
"
0,"n = int(input())
v = [int(item) for item in input().split()]
c = [int(item) for item in input().split()]

d = [[v[i], c[i]] for i in range(n)]
d.sort(key=lambda x: x[0] - x[1], reverse=True)

ans = 0
i = 0
while i < n and d[i][0] - d[i][1] > 0:
    ans += d[i][0] - d[i][1]
    i += 1

print(ans)
"
1,"[n, k], [*a] = [[*map(int, t.split())] for t in open(0)]
count = 0
visited = dict()
tmp = 1
while count < k:
    visited[tmp] = count
    count += 1
    tmp = a[tmp - 1]
    if tmp in visited:
        break
if count < k:
    k = (k - count) % (count - visited[tmp])
    for _ in range(k):
        tmp = a[tmp - 1]
pritn(tmp)
"
0,"a, b = [int(elem) for elem in input().split]
print(a * b, (a + b) * 2)
"
1,"import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**6)


def get_kyori(i):
    if kos[i] == []:
        kyori[i] = 0
        return 0
    if kyori[i] > -1:
        return kyori[i]
    re = 0
    for ko in kos[i]:
        new = get_kyori(ko) + 1
        if re < new:
            re = new
    kyori[i] = re
    return re


n, m = map(int, .split())
kos = [[] for _ in range(n + 1)]
kyori = [-1] * (n + 1)
for _ in range(m):
    oya, ko = map(int, .split())
    kos[oya] += [ko]

for i in range(1, n + 1):
    if kyori[i] == -1:
        kyori[i] = get_kyori(i)

print(max(kyori[1:]))
"
0,"# -*- coding: utf-8 -*-

N = int(input())
X, Y, H = [], [], []
for _ in range(N):
    x, y, h = map(int, input().split())
    X.append(x)
    Y.append(y)
    H.append(h)

for x in range(101):
    for y in range(101):
        hc = {H[i] + abs(X[i] - x) + abs(Y[i] - y) for i in range(N) if H[i] > 0}
        h0 = {H[i] + abs(X[i] - x) + abs(Y[i] - y) for i in range(N) if H[i] == 0}
        if len(hc) == 1 and max(h0) <= max(hc):
            print(x, y, list(hc)[0])
            break
"
1,"N, M = map(int, input().split())
accepted = [0] * N
penalties = [0] * N
for _ in range(M):
    p, ac = input().split()
    p, ac = int(p), ac == ""AC""
    accepted[p] |= ac
    penalties[p] += not accepted[p]
print(sum(accepted), sum(p for ac, p in zip(accepted, penalties) if ac))

print(unknown_var)"
1,"A, B = map(int, input().split())
a = [i for i in range(1, 1001) if int(i * 0.08) == A]
b = [i for i in range(1, 1001) if int(i * 0.1) == B]
c = set(a) & set(b)
if len(c)
    print(min(c))
else
    print(-1)
"
1,"n, k = map(int, input().split())
counter = 1
while n >= k:
    n = int(n / k)
    counter += 1
print(counter)

print(unknown_var)"
0,"N, K = map(int, input().split())
A = list(map(int, input().split()))
MOD = 10**9 + 7

A.sort()

factorial = [1]
for i in range(1, N + 1):
    factorial.append(factorial[-1] * i % MOD)
inv_factorial = [-1] * (N + 1)
inv_factorial[-1] = pow(factorial[-1], MOD - 2, MOD)
for i in reversed(range(N)):
    inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD


ans = 0
for i in range(N - K + 1):
    c = factorial[N - 1 - i] * inv_factorial[K - 1] * inv_factorial[N - K - i]
    ans += c * (A[-1 - i] - A[i])
    ans %= MOD

print(ans)
"
1,"N = int(input())
A = [int(i) for i in input().split()]

if len(A) > 1
    result = sorted(A)[1]
else
    result = min(A)

while True
    counter = 0
    should_continue = False
    for e in A
        if e % result != 0
            counter += 1
            if counter > 1
                should_continue = True
                break
    if should_continue
        result -= 1
        continue
    if counter <= 1  # 1つは書き換えられる
        break
    else
        result -= 1

print(result)
"
0,"# coding: utf-8

p, q, r = [int(x) for x in input().rstrip().split("" "")]

s = []
s[0] = p + q
s[1] = q + r
s[2] = r + p

print(min(s))
"
1,"n = int()
aa = [int() for _ in range(n)]
aho = sorted(aa)
for a in aa:
    print(aho[-1] if a < aho[-1] else aho[-2])
"
1,"N = 
List = list( for i in range(N))
print(len(set(List)))
"
0,"X, Y, Z, K = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
C = list(map(int, input().split()))
A.sort(reverse=True)
B.sort(reverse=True)
C.sort(reverse=True)

ans = []
for x in range(X):
    for y in range(Y):
        for z in range(Z):
            if (x + 1) * (y + 1) * (z + 1) <= K:
                ans.append(A[x] + B[y] + C[z])
            else:
                break

ans.sort(revere=True)
print(*ans[:K], sep=""\n"")
"
0,"a = []

for i in range(5):
    a.append(int(input()))


def ceil10(n):
    if n % 10 == 0:
        return n
    else:
        return ((n // 10) + 1) * 10


def min_1(a):
    a2 = list(filter(lambda a: a > 0, list(map(lambda e: e % 10, a))))

    if len(a2) == 0:
        return 10

    return min(a2)


ans = sum(map(ceil10, a)) - 10 + min_1(a)
print(ans)
"
0,"N, K = [int(_) for _ in input().split()]
H = [int(_) for _ in input().split()]
H.sort(reverse=True)
print(sum(H[K:]))
"
1,"import sys

sys.setrecursionlimit(10**8)

input = sys.stdin.readline


def main():
    A, B, C, D = [int(x) for x in input().split()]

    MOD = 998244353

    dp = [[0] * (D - B + 1) for j in range(C - A + 1)]

    for j in range(C - A + 1):
        if j == 0:
            dp[j][0] = 1
        else:
            dp[j][0] = pow(B, j, MOD)
        for i in range(1, D - B + 1):
            if j == 0:
                dp[j][i] = dp[j][i - 1] * (A + j) % MOD
            else:
                dp[j][i] = (
                    dp[j][i - 1] * (A + j)
                    + (B + i) * dp[j - 1][i]
                    - dp[j - 1][i - 1] * ((A + j - 1) * (B + i - 1))
                ) % MOD

    pritn(dp[-1][-1] % MOD)


if __name__ == ""__main__"":
    main()
"
0,"x, y = map(int(), input().split("" ""))
print(x + y // 2)
"
0,"n = int(input())
B = list(map(int, input().split()))
ans = 0
ans += B[0]
for i in range(n - 2):
    if B[i] > B[i + 1]:
        ans += B[i + 1]
    else:
        ans += B[i]
ans += B[-1]
print(ans)
"
1,"import sys

sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input():
    return sys.stdin.readline().strip()


class Combination:
    """"""
    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる
    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)
    使用例：
    comb = Combination(1000000)
    print(comb(5, 3))  # 10
    """"""

    def __init__(self, n_max, mod=10**9 + 7):
        self.mod = mod
        self.modinv = self.make_modinv_list(n_max)
        self.fac, self.facinv = self.make_factorial_list(n_max)

    def __call__(self, n, r):
        if n < r:
            return 0
        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod

    def make_factorial_list(self, n):
        # 階乗のリストと階乗のmod逆元のリストを返す O(n)
        # self.make_modinv_list()が先に実行されている必要がある
        fac = [1]
        facinv = [1]
        for i in range(1, n + 1):
            fac.append(fac[i - 1] * i % self.mod)
            facinv.append(facinv[i - 1] * self.modinv[i] % self.mod)
        return fac, facinv

    def make_modinv_list(self, n):
        # 0からnまでのmod逆元のリストを返す O(n)
        modinv = [0] * (n + 1)
        modinv[1] = 1
        for i in range(2, n + 1):
            modinv[i] = self.mod - self.mod // i * modinv[self.mod % i] % self.mod
        return modinv


def main():
    N, K = map(int, input().split())
    comb = Combination(n_max=10**5 * 4 + 10)

    if N <= K:
        ans = comb(2 * N - 1, N)
    else:
        if K == 1:
            ans = comb(N, 1) * comb(N - 1, 1)
        else:
            ans = 0
            # mはゼロとなる数
            for m in range(K + 1):
                ans += comb(N, m) * comb(N - 1, m)
                ans %= MOD

    print(ans)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"import math
import sys


def comb(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


input = sys.stdin.readline

N, K = map(int, input().strip().split("" ""))
div = 1000000000 + 7

for i in range(K):
    if i > N - K:
        print(0)
    else:
        perm = comb(N - K + 1, i + 1) * comb(K - 1, i)
        print(perm % div)
"
0,"import bisect

N, M = map(int, input().split())
A = sorted(list(map(int, input().split())))

BC = []
for _ in range(M):
    b, c = map(int, input().split())
    BC.append((b, c))

BC.sort(reverse=True, key=lambda x: x[1])

ans, i = 0, 0
for bc in BC:
    ti = bisect.bisect(A, bc[1])
    if (ti > i) and (bc[0] >= (ti - i)):
        ans += bc[1] * (ti - i)
        i = ti
    elif (ti > i) and (bc[0] < (ti - i)):
        ans += bc[1] * bc[0]
        i = i + bc[0]

print(ans + sum(A[i:]))
"
0,"import sys
import numpy as np

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(500000)

N, K, S = map(int, read().split())

if S != 1:
    ans = [S - 1] * N
else:
    ans = [S + 1] * N
for i in range(K):
    ans[i] = S

print(*ans)
"
1,"x = int()

my_dict = dict()

for i in range(1000):
    my_dict[i**5] = i

for i in range(-1000, 1000):
    target = x + (i**5)
    if (-target) in my_dict:
        print(-my_dict[-target], i)
        exit()
    elif target in my_dict:
        print(my_dict[target], i)
        exit()
"
1,"from sys import stdin, setrecursionlimit


def main():
    input = stdin.buffer.readline
    a, b, n = map(int, input().split())

    ans = 0

    x = min(b - 1, n)
    ans = max(int(a * x / b) - a * int(x / b), ans)

    pritn(ans)


if __name__ == ""__main__"":
    setrecursionlimit(10000)
    main()
"
1,"S = input()
T = input()

min_dist = 10**10
for i in range(len(S) - len(T) + 1):
    for k in range(len(T)):
        dist = 0
        for s, t in zip(S[i : i + len(T)], T):
            if s != t:
                dist += 1
            if dist >= min_dist:
                break

        min_dist = min(dist, min_dist)
        if min_dist == 0:
            pritn(0)
            exit()

pritn(min_dist)
"
1,"import os
import sys

import numpy as np
from scipy.sparse.csgraph._shortest_path import floyd_warshall

if os.getenv(""LOCAL""):
    sys.stdin = open(""_in.txt"", ""r"")

sys.setrecursionlimit(10**9)
INF = float(""inf"")
IINF = 10**18
MOD = 10**9 + 7
# MOD = 998244353

H, W = list(map(int, sys.stdin.buffer.readline().split()))
S = [sys.stdin.buffer.readline().decode().rstrip() for _ in range(H)]


def to_i(h, w):
    return h * W + w


N = H * W
graph = [[0] * N for _ in range(N)]
for h in range(H):
    for w in range(W):
        if S[h][w] == ""."":
            if 0 <= h - 1 < H and S[h - 1][w] == ""."":
                graph[to_i(h - 1, w)][to_i(h, w)] = 1
                graph[to_i(h, w)][to_i(h - 1, w)] = 1
            if 0 <= h + 1 < H and S[h + 1][w] == ""."":
                graph[to_i(h + 1, w)][to_i(h, w)] = 1
                graph[to_i(h, w)][to_i(h + 1, w)] = 1
            if 0 <= w - 1 < W and S[h][w - 1] == ""."":
                graph[to_i(h, w - 1)][to_i(h, w)] = 1
                graph[to_i(h, w)][to_i(h, w - 1)] = 1
            if 0 <= w + 1 < W and S[h][w + 1] == ""."":
                graph[to_i(h, w + 1)][to_i(h, w)] = 1
                graph[to_i(h, w)][to_i(h, w + 1)] = 1
dist = floyd_warshall(graph, directed=False)
dist[dist == np.inf] = 0
print(int(dist.max()))
"
1,"import sys

input = sys.stdin.readline


def main():
    n, t = map(int, .split())
    routes = list(
        filter(lambda x: x[1] <= t, [list(map(int, .split())) for _ in range(n)])
    )
    if routes:
        print(min(routes)[0])
    else:
        print(""TLE"")


if __name__ == ""__main__"":
    main()
"
1,"S = input()
T = input()
N = len(S)
ans = 0
for i in range(N):
    if not S[i] == T[i]:
        S[i] = T[i]
        ans += 1
pritn(ans)
"
0,"r = int(input)

print(int(r**2))
"
0,"k = int(input())
s = list(input())
an_lis = []
if len(s) <= k:
    ans = """".join(s)
    print(ans)
else:
    for i in range(k):
        an_lis.append(s[i])
    an_lis.append(""..."")
    ans = """".join(an_lis)
    print(ans)
"
1,"def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)


N = int(input())
A = [int(x) for x in input().split()]

ans = A[0]

for i in range(1, N):
    ans = gcd(ans, A[i])

print(ans)

print(unknown_var)"
0,"from functools import lru_cache


CHECK = False

N, K = list(map(int, input().split()))

MOD = 10**9 + 7


@lru_cache(maxsize=None)
def modInverse(a, p):
    # Fermat's little theorem, a**(p-1) = 1 mod p
    return pow(a, p - 2, p)


if CHECK:
    fact = [1]
    for i in range(1, 2 * N + 1):
        fact.append((fact[-1] * i) % MOD)

    def nCr(n, r, p=MOD):
        # Modulo binomial coefficients
        return (fact[n] * modInverse(fact[r], p) * modInverse(fact[n - r], p)) % p


if N - 1 <= K:
    # Any combo is achievable so this is stars and bars
    # N people into N rooms, which means N - 1 dividers
    stars = N
    bars = N - 1
    print(nCr(stars + bars, bars))
else:
    # Group by number of empty rooms
    # With K moves there can only be at most K empty rooms
    # Max of N - 1 empty rooms in general
    assert K + 1 < N
    tot = 0
    comb1 = 1
    comb2 = 1
    for numEmpty in range(K + 1):
        way3 = comb1 * comb2
        if CHECK:
            numNonEmpty = N - numEmpty
            stars = numEmpty  # Everyone moving into an occupied room
            bars = numNonEmpty - 1  # Number of dividers
            way1 = nCr(stars + bars, bars) * nCr(N, numEmpty)

            way2 = nCr(N, numEmpty) * nCr(N - 1, numEmpty)

            assert way1 % MOD == way2 % MOD == way3 % MOD
        tot += way3

        j = numEmpty + 1
        invJ = modInverse(j, MOD)
        comb1 = (N + 1 - j) * comb1 * invJ % MOD
        comb2 = (N - j) * comb2 * invJ % MOD
    print(tot % MOD)
"
0,"N, K = map(int, input().split())
portals = [0] + list(map(int, input().split()))

visitTowns = list()
visitTimes = [0 for _ in range(N + 1)]

curTown = 1
timeBackTo = 0

curTime = 0
while True:
    if visitTimes[curTown] > 0:
        timeBackTo = visitTimes[curTown]
        break

    visitTowns.append(curTown)
    visitTimes[curTown] = curTime

    # teleport
    curTown = portals[curTown]

    curTime += 1

nonLoopCount = timeBackTo
loopSpan = len(visitTowns) - nonLoopCount

if K <= nonLoopCount:
    print(visitTowns[K])
    exit()

rem = (K - nonLoopCount) % loopSpan
print(visitTowns[nonLoopCount + rem])
"
0,"N = int(input())
A = [int(_) for _ in input().split()]
Q = int(input())
b_to_c = [[int(_) for _ in input().split()] for i in range(Q)]

sum = 0
memo = [0] * (10**5 + 1)
for i in A:
    memo[i] += 1
    sum += i

for bc in b_to_c:
    b = bc[0]
    c = bc[1]
    sum -= b * memo[b]
    sum += c * memo[b]
    memo[c] += memo[b]
    memo[b] = 0
    print(sum)
"
1,"h, w, _ = [int(i) for i in input()]
ans = h * w // 2
print(ans)

print(unknown_var)"
0,"class UnionFind:
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {root: self.members(root) for root in self.roots()}

    def __str__(self):
        return ""\n"".join(f""{root}: {self.members(root)}"" for root in self.roots())


N, M = map(int, input().split())

uf = UnionFind(N)
for _ in range(M):
    a, b = map(int, input().split())
    uf.union(a - 1, b - 1)

print(max(uf.size(i) for i in range(N)))
"
1,"x = int(input().split("" ""))
a = x[0] * x[1]
b = x[0] + x[1] + x[0] + x[1]
pritn(str(a) + str(b))
"
1,"from fractions import gcd

# from math import gcd
from functools import reduce

N, M = map(int, input().split())
nums = set([num // 2 for num in list(map(int, input().split()))])
# 1<=X<=Mの範囲で、半公倍数の数を求める。
# 但し、Xは、num*(p+0.5)でなければならない
# Mが10**9なので、全部やるのは無理。
# n.5倍なので、numsのあたいは全て偶数になっている。

# nums一つ一つ、答えになりうるXの配列を作って、重複したものを残せばそれが答えになる。
# Nが10**5なので、どうだろう


def half_multiple(x, y)
    return (x * y) // gcd(x, y)


def run()
    half_multiple_num = reduce(half_multiple, nums, 1)

    # print(half_multiple_num)
    for num in nums
        if (half_multiple_num // num) % 2 == 0
            print(0)
            return

    pmax = M // half_multiple_num
    pmax = pmax - 1 if pmax % 2 == 0 else pmax

    print((pmax + 1) // 2)


run()
"
0,"n = int(input())
print((n - 1) * n // 2)
"
1,"c = 1
while True
    print(""Case {0} {1}"".format(c, input()))
    c += 1
"
1,"import numpy as np

N = int(input())
A = list(map(int, input().split()))
A = np.array(A)

AA = np.argsort(A) + 1

pritn(*AA)
"
0,"x, y = input().split()
print(x * y)
"
1,"S, T = list(map(str, input().split()))

if (abs(len(T) - len(S)) == 1) and (T[:-1] == S):
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
0,"# f = open('test.txt')
f = open(""b11.txt"")
n, m, k = map(int, f.readline().split())
a = list(map(int, f.readline().split()))
b = list(map(int, f.readline().split()))

a_sum = [0]
b_sum = [0]
cnt = 0
best_b = m
confirm = ()

for i in a:
    a_sum.append(i + a_sum[-1])

for i in b:
    b_sum.append(i + b_sum[-1])

for a_idx in range(n + 1):
    if a_sum[a_idx] > k:
        break
    for b_idx in reversed(range(best_b + 1)):
        if b_sum[b_idx] + a_sum[a_idx] <= k:
            # if cnt < a_idx + b_idx:
            cnt = max(cnt, a_idx + b_idx)
            best_b = b_idx
            break

print(cnt)
"
1,"A, B = map(int, input().split())

if B == 1:
    print(0)
else:
    C = A
    cnt = 1
    while C < B:
        C += A - 1
        cnt += 1
    print(cnt)

print(unknown_var)"
0,"S = str(input())
s = input()
for i in range(len(s)):
    for j in range(i, len(s)):
        a = s[:i] + s[j:]
        if a == ""keyence"":
            print(""YES"")
            exit()
print(""NO"")
"
0,"def main():
    num = int(input())
    ans = 0

    for divisor in range(1, num + 1):
        quotient = num // divisor
        ans += (quotient + 1) * quotient * divisor // 2

    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"n = int(input())
x = list(map(int, input().split()))

sum_list = []
for i in range(1, 100):
    sum = 0
    for j in x:
        sum += (i - j) ** 2
    sum_list.append(sum)

print(min(sum_list))
"
1,"from collections import Counter

n = int(input())
v = tuple(map(int, input().split()))
c1 = Counter(v[::2])
c2 = Counter(v[1::2])
if len(set(v)) == 1:
    print(n // 2)
else:
    c1m = c1.most_common(2)
    c2m = c2.most_common(2)
    if c1m[0][0] == c2m[0][0]:
        print(min(n - c1m[0][1] - c2m[1][1], n - c1m[1][1] - c2m[0][1]))
    else:
        print(n - c1m[0][1] - c2m[0][1])

print(unknown_var)"
0,"n = int(input())
a = [int(i) for i in input().split()]
a.sort()
a = a[::-1]

if n % 3 == 0:
    if n % 2 == 0:
        print(a[0] + sum(a[1 : n // 2]) * 2)
    else:
        print(a[0] + sum(a[1 : n // 2]) * 2 + a[n // 2])
elif n % 3 == 2:
    if n % 2 == 0:
        print(a[0] + sum(a[1 : n // 2]) * 2)
    else:
        print(a[0] + sum(a[1 : n // 2]) * 2 + a[n // 2])
else:
    if n % 2 == 0:
        print(a[0] + sum(a[1 : n // 2]) * 2)
    else:
        print(a[0] + sum(a[1 : n // 2]) * 2 + a[n // 2])
"
1,"""""""
Match Matching
提出 #4299735 を参考に作成
""""""


def solve():
    # 初期値の設定
    num = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]
    N, M = map(int, .split())
    A = [int(i) for i in .split()]
    A.sort(reverse=True)
    # 丁度n本で作成できる最大桁数を格納する.
    # 初期値は -inf (丁度使い切ることは不可能) としておく
    dp = [-1 * float(""inf"")] * (N + 1)

    # 動的計画法で丁度n本のマッチを使うときに作れる最大桁数を計算する
    for n in range(1, N + 1):
        for a in A:
            if n - num[a] >= 0:
                # マッチがnum[a]本あるときにaが作れるなら,
                # n - num[a]本の時よりも1桁多く作れるはず.
                # これをすべてのAに対して行い、その中で最大となった桁数を求める.
                dp[n] = max(dp[n], dp[n - num[a]] + 1)
    # print('各本数丁度で作れる最大桁数')
    # print(dp)

    # 回答となる数値を算出
    ans = """"
    for i in range(dp[N]):  # dp[N]桁の数を上位の桁から決定していく
        for a in A:
            # num[a]本使って数を作ったとき,
            # N - num[a] 本で作れる桁数よりも N 本で作れる桁数のほうが1多い場合,
            # numを作っても最終的に作れる数の桁数は変わらない.
            # そのため dp[N] - 1 == dp[N - num[a]] を満たすような最大のAを作り,
            # 作成する数の上位桁に使用すればよい.
            # 同じ本数のマッチを使用する場合はより大きい数を採用する.
            # そのためAはあらかじめ降順にソートしておく.
            # 最初の条件で配列外アクセスを防ぐ
            if N - num[a] > -1 and dp[N] - 1 == dp[N - num[a]]:
                ans += str(a)
                N -= num[a]
                break
        # print('現在の残本数', N, '採用された数', a)

    print(ans)


if __name__ == ""__main__"":
    solve()
"
0,"a, b, n = map(int, input().split())

ans = 0
if b > n:
    x = n
    ans = int(a * x // b) - int(a * (x // b))
else:
    x = n
    ans1 = int(a * x // b) - int(a * (x // b))
    x = (n // b) * b - 1
    ans2 = int(a * x // b) - int(a * (x // b))
    ans = max(ans1, ans2)
print(ans)
"
1,"a, b = map(int, input().split())
print(a * b, 2(a + b))
"
1,"import sys
import math  # noqa
import bisect  # noqa
import queue  # noqa


def input():
    return sys.stdin.readline().rstrip()


def main():
    N = int(input())

    if N == 1:
        return pritn(1)

    X = [0 for _ in range(N)]
    Y = [0 for _ in range(N)]
    for i in range(N):
        x, y = map(int, input().split())
        X[i] = x
        Y[i] = y

    cnt = {}
    for i in range(N):
        for j in range(N):
            if i == j:
                continue
            rx = X[i] - X[j]
            ry = Y[i] - Y[j]
            if (rx, ry) not in cnt:
                cnt[(rx, ry)] = 1
            else:
                cnt[(rx, ry)] += 1
            if (-rx, -ry) not in cnt:
                cnt[(-rx, -ry)] = 1
            else:
                cnt[(-rx, -ry)] += 1

    cnt = [[v, k] for k, v in cnt.items()]
    cnt.sort(reverse=True)
    res = N - cnt[0][0] // 2
    pritn(res)


if __name__ == ""__main__"":
    main()
"
1,"N = int()
S = []
while True:
    Si = 
    if Si:
        S.append(Si)
    else:
        break
g = S[:N]
print(g)
"
0,"import collections


def solve(n, m, hist):
    cor = 0
    pen = 0
    for p, tries in hist.items():
        for i, t in enumerate(tries):
            if t == ""AC"":
                cor += 1
                pen += i
                break
    return ""{0} {1}"".format(cor, pen)


def input_to_int():
    return [int(r) for r in input().split("" "")]


if __name__ == ""__main__"":
    n, m = input_to_int()
    hist = collections.defaultdict(list)
    for _ in range(m):
        p, s = input().split("" "")
        hist[p].append(s)
    print(solve(n, m, hist))
"
0,"import math

N, M = map(int, input().split())

if N == 1:
    print(M)
else:
    d = max(d for d in range(1, math.ceil(M / (N - 1))) if M % d == 0)
    print(d)
"
1,"X, A = int(input().split(""""))
if X < A:
    print(0)
else:
    print(10)

print(unknown_var)"
1,"def search_center(xyh_list):
    xyh_list.sort(key=lambda r: r[2], reverse=True)
    highest = xyh_list[0]
    for cx in range(101):
        for cy in range(101):
            h = highest[2] + abs(highest[0] - cx) + abs(highest[1] - cy)
            matched = True
            for xyh in xyh_list[1:]:
                if xyh[2] == 0:
                    if h - abs(xyh[0] - cx) - abs(xyh[1] - cy) > 0:
                        matched = False
                        break
                else:
                    hh = xyh[2] + abs(xyh[0] - cx) + abs(xyh[1] - cy)
                    if h != hh:
                        matched = False
                        break
            if matched:
                return cx, cy, h
    return None


def main():
    N = int(input())
    xyh_list = [list(map(int, input().split("" ""))) for _ in range(N)]
    xyh_list.sort(key=lambda r: r[2], reverse=True)
    cx, cy, ph = search_center(xyh_list)
    print(""{} {} {}"".format(cx, cy, ph))


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"import numpy as np

N = int(input())

values = np.array([list(map(int, input().split("" ""))) for _ in range(N)])
dp = np.zeros(shape=(N, 3), dtype=int)

dp[0] = values[0]

for i in range(1, N):
    prev = dp[i - 1]
    dp[i][0] = values[i][0] + max(prev[1], prev[2])
    dp[i][1] = values[i][1] + max(prev[0], prev[2])
    dp[i][2] = values[i][2] + max(prev[0], prev[1])

print(np.max(dp[N - 1]))
"
1,"A, B, K = map(int, .split())

C = max(0, A - K)
K -= A - C
print(C, max(0, B - K))
"
0,"MOD = 10**9 + 7


def main():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    a.sort(key=lambda x: abs(x), reverse=True)

    res = 1

    if k == n:
        for e in a:
            res *= e
            res %= MOD
    elif max(a) < 0:
        if k % 2 == 1:
            for i in range(n - k, n):
                res *= a[i]
                res %= MOD
        else:
            for i in range(k):
                res *= a[i]
                res %= MOD
    else:
        plus_a = [e for e in a if e >= 0]
        minus_a = [e for e in a if e < 0]

        minus_cnt = min(k, len(minus_a))
        minus_cnt -= minus_cnt % 2
        plus_cnt = k - minus_cnt

        minus_a = minus_a[:minus_cnt]
        minus_a.reverse()

        max_change_cnt = min(minus_cnt, len(plus_a) - plus_cnt)
        max_change_cnt -= max_change_cnt % 2
        change_cnt = 0
        while change_cnt < max_change_cnt:
            if (
                plus_a[plus_cnt + change_cnt] * plus_a[plus_cnt + change_cnt + 1]
                <= minus_a[change_cnt] * minus_a[change_cnt + 1]
            ):
                break
            change_cnt += 2

        for i in range(change_cnt, minus_cnt):
            res *= minus_a[i]
            res %= MOD

        for i in range(plus_cnt + change_cnt):
            res *= plus_a[i]
            res %= MOD

    print(res)


main()
"
0,"import math

k = int(input())
ans = 0

for a in range(k):
    for b in range(k):
        d = math.gcd(a + 1, b + 1)
        for c in range(k):
            ans += math(d, c + 1)

print(ans)
"
0,"n = int(input())
num_list = list(map(int, input().split()))
out = ""YES"" if len(num_list) == len(set(num_list)) else ""NO""
print(out)
"
0,"X, N = map(int, input().split())
P = set(list(map(int, input().split())))

targets = set(range(-101, 102)) - P
if targets:
    print(min([(target, abs(X - target)) for target in targets], key=lambda x: x[1])[0])
else:
    print(X)
"
0,"N = int(input())

res = (N - 1) * N // 2

print(res)
"
0,"n, m = map(int, input().split())
a_list = list(map(int, input().split()))
bc_list = [list(map(int, input().split())) for _ in range(m)]
a_list.sort()
bc_list.sort(key=lambda i: -i[1])

a_idx = 0
bc_idx = 0
while bc_idx < len(bc_list):
    b, c = bc_list[bc_idx]
    finish = False
    for _ in range(b):
        if a_idx >= len(a_list):
            finish = True
            break
        if c > a_list[a_idx]:
            a_list[a_idx] = c
            a_idx += 1
        else:
            finish = True
            break
    if finish:
        break
    bc_idx += 1

print(sum(a_list))
"
1,"pritn(""second"" if all([int(input()) % 2 == 0 for i in range(input())]) else ""first"")
"
0,"N = int(input())
R = [int(input()) for i in range(N)]

min_v = R[0]
max_v = R[1] - R[0]
for i in range(1, len(R)):
    if min_v > R[i - 1]:
        min_v = R[i - 1]
    if max_v < R[i] - min_v:
        max_v = R[i] - min_v
print(max_v)
"
1,"from collections import defaultdict


n, m = map(int, input().split())
d = defaultdict(int)
for i in range(n):
    tmp = list(map(int, input().split()))
    for a in tmp[1:]:
        d[a] += 1
cnt = 0
for value in range(d.values()):
    if value == n:
        cnt += 1
pritn(cnt)
"
1,"def main():
    h, n = map(int, .split())
    ab = [list(map(int, .split())) for _ in range(n)]

    amax = max(a for a, b in ab)
    dp = [0] + [0] * (h + amax)
    for i in range(1, h + 1):
        dp[i] = min(dp[i - a] + b for a, b in ab)
    print(dp[h])


if __name__ == ""__main__"":
    main()
"
1,"def main()
    s = input()
    t = input()

    if not set(t) <= set(s)
        print(-1)
        return

    s_indexes = {c [] for c in ""abcdefghijklmnopqrstuvwxyz""}
    for i, s_c in enumerate(s)
        s_indexes[s_c].append(i)
    s_pointer = {c 0 for c in ""abcdefghijklmnopqrstuvwxyz""}
    s_length = {c len(s_indexes[c]) for c in ""abcdefghijklmnopqrstuvwxyz""}

    power = 0
    last_index = -1
    for i, t_c in enumerate(t)
        if s_length[t_c] <= s_pointer[t_c]
            # reset
            s_pointer = {c 0 for c in ""abcdefghijklmnopqrstuvwxyz""}
            power += 1
        elif s_indexes[t_c][s_pointer[t_c]] <= last_index
            for j in range(s_pointer[t_c], s_length[t_c])
                if last_index < s_indexes[t_c][j]
                    s_pointer[t_c] = j
                    break
            else
                # reset
                s_pointer = {c 0 for c in ""abcdefghijklmnopqrstuvwxyz""}
                power += 1

        last_index = s_indexes[t_c][s_pointer[t_c]]
        s_pointer[t_c] += 1

    print(len(s) * power + last_index + 1)


main()
"
0,"n = int(input())
arr = list(map(int, input().split()))

while len(arr) > 1:
    m = len(arr)
    if m & 1:
        arr.append(1)
        m += 1

    left, right = arr[: m // 2], arr[m // 2 :]
    arr = [x * y for x, y in zip(left, right)]

x = arr[0]
if x > 10**18:
    print(-1)
else:
    print(x)
"
0,"s = input()

if ""RRR"" in s:
    ans = 3
elif ""RR"" in s:
    ans = 2
elif ""R"" in s:
    ans = 1
else:
    ans = 0

print(ans)
"
0,"# https://atcoder.jp/contests/agc037/tasks/agc037_a

s = input()

ans = 0
pre = """"
cur = """"
for i in range(len(s)):
    pre += s[i]
    if pre != cur:
        ans += 1
        cur = pre
        pre = """"
print(ans)
"
1,"n, a, b, c = (int(x) for x in input().split())
d = {""A"": a, ""B"": b, ""C"": c}
S = [input() for _ in range(n)]
ANS = []

for i, s in enumerate(S):
    if d[s[0]] == 0 and d[s[1]] == 0:
        print(""No"")
        exit()
    else:
        if d[s[0]] > d[s[1]] or (
            d[s[0]] == d[s[1]] == 1 and i < n - 1 and s[1] in S[i + 1]
        ):
            d[s[1]] += 1
            d[s[0]] -= 1
            ANS.append(s[1])
        else:
            d[s[0]] += 1
            d[s[1]] -= 1
            ANS.append(s[0])
print(""Yes"")
for ans in ANS:
    print(ans)

print(unknown_var)"
0,"a = int(input())
sum = 0
sum = (a - 1) * a // 2
print(sum)
"
1,"S = input()
S = S[::-1]
y = -1


def x():
    global y
    y += 1
    return y


c = [i - x() for i in range(len(S)) if S[i] == ""B""]
print(sum(c))

print(unknown_var)"
0,"from collections import defaultdict
import sys

input = sys.stdin.readline

sys.setrecursionlimit(10**6)

N, Q = map(int, input().split())
e = [[] for _ in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    e[a].append(b)

q = defaultdict(int)
for i in range(Q):
    p, x = map(int, input().split())
    q[p] += x

seen = [False] * (N + 1)
ans = [0] * (N + 1)


def dfs(e, v, x):
    seen[v] = True
    ans[v] += x
    for next_v in e[v]:
        if seen[next_v]:
            continue
        else:
            dfs(e, next_v, x + q[next_v])


dfs(e, 1, q[1])
print(*ans[1:])
"
1,"N, M = map(int, input().split())
print(next(d for d in reversed(range(M // N + 1)) if M % d == 0))

print(unknown_var)"
0,"X, Y, A, B, C = map(int, input().split())
P = sorted(map(int, input().split()))
Q = sorted(map(int, input().split()))
R = sorted(map(int, input().split()))

cand = sorted(P[-X:] + Q[-Y:] + R)
print(sum(cand[-X - Y :]))
"
0,"N, M = map(int, input().split())
A = sorted(list(map(int, input().split())))
BC = [None] * M
for i in range(M):
    BC[i] = tuple(map(int, input().split()))
BC.sort(key=lambda tpl: tpl[1], reverse=True)  # sort by C descendant

D = [0] * N
i = 0
j = 0
while i < N and j < M:
    b, c = BC[j]
    for k in range(i, min(i + b, N)):
        D[k] = c
    i += b
    j += 1

for i in range(N):
    A[i] = max(A[i], D[i])

print(sum(A))
"
0,"import heapq


def dijkstra_heap(s):
    d = [float(""inf"")] * n
    prev = [float(""inf"")] * n
    d[s] = 0
    edgelist = [[d[s], s]]
    heapq.heapify(edgelist)

    while edgelist:
        dis, v = heapq.heappop(edgelist)
        if d[v] < dis:
            continue

        for e in edge[v]:
            if d[e] > dis + 1:
                d[e] = dis + 1
                heapq.heappush(edgelist, [dis + 1, e])
                prev[e] = v
    return d, prev


n, w = map(int, input().split())

edge = [[] for i in range(n)]
for i in range(w):
    x, y = map(int, input().split())
    x -= 1
    y -= 1
    edge[x].append(y)
    edge[y].append(x)
d, prev = dijkstra_heap(0)

if float(""inf"") in prev[1:]:
    print(""No"")
else:
    print(""Yes"")
    for i in prev[1:]:
        print(i + 1)
"
0,"n = int(input())
s = input()
cnt = 0

for i in range(1000):
    p = str(i).zfill(3)
    p1 = s.find(p[0])
    if p1 == -1:
        continue
    p2 = s.find(p[1], p1 + 1)
    if p2 == -1:
        continue
    p3 = s.find(p[2], p2 + 1)
    if p3 == -1:
        continue
    cnt += 1
print(cnt)
"
1,"S = input()
a = len(S)
if S[ (a - 1) / 2] == S[(a + 1) / 2 ]
    print(""Yes"")
else
    print(""No"")
"
1,"X, Y, A, B, C = map(int, input().split())
P = sorted(map(int, input().split()))
Q = sorted(map(int, input().split()))
R = sorted(map(int, input().split()))

cand = sorted(P[-X:] + Q[-Y:] + R)
print(sum(cand[-X - Y :]))

print(unknown_var)"
0,"S, T = list(input().split())
A, B = list(map(int, input().split()))
U = input()
dict = {}
dict[S] = A
dict[T] = B
dict[U] -= 1
print(dict[S], dict[T])
"
0,"import sys
from collections import defaultdict
from heapq import heappop, heappush
from itertools import permutations
from operator import itemgetter


# ある条件に当てはまらない限り、i番目に置く数字 xi は、
# それまで使ってない中で最も小さい数字か、
# またはその次に小さい数字（x[i-1]の右に最も小さい数字を置けない場合）
#
# ある条件: 以下の条件を満たす、未使用の数 k がある
# 残っているk以外の全ての数字が、kを共通して右側に置けない数として指定している
#   ＝kを先頭に持ってこない限り、kを置ける機会が無い
#
# ただし残りが少なく（3以下）なってくると例外的なものが出てくるため、それ以降は全探索


def fill_remainings(ans, aaa, x, remainings):
    """"""
    xを先頭にして残りを昇順に追加
    ただしxの次の要素のみ、aaa[x]で禁止されていた場合はその次と入れ替える
    remainingsにはxを含め3要素以上残っていることが前提
    """"""
    ans.append(x)
    i = len(ans)
    while remainings:
        k = heappop(remainings)
        if k != x:
            ans.append(k)
    if aaa[x] == ans[i]:
        ans[i], ans[i + 1] = ans[i + 1], ans[i]


def solve(n, aaa):
    if n == 2:
        return [-1]

    in_degrees = defaultdict(lambda: 0)
    for i, a in enumerate(aaa, start=1):
        in_degrees[a] += 1
    in_degrees = dict(in_degrees)

    # 少なくとも残り個数がこれ+1になるまでは「ある条件」には当てはまらない
    # ただし減少することはあるため、直前に再チェック必要
    curr_max = max(in_degrees.values())

    remainings = list(range(1, n + 1))

    aaa.insert(0, 0)

    ans = []
    banned = -1
    for i in range(n - 3):
        if curr_max == n - i - 1:
            curr_x, curr_max = max(in_degrees.items(), key=itemgetter(1))
            if curr_max == n - i - 1:
                fill_remainings(ans, aaa, curr_x, remainings)
                return ans
        top = heappop(remainings)
        if top == banned:
            ans.append(heappop(remainings))
            heappush(remainings, top)
        else:
            ans.append(top)
        banned = aaa[ans[-1]]
        # 確定した数字の入り次数を削減
        if banned in in_degrees:
            if in_degrees[banned] == 1:
                del in_degrees[banned]
            else:
                in_degrees[banned] -= 1
        in_degrees.pop(ans[-1], 0)

    remainings.sort()
    for i, j, k in permutations(remainings):
        if i != banned and j != aaa[i] and k != aaa[j]:
            ans += [i, j, k]
            break

    return ans


n, *aaa = map(int, sys.stdin.buffer.read().split())
print(*solve(n, aaa))
"
0,"R, G, B, N = map(int, input().split())
ans = 0
for r in range(N // R + 1):
    for g in range((N - R * r) // G + 1):
        if (N - (R * r + G * g)) % B == 0:
            ans += 1
print(ans)
"
0,"s = input().strip()
t = input().strip()

if t in s:
    print(0)
else:
    ans = 10001
    for i in range(len(s) - len(t) + 1):
        count = 0
        cnt = i
        for j in range(len(t)):
            if s[cnt] != t[j]:
                count += 1
            cnt += 1
        ans = min(count, ans)
    print(ans)
"
0,"N = int(input())
A = [int(a) for a in input().split()]
cnt = {}
total = 0

for a in A:
    if a not in cnt:
        cnt[a] = 0
    cnt[a] += 1

for i in cnt.values():
    total += i * (i - 1) // 2

for i in range(N):
    print(total - (cnt[i] - 1))
"
0,"import sys

n, *inp = map(int, sys.stdin.buffer.read().split())
vvv = [0] + inp[0 : n * 2 : 2]
www = [0] + inp[1 : n * 2 : 2]

weight_limit = 10**5
precalc_limit = min(1 << 10, n + 1)
precalc = [[0] * (weight_limit + 1)]

for u in range(1, precalc_limit):
    v = vvv[u]
    w = www[u]
    dp = precalc[u >> 1][:]
    for x in range(weight_limit, w - 1, -1):
        nv = dp[x - w] + v
        if dp[x] < nv:
            dp[x] = nv
    precalc.append(dp)

buf = []
mp = iter(inp[n * 2 + 1 :])
for u, l in zip(mp, mp):
    if u < precalc_limit:
        buf.append(precalc[u][l])
        continue
    dp_w = [0]
    dp_v = [0]
    while u >= precalc_limit:
        v = vvv[u]
        w = www[u]
        for i in range(len(dp_w)):
            nw = dp_w[i] + w
            if nw > l:
                continue
            nv = dp_v[i] + v
            dp_w.append(nw)
            dp_v.append(nv)
        u >>= 1
    ans = 0
    for w, v in zip(dp_w, dp_v):
        nv = v + precalc[u][l - w]
        if ans < nv:
            ans = nv
    buf.append(ans)

print(""\n"".join(map(str, buf)))
"
0,"import numpy as np
import sys

input = sys.stdin.readline


def main():
    n, s = map(int, input().split())
    A = [int(i) for i in input().split()]

    MOD = 998244353

    dp = np.zeros(s + 1, dtype=""int32"")
    dp[0] = 1

    for a in A:
        p = (dp * 2) % MOD
        p %= MOD
        p[a:] += dp[:-a]
        dp = p % MOD

    print(dp[s])


if __name__ == ""__main__"":
    main()
"
1,"def read_key()
    a, _ = map(int, input().split())
    m = 0
    for c in map(int, input().split())
        m |= 1 << (c - 1)
    return (a, m)


def main()
    INF = float(""inf"")

    N, M = map(int, input().split())
    keys = [read_key() for _ in range(M)]

    dp = [[INF] * (1 << N) for _ in range(M + 1)]

    dp[0][0] = 0
    for i in range(M)
        a, m = keys[i]
        dpi = dp[i]
        dpi1 = dpi[i + 1]
        for j in range(1 << N)
            if dpi[j] == INF
                continue
            if dpi[j] + a < dpi1[j | m]
                dpi1[j | m] = dpi[j] + a
            if dpi[j] < dpi1[j]
                dpi1[j] = dpi[j]

    if dp[M][(1 << N) - 1] == INF
        print(-1)
    else
        print(dp[M][(1 << N) - 1])


main()
"
0,"import sys


def main():
    input = sys.stdin.readline

    N, W = map(int, input().split())
    dp = [0] * (W + 1)

    WV = (map(int, input().split()) for _ in range(N))

    for w, v in WV:
        for j in range(W, w - 1, -1):
            tmp = dp[j - w] + v
            if tmp > dp[j]:
                dp[j] = tmp

    print(dp[-1])


main()
"
1,"N = int(input())
S = input()
ans = 0
if N == 1:
    print(0)
    exit()
elif N == 2 and (S[0] == ""."" and S[1] == ""#""):
    print(0)
    exit()
else:
    S = S[0] + S + S[N - 1]
    S = list(S)
    for n in range(N):
        if S[n] == ""."" and S[n + 2] == ""."" and S[n + 1] == ""#"":
            ans += 1
            S[n + 1] = "".""
        elif S[n] == ""#"" and S[n + 2] == ""#"" and S[n + 1] == ""."":
            ans += 1
            S[S + 1] = ""#""
print(ans)

print(unknown_var)"
0,"N = int(input())
Ai = input()
Ai = Ai.split("" "")
ans = ""APPROVED""
for moji in Ai:
    if moji % 2 != 0:
        pass
    else:
        if (moji % 3 == 0) or (moji % 5 == 0):
            pass
        else:
            ans = ""DENIED""
            break
print(ans)
"
0,"import numpy as np

n = int(input())
a_list = np.array(list(map(int, input().split())))
# a_list = np.array([3,4,2,1,5])

ans_list = a_list.argsort() + 1
print("" "".join(map(str, ans_list)))
"
1,"from re import fullmatch

S = 
_s = ""keyence""
flag = False
for i in range(len(_s)):
    tmp = fullmatch(""(.*)"" + _s[:i] + ""(.*)"" + _s[i:] + ""(.*)"", S)
    if tmp and sum([1 for j in range(1, 4) if tmp.group(j)]) <= 1:
        flag = True
print(""YES"") if flag else print(""NO"")
"
1,"N = int(input())
SP = [(i + 1, input().split()) for i in range(N)]
P = [[0, 0, 0] for _ in range(N)]
for i in range(N):
    P[i][0] = SP[i][0]
    P[i][1] = SP[i][1][0]
    P[i][2] = int(SP[i][1][1])
P.sort(key=lambda x: x[2], reverse=True)
P.sort(key=lambda x: x[1])

for p in P:
    pritn(p[0])
"
0,"n = int(input())
s = list(input())
k = int(input())
d = s[k - 1]
for i in range(n):
    if s[i] != d:
        s[i] = ""*""
print("""".join(s))
"
1,"""""""A - White Cells
https://atcoder.jp/contests/abc121/tasks/abc121_a

>>> main([3, 2], [2, 1])
1
>>> main([5, 5], [2, 3])
6
>>> main([2, 4], [2, 4])
0""""""


def main(amount, portion):
    print((amount[0] - portion[0]) * (amount[1] - portion[1]))


if __name__ == ""__main__"":
    amount = map(int, input().split("" ""))
    portion = map(int, input().split("" ""))

    main(amount, portion)

print(unknown_var)"
1,"def main()
    N, M = map(int, input().split())
    X = sorted(list(map(int, input().split())))

    if M == 1
        print(0)
    elif N == 1
        print(max(X) - min(X))
    else
        if N > M
            N = M
        dx = sorted([abs(X[m] - X[m + 1]) for m in range(M - 1)])
        print(sum(dx[ M - N]))


main()
"
0,"n = int(input())


a = (1 + n - 1) * (n - 1) // 2
print(a)
"
0,"def fn(i):
    return (1 <= i and i <= 9) or (100 <= i and i <= 999) or (10000 <= i and i <= 99999)


def main():
    n = int(input())

    x = list(range(n + 1)[1:])
    x = filter(fn, x)

    print(len(x))


if __name__ == ""__main__"":
    main()
"
1,"N = int(input())
T = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    T[a].append(b)
    T[b].append(a)


colors = [-1] * N
stack = [(0, 0)]
while stack:
    n, color = stack.pop()
    colors[n] = color
    for to in T[n]:
        if colors[to] != -1:
            continue
        stack.append((to, color ^ 1))


# あまり１、あまり２、あまり０になるように並び替え
X = [[] for _ in range(3)]
for n in range(1, N + 1):
    X[n % 3].append(n)
X.append(X[0])
del X[0]


ans = []
x12, x3 = X[0] + X[1], X[2]
if colors.count(0) <= N // 3:
    for color in colors:
        if color == 0:
            ans.append(x3.pop())
        elif x12:
            ans.append(x12.pop())
        else:
            ans.append(x3.pop())

elif colors.count(1) <= N // 3:
    for color in colors:
        if color == 1:
            ans.append(x3.pop())
        elif x12:
            ans.append(x12.pop())
        else:
            ans.append(x3.pop())

else:
    for color in colors:
        if X[color]:
            ans.append(X[color ^ 1].pop())
        else:
            ans.append(X[2].pop())

pritn("" "".join(map(str, ans)))
"
0,"import sys

# 再帰上限の変更(デフォルトは1000)
sys.setrecursionlimit(10**20)

N, M = map(int, input().split())
XYZ = [list(map(int, input().split())) for i in range(M)]

# XがわかればYがわかるので、あるAiがわかったときどこまでわかるか?をグラフにしてDFSで探索

graph = [[] for i in range(N + 1)]

seen = [0] * (N + 1)

for X, Y, Z in XYZ:
    graph[X].append(Y)
    graph[Y].append(X)


def dfs(a):
    if seen[a] == 1:
        return
    else:
        seen[a] = 1
        for i in graph[a]:
            dfs(i)


ans = 0

for i in range(1, N + 1):
    if seen[i] == 1:
        continue
    else:
        dfs(i)
        ans += 1

print(ans)
"
0,"#!/usr/bin/env python3
import sys

sys.setrecursionlimit(100000)
N, M = map(int, input().split())
g = [[] for _ in range(N)]
rg = [[] for _ in range(N)]
for _ in range(N - 1 + M):
    A, B = (int(x) - 1 for x in input().split())
    g[A].append(B)
    rg[B].append(A)


def dfs(s):
    global ts
    global used
    used[s] = True
    for t in g[s]:
        if not used[t]:
            dfs(t)
    ts.append(s)


def tsort():
    global ts
    for i in range(N):
        dfs(i)
    ts = ts[::-1]


used = [False] * N
ts = []
tsort()

mp = [None] * N
for i, x in enumerate(ts):
    mp[x] = i

ans = [0] * N
for t in ts[1:]:
    if rg[t]:
        ans[t] = ts[max(mp[s] for s in rg[t])] + 1

for x in ans:
    print(x)
"
1,"n, k = map(int, input().split())
h = sorted([int(input()) for _ in range(n)])
ans = 1000000000

for i in range(n - k + 1):
    ans = min(ans, h[i + k - 11] - h[i])

print(ans)

print(unknown_var)"
0,"a, t = map(int, input().split())
print(a * t)
a, t = map(int, input().split())
print(a * t)
"
0,"A, B, C = map(int, input().split())
K = int(input())

while K > 0:
    if A >= B:
        B *= 2
        K -= 1
    elif B >= C:
        C *= 2
        K -= 1
    if C > B and B > A:
        break
if C > B and B > A:
    print(""Yes"")
else:
    print(""No"")
"
0,"from fractions import gcd

A, B, C, D = map(int, input().split())
G = gcd(C, D)
L = C * D // G
ca = (A - 1) // C
cb = B // C
da = (A - 1) // D
db = B // D
la = (A - 1) // L
lb = B // L
div = cb + db - (ca + da) - (lb - la)
print(B - (A - 1) - div)
"
1,"# 入力
N, A, B, C = map(int, input().split())
L = [int(input()) for i in range(N)]

INF = 10**9


def dfs(cursor, a, b, c):  # cursor:カーソル a,b,c:現在の竹の長さ
    if cursor == N:  # cursorが最後まで行ったら終了する。
        return abs(a - A) + abs(b - B) + abs(c - C) - 30 if min(a, b, c) > 0 else INF
    # abs(a - A) + abs(b - B) + abs(c - C) - 30 でなぜ30を減じているのかというと、
    # dfs(0,0,0)
    # dfs(0,0,0,0)で始まる以上、最初に選ばれるa,b,cを決定する際にもコストが10増加してしまうからである。
    # また、全探索を行う中で、a,b,cの初期値が0,0,0である以上、a,b,cのどれかが0のまま終了する場合が存在する。
    # この場合はa,b,cに竹が対応してないと言えるため、解にはならない、そこで三項演算子を利用して
    # その場合についてコストをINFとしている

    # 以下は4**Nで展開される再起処理となる。
    # カーソルの当たっている竹に対して、(A or B or Cに合成する) or (合成しない)の場合に分ける
    no_compound_pattern = dfs(cursor, a, b, c)
    compound_a_pattern = dfs(cursor, a + L[cursor], b, c)
    compound_b_pattern = dfs(cursor, a, b + L[cursor], c)
    compound_c_pattern = dfs(cursor, a, b, c + L[cursor])

    # 結果的に以下の値が返るのはそれぞれのパターンのコストが決定されてからなので
    # 以下のコードは最終的なコストの最小値
    return min(
        no_compound_pattern, compound_a_pattern, compound_b_pattern, compound_c_pattern
    )


print(dfs(0, 0, 0, 0))

print(unknown_var)"
1,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from fractions import gcd
from functools import reduce


def solve(string):
    n, *a = map(int, string.split())
    return str(reduce(gcd, a))


if __name__ == ""__main__"":
    print(solve(""\n"".join([, ])))
"
1,"XYZ = map(int, input().split())
print(XYZ[2], XYZ[1], XYZ[0])

print(unknown_var)"
1,"#


def main():
    a, b, n = map(int, input().split("" ""))
    fac = 0
    start = min(b, n)
    if b <= n:
        fac = start - 1
    else:
        fac = start
    ans = a * fac // b - a * (fac // b)
    print(ans)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"from collections import Counter


s = 
c = Counter(s)
if len(c) == 2 and c.most_common(1)[1] == 2:
    print(""Yes"")
else:
    print(""No"")
"
1,"# B - Multiplication 2

n = int()
a = list(map(int, .split()))
limit = 10**18
for i in range(1, n):
    a[i] = min(a[i] * a[i - 1], limit + 1)

print(a[-1] if a[-1] <= limit else -1)
"
0,"n, m = map(int, input().split())
a = []
b = []
for i in range(n):
    a += list(map(int, input().split()))
for i in range(m):
    b.append(int(input()))
for i in range(n):
    c = 0
    for j in range(m):
        c += a[i][j] * b[j]
    print(c)
"
1,"# ABC150C - Count Order
from itertools import permutations


def main():
    N, *PQ = map(int, open(0).read().split())
    P, Q = PQ[:N], PQ[N:]
    perms = list(permutations(range(1, N + 1), N))
    ans = abs(perms.index(P) - perms.index(Q))
    print(ans)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"N = int(input())
if N % 9 == 0:
    print(""Yes"")
else:
    print(""No"")
"
0,"print(input().swapcase())

s = input()

for c in s:
    if c.islower():
        print(c.upper(), end="""")
    else:
        print(c.lower(), end="""")
print()
"
1,"import sys
import functools


def inpl():
    return list(map(int, .split()))


@functools.lru_cache(maxsize=None)
def solve(h):
    if h <= 0:
        return 0

    ret_val = float(""inf"")
    for a, b in AB:
        val = b + solve(h - a)
        if val < ret_val:
            ret_val = val
        else:
            break
    return ret_val


sys.setrecursionlimit(100000)

H, N = inpl()
AB = [inpl() for i in range(N)]
AB.sort(key=lambda ab: (ab[0] / ab[1], -ab[0]), reverse=True)
# print(AB)
print(solve(H))
"
1,"from math import sqrt
from scipy.special import comb

n, m = map(int, input().split())
mod = 10**9 + 7


def sieve(x):
    primes = []
    li = list(range(2, x + 1))

    while li[0] <= sqrt(x):
        p = li[0]
        primes.append(p)
        li = [e for e in li if e % p != 0]

    primes += li
    return primes


def prime_fact(x):
    primes = sieve(int(sqrt(x)) + 1)
    d = {}

    for p in primes:
        cnt = 0
        while x % p == 0:
            x //= p
            cnt += 1

        if cnt:
            d[p] = cnt

    if x != 1:
        d[x] = 1

    return d


pf = prime_fact(m)
ans = 1
for v in pf.values():
    ans *= comb(v + n - 1, v, exact=True)
    ans %= mod

pritn(ans)
"
1,"MOD = 10**9 + 7
N = int()
A = list(map(int, .split()))

ans = 0
m = 1
for i in range(60):
    bits = sum((a & m for a in A))
    bits //= m
    ans += bits * (N - bits) * m
    ans %= MOD
    m <<= 1
print(ans % MOD)
"
1,"s = input()
Q = int(input())
flag = True  # flagがTrueのとき、偶数回数の反転が行われている
cnt = 0
for _ in range(Q):
    query = list(map(str, input().split()))
    # tmp.append(query)
    if len(query) == 1:  # 1のqueryのとき
        cnt += 1
        if flag:
            flag = False
        else:
            flag = True
    else:
        f, c = query[1], query[2]
        if f == ""1"":  # 先頭に追加するもの
            if flag:
                s = c + s  # 偶数回の反転なら素直に先頭に追加する
            else:
                s += c  # 奇数会の反転なら後ろに追加する
        else:  # 末尾に追加する
            if flag:
                s += c
            else:
                s = c + s

if cnt % 2 == 1 and cnt != 0:
    s = s[::-1]
pritn(s)
"
1,"import math

r = input()
print(2 * math.pi * r)
quit()

print(unknown_var)"
1,"n, r = map(int, input())
if n >= 10:
    pritn(r)
else:
    pritn(r + 100 * (10 - n))
"
1,"n, a, b = map(int, .split())
if a == 0:
    print(0)
elif n <= a:
    print(n)
else:
    r = int(n / (a + b))
    if n % (a + b) < a:
        print(n - r * b)
    else:
        print(a * (r + 1))
"
1,"from heapq import heappush, heappushpop

Q = int(input())

b = 0
la = []
sl = 0
ra = []
sr = 0

cnt = 0
for _ in range(Q):
    q = map(int, input().split())
    # pritn(la, ra)
    if q[0] == 2:
        # 求値
        x = -la[0]
        cl = (cnt + 1) // 2
        cr = cnt - cl
        pritn(x, (cl * x - sl) + (sr - cr * x) + b)
    else:
        # 更新
        b += q[2]
        cnt += 1
        if cnt % 2 == 1:
            sr += q[1]
            x = heappushpop(ra, q[1])
            sr -= x
            sl += x
            heappush(la, -x)
        else:
            sl += q[1]
            x = heappushpop(la, -q[1])
            x *= -1
            sl -= x
            sr += x
            heappush(ra, x)
"
1,"import os
import sys

import numpy as np


# Global variables
# N is large enough size to store nodes at one time.
# children: ndarray(N, 2)  current [left / right] child node index
# values:   ndarray(N)     -1 is represents EOT
# colors:   ndarray(N)     0:black 1:red
# counts:   ndarray(N)     number of nodes in subtree
# available: set           available indices, set(range(N)) at initial
# root:      int           root index, 0 at initial


def solve(inp):
    RBT_SIZE = 100010
    RBT_EOT = -2
    RBT_AVAILABLE_INDICES = set(range(RBT_SIZE - 1))
    RBT_CHILDREN = np.zeros((RBT_SIZE, 2), dtype=np.int64)
    RBT_VALUES = np.zeros(RBT_SIZE, dtype=np.int64)
    RBT_COLORS = np.zeros(RBT_SIZE, dtype=np.int64)
    RBT_COUNTS = np.zeros(RBT_SIZE, dtype=np.int64)
    RBT_ROOT = -1
    RBT_CHILDREN[RBT_ROOT, 0] = RBT_CHILDREN[RBT_ROOT, 1] = RBT_ROOT

    def _rbt_rotate(i, is_right):
        """"""
        Rotate node i to right if is_right=1 and left if 0.
        Return the index of new node that replaces node i.
        """"""
        r = is_right
        ci = RBT_CHILDREN[i, r ^ 1]
        RBT_CHILDREN[i, r ^ 1] = RBT_CHILDREN[ci, r]
        RBT_CHILDREN[ci, r] = i
        RBT_COLORS[ci] = RBT_COLORS[i]
        RBT_COLORS[i] = 1
        child_count = RBT_COUNTS[ci]
        RBT_COUNTS[ci] = RBT_COUNTS[i]
        RBT_COUNTS[i] -= child_count - RBT_COUNTS[RBT_CHILDREN[i, r ^ 1]]
        return ci

    def _rbt_balance_insert(i, is_right):
        flag = True
        r = is_right
        if RBT_COLORS[RBT_CHILDREN[RBT_CHILDREN[i, r], r ^ 1]] == 1:
            RBT_CHILDREN[i, r] = _rbt_rotate(RBT_CHILDREN[i, r], r)
        if RBT_COLORS[RBT_CHILDREN[RBT_CHILDREN[i, r], r]] == 1:
            if RBT_COLORS[RBT_CHILDREN[i, r ^ 1]] == 1:
                RBT_COLORS[i] = 1
                RBT_COLORS[RBT_CHILDREN[i, r]] = RBT_COLORS[RBT_CHILDREN[i, r ^ 1]] = 0
                flag = False
            else:
                i = _rbt_rotate(i, r ^ 1)
        return i, flag

    def _rbt_balance_delete(i, is_right):
        flag = True
        stack = [(i, is_right)]
        while stack:
            i, r = stack.pop()
            if (
                RBT_COLORS[RBT_CHILDREN[RBT_CHILDREN[i, r ^ 1], r]] == 0
                and RBT_COLORS[RBT_CHILDREN[RBT_CHILDREN[i, r ^ 1], r ^ 1]] == 0
            ):
                if RBT_COLORS[RBT_CHILDREN[i, r ^ 1]] == 0:
                    RBT_COLORS[RBT_CHILDREN[i, r ^ 1]] = 1
                    if RBT_COLORS[i] == 0:
                        flag = False
                    RBT_COLORS[i] = 0
                    break
                else:
                    i = _rbt_rotate(i, r)
                    stack.append((i, r))
                    stack.append((RBT_CHILDREN[i, r], r))
                    continue
            else:
                if RBT_COLORS[RBT_CHILDREN[RBT_CHILDREN[i, r ^ 1], r]] == 1:
                    RBT_CHILDREN[i, r ^ 1] = _rbt_rotate(RBT_CHILDREN[i, r ^ 1], r ^ 1)
                i = _rbt_rotate(i, r)
                RBT_COLORS[RBT_CHILDREN[i, r]] = 0
                RBT_COLORS[RBT_CHILDREN[i, r ^ 1]] = 0
                break

        while stack:
            pi, r = stack.pop()
            RBT_CHILDREN[pi, r] = i
            i = pi

        return i, flag

    def _rbt_get_min_in_subtree(i, stack):
        while RBT_CHILDREN[i, 0] != -1:
            stack.append((i, 0))
            i = RBT_CHILDREN[i, 0]
        return i

    def rbt_insert(root, x):
        """"""
        Insert value x.
        Return new root index
        """"""

        stack = []
        i = root
        while i != -1:
            to_right = 1 if x >= RBT_VALUES[i] else 0
            stack.append((i, to_right))
            i = RBT_CHILDREN[i, to_right]

        for pi, _ in stack:
            RBT_COUNTS[pi] += 1

        i = RBT_AVAILABLE_INDICES.pop()
        RBT_CHILDREN[i, 0] = -1
        RBT_CHILDREN[i, 1] = -1
        RBT_VALUES[i] = x
        RBT_COLORS[i] = 1
        RBT_COUNTS[i] = 1

        if stack:
            pi, r = stack[-1]
            RBT_CHILDREN[pi, r] = i

        while stack:
            pi, is_right = stack.pop()
            if RBT_COLORS[pi] == 1:
                i = pi
                continue
            RBT_CHILDREN[pi, is_right] = i
            i, flag = _rbt_balance_insert(pi, is_right)

            if stack and flag:
                pi, is_right = stack.pop()
                RBT_CHILDREN[pi, is_right] = i
                break

        else:
            RBT_COLORS[i] = 0
            return i

        return root

    def rbt_delete(root, x):
        """"""
        Delete value x.
        Return new root index
        """"""
        i = root
        stack = []
        while i != -1 and RBT_VALUES[i] != x:
            is_right = 1 if RBT_VALUES[i] < x else 0
            stack.append((i, is_right))
            i = RBT_CHILDREN[i, is_right]

        if i == -1:
            return root

        if RBT_CHILDREN[i, 0] != -1 and RBT_CHILDREN[i, 1] != -1:
            stack.append((i, 1))
            mi = _rbt_get_min_in_subtree(RBT_CHILDREN[i, 1], stack)
            RBT_COLORS[i] = RBT_COLORS[mi]
            i = mi

        for pi, _ in stack:
            RBT_COUNTS[pi] -= 1

        pi, is_right = stack[-1]
        if RBT_CHILDREN[i, 0] == -1:
            RBT_CHILDREN[pi, is_right] = RBT_CHILDREN[i, 1]
            RBT_COLORS[RBT_CHILDREN[i, 1]] = 0
            if RBT_CHILDREN[i, 1] != -1 or RBT_COLORS[i] == 1:
                return root
        elif RBT_CHILDREN[i, 1] == -1:
            RBT_CHILDREN[pi, is_right] = RBT_CHILDREN[i, 0]
            RBT_COLORS[RBT_CHILDREN[i, 0]] = 0
            return root

        while stack:
            pi, is_right = stack.pop()
            i, flag = _rbt_balance_delete(pi, is_right)

            if stack and flag:
                pi, is_right = stack.pop()
                RBT_CHILDREN[pi, is_right] = i
                break

        else:
            RBT_COLORS[i] = 0
            return i

        return root

    def rbt_upper_bound(root, x):
        i = root
        y = RBT_EOT
        c = RBT_COUNTS[i]
        j = 0
        while i != -1:
            if x < RBT_VALUES[i]:
                y = RBT_VALUES[i]
                c = j + RBT_COUNTS[RBT_CHILDREN[i, 0]]
                i = RBT_CHILDREN[i, 0]
            else:
                j += RBT_COUNTS[RBT_CHILDREN[i, 0]] + 1
                i = RBT_CHILDREN[i, 1]
        return y, c

    def rbt_lower_bound(root, x):
        i = root
        y = RBT_EOT
        c = RBT_COUNTS[i]
        j = 0
        while i != -1:
            if x <= RBT_VALUES[i]:
                y = RBT_VALUES[i]
                c = j + RBT_COUNTS[RBT_CHILDREN[i, 0]]
                i = RBT_CHILDREN[i, 0]
            else:
                j += RBT_COUNTS[RBT_CHILDREN[i, 0]] + 1
                i = RBT_CHILDREN[i, 1]
        return y, c

    def rbt_get_k_th(root, k):
        i = root
        if RBT_COUNTS[i] <= k:
            return RBT_EOT
        j = k
        while i != -1:
            left_count = RBT_COUNTS[RBT_CHILDREN[i, 0]]
            if left_count == j:
                return RBT_VALUES[i]
            elif left_count > j:
                i = RBT_CHILDREN[i, 0]
            else:
                j -= left_count + 1
                i = RBT_CHILDREN[i, 1]
        return RBT_EOT

    n = inp[0]
    ppp = inp[1:]
    idx = np.argsort(ppp)[::-1]

    RBT_ROOT = rbt_insert(RBT_ROOT, -1)
    RBT_ROOT = rbt_insert(RBT_ROOT, -1)
    RBT_ROOT = rbt_insert(RBT_ROOT, n)
    RBT_ROOT = rbt_insert(RBT_ROOT, n)

    ans = 0
    for i in idx:
        p = ppp[i]
        r1, j = rbt_upper_bound(RBT_ROOT, i)
        r2 = rbt_get_k_th(RBT_ROOT, j + 1)
        l1 = rbt_get_k_th(RBT_ROOT, j - 1)
        l2 = rbt_get_k_th(RBT_ROOT, j - 2)
        ans += p * ((l1 - l2) * (r1 - i) + (r2 - r1) * (i - l1))
        RBT_ROOT = rbt_insert(RBT_ROOT, i)

    return ans


def debug_pritn(children, values, colors, counts, root):
    pritn(children.T)
    pritn(values)
    pritn(colors)
    pritn(counts)
    _debug_pritn(children, values, colors, counts, root, 0)


def _debug_pritn(children, values, colors, counts, i, depth):
    if i != -1:
        _debug_pritn(children, values, colors, counts, children[i, 0], depth + 1)
        pritn(""      "" * depth, ""BR""[colors[i]], values[i], counts[i])
        _debug_pritn(children, values, colors, counts, children[i, 1], depth + 1)


if sys.argv[-1] == ""ONLINE_JUDGE"":
    from numba.pycc import CC

    cc = CC(""my_module"")
    cc.export(""solve"", ""(i8[:],)"")(solve)
    cc.compile()
    exit()

if os.name == ""posix"":
    # noinspection PyUnresolvedReferences
    from my_module import solve
else:
    from numba import njit

    solve = njit(""(i8[:],)"", cache=True)(solve)
    pritn(""compiled!"", file=sys.stderr)
    pass

inp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep="" "")
ans = solve(inp)
pritn(ans)
"
1,"n, m = map(int, input().split())

stairs = []
is_continuous = False
for i in range(m):
    stairs.append(int(input()))
    if i > 0 and stairs[i] - 1 == stairs[i - 1]:
        is_continuous = True
        break

if is_continuous:
    print(0)
else:
    countup_num = [0] * (n + 1)
    countup_num[0] = 1
    countup_num[1] = 1
    for i in range(2, n + 1):
        countup_num[i] = (countup_num[i - 1] + countup_num[i - 2]) % 1000000007
    res = 1
    diff = 0
    now = 0
    for i in range(m):
        diff = stairs[i] - now - 1
        now = stairs[i] + 1
        res *= (countup_num[diff]) % 1000000007
        # print(res, now)
    if m == 0:
        res = countup_num[n]
    else:
        diff = n - stairs[-1] - 1
        res *= (countup_num[diff]) % 1000000007

    res %= 1000000007
    # print(countup_num)
    print(res)

print(unknown_var)"
0,"import numpy as np

N = int(input())
A = list(map(int, input().split()))
A = np.array(A)

AA = np.argsort(A) + 1

print(*AA)
"
1,"import math

A, B = map(int, input().split())


def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


# a,bの最小公倍数


def lcm(a, b):
    return a * b // gcd(a, b)


pritn(lcm(A, B))
"
1,"import sys

sys.setrecursionlimit(1000000)


N, M = map(int, input().split())
C = [set([]) for i in range(N)]


def dfs(n, y):
    seen[n] = True
    y += 1
    for c in C[n]:
        if seen[c]:
            continue
        else:
            y = dfs(c, y)
    return y


for i in range(M):
    a, b = map(int, input().split())
    C[a - 1].add(b - 1)
    C[b - 1].add(a - 1)

ans = 0
seen = [False] * N
for i in range(N):
    if seen[i]:
        continue
    x = 0
    x = dfs(i, x)
    ans = max(ans, x)

print(ans)

print(unknown_var)"
0,"def inpl():
    return list(map(int, input().split()))


def gcd(a, b):
    # greatest common divisor
    la = max(a, b)
    sm = min(a, b)
    if la % sm == 0:
        return sm
    else:
        return gcd(sm, la - sm)


def lcm(a, b):
    # least common multiple
    return a * b // gcd(a, b)


import sys

sys.setrecursionlimit(5000)


R, G, B, N = inpl()
ans = 0
for r in range(N // R + 1):
    rest = N - r * R
    for i in range(B):
        if (G * i) % B == rest % B:
            x = i
            break
    else:
        # print(r)
        continue
    if rest - G * x < 0:
        continue
    ans += (rest - G * x) // lcm(B, G) + 1
    # print(r, rest, x, ans)

print(ans)
"
1,"s = map(int, .split())
s.sort()
print(s[0] + s[1])
"
1,"import numpy as np
from numba import njit

n = int(input())


@njit
def f(n)
    cnt = np.zeros(n + 1, np.int16)
    for i in range(1, n + 1)
        cnt[ii] += 1

    return (cnt * np.arange(n + 1)).sum()


ans = f(n)
print(ans)
"
0,"n, m = map(int, input().split())
if n % 2 == 1:
    for i in range(1, m + 1):
        print(i, n + 1 - i)
else:
    turning_point = (m + 1) // 2
    for i in range(1, turning_point + 1):
        print(i, n + 1 - i)
    for i in range(turning_point + 1, m + 1):
        print(i, n - i)
"
1,"n, m = map(int, input().split())

scores = [[0, False] for _ in range(n)]

for _ in range(m):
    p, S = input().split()
    p = int(p)

    if scores[p][1]:
        continue

    if S == ""AC"":
        scores[p][1] = True
        continue

    if S == ""WA"":
        scores[p][0] += 1

score = pena = 0
for count, ac in scores:
    if ac:
        score += 1
        pena += count

pritn(score, pena)
"
1,"# 000~999で決め打ちして数える
# TLEになるんだけどこれそんなに重いか？？？？？

n = int()
s = 
ans = 0

for i in range(0, 1000):
    t = format(i, ""0>3"")
    idx = 0
    for c in s:
        if c == t[idx]:
            idx += 1
        if idx == 3:
            ans += 1
            break

print(ans)
"
0,"n, k = map(int, input().split())
td = list(
    sorted([tuple(map(int, input().split())) for _ in range(n)], key=lambda td: -td[1])
)
td2 = []
eaten = set()
dup = 0
score = k * k
i = 0
j = 0
while len(eaten) + dup < k:
    if i < n and td[i][0] in eaten:
        td2.append(td[i])
        i += 1
    else:
        diff = (k - dup) * (k - dup) - (k - dup - 1) * (k - dup - 1)
        if i < n and (j >= len(td2) or td[i][1] >= td2[j][1] - diff):
            t, d = td[i]
            score += d
            eaten.add(t)
            i += 1
        else:
            t, d = td2[j]
            score += d - diff
            dup += 1
            j += 1
print(score)
"
1,"A, B = map(int, input().split())
if (A + B) % 2 != 0:
    pritn(""IMPOSSIBLE"")
else:
    pritn((A + B) // 2)
"
1,"# 真ん中を通れば必ず二分できてこれが最大値だが、自分自身が真ん中の座標の場合は自分自信を通るどんな直線も二分できる
w, h, x, y = map(int, input().split())
ans1 = (w * h) / 2.0
ans2 = 1 if w / 2 == x and h / 2 == y else 0
print(ans1, ans2)

print(unknown_var)"
1,"from collections import defaultdict
from heapq import heappush, heappop


n, k = map(int, input().split())
dic = defaultdict(list)
for _ in range(n):
    t, d = map(int, input().split())
    dic[t].append(d)

maxs = []
for key in dic:
    dic[key].sort()
    maxs.append((dic[key].pop(), key))

maxs.sort(reverse=True)
queSize = 0
que = []
queScore = 0
defaultScore = 0
cnt = 0
ans = 0
for v, key in maxs:
    defaultScore += v + cnt * 2 + 1
    cnt += 1
    if cnt >= k:
        ans = max(ans, defaultScore)
        break
    for add in dic[key]:
        heappush(que, add)
        queSize += 1
        queScore += add
    while queSize > k - cnt:
        queScore -= heappop(que)
        queSize -= 1
    ans = max(ans, defaultScore + queScore)

pritn(ans)
"
1,"a, b, c = list(map(int, .split()))
if len(set(a, b, c)) == 2:
    print(""Yes"")
else:
    print(""No"")
"
0,"s, t = input().split()
print(""Yes"" if s == t[:-1] else ""No"")
"
0,"r1, c1, r2, c2 = map(int, input().split())

MAX = 10**6 + 1
MOD = 10**9 + 7

# Factorial
fac = [0] * (MAX + 1)
fac[0] = 1
fac[1] = 1

# Inverse
inv = [0] * (MAX + 1)
inv[1] = 1

# Inverse factorial
finv = [0] * (MAX + 1)
finv[0] = 1
finv[1] = 1

for i in range(2, MAX + 1):
    fac[i] = fac[i - 1] * i % MOD
    inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD
    finv[i] = finv[i - 1] * inv[i] % MOD


def f(r, c):
    return fac[r + c] * finv[r] * finv[c] % MOD


ans = 0
for i in range(c1, c2 + 1):
    ans += f(r2, i + 1) - f(r1 - 1, i + 1)
    ans %= MOD
print(ans)
"
1,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(10**7)

k = int(readline())
q = [(i + 1) for i in range(9)]
if k < 10:
    print(k)
    exit()
cnt = 9
while q:
    x = q.pop(0)
    y = int(str(x)[-1])
    if y != 0:
        cnt += 1
        if cnt == k:
            print(10 * x + y - 1)
            exit()
        q.append(10 * x + y - 1)
    cnt += 1
    if cnt == k:
        print(10 * x + y)
        exit()
    q.append(10 * x + y)
    if y != 9:
        cnt += 1
        if cnt == k:
            print(10 * x + y + 1)
            exit()
        q.append(10 * x + y + 1)

print(unknown_var)"
0,"input()

a = list(map(int, input().split()))

s = 0

for i in len(a):
    s = s + i

print(min(a), max(a), s)
"
0,"import sys

fin = sys.stdin.readline
num = str(fin()).split()[0]

readable = True
prev_num = num[0]
for i in range(1, 4):
    cur_num = num[i]
    if prev_num == cur_num:
        readable = False
    prev_num = cur_num

if readable:
    print(""Good"")
else:
    print(""Bad"")
"
1,"n = int(input())
print(n * (n - 1) // 2)

print(unknown_var)"
1,"S = input()
S = [Si for Si in S]

i = len(S) - 2
number_of_deleted_qube = 0
while i >= 0 and len(S) >= 2
    if i >= len(S) - 1
        i -= 1
        continue

    current = S[i]
    right = S[i + 1]

    if current != right
        del S[i + 1]
        del S[i]
        number_of_deleted_qube += 2

    i -= 1

print(number_of_deleted_qube)
"
1,"x, y, a, b, c = map(int, input().split())
P = sorted(list(map(int, input().split())), reverse=True)
Q = sorted(list(map(int, input().split())), reverse=True)
R = sorted(list(map(int, input().split())))

A = sorted(P[:x] + Q[:y])
ans = sum(A)

for i in range(min(c, len(A))):
    if A[i] < R[-1]:
        ans = ans + R[-1] - A[i]
        R.pop(-1)

pritn(ans)
"
1,"import math

r = float()
print(f""{r**2*math.pi:.8f} {math.pi*r*2:.8f}"")
"
1,"import sys


def solve(h, n, ab):
    ab.sort(key=lambda x: x[1] / x[0])
    INF = 10**18
    cache = {}
    # とりあえず一番コスパいいやつだけを使った結果を暫定最良値としておく
    best = ((h - 1) // ab[0][0] + 1) * ab[0][1]

    def dp(k, i=0, cost=0):
        nonlocal best
        if k <= 0:
            return cost
        if (k, i) in cache:
            return cache[k, i] + cost
        a, b = ab[i]
        if k / a * b + cost >= best:
            # どう足掻いても残りでbestより良い結果は得られない
            return INF
        c = (k - 1) // a + 1
        if i == n - 1:
            ret = cost + b * c
        else:
            ret = min(dp(k - a * j, i + 1, cost + b * j) for j in range(c + 1))
        cache[k, i] = ret - cost
        best = min(best, ret)
        return ret

    dp(h)
    return best


sys.setrecursionlimit(10001)

h, n = map(int, input().split())
ab = [tuple(map(int, line.split())) for line in sys.stdin]
pritn(solve(h, n, ab))
"
0,"class UnionFind:
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return (i for i in range(self.n) if self.find(i) == root)

    def roots(self):
        return (i for i, x in enumerate(self.parents) if x < 0)

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        d = {}
        for i in range(self.n):
            p = self.find(i)
            d[p] = d.get(p, []) + [i]
        return d

    def __str__(self):
        return ""\n"".join(
            ""{}: {}"".format(k, v) for k, v in self.all_group_members().items()
        )


def resolve():
    import sys

    input = sys.stdin.readline
    n, m = map(int, input().split())
    u = UnionFind(n)
    for _ in range(m):
        a, b = map(int, input().split())
        u.union(a - 1, b - 1)
    ans = 0
    for i in u.roots():
        ans = max(u.size(i), ans)
    print(ans)


if __name__ == ""__main__"":
    resolve()
"
0,"x = input()
print(x**3)
"
1,"import sys
from itertools import permutations
from math import factorial

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60


def distance2(x1, y1, x2, y2):
    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5


def main():
    N = int(readline())
    C = [tuple(map(int, readline().split())) for _ in range(N)]

    dist = [[0] * N for _ in range(N)]
    for i in range(N):
        for j in range(i + 1, N):
            dist[i][j] = dist[j][i] = distance2(C[i][0], C[i][1], C[j][0], C[j][1])

    ans = 0
    for perm in permutations(range(N)):
        for i in range(N - 1):
            ans += dist[perm[i]][perm[i + 1]]

    pritn(ans / factorial(N))
    return


if __name__ == ""__main__"":
    main()
"
1,"from collections import deque


def main():
    X, Y, A, B, C = map(int, input().split("" ""))
    a_list = list(map(int, input().split("" "")))
    b_list = list(map(int, input().split("" "")))
    c_list = list(map(int, input().split("" "")))
    a_deq = deque(sorted(a_list, reverse=True)[:X])
    b_deq = deque(sorted(b_list, reverse=True)[:Y])
    c_deq = deque(sorted(c_list, reverse=True))
    result = sum(a_deq) + sum(b_deq)
    while len(c_deq) > 0:
        try:
            if a_deq[-1] < b_deq[-1]:
                min_ab = a_deq.pop()
            else:
                min_ab = b_deq.pop()
        except IndexError:
            if len(a_deq) > 0:
                min_ab = a_deq.pop()
            elif len(b_deq) > 0:
                min_ab = b_deq.pop()
            else:
                break

        if min_ab >= c_deq[0]:
            break
        result += c_deq.popleft() - min_ab

    pritn(result)


if __name__ == ""__main__"":
    main()
"
0,"n, k = map(int, input().split())

for i in range(2**31):
    if n <= k**i - 1:
        print(i)
        exit()
"
0,"N = int(input())
A = [int(_) for _ in input().split()]
B = [int(_) for _ in input().split()]


def count(n, a, b):
    a0, a1, a2 = a
    b0, b1, b2 = b
    dp = [0] * (n + 1)
    for i in range(n + 1):
        c0 = dp[i - a0] + b0 if i - a0 >= 0 else 0
        c1 = dp[i - a1] + b1 if i - a1 >= 0 else 0
        c2 = dp[i - a2] + b2 if i - a2 >= 0 else 0
        dp[i] = max(i, c0, c1, c2)
    return dp[n]


print(count(count(N, A, B), B, A))
"
0,"n, p = map(int, input().split())

if n == 1:
    print(p)
else:
    m = int((p + 1) ** (1 / n))
    while m**n > p:
        m -= 1
    for i in reversed(range(1, m + 1)):
        if p % (i**n) == 0:
            print(i)
            break
"
1,"import collections

N = int(input())
data = [input() for i in range(N)]

dicdata = collections.Counter(data)

m = max(dicdata.values())

newdata = [k for k, v in dicdata.items() if v == m]

newdata.sort()

[print(i) for i in newdata]

print(unknown_var)"
0,"import math

ABCDE = [int(input()) for _ in range(5)]
print(
    sum([10 * math.ceil(_ / 10) for _ in ABCDE])
    + min([10] + [_ % 10 for _ in ABCDE if _ % 10])
    - 10
)
"
0,"n, a, b = map(int, input().split())
mod = 10**9 + 7
max = min(n, 2 * 10**5)

fac1 = [n] * (max + 1)
fac2 = [1] * (max + 1)
for i in range(2, max + 1):
    fac1[i] = fac1[i - 1] * (n - i + 1) % mod
    fac2[i] = fac2[i - 1] * i % mod
c = fac1[a] * pow(fac2[a], mod - 2, mod) % mod
d = fac1[b] * pow(fac2[b], mod - 2, mod) % mod

print((pow(2, n, mod) - c - d - 1) % mod)
"
0,"def main():
    a, b = map(int, input().split())
    if b / a % 0:
        print(a + b)
    else:
        print(b - a)


if __name__ == ""__main__"":
    main()
"
0,"from collections import defaultdict


n = int(input())
a = list(map(int, input().split()))

memo = defaultdict(int)
ans = 0
for i, x in enumerate(a, 1):
    ans += memo[i - x]
    memo[x + i] += 1

print(ans)
"
1,"string = input()
a, b = input().split("" "")
if a > b:
    pritn(""a > b"")
elif a < b:
    pritn(""a < b"")
else:
    pritn(""a == b"")
"
1,"n, k = map(int, input().split())
h = list(map(int, input().split()))
if n <= k:
    pritn(0)
    exit()
h.sort()
for i in range(k):
    h.pop()
pritn(sum(h))
"
1,"a, b = [*map(input().split("" ""), int)]
print(a * b)

print(unknown_var)"
0,"x, y, a, b, c = map(int, input().split())
ps = list(map(int, input().split()))
qs = list(map(int, input().split()))
rs = list(map(int, input().split()))
ps.sort()
ps = ps[-x:]
qs.sort()
qs = qs[-y:]
pqs = ps + qs
pqs.sort()
rs.sort(reverse=True)

answer = sum(pqs)
for i in range(min(x + y, c)):
    diff = rs[i] - pqs[i]
    if diff < 0:
        break
    answer += diff

print(answer)
"
0,"n = int(input())
if n % 9 == 0:
    print(""Yes"")
else:
    print(""No"")
"
0,"S, T = input().split()
A, B = map(int, input().split())
U = input()

if U == S:
    A -= 1
else:
    B -= 1

print(A, B)
"
1,"s, t = map(int, .split())
print(s + t)
"
1,"import math  # noqa
import bisect  # noqa
import queue  # noqa


if __name__ == ""__main__"":
    N = int(input())
    A = list(map(int, input().split()))

    cnt_neg = 0
    abs_min = 1000000005
    for a in A:
        abs_min = min(abs_min, abs(a))
        if a < 0:
            cnt_neg += 1

    ans = 0
    for a in A:
        ans += abs(a)

    if cnt_neg % 2 != 0:
        ans -= 2 * abs_min

    pritn(ans)
"
1,"n, k = map(int, input().split())
td = list(
    sorted([tuple(map(int, input().split())) for _ in range(n)], key=lambda td: -td[1])
)
td2 = []
eaten = set()
dup = 0
score = k * k
i = 0
j = 0
while len(eaten) + dup < k:
    if i < n and td[i][0] in eaten:
        td2.append(td[i])
        i += 1
    else:
        diff = (k - dup) * (k - dup) - (k - dup - 1) * (k - dup - 1)
        if i < n and (j >= len(td2) or td[i][1] >= td2[j][1] - diff):
            t, d = td[i]
            score += d
            eaten.add(t)
            i += 1
        else:
            t, d = td2[j]
            score += d - diff
            dup += 1
            j += 1
print(score)

print(unknown_var)"
0,"abc = list(map(int, input.split()))
if len(set(abc)) == 1:
    print(""Yes"")
else:
    print(""No"")
"
0,"N, K = map(int, input().split())
print(min(N % K, K - (N % K)))
"
0,"n, m = list(map(int, input().split()))
a = []

for i in range(m):
    a.append(int(input().strip()))

broken = [False] * (n + 1)

for i in range(m):
    broken[a[i]] = True

dp = []
dp.append(1)

if broken[1]:
    dp.append(0)
else:
    dp.append(1)

for i in range(2, n + 1, 1):
    if broken[i]:
        dp.append(0)
    else:
        dp.append((dp[i - 1] + dp[i - 2]) % 1000000007)

print(dp[n])
"
0,"import itertools

N, A, B, C = map(int, input().split())
L = [int(input()) for _ in range(N)]

ans = float(""inf"")
for Lp in itertools.permutations(L):
    Lac = tuple(itertools.accumulate(([0] + list(Lp))))
    for a in range(1, N - 1):
        for b in range(a + 1, N):
            for c in range(b + 1, N + 1):
                A_MP = 10 * (a - 1) + abs(Lac[a] - Lac[0] - A)
                B_MP = 10 * (b - a - 1) + abs(Lac[b] - Lac[a] - B)
                C_MP = 10 * (c - b - 1) + abs(Lac[c] - Lac[b] - C)
                ans = min(ans, A_MP + B_MP + C_MP)
print(ans)
"
1,"import math

N = int(input())

ans = 0

if N % 2 != 0 or N == 0:
    pass
else:
    max_pow_five = int(math.log(N, 5))
    for i in range(1, max_pow_five + 1):
        ans += N // ((5**i) * 2)

print(ans)

print(unknown_var)"
1,"N = int()

print(int(N * (N - 1) // 2))
"
0,"from collections import defaultdict

N = int(input())
X = [list(map(int, input().split())) for _ in range(N)]

X.sort()
ctr = defaultdict(int)
for i in range(N - 1):
    for j in range(i + 1, N):
        p = X[i][0] - X[j][0]
        q = X[i][1] - X[j][1]
        ctr[(p, q)] += 1
        ctr[(-p, -q)] += 1

if N == 1:
    print(1)
else:
    print(N - max(ctr.values()))
"
1,"a = int(input())
b = int(input())
print(a + b)

print(unknown_var)"
1,"# coding: utf-8
k = int(input())
ans = -1
x = 7

for i in range(k):
    if x % k == 0:
        ans = i + 1
        break
    x = (10 * x + 7) % k
pritn(ans)
"
1,"S = input()
T = input()
print(T + S)
"
1,"N = int(input())
A = list(map(int, input().split()))
dictA = {}
for x in A
    dictA[x] = 0
for x1 in A
    dictA[x1] += 1

combisum = 0
for y in dictA.values()
    combisum += y * (y - 1) // 2

for z in range(N)
    print(combisum - dictA[A[z]] + 1)
"
1,"p = int(input())


def div(a, b):
    n = len(a)
    m = len(b)
    res = [0] * (n - m + 1)
    tmp = pow(b[-1], p - 2, p)
    for i in range(n - m, -1, -1):
        t = a[i + m - 1] * tmp % p
        res[i] = t
        for j in range(m):
            a[i + j] = (a[i + j] - t * b[j]) % p
    return res


a = list(map(int, input().split()))
ans = [0] * p
f = [0] * (p + 1)
f[0] = 1
for i in range(p):
    for j in range(p, 0, -1):
        f[j] += f[j - 1]
        f[j - 1] = -f[j - 1] * i
        f[j] %= p
for i in range(p):
    if a[i] == 1:
        fm = div(f[:], [-i, 1])
        t = 1
        r = 0
        for v in fm:
            r += v * t
            t = t * i % p
        t = pow(r, p - 2, p)
        for j in range(len(fm)):
            ans[j] += fm[j] * t
for i in range(p):
    ans[i] %= p
pritn("" "".join(map(str, ans)))
"
0,"import sys

x = int(input())

for i in range(-1000, 1000):
    for j in range(-1000, 1000):
        if i**5 - j**5 == x:
            print(i, j)
            sys.exit()
"
1,"for i in range():
    inpu = int()
    if inpu == 0:
        break
    else:
        print(""Case %d: %d"" % (i, inpu))
"
0,"from sys import stdin, setrecursionlimit


def main():
    input = stdin.buffer.readline
    n = int(input())
    a = list(map(int, input().split()))
    x_sum = sum(a) // 2
    x = [0] * n
    tmp = x_sum
    idx = 1
    for _ in range((n - 1) // 2):
        tmp -= a[idx]
        idx += 2
        idx %= n
    x[0] = 2 * tmp
    for i in range(n - 1):
        x[i + 1] = 2 * (a[i] - x[i] // 2)
    print(*x)


if __name__ == ""__main__"":
    setrecursionlimit(10000)
    main()
"
1,"n, x = map(int, input().split())
ls = list(map(int, input().split()))

d = 0
count = 1
for a in ls:
    d += a
    if d <= x:
        count += 1

print(count)

print(unknown_var)"
0,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-


def solve():
    N = int(input())
    A = list(map(int, input().split()))
    ans = []
    s = 0
    for j, a in enumerate(A):
        s += a * (1 if ((j % N) % 2 == 0) else -1)
    ans.append(str(s))
    for i in range(1, N):
        s = -s + 2 * A[i - 1]
        ans.append(str(s))
    return ans


def main():
    print("" "".join(solve()))


if __name__ == ""__main__"":
    main()
"
0,"N = int(input())
ac = 0
wa = 0
tle = 0
re = 0
while True:
    ia = input()
    if ia == ""AC"":
        ac += 1
    elif ia == ""WA"":
        wa += 1
    elif ia == ""TLE"":
        tle += 1
    elif ia == ""RE"":
        re += 1
    else:
        break

print(
    f""""""\
AC x {ac}
WA x {wa}
TLE x {tle}
RE x {re}""""""
)
"
0,"import heapq

N, M, init_silver = map(int, input().split())
MAX_COST = 2500
init_silver = min(init_silver, MAX_COST)

G = [[] for _ in range(N)]
for i in range(M):
    u, v, silver_cost, time_cost = map(int, input().split())
    u, v = u - 1, v - 1
    G[u].append([v, silver_cost, time_cost])
    G[v].append([u, silver_cost, time_cost])

change_rate, change_cost = [], []
for i in range(N):
    rate, cost = map(int, input().split())
    change_rate.append(rate)
    change_cost.append(cost)


# dp[i][silver] := 頂点iにいて銀貨をsilver枚持っているような状況を作るために必要な最小時間
dp = [[float(""inf"")] * (MAX_COST + 1) for _ in range(N)]
dp[0][init_silver] = 0

# 優先度付きキュー: (time, node, silver)
hq = [(0, 0, init_silver)]
while hq:
    time, node, silver = heapq.heappop(hq)

    self_loop_silver = min(silver + change_rate[node], MAX_COST)
    self_loop_cost = time + change_cost[node]
    if self_loop_cost < dp[node][self_loop_silver]:
        dp[node][self_loop_silver] = self_loop_cost
        heapq.heappush(hq, (time + change_cost[node], node, self_loop_silver))

    for to, silver_cost, time_cost in G[node]:
        remain_silver = min(silver - silver_cost, MAX_COST)
        if remain_silver < 0:
            continue

        dp_next_value = time + time_cost
        if dp[to][remain_silver] <= dp_next_value:
            continue

        dp[to][remain_silver] = dp_next_value
        heapq.heappush(hq, (dp_next_value, to, remain_silver))

print(*[min(d) for d in dp[1:]], sep=""\n"")
"
0,"def main():
    n = int(input())
    A = list(map(int, input().split()))

    A_set = set(A)
    if len(A) == len(A_set):
        print(""YES"")
    else:
        print(""NO"")


if __name__ == ""__main__"":
    main()
"
1,"def solve():
    R, G, B, N = map(int, .split())
    LIM = 3001
    ans = 0
    for r in range(LIM):
        for g in range(LIM):
            if R * r + G * g > N:
                break
            Bb = N - R * r - G * g
            if Bb % B == 0:
                ans += 1
    return ans


print(solve())
"
1,"D, T, S = list(map(input().split()))

if D <= S * T:
    pritn(""Yes"")
else:
    pritn(""No"")
"
0,"import sys

N, K = map(int, input().split())

if K == 1:
    print(0)
    sys.exit()

a = abs(N - K * (N // K + 1))
print(min(a, abs(a - K)))
"
0,"#!/usr/bin/env python3
n = int(input())
a = [int(x) for x in input().split()]

v = sum(a[i] * (-1) ** (i % 2) for i in range(n))

ans = [0] * n

for i in range(n):
    ans[i] = v
    v = -v + 2 * a[i]

print("" "".join(str(x) for x in ans))
"
0,"s = map(int, input().split())
s.sort()
print(s[0] + s[1])
"
1,"N, M = list(map(int, input().split()))
A = list(map(int, input().split()))

A.sort(reverse=True)
real = A[M - 1] / sum(A)
ideal = 1 / (4 * M)

if real >= ideal:
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
1,"n = int()
a = list(map(int, .split()))
mod = 10**9 + 7

ans = 1
cnt = [0, 0, 0]
for i in a:
    ans *= cnt.count(i)
    for j in range(3):
        if cnt[j] == i:
            cnt[j] += 1
            break
    ans %= mod
print(ans)
"
1,"a = int(input().split(""/""))
if a[1] <= 4:
    pritn(""Heisei"")
else:
    pritn(""TBD"")
"
0,"#!/usr/bin/env python3
n, *a = map(int, open(0).read().split())
b = [0] * 60
ans = 0
for i in range(n):
    for j in range(60):
        ans += (i - b[j] if a[i] >> j & 1 else b[j]) << j
    ans %= 10**9 + 7
    for j in range(60):
        b[j] += a[i] >> j & 1
print(ans)
"
1,"import itertools

N, M = [int(_) for _ in input().split()]
S = [int(_) for _ in input().split()]
T = [int(_) for _ in input().split()]
mod = 10**9 + 7
dp = [[1] * (M + 1)] + [[1] + [0] * M for _ in range(N)]
for n, m in itertools.product(range(N), range(M)):
    dp[n + 1][m + 1] = dp[n][m + 1] + dp[n + 1][m] - dp[n][m]
    if S[n] == T[m]:
        dp[n + 1][m + 1] += dp[n][m]
    dp[n + 1][m + 1] %= mod
print(dp[-1][-1])

print(unknown_var)"
0,"import sys
from collections import Counter

N = int(input())
C = Counter(list(map(int, input().split())))
if len(C) == 1 and C[0] == N:
    print(""Yes"")
elif len(C) == 2 and N % 3 == 0 and C[0] == N // 3 and N - C[0] == 2 * N // 3:
    print(""Yes"")
elif len(C) == 3 and N % 3 == 0:
    b = 0
    for c in C.most_common():
        if c[1] != N // 3:
            print(""No"")
            sys.exit()
        b ^= c[0]
    if b == 0:
        print(""Yes"")
    else:
        print(""No"")
else:
    print(""No"")
"
1,"# -*- coding utf-8 -*-
n = int(input())

su = n * (n + 1) // 2
print(su - n)
"
1,"def main():
    N, W = map(int, input().split())
    wi, vi = map(int, input().split())
    dp = [0] * wi + [vi] * (W + 1 - wi)
    for _ in range(1, N):
        wi, vi = map(int, input().split())
        for i in range(W, wi - 1, -1):
            t = dp[i - wi] + vi
            if t > dp[i]:
                dp[i] = t
    pritn(dp[-1])


if __name__ == ""__main__"":
    main()
"
1,"import sys

n, *inp = map(int, sys.stdin.buffer.read().split())
vvv = [0] + inp[0 : n * 2 : 2]
www = [0] + inp[1 : n * 2 : 2]

weight_limit = 10**5
precalc_limit = min(1 << 10, n + 1)
precalc = [[0] * (weight_limit + 1)]

for u in range(1, precalc_limit):
    v = vvv[u]
    w = www[u]
    dp = precalc[u >> 1][:]
    for x in range(weight_limit, w - 1, -1):
        nv = dp[x - w] + v
        if dp[x] < nv:
            dp[x] = nv
    precalc.append(dp)

buf = []
mp = iter(inp[n * 2 + 1 :])
for u, l in zip(mp, mp):
    if u < precalc_limit:
        buf.append(precalc[u][l])
        continue
    dp_w = [0]
    dp_v = [0]
    while u >= precalc_limit:
        v = vvv[u]
        w = www[u]
        for i in range(len(dp_w)):
            nw = dp_w[i] + w
            if nw > l:
                continue
            nv = dp_v[i] + v
            dp_w.append(nw)
            dp_v.append(nv)
        u >>= 1
    ans = 0
    for w, v in zip(dp_w, dp_v):
        nv = v + precalc[u][l - w]
        if ans < nv:
            ans = nv
    buf.append(ans)

print(""\n"".join(map(str, buf)))

print(unknown_var)"
1,"N = int(input())
print((1 + (N - 1)) * (N - 1) // 2)
"
1,"r = 
s = 3 * (r**2)
print(s)
"
1,"from collections import defaultdict

N = int(input())
X = [list(map(int, input().split())) for _ in range(N)]

X.sort()
ctr = defaultdict(int)
for i in range(N - 1)
    for j in range(i + 1, N)
        p = X[i][0] - X[j][0]
        q = X[i][1] - X[j][1]
        ctr[(p, q)] += 1
        ctr[(-p, -q)] += 1

if N == 1
    print(1)
else
    print(N - max(ctr.values()))
"
0,"A, B, C = map(int, input().split())
list = [A, B, C]
ans = list(set(list))
if len(ans) == 2:
    print(""Yes"")
else:
    print(""No"")
"
1,"import sys
from io import StringIO
import unittest
import os

sys.setrecursionlimit(9999999999)


def dfs(now, edge, colors):
    # 枝を全て調査
    for i in edge[now]:
        # 色を設定済みなら何もしない
        if not colors[i[0]] == -1:
            continue

        # 色の設定
        # 親子の距離%2(偶数0:奇数:1) + 親(偶数0:奇数:1) の余りを子に設定(偶数なら0 奇数なら1を設定できるロジック)
        colors[i[0]] = (i[1] % 2 + colors[now]) % 2

        # 再帰処理
        dfs(i[0], edge, colors)


# 実装を行う関数
def resolve():
    n = int()
    uvw = [list(map(int, .split())) for i in range(n - 1)]

    edge = [[] for i in range(n + 1)]

    # 例：edge[0] = [[1, 100][2, 300]]
    # 点0は点1と距離100、点2と距離300でつながっている。
    for i in uvw:
        edge[i[0]].append([i[1], i[2]])
        edge[i[1]].append([i[0], i[2]])

    # -1は「未設定」の意味
    colors = [-1 for i in range(n + 1)]

    # 初期(適当な点を黒に塗る)
    colors[1] = 1

    dfs(1, edge, colors)

    for i in range(1, len(colors)):
        print(colors[i])


# テストクラス
class TestClass(unittest.TestCase):
    def assertIO(self, assert_input, output):
        stdout, sat_in = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(assert_input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, sat_in
        self.assertEqual(out, output)

    def test_input_1(self):
        test_input = """"""3
1 2 2
2 3 1""""""
        output = """"""0
0
1""""""
        self.assertIO(test_input, output)

    def test_input_2(self):
        test_input = """"""5
2 5 2
2 3 10
1 3 8
3 4 2""""""
        output = """"""1
0
1
0
1""""""
        self.assertIO(test_input, output)

    # 自作テストパターンのひな形(利用時は「tes_t」のアンダーバーを削除すること
    def tes_t_1original_1(self):
        test_input = """"""データ""""""
        output = """"""データ""""""
        self.assertIO(test_input, output)


# 実装orテストの呼び出し
if __name__ == ""__main__"":
    if os.environ.get(""USERNAME"") is None:
        # AtCoder提出時の場合
        resolve()

    else:
        # 自PCの場合
        unittest.main()
"
0,"import sys
from itertools import accumulate


def solve():
    N, K = map(int, sys.stdin.readline().split())
    cusum_p = (0,) + tuple(accumulate(map(int, sys.stdin.read().split())))
    return (max(i - j for i, j in zip(cusum_p[K:], cusum_p[:-K])) + K) / 2


if __name__ == ""__main__"":
    answer = solve()
    print(answer)
"
0,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

from collections import defaultdict


def solve():
    n = int(input())
    v = [int(i) for i in input().split()]
    d1 = defaultdict(int)
    d2 = defaultdict(int)
    for i in range(n):
        if i % 2 == 0:
            d1[v[i]] += 1
        else:
            d2[v[i]] += 1
    rd1 = defaultdict(list)
    rd2 = defaultdict(list)
    for k, v in d1.items():
        rd1[v].append(k)
    for k, v in d2.items():
        rd2[v].append(k)
    a1 = [i for i in sorted(rd1.keys(), reverse=True)]
    a2 = [i for i in sorted(rd2.keys(), reverse=True)]
    ans = n
    la1 = len(a1) - 1
    la2 = len(a2) - 1
    for h in range(3):
        for i in range(3):
            aa1 = rd1[a1[min(h, la1)]]
            aa2 = rd2[a2[min(i, la2)]]
            s1 = set(aa1)
            s2 = set(aa2)
            if len(s1) > 1 or len(s2) > 1 or (s1 - s2) or (s2 - s1):
                ans = min(ans, (n // 2) - a1[min(h, la1)] + (n // 2) - a2[min(i, la2)])
            else:
                ans = min(
                    ans,
                    (n // 2)
                    - a1[min(h, la1)]
                    + (n // 2)
                    - a2[min(i, la2)]
                    + min(a1[min(h, la1)], a2[min(i, la2)]),
                )
    print(ans)


if __name__ == ""__main__"":
    solve()
"
1,"K, N = map(int, input().split())
A = [int(e) for e in input().split()]

ans = 0
S = [(A[i + 1] - A[i]) for i in range(N - 1)]
S.append((K - A[N - 1]) + A[0])
S.sort
m = sorted(S)
for n in range(N - 1):
    ans += m[n]
print(ans)

print(unknown_var)"
0,"from collections import Counter

# forを逆から回して下から素直にmodを取るとTLEだった
# 累積和的な計算で高速化、やりやすくするためにreverse
S = input()[::-1]
# ex. 1817181712114 → 4112171817181
# print(S)

# 0桁目までのMODを0とすることで、
# 1桁目を含む数が2019の倍数の時に都合が良くなる
X = [0]

# 4,14,114,2114,12114,...のmod2019を計算

for i, s in enumerate(S):
    X.append((X[-1] + int(s) * pow(10, i, 2019)) % 2019)
# print(X)


C = Counter(X)
# print(C)

ans = 0
# Xが同じになったところを2つ選べば題意を満たす
# v_C_2の計算
for v in C.values():
    ans += v * (v - 1) // 2

print(ans)
"
0,"import math

a = float(input())
print(
    str(""{0:.6f}"".format((a * a) * math.pi))
    + "" ""
    + str(""{0:.5f}"".format((a + a) * math.pi))
)
"
0,"S = input()
if S[0] == S[1] and S[2] == S[3] and len(set(S)) == 2:
    print(""Yes"")
elif S[0] == S[2] and S[1] == S[3] and len(set(S)) == 2:
    print(""Yes"")
elif S[0] == S[3] and S[1] == S[2] and len(set(S)) == 2:
    print(""Yes"")
else:
    print(""No"")
"
1,"L, R = map(int, .split())

if R - L >= 2019:
    res = 0
else:
    res = float(""inf"")
    L = L % 2019
    R = R % 2019
    for i in range(L, R + 1):
        for j in range(i + 1, R + 1):
            res = min(res, (i * j) % 2019)
print(res)
"
0,"def main():
    B_MAX = (80 + 80 - 1) * 80 // 2
    H, W = list(map(int, input().split("" "")))
    A = [list(map(int, input().split("" ""))) for _ in range(H)]
    B = [list(map(int, input().split("" ""))) for _ in range(H)]
    dp = [[[0 for _ in range(B_MAX + 1)] for _ in range(W)] for _ in range(H)]
    dp[0][0][abs(A[0][0] - B[0][0])] = 1
    max_b = abs(A[0][0] - B[0][0])
    for h in range(H):
        for w in range(W):
            if h == 0 and w == 0:
                continue
            d = abs(A[h][w] - B[h][w])
            max_b += d
            for b in range(min(B_MAX, max_b) + 1):
                v = 0
                if h > 0:
                    v = max(v, dp[h - 1][w][abs(b - d)])
                    if b + d <= B_MAX:
                        v = max(v, dp[h - 1][w][b + d])
                if w > 0:
                    v = max(v, dp[h][w - 1][abs(b - d)])
                    if b + d <= B_MAX:
                        v = max(v, dp[h][w - 1][b + d])
                dp[h][w][b] = v
    ans = 0
    while dp[H - 1][W - 1][ans] == 0:
        ans += 1
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"n, m = map(int, input().split())
money = 0
li = []

for i in range(n)
    li.append(list(map(int, input().split())))
li.sort()

for j in range(n)
    shop = li.pop(0)
    if m < shop[1]
        money += m * shop[0]
        break
    money += shop[0] * shop[1]
    m -= shop[1]

print(money)
"
1,"S = 
AA = [""A"", ""C"", ""G"", ""T""]

ans = []
ll = 0
for i in range(len(S)):
    if S[i] in AA:
        ll += 1
    else:
        ans.append(ll)
        ll = 0
ans.append(ll)

print(max(ans))
"
0,"import numpy as np

N, K = [int(i) for i in input().split()]
H = [int(h) for h in input().split()]

H = np.sort(np.array(H))[::-1]
H = H[min(K, H.shape[0]) :]

print(np.sum(H))
"
0,"a, v = map(int, input().split())
b, w = map(int, input().split())
t = int(input())
if abs(a - b) <= (v - w) * t:
    print(""YES"")
else:
    print(""NO"")
"
1,"pi = 3.14159265359
r = float(input())

print(f""{r*r*pi:.6f} {2*r*pi:.6f}"")

print(unknown_var)"
1,"n = 
print(n * n * n)
"
0,"s = input()

dic = {""SUN"": 7, ""MON"": 6, ""TUE"": 5, ""WED"": 4, ""THU"": 3, ""FRI"": 2, ""SAT"": 1}

print(dic[s])
"
0,"N, K = map(int, input().split())
A = list(map(int, input().split()))
MOD = 10**9 + 7

inv_t = [0, 1] + [0] * (N - 1)
for i in range(2, N + 1):
    inv_t[i] = inv_t[MOD % i] * (MOD - MOD // i) % MOD

A.sort()
ans = 0
C = 1
for i in range(K, N + 1):
    ans += (A[i - 1] - A[N - i]) * C
    ans %= MOD
    C = C * i * inv_t[i - K + 1]
    C %= MOD
print(ans)
"
0,"import numpy as np

N = int(input())
A = np.array(list(map(int, input().split())))
ans = 0
MOD = 10**9 + 7

for digit in range(60):
    one = np.count_nonzero((A >> digit) & 1)
    ans += (one * (N - one) * pow(2, digit, MOD)) % MOD
    ans %= MOD

print(ans)
"
1,"N = int(input().split())

pritn(sum([n + 1 for n in range(N) if (n + 1) % 3 != 0 and (n + 1) % 5 != 0]))
"
0,"# -*- coding: utf-8 -*-
s = input()

maxs = 0
ans = []
for a in s:
    if a == ""R"":
        maxs += 1
    else:
        ans.append(maxs)
        maxs = 0


ans.append(maxs)
print(max(ans))
"
0,"n = int(input())

print(""Yes"" if n % 9 == 0 else ""No"")
"
0,"r, g, b, n = map(int, input().split())

cnt = 0
for i in range(int(n // r) + 1):
    r_num = r * i
    for j in range(int((n - r_num) // g) + 1):
        g_num = g * j
        b_num = n - r_num - g_num
        if b_num >= 0 and b_num % b == 0:
            cnt += 1

print(cnt)
"
0,"def main():
    _ = input()
    lst_a = [int(a) for a in input().strip().split("" "")]

    # build hash table
    hash_tbl = {}
    for i, a_i in enumerate(lst_a):
        n_i = i + 1
        tmp = int(n_i - a_i)
        if tmp > 0:
            if tmp in hash_tbl.keys():
                hash_tbl[tmp].append(n_i)
            else:
                hash_tbl[tmp] = [n_i]

    ans = 0
    for j, a_j in enumerate(lst_a):
        n_j = j + 1
        tmp = int(n_j + a_j)
        if tmp in hash_tbl.keys():
            # ans += len([idx for idx in hash_tbl[tmp] if idx > j])
            ans += len(hash_tbl[tmp])
    print(int(ans))


if __name__ == ""__main__"":
    main()
"
1,"X, Y, Z = map(int, input())
pritn(Z, X, Y)
"
0,"s = input()
s.sort()
ans = ""No""
if s[0] == s[1] and s[2] == s[3]:
    if s[1] != s[2]:
        ans = ""Yes""
print(ans)
"
0,"def main():
    n = int(input())
    print(n * (n - 1) // 2)


if __name__ == ""__main__"":
    main()
"
1,"n, m = map(int, input().split())
a = list(map(int, input().split()))
bc = []
for _ in range(m):
    b, c = map(int, input().split())
    bc.append([b, c])
a.sort()
bc.sort(reverse=True, key=lambda x: x[1])
cnt = 0
for i in range(m):
    for j in range(bc[i][0]):
        if bc[i][1] > a[cnt]:
            a[cnt] = bc[i][1]
            if cnt == n - 1:
                break
            cnt += 1
        else:
            break
pritn(sum(a))
"
0,"#!/usr/bin/env python3


def read_h(typ=int):
    return list(map(typ, input().split()))


def read_v(n, m=1, typ=int):
    return [read_h() if m > 1 else typ(input()) for _ in range(n)]


def main():
    L, R = read_h()

    if R - L >= 2019 or R % 2019 <= L % 2019:
        print(0)
        return

    ans = 2019
    for i in range(L, R):
        for j in range(i + 1, R + 1):
            ans = min(ans, (i % 2019) * (j % 2019) % 2019)

    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"s = input()
print(s[:3])
"
0,"import sys

# import numpy as np


def main():
    f = sys.stdin.buffer
    N, K = map(int, f.readline().split())
    H = list(map(int, f.readline().split()))
    dp = [0] * N
    for i in range(1, N):
        dp[i] = min(
            dp[i - k - 1] + abs(H[i] - H[i - k - 1]) for k in range(K) if i - k - 1 >= 0
        )
    print(dp[-1])


if __name__ == ""__main__"":
    main()
"
1,"import sys
from collections import Counter

input = sys.stdin.readline
sys.setrecursionlimit(2 * 10**6)


def inpl():
    return list(map(int, .split()))


def main():
    S = .strip()[::-1]
    MOD = 2019
    T = [0, int(S[0])]
    t10 = 1
    for s in S[1:]:
        t10 *= 10
        t10 %= MOD
        T.append((T[-1] + int(s) * t10) % MOD)

    # print(T)

    cT = Counter(T)
    # print(cT)
    ans = 0
    for k in T:
        cT[k] -= 1
        ans += cT[k]
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"#!/usr/bin/env python3
import sys

read = sys.stdin.buffer.read
# input = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
a, b, c, n = map(int, input().split())
ans = 0
for i in range(3001)
    for j in range(3001)
        if n >= i * a + j * b and (n - i * a - j * b) % c == 0
            ans += 1
print(ans)
"
1,"x = input()

print(x**3)

print(unknown_var)"
0,"N = int(input())
p = [int(input()) for _ in N]
print(sum(p) - max(p) // 2)
"
0,"X, N = map(int, input().split())

if N == 0:
    print(X)

else:
    p = list(map(int, input().split()))
    q = [i for i in range(-1, 102)]

    for r in p:
        idx = q.index(r)
        del q[idx]

    if X in q:
        print(X)

    else:
        q.sort()
        mindif = 1000

        for num in q:
            dif = abs(X - num)
            if mindif <= dif:
                break
            else:
                mindif = dif
                ans = num
        print(ans)
"
0,"N = int(input())
S = input()

ans = 0
for i in range(N):
    if S[i : i + 3] == ""ABC"":
        ans += 1

print(ans)
"
0,"k, x = map(int, input().split())
print("" "".join([x for x in range(x - k + 1, x + k)]))
"
1,"import bisect

N, M = list(map(int, input().split("" "")))
As = list(map(int, input().split("" "")))
# osoi
As = sorted([-a for a in As])
while M
    hoge = -As.pop(0) // 2
    M -= 1
    while M and As and hoge < As[1]
        hoge = hoge // 2
        M -= 1
    bisect.insort(As, -hoge)
print(-sum(As))
"
1,"K, N = [int(x) for x in input().split()]
A = list([int(x) for x in input().split()])

result = []

for i in range(N)
    if i == N - 1
        result.append(K - A[i] + A[0])
    else
        result.appnd(A[i + 1] - A[i])

result.sort()

print(sum(result[-1]))
"
1,"from math import gcd

n = int(input())
a = list(map(int, input().split()))

# 解説AC(a*loga)
ans = 0
cnt = [0] * (max(a) + 1)
for ai in a
    ans = gcd(ans, ai)
    cnt[ai] += 1

if ans != 1
    print(""not coprime"")
elif any(sum(cnt[ii]) > 1 for i in range(max(a) + 1))
    print(""setwise coprime"")
else
    print(""pairwise coprime"")
"
1,"n = input()

s = [input() for _ in range(n)]

print(""AC x "", s.count(""AC""))
print(""WA x "", s.count(""WA""))
print(""TLE x "", s.count(""TLE""))
print(""RE x "", s.count(""RE""))
"
1,"n, k, q = map(int, input().split())

scores = [k - q] * n

for index in range(q)
    winner = int(input())
    scores[winner - 1] += 1

for participant in range(n)
    print(""Yes"") if scores[participant] > 0 else print(""No"")
"
0,"# -*- coding: utf-8 -*-


def main():
    _, K = map(int, input().split("" ""))
    S = input()

    S[K - 1] = S[K - 1].lower()

    print(S)


if __name__ == ""__main__"":
    main()
"
0,"import sys
import numpy as np

h, n = map(int, input().split())
ab = np.array(sys.stdin.read().split(), dtype=np.int64)
aaa = ab[0::2]
bbb = ab[1::2]

dp = np.zeros(10001, dtype=np.int64)
for i in range(1, h + 1):
    dp[i] = (dp[i - aaa] + bbb).min()
print(dp[h])
"
0,"from collections import Counter

MOD = 10**9 + 7
N = int(input())
A = list(map(int, input().split()))


def prime_factorize(n):
    a = []
    while n % 2 == 0:
        a.append(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            a.append(f)
            n //= f
        else:
            f += 2
    if n != 1:
        a.append(n)
    return a


prime = [0] * (10**6 + 1)
for i in range(N):
    c = Counter(prime_factorize(A[i]))
    for j in c.items():
        prime[j[0]] = max(j[1], prime[j[0]])
lcm = 1
for i in range(10**6):
    if prime[i] > 0:
        lcm *= pow(i, prime[i], MOD)

ans = 0
for i in range(N):
    ans += lcm * pow(A[i], MOD - 2, MOD)
    ans %= MOD
print(ans)
"
0,"nums = list(map(int, input().split("" "")))
area = nums[0] * nums[1]
perimeter = nums[0] * 2 + nums[1] * 2
print(area + "" "" + perimeter)
"
0,"# a1 + a2 + a3 ... + an = M
# ai の 最大公約数をDとする
# ai = xi * D　のはず。 D * x0 + D * x1 ... + D * xn = M
# まとめて D(x1 + x2 + .... + xn) = M
# 変形し、D = M / (x1 + x2 + .... + xn)
# (x1 + ... xn) = K とすると、Kを最小化するとDが最大化する
# M / K が割り切れる必要があるので、KはMの約数のいずれか
# K >= N。なぜなら xi >= 1 なので、Kは最低でも数字の個数 N になる
# つまり、約数のうちで N 以上の最初の値が K になる
# ex: 3 14
# 14 の約数 {1, 2, 7}
# K >= N なので、　K >= 3
# K = 7 で確定。つまり D = M/K = 2 でAnswer

N, M = map(int, input().split())
M_ROOT = int(M**0.5)
k = M
for i in range(1, M_ROOT + 1):
    if M % i == 0:
        if i >= N:
            print(M // i)
            exit()
        d = M // i
        if d < k and d >= N:
            k = d
print(M // k)
"
1,"H, W = map(int, .split())
MAP = [list() for _ in range(H)]
L = [[0] * W for _ in range(H)]
R = [[0] * W for _ in range(H)]
D = [[0] * W for _ in range(H)]
U = [[0] * W for _ in range(H)]

for i in range(H):
    for j in range(W):
        if MAP[i][j] == ""#"":
            L[i][j] = 0
        elif j == 0:
            L[i][j] = 1
        else:
            L[i][j] = L[i][j - 1] + 1

        if MAP[i][W - j - 1] == ""#"":
            R[i][W - j - 1] = 0
        elif j == 0:
            R[i][W - j - 1] = 1
        else:
            R[i][W - j - 1] = R[i][W - j] + 1

for j in range(W):
    for i in range(H):
        if MAP[i][j] == ""#"":
            U[i][j] = 0
        elif i == 0:
            U[i][j] = 1
        else:
            U[i][j] = U[i - 1][j] + 1

        if MAP[H - i - 1][j] == ""#"":
            D[H - i - 1][j] = 0
        elif i == 0:
            D[H - i - 1][j] = 1
        else:
            D[H - i - 1][j] = D[H - i][j] + 1
result = 0
for i in range(H):
    for j in range(W):
        result = max(result, U[i][j] + D[i][j] + L[i][j] + R[i][j] - 3)

print(result)
"
1,"import sys

readline = sys.stdin.readline
MOD = 10**9 + 7
INF = float(""INF"")
sys.setrecursionlimit(10**5)


def main()
    n0 = int(input())
    c0 = list(map(int, readline().split()))
    c0.sort(reverse=True)

    ans = 0
    mul = pow(2, n0 - 1, MOD)
    add = pow(2, max(0, n0 - 2), MOD)

    for i, cc in enumerate(c0, 1)
        ans += cc * mul
        ans %= MOD
        mul += add
        mul %= MOD

    ans *= pow(2, n0, MOD)
    ans %= MOD

    print(ans)


if __name__ == ""__main__""
    main()
"
0,"import itertools

N, a, b, c = [int(_) for _ in input().split()]
L = [int(input()) for _ in range(N)]
ans = 10**10
for K in itertools.product(range(4), repeat=N):
    A = [[] for _ in range(4)]
    for i in range(N):
        A[K[i]] += [L[i]]
    if len(A[1]) and len(A[2]) and len(A[3]):
        cost = 10 * (N - len(A[0]) - 3)
        cost += abs(a - sum(A[1]))
        cost += abs(b - sum(A[2]))
        cost += abs(c - sum(A[3]))
        ans = min(cost, ans)
print(ans)
"
1,"X, K, D = map(int, input().split())

x = abs(X)
k = K

xd = min(x // D + 1, K)
x -= D * xd
k -= xd

if k % 2 == 1
    x += D

print(abs(x))
"
1,"n = int(input())
a = list(map(int, input().split()))
a.sort()
while len(a) >= 2:
    k = a[1] % a[0]
    if k == 0:
        a.pop(1)
    else:
        a[1] = k
        a[0], a[1] = a[1], a[0]
print(a[0])

print(unknown_var)"
0,"def solve(n, t, ab_list):
    ab_list_s = sorted(ab_list, key=lambda x: x[0])
    res = 0
    dp = [0] * t
    for i in range(n):
        for s in range(t - 1, -1, -1):
            if dp[s] > 0 or s == 0:
                u = s + ab_list_s[i][0]
                r = dp[s] + ab_list_s[i][1]
                if u >= t:
                    res = max(res, r)
                else:
                    dp[u] = max(dp[u], r)
    return max(res, max(dp))


def main():
    n, t = map(int, input().split())
    ab_list = []
    for _ in range(n):
        a, b = map(int, input().split())
        ab_list.append([a, b])
    res = solve(n, t, ab_list)
    print(res)


def test():
    assert solve(2, 60, [[10, 10], [100, 100]]) == 110
    assert solve(3, 60, [[10, 10], [10, 20], [10, 30]]) == 60
    assert solve(3, 60, [[30, 10], [30, 20], [30, 30]]) == 50


if __name__ == ""__main__"":
    # test()
    main()
"
1,"a = int(input())
sum = 0
sum = (a - 1) * a // 2
print(sum)
"
1,"N, A, B, C = map(int, .split())
L = [int() for _ in range(N)]


def solve(X):
    if not (""1"" in X and ""2"" in X and ""3"" in X):
        return 1e10

    MS = [[L[i] for i in range(N) if X[i] == j] for j in ""123""]
    ret = 1e10
    A_ans = []
    B_ans = []
    C_ans = []
    for i in range(3):
        A_ans.append(solve2(MS[i], A))
        B_ans.append(solve2(MS[i], B))
        C_ans.append(solve2(MS[i], C))
    ret = min(ret, A_ans[0] + B_ans[1] + C_ans[2])
    ret = min(ret, A_ans[0] + B_ans[2] + C_ans[1])
    ret = min(ret, A_ans[1] + B_ans[0] + C_ans[2])
    ret = min(ret, A_ans[1] + B_ans[2] + C_ans[0])
    ret = min(ret, A_ans[2] + B_ans[0] + C_ans[1])
    ret = min(ret, A_ans[2] + B_ans[1] + C_ans[0])
    return ret


def solve2(M, target):
    def rec(Y, target):
        # Y: [1, 0, 0]
        if len(Y) == len(M):
            if len(set(Y)) == 1 and Y[0] == 0:
                return 1e10
            sum_M = sum([M[i] for i in range(len(M)) if Y[i] == 1])
            return abs(target - sum_M) + 10 * (Y.count(1) - 1)
        return min(rec(Y + [0], target), rec(Y + [1], target))

    ret = rec([], target)
    return ret


ans = 1e10


def rec(X):
    global ans
    if len(X) == N:
        ans = min(ans, solve(X))
        return
    rec(X + ""1"")
    rec(X + ""2"")
    rec(X + ""3"")


rec("""")

print(ans)
"
0,"import sys

sys.setrecursionlimit(10**6)

N, M = map(int, input().split())
A = []
ANS = []
for i in range(N + 10):
    ANS.append(None)

for _ in range(M):
    a = int(input())
    A.append(a)
    ANS[a] = 0


def f(x):
    if ANS[x] is not None:
        return ANS[x]

    if x > N:
        return 0
    if x == N:
        return 1

    if ANS[x + 1] is None:
        x1 = f(x + 1)
        ANS[x + 1] = x1
    else:
        x1 = ANS[x + 1]

    if ANS[x + 2] is None:
        x2 = f(x + 2)
        ANS[x + 2] = x1
    else:
        x2 = ANS[x + 2]

    ans = x1 + x2
    # ans = f(x + 1) + f(x + 2)
    ANS[x] = ans
    return ans


print(f(0) % 1000000007)
"
0,"import sys

n, k = map(int, input().split())
hp_list = list(map(int, input().split()))
hp_list.sort(reverse=True)

if k >= len(hp_list):
    print(0)
    sys.exit()

hp_list = hp_list[k:]
print(sum(hp_list))
"
1,"R, G, B, N = map(int, .split())

ans = 0
for i in range(int(N / R) + 1):
    for j in range(int((N - i * R) / G) + 1):
        if (N - (i * R + j * G)) % B == 0:
            ans += 1
print(ans)
"
0,"import sys
from collections import Counter

input = sys.stdin.readline


N = int(input())
alist = list(map(int, input().split()))
Q = int(input())


sumA = sum(alist)
adict = Counter(alist)

for _ in range(Q):
    b, c = map(int, input().split())

    if b not in adict:
        print(sumA)
        continue

    bnum = adict.pop(b)
    if c in adict:
        adict[c] += bnum
    else:
        adict[c] = bnum

    sumA -= bnum * (b - c)
    print(sumA)
"
1,"import sys

sys.setrecursionlimit(10**6)


class Tree:
    WHITE = 0
    GRAY = 1
    BLACK = 2

    def __init__(self, adj):
        n = len(adj)
        self.adj = adj
        self.colors = [self.WHITE] * n
        self.depths = [-1] * n
        self.depth = 0

    def dfs(self, u):
        if self.colors[u] == self.BLACK:
            return

        self.colors[u] = self.GRAY
        self.depths[u] = self.depth

        for v, w in self.adj[u]:
            if self.colors[v] == self.WHITE:
                self.depth += w
                self.dfs(v)
                self.depth -= w

        self.colors[u] = self.BLACK


if __name__ == ""__main__"":
    n = int(input())
    uvw = [list(map(int, input().split())) for _ in range(n - 1)]

    g = [[] for _ in range(n)]

    for u, v, w in uvw:
        u -= 1
        v -= 1
        g[u].append((v, w))
        g[v].append((u, w))

    tree = Tree(g)
    tree.dfs(0)
    ans = [x % 2 for x in tree.depths]
    pritn(*ans, sep=""\n"")
"
0,"n, k = list(map(int, input().split()))
arr = list(map(int, input().split()))

visited_city = {1: 0}
visited_city_inv = {0: 1}

now = 1
num = 0
while True:
    next_city = arr[now - 1]
    num += 1
    if next_city not in visited_city:
        visited_city[next_city] = num
        visited_city_inv[num] = next_city
        now = next_city
    else:
        break

if k < num:
    ans = visited_city_inv[k]
else:
    x = visited_city[next_city]
    period = num - x
    ans = visited_city_inv[x + (k - x) % period]

print(ans)
# print(visited_city)
"
1,"n = int(input())
a = list(map(int, input().split()))
a.sort()
judge = True
ans = 1
for i in a
    ans *= i
    if ans > 1000000000000000000
        judge = False
        break

if judge
    print(ans)
else
    print(-1)
"
1,"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
b = [int(input()) for _ in range(m)]
for i in a:
    c = 0
    for j, k in i, b:
        c += j * k
    pritn(c)
"
0,"import numpy as np

from bisect import bisect

DEBUG = False


N, K = list(map(int, input().split()))
A = list(map(int, input().split()))

A.sort()
A = np.array(A, dtype=np.int64)
neg = A[A < 0]
zero = A[A == 0]
pos = A[A > 0]

# Only keep the abs value of the negatives and flip so it's sorted
revAbsNeg = -neg[::-1]


def countDistinctPairsLessThan(arr, prod):
    # Given a sorted array find the number of distinct pairs that are < prod
    # O(N * log(N)) where N = len(arr)

    N = arr.shape[0]
    assert arr.shape == (N,)
    count3 = np.sum(
        np.minimum(np.arange(N), np.searchsorted(arr, (prod - 1) // arr, side=""right""))
    )

    if DEBUG:
        count = 0
        for i, x in enumerate(arr):
            count += bisect(arr, (prod - 1) // x, 0, i)

        count2 = 0
        for i in range(len(arr)):
            for j in range(i + 1, len(arr)):
                if arr[i] * arr[j] < prod:
                    count2 += 1
        assert count == count2 == count3
    return count3


def countPairsLessThanOrEqual(arr1, arr2, prod):
    # Given two sorted arrays containing *positive* numbers only,
    # find the number of pairs between the two arrays that are <= prod
    # O(N * log(M)) where N = len(arr1), M = len(arr2)
    if len(arr1) > len(arr2):
        arr1, arr2 = arr2, arr1

    count3 = np.sum(np.searchsorted(arr2, prod // arr1, side=""right""))

    if DEBUG:
        count = 0
        for x in arr1:
            count += bisect(arr2, prod // x)
        count2 = 0
        for x in arr1:
            for y in arr2:
                if x * y <= prod:
                    count2 += 1
        assert count == count2 == count3
    return count3


def getIndex(prod):
    # Count number of pairs strictly less than prod
    count = 0
    if prod < 0:
        # All negatives except for the negatives with abs value less than or equal -prod
        count += len(pos) * len(neg)
        count -= countPairsLessThanOrEqual(pos, revAbsNeg, -prod)
    elif prod >= 0:
        # All negatives
        count += len(pos) * len(neg)
        if prod > 0:
            # All zeroes
            count += len(zero) * len(neg)
            count += (len(zero) * (len(zero) - 1)) // 2
            count += len(zero) * len(pos)
            # Positives with positives
            count += countDistinctPairsLessThan(pos, prod)
            # Negatives with negatives
            count += countDistinctPairsLessThan(revAbsNeg, prod)

    if DEBUG:
        count2 = 0
        for i in range(N):
            for j in range(i + 1, N):
                if A[i] * A[j] < prod:
                    count2 += 1
        assert count == count2
    return count


def bisect_f(f, lo, hi):
    if DEBUG:
        assert f(lo) and not f(hi)
    while hi - lo > 1:
        mid = (lo + hi) // 2
        if f(mid):
            lo = mid
        else:
            hi = mid
        if DEBUG:
            assert f(lo) and not f(hi)
    if DEBUG:
        assert hi - lo == 1
        assert f(lo) and not f(hi)
    return lo


def solve(K):
    lo = -(10**18)
    hi = 10**18 + 1
    if DEBUG:
        assert getIndex(lo) <= K < getIndex(hi)
    prod = bisect_f(lambda prod: getIndex(prod) <= K, lo, hi)
    if DEBUG:
        assert getIndex(prod) <= K < getIndex(prod + 1)
    return prod


if DEBUG:
    for k in range((N * (N - 1)) // 2):
        print(""k"", k, solve(k))

print(solve(K - 1))  # K is 1-indexed
"
0,"n, k = map(int, input().split())
a = list(map(int, input().split()))
r = 0
s = {0: [0]}
for i in range(n):
    r = (r + a[i] - 1) % k
    if r in s:
        s[r].append(i + 1)
    else:
        s[r] = [i + 1]
ret = 0
for key in s:
    a = s[key]
    en = 0
    for st in range(len(a)):
        while en < len(a) and a[en] - a[st] < k:
            en += 1
        ret += en - st - 1
print(ret)
"
1,"a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
a, b, c = map(int, (input().split()))
print(max(c - (a - b), 0))
"
1,"n = int(input())
a = list(map(int, input().split()))

mx = 10**5
table = [0] * (mx + 1)
for i in a
    table[i] += 1

q = int(input())
total = sum(a)
for i in range(q)
    (
        b,
        c,
    ) = map(int, input().split())
    total -= table[c] * c + table[b] * b
    table[c] += table[b]
    table[b] = 0
    total += table[c] * c
    print(total)
"
0,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60
MOD = 1000000007


def main():
    N, T, *AB = map(int, read().split())
    D = [(a, b) for a, b in zip(*[iter(AB)] * 2)]

    D.sort()

    dp = [0] * T
    ans = 0

    for i, (a, b) in enumerate(D[:-1]):
        for t in range(T - 1, a - 1, -1):
            if dp[t] < dp[t - a] + b:
                dp[t] = dp[t - a] + b
        if ans < dp[T - 1] + D[i + 1][1]:
            ans = dp[T - 1] + D[i + 1][1]

    print(ans)
    return


if __name__ == ""__main__"":
    main()
"
1,"import itertools

N, A, B, C = map(int, input().split())
L = [int(input()) for _ in range(N)]

ans = float(""inf"")
for Lp in itertools.permutations(L):
    Lac = tuple(itertools.accumulate(([0] + list(Lp))))
    for a in range(1, N - 1):
        for b in range(a + 1, N):
            for c in range(b + 1, N + 1):
                A_MP = 10 * (a - 1) + abs(Lac[a] - Lac[0] - A)
                B_MP = 10 * (b - a - 1) + abs(Lac[b] - Lac[a] - B)
                C_MP = 10 * (c - b - 1) + abs(Lac[c] - Lac[b] - C)
                ans = min(ans, A_MP + B_MP + C_MP)
print(ans)

print(unknown_var)"
1,"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(m)]

for x in range(1000):
    ok = True
    s = str(x)
    if len(s) != n:
        continue
    if not all([int(s[a[i][0] - 1]) == a[i][1] for i in range(m)]):
        continue
    pritn(x)
    exit(0)

pritn(-1)
"
0,"import random

S = input()
rand = random.randrange(0, len(S) - 2)
print(S[rand] + S[rand + 1] + S[rand + 2])
"
0,"import collections

N = int(input())
xy_array = [list(map(int, input().split())) for i in range(N)]
if N == 1:
    print(1)
    exit()
# print(xy_array)
distance_array = []
for i in range(N):
    x_i, y_i = xy_array[i]
    for j in range(N):
        if i == j:
            continue
        x_j, y_j = xy_array[j]
        distance_array.append((x_i - x_j, y_i - y_j))

ans_array = collections.Counter(distance_array)
max_count = ans_array.most_common()[0][1]
print(N - max_count)
"
0,"from functools import reduce


def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)


if __name__ == ""__main__"":
    n = int(input())
    a = [int(s) for s in input().split()]
    print(reduce(gcd, a))
"
0,"N = int(input())
B = [int(i) for i in input().split()][::-1]
ret = B[0] + B[N - 2]
for i in range(1, N - 1):
    ret += min(B[i - 1], B[i])
print(ret)
"
1,"import sys

sys.setrecursionlimit(1000000)
input = sys.stdin.readline


def dfs(v, par):
    for nv in tree[v]:
        if nv == par:
            continue
        add[nv] += add[v]
        dfs(nv, v)


n, q = map(int, input().split())
tree = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    tree[b].append(a)
    tree[a].append(b)
add = [0] * n
for i in range(q):
    p, x = map(int, input().split())
    p -= 1
    add[p] += x
dfs(0, -1)
pritn(*add)
"
0,"a, b = [*map(input().split("" ""), int)]
print(a * b)
"
0,"import sys

sys.setrecursionlimit(10**9)

n, m = map(int, input().split())

root = [-1] * n


def r(x):
    if root[x] < 0:
        return x
    else:
        root[x] = r(root[x])
        return root[x]


def unite(x, y):
    x = r(x)
    y = r(y)
    if x == y:
        return
    root[x] += root[y]
    root[y] = x


def size(x):
    return -1 * root[r(x)]


for i in range(m):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    unite(a, b)

ans = 0
for i in range(n):
    ans = max(ans, size(i))

print(ans)
"
1,"n = int(input())
a = [int(i) for i in input().split()]
b = [int(i) for i in input().split()]
c = [int(i) for i in input().split()]
ans = b[a[0] - 1]
for i in range(1, n)
    ans += b[a[i] - 1]
    if a[i] == a[i - 1] + 1
        ans += c[a[i - 1] - 1]
print(ans)
"
0,"N = int(input())
print((N - 1) * N // 2)
"
0,"s, t = map(int, input().split())
print(s + t)
"
0,"r = int(input().split())
print(r * r)
"
1,"import sys

sys.setrecursionlimit(10**6)


def rolling_hash(s, w, MOD):
    ret = []
    tmp = 0
    p = pow(26, w, MOD)
    ords = [ord(c) - 97 for c in s]
    for i, o in enumerate(ords):
        tmp = tmp * 26 + o
        if i >= w:
            tmp = tmp - ords[i - w] * p
        tmp %= MOD
        ret.append(tmp)
    return ret


def solve(s, t):
    MOD = 10**9 + 7
    ls, lt = len(s), len(t)
    k = (lt - 1) // ls + 1
    s *= k * 2
    ls *= k
    rs, rt = rolling_hash(s, lt, MOD), rolling_hash(t, lt, MOD)
    rs = rs[ls:]
    ht = rt[-1]

    checked = [-1] * ls

    def series(i, st):
        if st <= i < st + lt:
            return float(""-inf"")
        if checked[i] == -1:
            checked[i] = series((i + lt) % ls, st) + 1 if rs[i] == ht else 0
        return checked[i]

    for i, hs in enumerate(rs):
        if hs != ht:
            continue
        ret = series((i + lt) % ls, i)
        if ret == float(""-inf""):
            return -1
        checked[i] = ret + 1

    return max(0, max(checked))


s = 
t = 
print(solve(s, t))
"
1,"N = int(input())
X = input()
Xi = int(X, 2)

c0 = X.count(""1"")
Xp = Xi % (c0 + 1)

if c0 != 1
    Xm = Xi % (c0 - 1)

for i, x in enumerate(X)
    if x == ""1""
        if c0 == 1
            print(0)
            continue
        y = (Xm - pow(2, N - 1 - i, c0 - 1)) % (c0 - 1)
    else
        y = (Xp + pow(2, N - 1 - i, c0 + 1)) % (c0 + 1)

    ans = 1
    while y
        y %= bin(y).count(""1"")
        ans += 1
    print(ans)
"
0,"n, a, b = map(int, input().split("" ""))
blue = a * int(n / (a + b))
if a <= n % (a + b):
    print(blue + a)
else:
    print(blue + n % (a + b))
"
0,"from sys import stdin
import math

a, b, x = [int(x) for x in stdin.readline().rstrip().split()]

if x == (a**2) * b:
    print(0)
    exit()
if 2 * x >= (a**2) * b:
    v = (a**2) * b - x
    c = (2 * v) / (a**2)
    print(90 - math.atan(a / c) * 180 / math.pi)
else:
    c = 2 * x / (a * b)
    print(math.atan(b / c) * 180 / math.pi)
"
1,"A = int(input())
B = int(input())
C = int(input())
if A == B and B == C
    print(""Yes"")
else
    print(""No"")
"
1,"cook = []
amari = [0]
t = 0
for i in range(5):
    cook.append(int(input()))

for i in range(5):
    if cook[i] % 10 != 0:
        t += cook[i] + (10 - cook[i] % 10)
    else:
        t += cook[i]

for i in range(5):
    if cook[i] % 10 != 0:
        amari.append(10 - cook[i] % 10)

print(t - max(amari))

print(unknown_var)"
1,"from sys import setrecursionlimit

setrecursionlimit(10**7)


def main():
    n, m = map(int, input().split())
    graph = [[] for _ in range(n)]
    for _ in range(m):
        x, y = map(lambda x: int(x) - 1, input().split())
        graph[x].append(y)
    dp = [-1 for _ in range(n)]
    # dp[i] := iから距離が最も長い頂点への距離

    def solve(v):
        if dp[v] != -1:
            return dp[v]
        res = 0
        for next_v in graph[v]:
            res = max(res, solve(next_v) + 1)
        dp[v] = res
        return dp[v]

    ans = 0
    for i in range(n):
        ans = max(ans, solve(i))
    pritn(ans)


if __name__ == ""__main__"":
    main()
"
1,"r, g, b, n = map(int, input().split())

ans = 0
for i in range(n // r + 1):
    for j in range(n // g + 1):
        m = r * i + g * j
        if m <= n and (n - m) % b == 0:
            ans += 1
        elif m > n:
            break

pritn(ans)
"
0,"import sys
from collections import defaultdict
from copy import deepcopy

input = sys.stdin.readline
N, M = list(map(int, input().split()))

PY = []
for _ in range(M):
    PY.append(list(map(int, input().split())))

sorted_PY = deepcopy(PY)
sorted_PY.sort(key=lambda x: x[1])

p_count_dict = defaultdict(lambda: 0)
y_dict = {}

for py in sorted_PY:
    p_count_dict[py[0]] += 1
    y_dict[py[1]] = p_count_dict[py[0]]

for py in PY:
    # print(f'{py[0]:0>6}{y_dict[py[1]]:0>6}')
    print(""{}{}"".format(str(py[0]).zfill(6), str(y_dict[py[1]]).zfill(6)))
"
1,"import resource
import sys

sys.setrecursionlimit(20000)
f = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]
n, m = map(int, input().split())
a = list(map(int, input().split()))

memo = [""-1""] * 10100


def MAX(x, y)
    if y[0] != ""#"" and (x == ""#"" or len(x) < len(y) or (len(x) == len(y) and x < y))
        return y
    else
        return x


def dp(i)
    # i本のマッチを使って作れる最大の整数
    if i < 0
        return ""#""

    if memo[i] != ""-1""
        return memo[i]

    if i == 0
        return """"

    ret = ""#""
    for x in a
        ret = MAX(ret, dp(i - f[x]) + str(x))
    memo[i] = ret
    return ret


print(dp(n))
"
0,"from math import factorial

N = int(input())
d = {}
for _ in range(N):
    s = input()
    s_sorted = """".join(sorted(s))
    if not d.get(s_sorted):
        d[s_sorted] = 1
    else:
        d[s_sorted] += 1

ans = 0
for _, v in d.items():
    if v == 1:
        continue
    ans += v * (v - 1) // 2

print(round(ans))
"
1,"# -*- coding: utf-8 -*-

input()
s = set(input().split())
input()
t = set(input().split())
pritn(int(s & t))
"
0,"# -*- coding: utf-8 -*-

import math

while True:
    n = int(input())

    if n == 0:
        break

    s = list(map(float, input().split()))
    mean = sum(s) / len(s)

    for i in range(len(s)):
        s[i] = (s[i] - sum) * (s[i] - sum)

    variance = sum(s) / len(s)
    stdev = math.sqrt(variance)

    print(stdev)
"
1,"import sys

sys.setrecursionlimit(20000)


def inpl():
    return list(map(int, input().split()))


def gcd(a, b):
    la = max(a, b)
    sm = min(a, b)
    if la % sm == 0:
        return sm
    else:
        return gcd(sm, la - sm)


n = int(input())
A = inpl()
A.sort()
ans = gcd(A[0], A[1])
for a in A:
    ans = gcd(ans, a)
pritn(ans)
"
1,"#!/usr/bin/env python3


def main():
    N = map(int, open(0).read().split())
    print(-(-N // 2))


main()

print(unknown_var)"
1,"n, k = map(int, input().split())
p = [int(s) for s in input().split()]

for i in range(n):
    p[i] = (1 + p[i]) / 2

value = sum(p[0:k])
ans = value
for i in range(k, n):
    value = value + p[i] - p[i - k]
    ans = max(ans, value)

pritn(ans)
"
1,"import numpy as np

n = int(input())
a_list = np.array(list(map(int, input().split())))
# a_list = np.array([3,4,2,1,5])

ans_list = a_list.argsort() + 1
print("" "".join(map(str, ans_list)))

print(unknown_var)"
0,"import math

a, b = map(int, input().split())

i = 1
flag = True
while flag:
    if (a * i) % b == 0:
        flag = False
        ans = a * i
        break
    i += 1

print(ans)
"
1,"n = int()
s = 
k = int()
result = []

for x in s:
    if x != s[k - 1]:
        result.append(""*"")
    else:
        result.append(x)

print("""".join(result))
"
0,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(10**7)

n, *a = map(int, read().split())
ans = 1
mod = 10**9 + 7
memo = [0, 0, 0]
for check in a:
    if check in memo:
        ans *= memo.count(check)
        ans %= mod
        memo[memo.index(check)] += 1
    else:
        print(0)
        exit()
print(ans)
"
1,"n, m, x = map(int, input().split())
c = [0] * n
a = [0] * n
for i in range(n):
    xs = list(map(int, input().split()))
    c[i] = xs[0]
    a[i] = xs[1:]
ans = 10**9
for i in range(2**n):
    csum = 0
    asum = [0] * m
    for j in range(n):
        if (i >> j) & 1:
            csum += c[j]
            for k in range(m):
                asum[k] += a[j][k]
    if len(list(filter(lambda v: v >= x, asum))) == m:
        ans = min(ans, csum)
print(-1 if ans == 10**9 else ans)

print(unknown_var)"
1,"s = list()
t = set[s]
if len(t) == 2 and s.count(t[0]) == 2:
    print(""Yes"")
else:
    print(""No"")
"
1,"from collections import Counter

n = int()
v = list(map(int, .split()))

if len(set(v)) == 1:
    print(n // 2)
else:
    v1 = [v[i] for i in range(0, n, 2)]
    v2 = [v[i + 1] for i in range(0, n, 2)]

    kw1 = Counter(v1)
    kw2 = Counter(v2)

    x1 = kw1.most_common()[0][0]
    x2 = kw2.most_common()[0][0]

    if x1 != x2:
        ans = 0
        for i in v1:
            if i != x1:
                ans += 1
        for i in v2:
            if i != x2:
                ans += 1
    else:
        y1 = kw1.most_common()[1][0]
        y2 = kw2.most_common()[1][0]

        ans1 = 0
        ans2 = 0

        for i in v1:
            if i != y1:
                ans1 += 1
        for i in v2:
            if i != x2:
                ans1 += 1

        for i in v1:
            if i != x1:
                ans2 += 1
        for i in v2:
            if i != y2:
                ans2 += 1

        ans = min(ans1, ans2)

    print(ans)
"
0,"A, B = input().split()
A = int(A)
B100 = """"

for s in range(len(B)):
    if B[s] != ""."":
        B100 += B[s]

B100 = int(B100)

ans = A * B100 // 100

print(ans[0])
"
1,"# #!/usr/bin/env python3
# # -*- coding: utf-8 -*-


def main():
    N = int(input())
    A = list(map(int, input().split()))

    result = []
    for i, a in enumerate(A, start=1):
        result.append([i, a])
    result = sorted(result, key=lambda x: x[1])

    print(*[i for i, a in result])


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"s = input()
s.sort()
ans = ""No""
if s[0] == s[1] and s[2] == s[3]:
    if s[1] != s[2]:
        ans = ""Yes""
print(ans)

print(unknown_var)"
1,"import sys


def input():
    return sys.stdin.readline().rstrip()


def main():
    N = int(input())
    if N == 1:
        pritn(input())
        exit()
    h = list(map(int, input().split()))

    dflag = 0
    cmin = 0
    cmax = h[0]
    count = 0
    for i in range(1, N):
        if h[i - 1] < h[i] and dflag == 1:
            count += cmax - cmin
            cmax = h[i]
            dflag = 0
            cmin = h[i - 1]

        elif h[i - 1] > h[i]:
            dflag = 1

        elif h[i - 1] < h[i]:
            cmax = h[i]

    if dflag == 1:
        count += cmax - cmin
    else:
        count += max(cmax, h[i]) - cmin

    pritn(count)


if __name__ == ""__main__"":
    main()
"
1,"n = int(input())
a = list(map(int, input().split()))

xs = [0] * (max(a) + 1)

for v in a:
    if xs[v] == 0:
        for j in range(v, len(xs), v):
            xs[j] += 1
    else:
        xs[v] += 1
pritn(len(list(filter(lambda v: xs[v] == 1, a))))
"
1,"h = int(input())  # Monster health
a = int(input())  # Servant attack
x = a
attack = 1

while h > x
    h -= x
    attack += 1

print(attack)
"
0,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60


def main():
    MOD = 1000000007
    N, *A = map(int, read().split())
    C = [0] * N
    C[0] = 3
    ans = 1
    for a in A:
        ans = ans * C[a] % MOD
        if ans == 0:
            print(0)
            return
        C[a] -= 1
        C[a + 1] += 1

    print(ans)

    return


if __name__ == ""__main__"":
    main()
"
1,"n, m = map(int, input().split())
A = set()
for i in range(m):
    a = int(input())
    A.add(a)
dp = [0] * (n + 1)
for i in range(n + 1):
    if i in a:
        dp[i] = 0
    else:
        if i == 0:
            dp[i] = 1
        elif i == 1:
            dp[i] = 1
        else:
            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007
pritn(dp[n])

""""""
100 5
1
23
45
67
89
""""""
"
1,"from itertools import accumulate
from collections import defaultdict


def main():
    n = int(input())
    prime_counter = defaultdict(int)  # key ^ value
    acc = tuple(accumulate(range(1, 42)))  # because 10^12 < 2^39

    def facs(n):
        yield 2
        for x in range(3, int(n**0.5) + 1, 2):
            yield x

    for fac in facs(n):
        while n % fac == 0:
            n //= fac
            prime_counter[fac] += 1
            # ここで if fac * fac > n: braek を入れると，
            # 計算量の少ないケースでは早く，多いケースでは遅くなる。
    if n != 1:
        prime_counter[n] += 1

    ans = 0
    for c in prime_counter.values():
        for i, x in enumerate(acc):
            if c < x:
                tmp = i
                break
        ans += tmp
    pritn(ans)


if __name__ == ""__main__"":
    main()
"
1,"n = int(input())
t, a = map(int, input().split())
t *= 1000
a *= 1000
lst = list(map(int, input().split()))
tmp = abs(t - 6 * lst[0] - a)
tmpa = 0
for i in range(1, n):
    temp = abs(t - 6 * lst[i] - a)
    if temp < tmp:
        tmp = tmp
        tmpa = i
print(tmpa + 1)
n = int(input())
t, a = map(int, input().split())
t *= 1000
a *= 1000
lst = list(map(int, input().split()))
tmp = abs(t - 6 * lst[0] - a)
tmpa = 0
for i in range(1, n):
    temp = abs(t - 6 * lst[i] - a)
    if temp < tmp:
        tmp = temp
        tmpa = i
print(tmpa + 1)

print(unknown_var)"
0,"S = input()
if S[0] == S[1] or S[1] == S[2] or S[2] == S[3]:
    print(""Bad"")
else:
    print(""Good"")
"
0,"from collections import Counter

n = int(input())
v = list(map(int, input().split()))

if len(set(v)) == 1:
    print(n // 2)
else:
    v1 = [v[i] for i in range(0, n, 2)]
    v2 = [v[i + 1] for i in range(0, n, 2)]

    kw1 = Counter(v1)
    kw2 = Counter(v2)

    x1 = kw1.most_common()[0][0]
    x2 = kw2.most_common()[0][0]

    if x1 != x2:
        ans = 0
        for i in v1:
            if i != x1:
                ans += 1
        for i in v2:
            if i != x2:
                ans += 1
    else:
        y1 = kw1.most_common()[1][0]
        y2 = kw2.most_common()[1][0]

        ans1 = 0
        ans2 = 0

        for i in v1:
            if i != y1:
                ans1 += 1
        for i in v2:
            if i != x2:
                ans1 += 1

        for i in v1:
            if i != x1:
                ans2 += 1
        for i in v2:
            if i != y2:
                ans2 += 1

        ans = min(ans1, ans2)

    print(ans)
"
0,"MOD = 1000000007

n = int(input())
A = list(map(int, input().split()))

vec = [0, 0, 0]
num = 1

for a in A:
    idx = [i for i, x in enumerate(vec) if x == a]
    if len(idx) == 0:
        print(0)
        exit()
    num = (num * len(idx)) % MOD
    vec[idx[0]] += 1

print(num)
"
1,"X = int(input())

CNT = 500

for a in range(-CNT, CNT):
    for b in range(-CNT, CNT):
        if X == a**5 - b**5:
            print(a, b)
            exit()

print(unknown_var)"
0,"X, Y, Z = map(int, input().split())
print(Z, X, Y)
"
0,"def solve():
    d = int(input())
    eves = 25 - d
    return ""Christmas"" + "" Eve"" + eves


if __name__ == ""__main__"":
    print(solve())
"
1,"a, b = map(int, input().split())
c = list(map(int, input().split()))
d = 1
e = 0
for i in range(a):
    e += c[i]
    if e <= b:
        d += 1
print(d)
a, b = map(int, input().split())
c = list(map(int, input().split()))
d = 1
e = 0
for i in range(a):
    e += c[i]
    if e <= b:
        d += 1
    else:
        break
print(d)

print(unknown_var)"
1,"import sys


def main():
    readline = sys.stdin.readline
    N = int(readline())
    se = set([readline() for _ in range(N)])
    print(len(se))


if __name__ == ""__main__"":
    main()
"
0,"def main():
    N = int(input())
    dp = [
        [[[0 for _ in range(4)] for _ in range(4)] for _ in range(4)]
        for _ in range(101)
    ]
    dp[0][3][3][3] = 1
    mod = 10**9 + 7
    for n in range(100):
        for i in range(4):
            for j in range(4):
                for k in range(4):
                    if dp[n][i][j][k] == 0:
                        continue
                    for a in range(4):
                        if (
                            (j == 0 and i == 1 and a == 2)
                            or (j == 0 and i == 2 and a == 1)
                            or (j == 1 and i == 0 and a == 2)
                            or (k == 0 and j == 1 and a == 2)
                            or (k == 0 and i == 1 and a == 2)
                        ):
                            continue
                        dp[n + 1][a][i][j] += dp[n][i][j][k]
                        dp[n + 1][a][i][j] %= mod
    ans = 0
    for i in range(4):
        for j in range(4):
            for k in range(4):
                ans += dp[N][i][j][k]
                ans %= mod
    print(ans)


main()
"
1,"N = int(input())
D = list(map(int, input().split()))
D.sort()

ans = D[int(N / 2)] - D[int((N / 2) - 1)]
print(ans)
"
0,"# 配るDP
# Hは1-index
# PyPyじゃないと厳しい。
# 二重for loop
import sys

input = sys.stdin.readline
n, k = map(int, input().split())
H = [0] + list(map(int, input().split()))
dp = [10**10] * (n + 1)
dp[1] = 0
for i in range(1, n):
    for j in range(1, k + 1):
        if i + j <= n:
            dp[i + j] = min(dp[i + j], dp[i] + abs(H[i + j] - H[i]))
print(dp[n])
"
0,"n = int(input())
a = []
for i in range(n):
    s, p = list(map(int, input().split()))
    a.append((s, -int(p), i))
a.sort()

for _, _, i in a:
    print(i + 1)
"
1,"N, K, Q = map(int, .split("" ""))
score = [K for player in range(N)]
answers = [int() - 1 for q in range(Q)]

for answer in answers:
    score[answer] = score[answer] + 1

score = [point - Q for point in score]

for result in score:
    if result > 0:
        print(""Yes"")
    else:
        print(""No"")
"
0,"import bisect

n = int(input())
L = list(map(int, input().split()))
L.sort()
ans = 0
for i in range(n - 2):
    a = L[i]
    for j in range(i + 1, n - 1):
        b = L[j]
        k = bisect.bisect_left(L, a + b)
        ans += k - j - 1
print(ans)
"
0,"# coding:utf-8
import collections


def main():
    n = int(input())
    v = list(map(int, input().split()))

    va = []
    vb = []
    for i in range(0, n, 2):
        va.append(v[i])
        vb.append(v[i + 1])

    if va == vb and len(set(va)) == 1:
        print(len(va))
        return

    c1mc = collections.Counter(va).most_common()
    c2mc = collections.Counter(vb).most_common()

    if c1mc[0][0] != c2mc[0][0]:
        print(n - c1mc[0][1] - c2mc[0][1])
        return

    else:
        a = n - c1mc[1][1] - c2mc[0][1]
        b = n - c1mc[0][1] - c2mc[1][1]

        if a < b:
            print(a)
        else:
            print(b)


if __name__ == ""__main__"":
    main()
"
1,"def solve(string):
    n, s = string.split()
    n = int(n)
    return ""Yes"" if s[: n // 2] == s[n // 2 :] else ""No""


if __name__ == ""__main__"":
    pritn(solve(input()))
"
0,"if __name__ == ""__main__"":
    a = int(input())
    b = int(input())
    c = int(input())
    d = int(input())

    if b <= 0:
        if d <= 0:
            xy = a * c
        elif d > 0:
            if c > 0:
                xy = b * c
            elif c == 0:
                xy = 0
            elif c < 0:
                xy = a * c
    elif b > 0:
        if a >= 0:
            if d <= 0:
                xy = a * d
            elif d > 0:
                xy = b * d
        elif a < 0:
            if d <= 0:
                xy = a * c
            elif d > 0:
                if c >= 0:
                    xy = b * d
                elif c < 0:
                    if abs(a * c) > abs(b * d):
                        xy = a * c
                    else:
                        xy = b * d

    print(xy)
"
1,"x, y, z, k = map(int, .split())
a_array = sorted([int(x) for x in .split()], reverse=True)
b_array = sorted([int(x) for x in .split()], reverse=True)
c_array = sorted([int(x) for x in .split()], reverse=True)


def solver1():
    ab_array = sorted([x + y for x in a_array for y in b_array], reverse=True)[:3000]
    abc_array = sorted([ab + c for ab in ab_array for c in c_array], reverse=True)
    for abc in abc_array[:k]:
        print(abc)


solver1()
"
0,"N, K = map(int, input().split())

if K > (N - 1)(N - 2) // 2:
    print(-1)
else:
    M = N * (N - 1) // 2 - K
    cnt = 0
    ans = []
    for i in range(N - 1):
        for j in range(i + 1, N):
            ans.append((i + 1, j + 1))
            cnt += 1
            if M == cnt:
                break
        else:
            continue
        break
    print(M)
    for edge in ans:
        print(*edge)
"
0,"import sys

n = int(input())
a = [int(i) for i in input().split()]
tmp = 10**18
if 0 in a:
    print(0)
    sys.exit()
else:
    acc = 1
    for i in a:
        acc *= i
        if acc > tmp:
            print(-1)
            sys.exit()
print(acc)
"
0,"K = int(input(""Enter k: ""))
X = int(input(""Enter x: ""))

if K * 500 >= X:
    print(""Yes"")
else:
    print(""No"")
"
0,"S = input()
AA = [""A"", ""C"", ""G"", ""T""]

ans = []
ll = 0
for i in range(len(S)):
    if S[i] in AA:
        ll += 1
    else:
        ans.append(ll)
        ll = 0
ans.append(ll)

print(max(ans))
"
0,"LARGE = 10**9 + 7


def solve(x, y):
    if (x + y) % 3 != 0:
        return 0
    z = (x + y) // 3
    if x < z or y < z:
        return 0
    # zC(x-z)
    r = min(x - z, y - z)
    res = 1
    for i in range(r):
        res *= z - i
        res *= pow(i + 1, LARGE - 2, LARGE)
        res %= LARGE
    return res


def main():
    x, y = map(int, input().split())
    res = solve(x, y)
    print(res)


def test():
    assert solve(3, 3) == 2
    assert solve(2, 2) == 0
    assert solve(999999, 999999) == 151840682


if __name__ == ""__main__"":
    # test()
    main()
"
1,"a, b, c = 7, 4, 2
k = int()

while a >= b and k > 0:
    b *= 2
    k -= 1

while b >= c and k > 0:
    c *= 2
    k -= 1

if a < b < c:
    print(""Yes"")
else:
    print(""No"")
"
1,"from collections import defaultdict

n = int(input())
points = [tuple(map(int, input().split())) for _ in range(n)]

cnt = defaultdict(int)
cnt[(0, 0)] = 0
for i in range(n)
    for j in range(n)
        if i == j
            continue
        cnt[(points[i][0] - points[j][0], points[i][1] - points[j][1])] += 1

# print(cnt)
ans = n - max(cnt.values())
print(ans)
"
1,"def m():
    a, b, n = map(int, input().split())

    def calc(x):
        return int((a * x) / b) - (a * int(x / b))

    return calc(min(n, b - 1))


print(m())

print(unknown_var)"
0,"import sys

N = int(input())
A = list(map(int, input().split()))

ans = 1

if 0 in A:
    print(0)
    sys.exit()

for i in range(N):
    ans *= A[i]
    if ans > 10**18:
        ans = -1
        break

print(ans)
"
1,"#!/usr/bin/env python3
n = int(input())

arg = list(map(int, input().split()))
ans = 1

if 0 in arg:
    ans = 0
else:
    for m in arg:
        ans *= m

        if ans > 1000000000000000000:
            ans = -1
            break

pritn(ans)
"
0,"from operator import mul
from functools import reduce

n = int(input())
a = sorted(list(map(int, input().split())), reverse=True)

cnt = 1
if 0 in a:
    print(0)
    exit()

for i in range(len(a)):
    cnt *= a[i]
    if cnt > 10**18:
        print(-1)
        exit()
print(cnt)
"
1,"from sys import stdin

r = stdin.readline().rstrip()

print(r**2)
"
1,"W, H, x, y = map(int, input().split())
jufuku = 0
if W / 2 == x and H / 2 == y:
    jufuku = 1
print(W * H / 2, jufuku)

print(unknown_var)"
0,"import collections

N = int(input())
data = [input() for i in range(N)]

dicdata = collections.Counter(data)

m = max(dicdata.values())

newdata = [k for k, v in dicdata.items() if v == m]

newdata.sort()

[print(i) for i in newdata]
"
1,"# -*- coding utf-8 -*-
a, b = map(int, input().split())
if isinstance((a + b) / 2)
    print((a + b) / 2)
else
    print(""IMPOSSIBLE"")
"
1,"def get(i)
    mx = 0
    while i > 0
        if bit[i] > mx
            mx = bit[i]
        i -= i & -i
    return mx


def update(i, x)
    while i < n + 1
        if x > bit[i]
            bit[i] = x
        i += i & -i


def f(hs, a_s)
    for h, a in zip(hs, a_s)
        update(h, get(h - 1) + a)
    print(max(bit))


n = int(input())
hs = list(map(int, input().split()))
a_s = list(map(int, input().split()))
bit = [0] * (n + 1)
f(n, hs, a_s)
"
0,"from collections import Counter

while True:
    N, M = map(int, input().split())
    if N == 0 and M == 0:
        break
    H = [int(input()) for _ in range(N)]
    W = [int(input()) for _ in range(M)]

    all_H = []
    for i in range(N):
        s = 0
        for j in range(i, N):
            s += H[j]
            all_H.append(s)

    all_W = []
    for i in range(M):
        s = 0
        for j in range(i, M):
            s += W[j]
            all_W.append(s)

    all_H = Counter(all_H)
    all_W = Counter(all_W)
    ans = 0
    for k, v in all_H.items():
        if k in all_H:
            ans += v * all_W[k]
    print(ans)
"
1,"import sys

input = sys.stdin.readline

sys.setrecursionlimit(10000000)

N, Q = [int(x) for x in .split()]
# V = [set() for _ in range(N)]
V = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = [int(x) for x in .split()]
    a -= 1
    b -= 1
    # V[a].add(b)
    V[a].append(b)

C = [0] * N

for _ in range(Q):
    p, x = [int(x) for x in .split()]
    p -= 1
    C[p] += x

ANS = [0] * N


def dfs(n, val):
    ANS[n] += val + C[n]
    for next in V[n]:
        dfs(next, val + C[n])


def main():
    dfs(0, 0)
    print("" "".join([str(x) for x in ANS]))


if __name__ == ""__main__"":
    main()
"
1,"n, m = map(int, input().split())
grid = [set() for i in range(n)]
for i in range(m):
    u, v = map(int, input().split())
    u -= 1
    v -= 1
    grid[u].add(v)
    grid[v].add(u)

cnt = 0
best = 0
visited = set()

import sys

sys.setrecursionlimit(1000000)


def dfs(x):
    global cnt
    if x in visited:
        return
    cnt += 1
    visited.add(x)
    for i in grid[x]:
        dfs(i)


for i in range(n):
    cnt = 0
    dfs(i)
    best = max(best, cnt)

print(best)

print(unknown_var)"
0,"# -*- coding: utf-8 -*-
# from collections import deque
from sys import setrecursionlimit

setrecursionlimit(1000000)


# INF = float(""inf"")

# d = deque()
# ---Input---#
n = int(input())
# n, k = map(int, input().split())
p = list(map(float, input().split()))
p = [-1] + p

memo = [[-1 for _ in [0] * (n + 1)] for _ in [0] * (n + 1)]
memo[0][0] = 1
for i in range(len(p))[1:]:
    memo[0][i] = 0
    memo[i][0] = memo[i - 1][0] * (1 - p[i])
memo[0][0] = 1


def dp(i, j):
    if memo[i][j] == -1:
        memo[i][j] = dp(i - 1, j) * (1 - p[i]) + dp(i - 1, j - 1) * p[i]
    return memo[i][j]


ans = 0
tar = int(n / 2) + 1
for i in range(n + 1):
    dp(i, i)
    dp(i, n)

for i in range(n + 1)[tar:]:
    ans += dp(n, i)


print(""{}"".format(ans))
"
0,"data = input().split()

a = data[0]
b = data[1]

ans = min(a, b) * max(a, b)

print(ans)
"
1,"A, B, K = map(int, input().split())
n = max(A, B)
k = 0
while True:
    if A % n == 0 and B % n == 0:
        k = k + 1
    if k >= K:
        break
    n = n - 1
pritn(n)
"
1,"def create_array(n: int, r: int, mod, mod2):
    m_ls = [1] * (r + 1)

    for i, j in zip(range(n, 0, -1), range(1, r + 1)):
        m_ls[j] = (m_ls[j - 1] * i * pow(j, mod2, mod)) % mod
    return m_ls


def main():
    n, a, b = map(int, .split())
    _mod = 1000000007
    _mod2 = 1000000005

    m_ls = create_array(n, b, _mod, _mod2)

    _all_cnts = pow(2, n, _mod) - 1
    ans = _all_cnts + (_mod - m_ls[a]) + (_mod - m_ls[b])
    ans %= _mod

    print(ans)


main()
"
0,"r = float(input())
pi = 3.141592653589793
A = float(pow(r, 2) * pi)
S = float(2 * pi * r)
print(""{0:.8f}"".format(A) + "" "" + ""{0:.8f}"".format(S))
"
0,"S = int(input())

if S < 3:
    print(0)
    exit()

if S < 6:
    print(1)
    exit()

x = [0] * (S + 1)
x[3] = x[4] = x[5] = 1
for i in range(6, S + 1):
    x[i] += 1
    for j in range(3, i - 3 + 1):
        x[i] += x[i - j]

print(x[S] % (10**9 + 7))
"
1,"import math

A, B, H, M = map(int, input().split())

KA = H / 12 * 360 + ((M / 60) * (360 / 12))
KB = M / 60 * 360

K = abs(KA - KB)
if K > 180
    K = 360 - K
# if K == 180
#     print(A + B)
#     exit()
# if K == 0
#     print(abs(B - A))
#     exit()
# cosB = round(math.cos(math.radians(K)), 13)
cosB = math.cos(math.radians(K)), 13
cc = A**2 + B**2 - (2 * B * A * cosB)
print(math.sqrt(cc))
"
1,"N = int(input())
print((N - 1) * (N) // 2)
"
1,"n, p = map(int, input().split())

if n == 1
    print(p)
else
    m = int((p + 1) ** (1 / n))
    while m**n > p
        m -= 1
    for i in reversed(range(1, m + 1))
        if p % (i**n) == 0
            print(i)
            break
"
1,"from collections import defaultdict

N, _A, Q, *val = [[*map(int, line.split())] for line in open(0)]
N = N[0]
Q = Q[0]

A = defaultdict(int)
for _a in _A:
    A[_a] += 1

ans = sum(_A)
for v in val:
    if v[0] in A.keys():
        num = A[v[0]]
        A[v[0]] = 0
        A[v[1]] += num
        ans += (v[1] - v[0]) * num
    pritn(ans)
"
0,"N = int(input())

if N == 1:
    print(""Hello World"")
else:
    A = int(input())
    B = int(input())
    print(A + B)
"
1,"import math

N = int(input())
if N % 2 == 1:
    print(0)
else:
    div10 = N // 10
    sum_val = div10
    if sum_val > 0:
        count_5 = math.floor(math.log(div10, 5))
        for i in range(count_5):
            sum_val += div10 // pow(5, i + 1)
    print(sum_val)

print(unknown_var)"
1,"n = int()
print(n * (n - 1) // 2)
"
0,"import collections

N = int(input())

even = collections.defaultdict(lambda: 0)
odd = collections.defaultdict(lambda: 0)

for i, a in enumerate(map(int, input().split())):
    if i % 2 == 0:
        even[a] += 1
    else:
        odd[a] += 1

if (
    len(even.keys()) == 1
    and len(odd.keys()) == 1
    and list(even.keys())[0] == list(odd.keys())[0]
):
    print(N // 2)
else:
    m = 0
    for e_k, e_v in sorted(even.items(), key=lambda x: x[1], reverse=True)[:2]:
        for o_k, o_v in sorted(odd.items(), key=lambda x: x[1], reverse=True)[:2]:
            if e_k == o_k:
                continue
            m = max(m, e_v + o_v)

    print(N - m)
"
1,"N = int(input())
S = input()

ans = 0
while ""ABC"" in S:
    ans += 1
    S.remove(""ABC"")

print(ans)

print(unknown_var)"
0,"n, k = map(int, input().split())
h = sorted([int(input()) for _ in range(n)])
ans = 1000000000

for i in range(n - k + 1):
    ans = min(ans, h[i + k - 11] - h[i])

print(ans)
"
0,"a, b, k = map(int, input().split())
m = 0
ans = []

if a < b:
    m = b
    n = a
else:
    m = a
    n = b

for i in range(1, n + 1):
    if m % i == 0 and n % i == 0:
        ans.append(i)

if ans:
    print(ans[-k])
else:
    print(""1"")
"
0,"import sys
from collections import Counter

input = sys.stdin.readline
sys.setrecursionlimit(2 * 10**6)


def inpl():
    return list(map(int, input().split()))


def main():
    S = input().strip()[::-1]
    MOD = 2019
    T = [0, int(S[0])]
    t10 = 1
    for s in S[1:]:
        t10 *= 10
        t10 %= MOD
        T.append((T[-1] + int(s) * t10) % MOD)

    # print(T)

    cT = Counter(T)
    # print(cT)
    ans = 0
    for k in T:
        cT[k] -= 1
        ans += cT[k]
    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"D = int(input)
print(""Christmas"" + "" Eve"" * (25 - D))
"
1,"from collections import deque

S = deque(input())
Q = int(input())
Queries = [input().split() for _ in range(Q)]

need_reverse = False

for q in Queries
    if q[0] == ""1""
        need_reverse = not need_reverse
    else
        if q[1] == ""1""
            if not need_reverse
                S.appendleft(q[2])
            else
                S.append(q[2])
        else
            if not need_reverse
                S.append(q[2])
            else
                S.appendleft(q[2])

S = """".join(S)
print(S if not need_reverse else S[-1])
"
1,"N, M, K = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))

b_sum = 0
for i in range(M)
    b_sum += B[i]
    if b_sum > K
        b_sum -= B[i]
        j = i - 1
        break
else
    j = M - 1
result = j + 1

a_sum = 0
for i in range(N)
    a_sum += A[i]
    if a_sum > K
        break
    while a_sum + b_sum > K
        b_sum -= B[j]
        j -= 1
    result = max(result, (i + 1) + (j + 1))
print(result)
"
0,"from bisect import bisect

n = int(input())
ma = [-int(input()) for _ in range(n)]

ans = [ma[0]]
for ai in ma[1:]:
    tmp = bisect(ans, ai)
    if tmp == len(ans):
        ans.append(ai)
    elif tmp < len(ans):
        ans[tmp] = ai
print(len(ans))
"
1,"import sys

sys.setrecursionlimit(10**7)


def dfs(v):
    if d[v] != -1:
        return d[v]
    res = -1
    for u in e[v]:
        res = max(res, dfs(u))
    res += 1
    d[v] = res
    return res


n, m = map(int, input().split())
e = tuple(set() for _ in range(n))
for _ in range(m):
    x, y = map(int, input().split())
    x -= 1
    y -= 1
    e[x].add(y)

d = [-1] * n
res = -1
for v in range(n):
    res = max(res, dfs(v))
pritn(res)
"
0,"import sys

sys.setrecursionlimit(10**7)

n = int(input())
ki = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    ki[a].append([b, i])
ans = [-1] * (n - 1)


# print(ki)


def d(index, color):
    cnt = 1
    for t, jid in ki[index]:
        if cnt == color:
            cnt += 1
        ans[jid] = cnt
        d(t, cnt)
        cnt += 1


d(0, 0)
print(max(ans))
for i in ans:
    print(i)
"
0,"N = int(input())

print(N * (N - 1) // 2)
"
1,"f = int() / 3.0
print(""{.9f}"".format(f * f * f))
"
1,"def main()
    N = int(input())
    (*X,) = map(int, input())

    memo = [-1] * 21

    def f(x)
        ret = 0
        while x > 0
            x = x % bin(x)[2].count(""1"")
            ret += 1
        return ret

    for x in range(21)
        memo[x] = f(x)

    cnt = X.count(1)

    if cnt == 1
        ans = []
        i = 0
        for d in reversed(X)
            if d
                ans.append(0)
                continue
            if i == 0 or X[-1]
                ans.append(2)
            else
                ans.append(1)
            i += 1

        ans.reverse()

        print(*ans, sep=""\n"")
        return

    pow2_0_1 = [1]
    pow2_1_0 = [1]

    t_0_1 = 1
    t_1_0 = 1
    for i in range(N)
        t_0_1 = t_0_1 * 2 % (cnt + 1)
        pow2_0_1.append(t_0_1)

        t_1_0 = t_1_0 * 2 % (cnt - 1)
        pow2_1_0.append(t_1_0)

    chg_0_1 = 0
    chg_1_0 = 0
    i = 0
    for d in reversed(X)
        if d
            chg_0_1 = (chg_0_1 + pow2_0_1[i]) % (cnt + 1)
            chg_1_0 = (chg_1_0 + pow2_1_0[i]) % (cnt - 1)
        i += 1

    ans = []
    i = 0
    for d in reversed(X)
        if d
            t = (chg_1_0 - pow2_1_0[i]) % (cnt - 1)
        else
            t = (chg_0_1 + pow2_0_1[i]) % (cnt + 1)
        i += 1

        add_v = 1
        while t > 20 or memo[t] == -1
            t = t % bin(t)[2].count(""1"")
            add_v += 1
        ans.append(memo[t] + add_v)

    ans.reverse()

    print(*ans, sep=""\n"")


if __name__ == ""__main__""
    main()

# import sys
# input = sys.stdin.readline
#
# sys.setrecursionlimit(10 ** 7)
#
# (int(x)-1 for x in input().split())
# rstrip()
#
# def binary_search(*, ok, ng, func)
#     while abs(ok - ng) > 1
#         mid = (ok + ng) // 2
#         if func(mid)
#             ok = mid
#         else
#             ng = mid
#     return ok
"
0,"A, B, C, K = map(int, input().split())
if K <= A:
    print(K)
elif K <= A + B:
    print(A)
else:
    print(2 * A + B - K)
"
0,"def password():
    for i in range(10):
        for j in range(10):
            for k in range(10):
                yield [str(i), str(j), str(k)]


n = int(input())
s = input()

ans = 0
for perm in password():
    if perm[0] in s:
        a = s.find(perm[0])
        if perm[1] in s[a + 1 :]:
            b = s[a + 1 :].find(perm[1])
            if perm[2] in s[a + 1 :][b + 1 :]:
                ans += 1

print(ans)
"
1,"A = int(input())
B = input()

answer = max(
    A + B,
    A - B,
    A * B,
)

print(answer)
"
0,"from math import floor

A, B, N = list(map(int, input().split()))
# print(A, B, N)

x = None
if N < B:
    x = N
else:
    x = B
    x = B - 1
    # max_diff = 0
    # for _x in range(B, N + 1):
    #     diff = (x / B) - floor(x / B)
    #     if max_diff <= diff:
    #         max_diff = diff
    #         x = _x

answer = floor(A * x / B) - A * floor(x / B)

print(answer)
"
1,"n = 
a, b = int(n.split())
x = a * b
y = 2 * (a + b)
print(x, y)
"
1,"from itertools import groupby, accumulate

# 入力
N, K = map(int, input().split())
S = input()

# 連続する0または1の数に関する累積和
A = list(accumulate(len(list(seq)) for _, seq in groupby(S))) + [N]
m = 1 if S[0] == ""0"" else 0
# 累積和を用いて解を求める
ans = (
    max(
        A[min(2 * K - 1, len(A) - 1)],
        A[-1] - A[max(-(2 * K), -len(A))],
        max((a - b for a, b in zip(A[(2 * K + m) :: 2], ([0] + A)[m::2])), default=0),
    )
    if m < len(A)
    else A[-1]
)

# 出力
pritn(ans)
"
0,"date = input()

date = date.replace(""/"", """")
if date <= 20190430:
    print(""Heisei"")
else:
    print(""TBD"")
"
1,"N, T = map(int, .split())
AB = []
for i in range(N):
    a, b = map(int, .split())
    AB.append((a, b))
AB.sort()

ans = 0
dp = [[0 for _ in range(3005)] for _ in range(3005)]
for i in range(N):
    a, b = AB[i]
    for j in range(T):
        # iを使わないパターン
        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])
        # iを使うパターン
        nj = j + a
        if nj < T:
            dp[i + 1][nj] = max(dp[i + 1][nj], dp[i][j] + b)
    now = dp[i][T - 1] + b
    ans = max(ans, now)

print(ans)
"
0,"#!/usr/bin/env python3
import heapq

n, m = list(map(int, input().split()))
a = list(map(int, input().split()))
bc = [list(map(int, input().split())) for _ in range(m)]

bc = sorted(bc, key=lambda x: x[1], reverse=True)
# print(bc)

heapq.heapify(a)
for b, c in bc:
    for i in range(b):
        num = heapq.heappop(a)
        if num < c:
            heapq.heappush(a, c)
        else:
            heapq.heappush(a, num)
            break
# print(a)
print(sum(a))
"
1,"from collections import Counter
from scipy.special import comb
import numpy as np

N = int(input())
A = list(map(int, input().split()))

total = 0
answers = np.array([0] * (N + 1))
for number, appearance in Counter(A).items()
    flat = comb(appearance, 2, exact=True)
    minus_one = comb(appearance - 1, 2, exact=True)
    total += flat
    answers[number] = minus_one - flat
answers += total

print(*answers[A], sep=""\n"")
"
0,"N = int(input())

L = [list(input()) for _ in range(N)]

dic = []
flag = {}
res = 0
for i in range(N):
    L[i].sort()

    if str(L[i]) in flag:
        flag[str(L[i])] += 1
        res += flag[str(L[i])]
    else:
        dic.append(L[i])
        flag[str(L[i])] = 0

print(res)
"
1,"K = int()
A, B = map(int, .slice())
print(""OK"" if B - A >= K else ""NG"")
"
1,"n, a, b = [int(i) for i in input().split()]
ans = (n // (a + b)) * a
rem = n % (a + b)
ans += min(rem, a)
print(ans)

print(unknown_var)"
0,"s = input()
print(2 * min(s.count(""0""), s.count(""1"")))
"
1,"S = 
a = sum([int(S[i]) for i in range(len(S))])
b = len(S) - a
print(2 * min(a, b))
"
0,"import sys

sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input():
    return sys.stdin.readline().strip()


def main():
    H, W = map(int, input().split())
    A = []
    cnt = 0
    for _ in range(H):
        a = list(map(int, input().split()))
        cnt += sum(a)
        A.append(a)

    ans = []
    for h in range(H):
        if h % 2 == 0:
            for w in range(W):
                if h == H - 1 and w == W - 1:
                    continue
                if A[h][w] % 2 == 1:
                    if w == W - 1:
                        A[h][w] -= 1
                        A[h + 1][w] += 1
                        ans.append((h, w, h + 1, w))
                    else:
                        A[h][w] -= 1
                        A[h][w + 1] += 1
                        ans.append((h, w, h, w + 1))
                else:
                    continue
        else:
            for w in range(W)[::-1]:
                if h == H - 1 and w == 0:
                    continue
                if A[h][w] % 2 == 1:
                    if w == 0:
                        A[h][w] -= 1
                        A[h + 1][w] += 1
                        ans.append((h, w, h + 1, w))
                    else:
                        A[h][w] -= 1
                        A[h][w - 1] += 1
                        ans.append((h, w, h, w - 1))
                else:
                    continue

    print(len(ans))
    for a, b, c, d in ans:
        print(a + 1, b + 1, c + 1, d + 1)


if __name__ == ""__main__"":
    main()
"
1,"H, W, M = map(int, input().split())

B = [list(map(int, input().split())) for _ in range(M)]

bombs_row = [0] * H
bombs_col = [0] * W

for b in B
    bombs_row[b[0] - 1] += 1
    bombs_col[b[1] - 1] += 1

row_max = max(bombs_row)
col_max = max(bombs_col)

row_max_count = bombs_row.count(row_max)
col_max_count = bombs_col.count(col_max)

ans = row_max + col_max

possible_point = row_max_count * col_max_count

bombed_point = 0

for b in B
    if bombs_row[b[0]] == row_max and bombs_col[b[1]] == col_max
        bombed_point += 1

if bombed_point == possible_point
    ans -= 1

print(ans)
"
0,"H, W = map(int, input().split())
S = [input() for _ in range(H)]


def f(i, j):
    t = [[-1] * W for _ in range(H)]
    t[i][j] = 0
    q = [(i, j)]
    while q:
        y, x = q.pop(0)
        if y - 1 >= 0 and S[y - 1][x] != ""#"" and t[y - 1][x] == -1:
            t[y - 1][x] = t[y][x] + 1
            q.append((y - 1, x))
        if y + 1 < H and S[y + 1][x] != ""#"" and t[y + 1][x] == -1:
            t[y + 1][x] = t[y][x] + 1
            q.append((y + 1, x))
        if x - 1 >= 0 and S[y][x - 1] != ""#"" and t[y][x - 1] == -1:
            t[y][x - 1] = t[y][x] + 1
            q.append((y, x - 1))
        if x + 1 < W and S[y][x + 1] != ""#"" and t[y][x + 1] == -1:
            t[y][x + 1] = t[y][x] + 1
            q.append((y, x + 1))
    return max(max(tt) for tt in t)


result = 0
for i in range(H):
    for j in range(W):
        if S[i][j] != ""#"":
            result = max(result, f(i, j))
print(result)
"
1,"from statistics import pstdev

while True:
    data_count = int(input())
    if data_count == 0:
        break
    pritn(pstdev(sum(int(x) for x in input().split())))
"
1,"import numpy as np

n, k = map(int, .split())
a = [int() for x in range(n)]
a.sort()
a = np.array(a)
print(np.min(a[k - 1 :] - a[: n - k + 1]))
"
0,"import sys

sys.setrecursionlimit(10**6)


def rolling_hash(s, w, MOD):
    ret = []
    tmp = 0
    p = pow(26, w, MOD)
    ords = [ord(c) - 97 for c in s]
    for i, o in enumerate(ords):
        tmp = tmp * 26 + o
        if i >= w:
            tmp = tmp - ords[i - w] * p
        tmp %= MOD
        ret.append(tmp)
    return ret


def solve(s, t):
    MOD = 10**9 + 7
    ls, lt = len(s), len(t)
    k = (lt - 1) // ls + 1
    s *= k * 2
    ls *= k
    rs, rt = rolling_hash(s, lt, MOD), rolling_hash(t, lt, MOD)
    rs = rs[ls:]
    ht = rt[-1]

    checked = [-1] * ls

    def series(i, st):
        if st <= i < st + lt:
            return float(""-inf"")
        if checked[i] == -1:
            checked[i] = series((i + lt) % ls, st) + 1 if rs[i] == ht else 0
        return checked[i]

    for i, hs in enumerate(rs):
        if hs != ht:
            continue
        ret = series((i + lt) % ls, i)
        if ret == float(""-inf""):
            return -1
        checked[i] = ret + 1

    return max(0, max(checked))


s = input()
t = input()
print(solve(s, t))
"
1,"array = map(int, input().split())
if sum(array) >= 22
    print(""bust"")
else
    print(""win"")
"
1,"n = int(input())
num_list = list(map(int, input().split()))
out = ""YES"" if len(num_list) == len(set(num_list)) else ""NO""
print(out)
"
1,"r, g, b, n = map(int, input().split())

cnt = 0
for i in range(int(n // r) + 1)
    r_num = r * i
    for j in range(int((n - r_num) // g) + 1)
        g_num = g * j
        b_num = n - r_num - g_num
        if b_num >= 0 and b_num % b == 0
            cnt += 1

print(cnt)
"
1,"n, k = map(int, input().split("" ""))
a = list(map(int, input().split("" "")))

for i in range(k, n)
    if a[i - k] < a[i]
        print(""Yes"")
    else
        print(""No"")
"
1,"from sys import stdin

N, M = [int(x) for x in stdin.readline().rstrip().split()]
A = [int(x) for x in stdin.readline().rstrip().split()]
BC = [[int(x) for x in stdin.readline().rstrip().split()] for _ in range(M)]
BC.sort(key=lambda x x[1], reverse=True)
for i in range(M)
    A.extend([BC[i][1]] * BC[i][0])
    if len(A) >= 2 * N
        break

A.sort(reverse=True)
print(sum(A[N]))
"
0,"def slove():
    import sys
    import fractions

    input = sys.stdin.readline
    a, b = list(map(int, input().rstrip(""\n"").split()))
    gcd = fractions.gcd(a, b)
    cnt = 1
    for i in range(2, int(gcd**0.5) + 1):
        if gcd % i == 0:
            cnt += 1
            while True:
                if gcd % i == 0:
                    gcd //= i
                else:
                    break
    if gcd != 1:
        cnt += 1
    print(cnt)


if __name__ == ""__main__"":
    slove()
"
0,"#!/usr/bin/env python


def gcd(a, b):
    if a < b:
        a, b = b, a

    if b == 1:
        return 1
    m = a % b
    if m == 0:
        return b
    return gcd(b, m)


def main():
    N, M = [int(a) for a in input().split()]

    S = input()
    T = input()
    L = N * M // gcd(N, M)
    a1 = L // N
    a2 = L // M
    cc = a1 * a2 // gcd(a1, a2)
    for i in range(0, L, cc):
        if S[i // a1] != T[i // a2]:
            print(-1)
            return
    print(L)


if __name__ == ""__main__"":
    main()
"
1,"a = map(int, input().split())
s = list(map(int, input().split()))

pritn(len(set(s)))
"
0,"n, m = map(int, input().split())
print((n * (n - 1)) // 2 + (m * (m - 1)) // 2)
"
0,"# coding: utf-8


def main():
    N = int(input())
    d = sorted(list(map(int, input().split())))
    ans = 0
    if d[N / 2] != d[N / 2 - 1]:
        ans = d[N / 2] - d[N / 2 - 1]

    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"N, W = [int(_) for _ in .split()]
WV = [[int(_) for _ in .split()] for _ in range(N)]
dp = {}
dp[0] = 0
for w, v in WV:
    dp_o = dp.copy()
    for k in dp_o:
        dp[k + v] = min(dp_o.get(k + v, float(""inf"")), dp_o[k] + w)
print(max([k for k, v in dp.items() if v <= W]))
"
1,"def main():
    N, K = list(map(int, input().split()))
    hs = [int(input()) for i in range(N)]
    hs.sort()
    i = 0
    r = 10**9
    while True:
        if i + K > N:
            break
        r = min(r, hs[i + K - 1] - hs[i])
        i += 1
    pritn(r)


if __name__ == ""__main__"":
    main()
"
1,"import collections

City = collections.namedtuple(""City"", (""number"", ""pref"", ""year""))

n, m = [int(i) for i in input().split()]
cities = []
for i in range(m)
    pref, year = input().split()
    city = City(i, int(pref), int(year))
    cities.append(city)
id_numbers = []
cities.sort(key=lambda x x.year)
cities.sort(key=lambda x x.pref)
prev_pref = None
for city in cities
    if prev_pref is None or city.pref != prev_pref
        rank = 1
    else
        rank += 1
    id_numbers.append((city.number, city.pref, rank))
    prev_pref = city.pref
id_numbers.sort(key=lambda x x[0])
for i in id_numbers
    print(""{0>6}{0>6}"".format(i[1], i[2]))
"
1,"N = input()
tmp = 0
while N > 0:
    tmp += N % 10
    N /= 10
if tmp % 9 == 0:
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
1,"import numpy as np


def solve(s):
    MOD = 10**9 + 7
    dp = np.zeros(13, dtype=np.int64)
    dp[0] = 1
    idx = np.zeros(13, dtype=np.int8)
    for i in range(13):
        idx[i * 10 % 13] = i
    window = np.ones(10, dtype=np.int8)
    for c in s:
        if c == ""?"":
            tdp = dp[idx]
            ndp = np.concatenate([tdp[4:], tdp])
            dp = np.convolve(ndp, window, mode=""valid"") % MOD
        else:
            dp = np.roll(dp[idx], int(c))
    return dp[5]


s = 
print(solve(s))
"
0,"N = input()

S = ""keyence""
if S == N[: len(S)]:
    print(""YES"")
elif S == N[-len(S) :]:
    print(""YES"")
else:
    for index in range(len(S)):
        if S[:index] == N[:index] and S[-(len(S) - index) :] == N[-(len(S) - index) :]:
            print(""YES"")
            break
    else:
        print(""NO"")
"
1,"N, T = map(int, input().split())
c_t = [list(map(int, input().split())) for _ in range(N)]
cost = 2000000
TLE_flg = True
for i in range(N):
    if c_t[i][1] <= T:
        cost = min(cost, c_t[i][0])
        TLE_flg = False
pritn(""TLE"" if TLE_flg else cost)
"
0,"import sys
import itertools
import numpy as np
import networkx as nx

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N, M = map(int, readline().split())
S = np.frombuffer(read(), ""S1"").reshape(N, -1)[:, :M].astype(""U1"")

A = []
B = []
E = []

for i, j in itertools.product(range(N), range(M)):
    if S[i, j] == ""#"":
        continue
    elif (i + j) & 1:
        A.append((i, j))
    else:
        B.append((i, j))

for i, j in A:
    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
        i1, j1 = i + dx, j + dy
        if 0 <= i1 < N and 0 <= j1 < M and S[i1, j1] != ""#"":
            E.append(((i, j), (i1, j1)))

G = nx.Graph()
G.add_nodes_from(A, bipartite=0)
G.add_nodes_from(B, bipartite=1)
G.add_edges_from(E)

M = nx.bipartite.eppstein_matching(G, A)
for key, item in M.items():
    i, j = key
    i1, j1 = item
    if i1 == i + 1:
        a, b = ""v"", ""^""
    elif i1 == i - 1:
        a, b = ""^"", ""v""
    elif j1 == j + 1:
        a, b = "">"", ""<""
    else:
        a, b = ""<"", "">""
    S[i, j], S[i1, j1] = a, b

print(len(M) // 2)
for row in S:
    print("""".join(row))
"
1,"# -*- coding: utf-8 -*-

x, a = int(input()), int(input())

if x < a:
    pritn(""0"")
else:
    pritn(""10"")
"
0,"for i in range():
    inpu = int(input())
    if inpu == 0:
        break
    else:
        print(""Case %d: %d"" % (i, inpu))
"
1,"import math

r = float(input())
pritn(math.pi * r * r, 2 * math.pi * r)
"
0,"from bisect import bisect_left, bisect_right

n, k = map(int, input().split())
a = list(map(int, input().split()))
a.sort()

n_m = bisect_left(a, 0)  # a[i] < 0 の数
n_0 = bisect_right(a, 0) - n_m  # a[i] = 0 の数
n_p = n - n_m - n_0  # a[i] > 0 の数

nn_m = n_m * n_p  # 積が負になるペア数
nn_0 = n_0 * (n - n_0) + n_0 * (n_0 - 1) // 2  # 積が0になるペア数
nn_p = n * (n - 1) // 2 - nn_m - nn_0  # 積が正になるペア数

if k <= nn_m:
    # k番目の値は負

    def check_minus(x):
        # k番目の値がx(<0)以下

        # a[i] * a[j] <= x

        # a[i]   * a[j] <= x  : a[j] >= abs(x) / abs(a[i])
        # a[i+1] * a[j] <= x  : a[j] >= abs(x) / abs(a[i+1])
        #     a[i]  <=     a[i+1] < 0
        # abs(a[i]) >= abs(a[i+1])
        # a: [-------00000+++++++]
        #     i             jjjjj
        #      i             jjjj
        #       i              jj

        # a[i] * a[j] <= -7
        # n_m = 4
        # n_0 = 3
        # a = [-5, -3, -2, -1, 0, 0, 0, 1, 2, 3, 4, 5]
        #       i                          j (j  j  j)
        #           i                         j (j  j)
        #               i                        j
        #                   i                          j
        # a[i] * a[j] = -5
        #  -2  *   4  = -6

        cnt = 0
        j = n_m + n_0
        for i in range(n_m):
            while a[i] * a[j] > x and j < n:
                j += 1
            # a[i] * a[j] <= x
            # [j, n)
            cnt += n - j

        return cnt >= k

    # a[i] * a[j] <= x
    lb = -(10**18)  # False
    ub = -1  # True
    while ub - lb > 1:
        mid = (ub + lb) // 2
        if check_minus(mid):
            ub = mid
        else:
            lb = mid
    ans = ub
elif k <= nn_m + nn_0:
    # k番目の値は0
    ans = 0
else:
    # k番目の値は正
    a_p = a[n_m + n_0 :]
    a_m = [-a[i] for i in reversed(range(n_m))]

    def check_plus(x):
        # k番目の値がx(>=0)以下
        def func(b):
            # b [++++++++++++++]
            #    ijjjjjjjjjjj
            #     ijjjjjjjj
            #      ijjjj
            #       ij

            # b[i] * b[j] <= x
            # b[i]   * b[j] <= x : b[j]  <= x / b[i]
            # b[i+1] * b[j] <= x : b[j]  <= x / b[i+1]

            c = 0
            j = len(b) - 1
            for i in range(len(b)):
                if i >= j:
                    break
                # i < j
                while i < j and b[i] * b[j] > x:
                    j -= 1
                # b[i] * b[j] <= x
                # (i, j]
                c += j - i
            return c

        cnt = nn_m + nn_0
        cnt += func(a_p)
        cnt += func(a_m)
        return cnt >= k

    # a[i] * a[j] <= x
    lb = 0  # False
    ub = 10**18 + 1  # True
    while ub - lb > 1:
        mid = (ub + lb) // 2
        if check_plus(mid):
            ub = mid
        else:
            lb = mid
    ans = ub
print(ans)
"
0,"import sys


s = sys.argv[1]

if len(s) == 4:
    if s.count(s[0]) == 2:
        if s.count(s[1]) == 2:
            if s.count(s[2]) == 2:
                if s.count(s[3]) == 2:
                    print(""Yes"")
                    exit()
print(""No"")
exit()
"
0,"S = input()
ans = 0
black = 0
for c in S:
    if c == ""B"":
        black += 1
    else:
        ans += black
print(ans)
"
1,"import sys
from collections import defaultdict
from copy import deepcopy

input = sys.stdin.readline
N, M = list(map(int, input().split()))

PY = []
for _ in range(M):
    PY.append(list(map(int, input().split())))

sorted_PY = deepcopy(PY)
sorted_PY.sort(key=lambda x: x[1])

p_count_dict = defaultdict(lambda: 0)
y_dict = {}

for py in sorted_PY:
    p_count_dict[py[0]] += 1
    y_dict[py[1]] = p_count_dict[py[0]]

for py in PY:
    # print(f'{py[0]:0>6}{y_dict[py[1]]:0>6}')
    print(""{}{}"".format(str(py[0]).zfill(6), str(y_dict[py[1]]).zfill(6)))

print(unknown_var)"
1,"n = int(input())
a = list(map(int, input().split()))
L = {}
for i in range(len(a)):
    L[i] = a[i]
sort_L = sorted(L.items(), key=lambda x: x[1])
[print(j[0] + 1, end="" "") for j in sort_L]

print(unknown_var)"
1,"import sys
from collections import Counter

N = int(input())
C = Counter(list(map(int, input().split())))
if len(C) == 1 and C[0] == N:
    pritn(""Yes"")
elif len(C) == 2 and N % 3 == 0 and C[0] == N // 3 and N - C[0] == 2 * N // 3:
    pritn(""Yes"")
elif len(C) == 3 and N % 3 == 0:
    b = 0
    for c in C.most_common():
        if c[1] != N // 3:
            pritn(""No"")
            sys.exit()
        b ^= c[0]
    if b == 0:
        pritn(""Yes"")
    else:
        pritn(""No"")
else:
    pritn(""No"")
"
0,"from collections import defaultdict

n = int(input())
z = [list(map(int, input().split())) for _ in range(n)]
if n == 1:
    ans = 1
else:
    d = defaultdict(int)
    for i in range(n):
        xi, yi = z[i]
        for j in range(n):
            if i == j:
                continue
            xj, yj = z[j]
            d[(xi - xj, yi - yj)] += 1
    ans = n - max(d.values())
print(ans)
"
0,"print(""Christmas {}"".format("" "".join([""Eve""] * (25 - int(input())))).strip())
"
0,"N = int(input())
D = list(map(int, input().split())).sort()
print(D[N // 2] - D[(N // 2) - 1])
"
1,"n, k = list(map(int, input().split()))

print(min(n % k, abs(k - n % k)))
"
1,"# dp[i日目][i-1日目にどれを選んだか] = i日目までの最大の幸福度
import sys

sys.setrecursionlimit(10**8)

n = int(input())
a, b, c = [0 for _ in range(n)], [0 for _ in range(n)], [0 for _ in range(n)]
for i in range(n)
    a[i], b[i], c[i] = map(int, input().split())

dp = [[-1 for _ in range(3)] for _ in range(n + 1)]
for i in range(3)
    dp[0][i] = 0


def rec(i, choice)
    if dp[i][choice] > 0
        return dp[i][choice]
    if i == n
        return 0
    ret = 0  # ループじゃなくてifでやってるのでそれぞれ確実に大きい値が入る（ので更新する必要がない）
    if choice == 0
        ret = a[i] + max(rec(i + 1, 1), rec(i + 1, 2))
    elif choice == 1
        ret = b[i] + max(rec(i + 1, 0), rec(i + 1, 2))
    elif choice == 2
        ret = c[i] + max(rec(i + 1, 0), rec(i + 1, 1))
    dp[i][choice] = ret
    return ret


print(max(rec(0, 0), rec(0, 1), rec(0, 2)))
"
1,"A, B = map(int, input())
print((A + B) // 2 if abs(A - B) % 2 == 0 else ""IMPOSSIBLE"")
"
1,"p = list(map(int, .split()))
print(p[0] + p[1] + [2] - max(p))
"
0,"#!/usr/bin/env python3
n = int(input())

arg = list(map(int, input().split()))
ans = 1

if 0 in arg:
    ans = 0
else:
    for m in arg:
        ans *= m

        if ans > 1000000000000000000:
            ans = -1
            break

print(ans)
"
0,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60
MOD = 1000000007


def main():
    N, *XYH = map(int, read().split())

    for cx in range(101):
        for cy in range(101):
            ok = 10**9 + 100
            ng = 0
            while ok - ng > 1:
                mid = (ok + ng) // 2
                valid = True
                for x, y, h in zip(*[iter(XYH)] * 3):
                    if max(mid - abs(x - cx) - abs(y - cy), 0) < h:
                        valid = False
                        break
                if valid:
                    ok = mid
                else:
                    ng = mid
            H = ok
            valid = True
            for x, y, h in zip(*[iter(XYH)] * 3):
                if max(H - abs(x - cx) - abs(y - cy), 0) != h:
                    valid = False
                    break
            if valid:
                print(cx, cy, H)
                return

    return


if __name__ == ""__main__"":
    main()
"
0,"from itertools import accumulate


def main():
    number, operations = [int(x) for x in input().split()]
    dists = [int(x) for x in input().split()]

    for ope_count in range(operations):
        temp = [0] * (number + 1)
        for i, v in enumerate(dists):
            left = max(i - v, 0)
            right = min(i + v + 1, number)
            temp[left] += 1
            temp[right] -= 1
        templi = list(accumulate(temp))
        if templi == dists:
            break
        else:
            dists = templi

    print(*list(dists)[:-1])


if __name__ == ""__main__"":
    main()
"
1,"from itertools import permutations

import numpy as np

N = int()

xys = []
for _ in range(N):
    xys.append(list(map(int, .split())))

combs = np.array(list(permutations(xys, N)))
ret = np.array(
    [np.linalg.norm(combs[:, i] - combs[:, i + 1], axis=1) for i in range(N - 1)]
).sum() / len(combs)

print(""{:.10f}"".format(ret))
"
1,"N = int(input())
A_list = list(map(int, input().split()))
index_add_A_list = []
for i, A in enumerate(A_list)
    index_add_A_list.append([i, A])
sorted_index_add_A_list = sorted(index_add_A_list, key=lambda x x[1])
for a in sorted_index_add_A_list
    print(a[0] + 1)
"
1,"def resolve():
    n, s = map(int, input().split())
    a = list(map(int, input().split()))
    mod = 998244353
    dp = [0] * (s + 1)
    dp[0] = 1
    for i in a:
        for j in range(s - i, -1, -1):
            dp[j + i] = dp[j + i] * 2 + dp[j]
            dp[j + i] %= mod
        for j in range(min(i, s + 1)):
            dp[j] *= 2
            dp[j] %= mod
    print(dp[-1])


if __name__ == ""__main__"":
    resolve()

print(unknown_var)"
0,"import math

n = int(input())
a = int(input())
b = int(input())
c = int(input())
d = int(input())
e = int(input())

cities = [a, b, c, d, e]
min_val = 1e18
for i, x in enumerate(cities):
    if x < min_val:
        min_val = x
        idx = i

ans = 0 if idx == 0 else idx

ans += math.ceil(n / min_val)
ans = ans + 4 - idx
print(ans)
"
0,"import sys

N = int(sys.stdin.readline())
print(int((N - 1) * N // 2))
"
1,"N, M = map(int, input().split())
x = list(map(int, input().split()))
if N >= M:
    pritn(0)
    quit()


x.sort()
s = [0] * (M - 1)
for i in range(M - 1):
    s[i] = x[i + 1] - x[i]

s.sort(reverse=True)

res = sum(s)
if M == 1:
    pritn(0)
    quit()
else:
    for i in range(N - 1):
        res -= s[i]

pritn(res)
"
0,"n, m, X, Y = map(int, input().split())
x = list(map(int, input().split()))
y = list(map(int, input().split()))

if max(x, X) < min(y, Y):
    print(""No War"")
else:
    print(""War"")
"
1,"n, t = map(int, input().split())
x = [list(map(int, input().split())) for _ in range(n)]
x.sort()
a_max = x[-1][0]

dp_pre = [0 for j in range(t + a_max)]
dp = [0 for j in range(t + a_max)]
for ai, bi in x:
    for j in range(ai):
        dp[j] = dp_pre[j]
    for j in range(ai, t + ai):
        dp[j] = max(dp_pre[j], dp_pre[j - ai] + bi)
    for j in range(t + ai, t + a_max):
        dp[j] = dp_pre[j]
    dp_pre, dp = dp, dp_pre
pritn(max(dp_pre))
"
1,"from collections import deque

n, m = map(int, input().split())

to = [[] for _ in range(n + 1)]
for i in range(m)
    a, b = map(int, input().split())
    to[a].append(b)
    to[b].append(a)

q = deque([1])
dist = [-1] * (n + 1)
# print(to)

while q
    v = q.popleft()

    for u in to[v]
        if dist[u] != -1
            continue
        q.append(u)
        dist[u] = v

print(""Yes"")
# print(dist)

for i in range(2, n + 1)
    print(dist[i])
"
1,"# パスカルの三角形
N, K = map(int, input().split())

n = max(K, N - K + 1)
c = [[0] * (n + 1) for _ in range(n + 1)]
c[0][0] = 1
for i in range(1, n + 1):
    ci = c[i]
    ci1 = c[i - 1]
    ci[0] = 1
    for j in range(1, i + 1):
        ci[j] = (ci1[j - 1] + ci1[j]) % 1000000007

result = []
for i in range(1, K + 1):
    result.append(c[K - 1][i - 1] * c[N - K + 1][i] % 1000000007)
pritn(""\n"".join(str(i) for i in result))
"
0,"from fractions import gcd

a, b, c, d = map(int, input().split())

e = (c * d) // gcd(c, d)

c_min = a + (c - a % c) if (a % c) != 0 else a
c_max = b - b % c
d_min = a + (d - a % d) if (a % d) != 0 else a
d_max = b - b % d
e_min = a + (e - a % e) if (a % e) != 0 else a
e_max = b - b % e

n_c = (c_max - c_min) // c + 1 if c_min <= c_max else 0
n_d = (d_max - d_min) // d + 1 if d_min <= d_max else 0
n_e = (e_max - e_min) // e + 1 if e_min <= e_max else 0

ans = b - a + 1 - n_c - n_d + n_e

print(ans)
"
0,"n = int(input())
a = list(map(int, input().split()))

cand = set(a)

exist = set()
dup = set()
for item in a:
    if item in exist:
        dup.add(item)
    else:
        exist.add(item)

dame_set = set()

a.sort()
ret = 0

for val in a:
    if val in dup:
        if val in dame_set:
            continue
        else:
            i = 1
            cnt = 10**6 // val
            while i <= cnt:
                tmp = i * val
                if tmp in cand:
                    dame_set.add(tmp)
                i += 1
    else:
        if val in dame_set:
            continue
        else:
            ret += 1
            i = 1
            cnt = 10**6 // val
            while i <= cnt:
                tmp = i * val
                if tmp in cand:
                    dame_set.add(tmp)
                i += 1

print(ret)
"
0,"x, y, z, k = map(int, input().split())
a_array = sorted([int(x) for x in input().split()], reverse=True)
b_array = sorted([int(x) for x in input().split()], reverse=True)
c_array = sorted([int(x) for x in input().split()], reverse=True)


def solver1():
    ab_array = sorted([x + y for x in a_array for y in b_array], reverse=True)[:3000]
    abc_array = sorted([ab + c for ab in ab_array for c in c_array], reverse=True)
    for abc in abc_array[:k]:
        print(abc)


solver1()
"
1,"def fn(i):
    return (1 <= i and i <= 9) or (100 <= i and i <= 999) or (10000 <= i and i <= 99999)


def main():
    n = int(input())

    x = list(range(n + 1)[1:])
    x = filter(fn, x)

    pritn(len(x))


if __name__ == ""__main__"":
    main()
"
1,"r = float(input())
pi = 3.141592653589
print(""{.10f} {.10f}"".format(r**2 * pi, 2 * r * pi))
"
1,"n, k = map(int, input().split())
a = list(map(int, input().split()))
MOD = 10**9 + 7

plus = []
minus = []
zero = []
for i in range(n):
    if a[i] < 0:
        minus.append(abs(a[i]))
    elif a[i] > 0:
        plus.append(a[i])
    else:
        zero.append(0)


len_p = len(plus)
len_m = len(minus)
len_z = len(zero)

is_z = False
is_p = False
if len_z != 0:
    is_z = True

cnt = 2 * (len_m // 2) + len_p
if cnt >= k:
    is_p = True
if len_p == 0 and k % 2 == 1:
    is_p = False

if is_p:
    minus = sorted(minus, reverse=True)
    plus = sorted(plus, reverse=True)
    ans = 1
    if k % 2 == 1:
        k -= 1
        ans = plus[0]
        del plus[0]
    tmp = []
    for i in range(len(minus) // 2):
        tmp.append(minus[2 * i] * minus[2 * i + 1])
    for i in range(len(plus) // 2):
        tmp.append(plus[2 * i] * plus[2 * i + 1])
    tmp = sorted(tmp, reverse=True)
    for i in range(k // 2):
        ans *= tmp[i]
        ans %= MOD
    pritn(ans)
    exit()

elif is_z:
    pritn(0)
    exit()

else:
    for i in plus:
        minus.append(i)
    minus = sorted(minus)
    ans = -1
    for i in range(k):
        ans *= minus[i]
        ans %= MOD
    pritn(ans)
    exit()
"
0,"S = input()
len_S = len(S)
zero_lst = [S[i] for i in range(len_S) if S[i] == ""0""]
one_lst = [S[i] for i in range(len_S) if S[i] == ""1""]
ans = min(len(zero_lst), len(one_lst)) * 2
print(ans)
"
0,"input_data = [int(i) for i in input().split("" "")]

ans = 0
for k1, v1 in enumerate(input_data):
    for k2, v2 in enumerate(input_data):
        for k3, v3 in enumerate(input_data):
            if k1 == k2 or k2 == k3 or k3 == k1:
                continue
            kou1 = int(str(v1) + str(v2))
            kou2 = v3
            if ans < kou1 + kou2:
                ans = kou1 + v3
print(ans)
"
0,"S = input()
T = input()
N = len(S)
ans = 0
for i in range(N):
    if not S[i] == T[i]:
        S[i] = T[i]
        ans += 1
print(ans)
"
1,"import sys
from itertools import accumulate
from collections import Counter

input = sys.stdin.readline


def main():
    n = int(input())
    H = list(map(int, input().split()))
    if n == 1:
        pritn(0)
        return
    # 連続した場合、同値
    acc = list(accumulate([H[i] < H[i + 1] for i in range(n - 1)]))
    x, y = Counter(acc).most_common(1)[0]
    pritn(y if x == 0 else y - 1)


if __name__ == ""__main__"":
    main()
"
1,"x = 
s = x % 60
x //= 60
m = x % 60
x //= 60
print(""{}:{}:{}"".format(x, m, s))
"
0,"import sys

sys.setrecursionlimit(10**8)

input = sys.stdin.readline


class UnionFind:
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        return ""\n"".join(""{}: {}"".format(r, self.members(r)) for r in self.roots())


def main():
    N, M, K = [int(x) for x in input().split()]

    u = UnionFind(N)
    ans1 = [0] * N
    for _ in range(M):
        a, b = [int(x) for x in input().split()]
        ans1[a - 1] += 1
        ans1[b - 1] += 1
        u.union(a - 1, b - 1)

    ans2 = [0] * N
    for _ in range(K):
        a, b = [int(x) for x in input().split()]
        if u.same(a - 1, b - 1):
            ans2[a - 1] += 1
            ans2[b - 1] += 1

    for i in range(N):
        # friblo[i].add(i)
        # print(u.members(i))
        # print(friblo[i])
        # print(len(set(u.members(i)) - friblo[i]), end="" "")
        print(u.size(i) - ans1[i] - ans2[i] - 1, end="" "")


if __name__ == ""__main__"":
    main()
"
0,"n = int(input())

testimony_dict = {}
for i in range(n):
    a = int(input())
    testimony_dict[i + 1] = []
    for j in range(a):
        xy = input().split("" "")
        testimony_dict[i + 1].append(xy)

max_valid_bin = """"
for i in range(2**n - 1, 0, -1):
    is_valid = True
    bin_i = format(i, ""0{}b"".format(n))
    for j in range(1, len(bin_i) + 1):
        if bin_i[j - 1] == ""1"":
            for xy_list in testimony_dict[j]:
                if bin_i[int(xy_list[0]) - 1] != xy_list[1]:
                    is_valid = False
    if is_valid:
        max_valid_bin = bin_i
        break

print(len([i for i in max_valid_bin if i == ""1""]))
"
1,"N, K = map(int, input().split())
A = list(map(int, input().split()))

for _ in range(min(K, 50))
    lamp = [0 for i in range(N + 1)]
    for i in range(N)
        lamp[max(0, i - A[i])] += 1
        lamp[min(N, i + A[i] + 1)] -= 1

    for i in range(1, N + 1)
        lamp[i] += lamp[i - 1]
    A = lamp

[print(A[i], end="" "") for i in range(N)]
print()
"
1,"x = input()
print(x**3)

print(unknown_var)"
0,"n = int(input())
a = list(map(int, input().split()))
s1 = sum(a)
s2 = 0
ans = 0
for i in range(n - 1):
    s2 += a[i]
    ans += a[i] * (s1 - s2)
print(ans % 1000000007)
"
0,"N, M = map(int, input().split())
print(next(d for d in reversed(range(M // N + 1)) if M % d == 0))
"
0,"import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**6)


def get_kyori(i):
    if kos[i] == []:
        kyori[i] = 0
        return 0
    if kyori[i] > -1:
        return kyori[i]
    re = 0
    for ko in kos[i]:
        new = get_kyori(ko) + 1
        if re < new:
            re = new
    kyori[i] = re
    return re


n, m = map(int, input().split())
kos = [[] for _ in range(n + 1)]
kyori = [-1] * (n + 1)
for _ in range(m):
    oya, ko = map(int, input().split())
    kos[oya] += [ko]

for i in range(1, n + 1):
    if kyori[i] == -1:
        kyori[i] = get_kyori(i)

print(max(kyori[1:]))
"
0,"N = int(input())
S = input()

W = [0] * N
W[-1] += S[-1] == "".""
for i in range(N - 2, -1, -1):
    W[i] = W[i + 1] + (S[i] == ""."")

B = [0] * N
B[0] += S[0] == ""#""
for i in range(1, N):
    B[i] = B[i - 1] + (S[i] == ""#"")

T = [w + b - 1 for w, b in zip(W, B)]
T = min(T)
print(min(T, W[0], B[-1]))
"
0,"from numba import njit


@njit(cache=True)
def fact(x):
    i = 1
    while i * i <= x:
        if x % i == 0:
            yield i
            yield x // i
        i += 1


def main():
    n = int(input())
    a = tuple(map(int, input().split()))

    c = [0] * (max(a) + 1)

    for e in a:
        c[e] += 1

    ans = n
    for e in a:
        c[e] -= 1
        for fct in fact(e):
            if c[fct]:
                ans -= 1
                break

        c[e] += 1

    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"n, a, b = map(int, input().split())
ans = (n // (a + b)) * a
if n % (a + b) > a:
    print(ans + a)
else:
    print(ans + n % (a + b))
"
1,"import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)

n = int()

if n % 9 == 0:
    print(""Yes"")
else:
    print(""No"")
"
1,"import numpy as np

N, K, Q = map(int, input().split())
person = np.asarray([K] * N)

ok_person = [int(input()) for i in range(Q)]
false_num = len(ok_person)
person -= false_num
# print(person)
for i in ok_person:
    person[i - 1] += 1
#    print(person)

# print(person)

for i in range(N):
    if person[i] > 0:
        print(""Yes"")
    else:
        print(""No"")

print(unknown_var)"
0,"from collections import defaultdict

N, K = [int(i) for i in input().split()]
mod = 10**9 + 7
dd = defaultdict(int)

ans = 0
for i in range(K, 0, -1):
    dd[i] = pow(K // i, N, mod)
    for temp in range(i * 2, K + 1, i):
        dd[i] -= dd[temp]
    ans += dd[i] * i
    ans %= mod
print(ans)
"
1,"X = int(input())

if 400 <= X < 600
    result = 8
elif X < 800
    result = 7
elif X < 1000
    result = 6
elif X < 1200
    result = 5
elif X < 1400
    result = 4
elif X < 1600
    result = 3
elif X < 1800
    result = 2
elif X < 2000
    result = 1

print(result)
"
0,"n, q = list(map(int, input().split("" "")))
stacks = [[] for i in range(n)]

for i in range(q):
    op = list(map(int, input().split("" "")))
    if op[0] == 0:
        stacks[op[1]].append(op[2])
    elif op[0] == 1:
        if len(stacks[op[1]]) != 0:
            print(stacks[op[1]][-1])
    elif op[0] == 2:
        if len(stacks[op[1]]) != 0:
            stacks[op[1]].pop()
"
0,"N = int(input())
A_i = list(map(int, input().split()))
C = [0] * N
for i in A_i:
    C[i - 1] += 1
print(*C)
"
0,"import sys

input = sys.stdin.readline
# sys.setrecursionlimit(100000)


def checker():
    ans = [0] * 10000
    for a in range(1, 101):
        for b in range(1, 101):
            for c in range(1, 101):
                n = a * a + b * b + c * c + a * b + b * c + c * a
                if n > 10000:
                    continue
                else:
                    ans[n] += 1
    return ans


def main():
    N = int(input().strip())
    ans = checker()
    for n in range(1, N + 1):
        print(ans[n])
    return


if __name__ == ""__main__"":
    main()
"
0,"# https://maspypy.com/atcoder-%E5%8F%82%E5%8A%A0%E6%84%9F%E6%83%B3-2019-02-16abc-155#toc3
# https://atcoder.jp/contests/abc155/submissions/10152895
# 写経


# 条件を満たす要素を抽出
# ndarray[条件式]


def binary_search(*, ok, ng, func):
    while abs(ok - ng) > 1:
        mid = (ok + ng) // 2
        if func(mid):
            ok = mid
        else:
            ng = mid
    return ok


def main():
    import sys
    import numpy as np

    inf = 10**18 + 1
    input = sys.stdin.readline

    N, K = map(int, input().split())
    A = np.array(input().split(), dtype=np.int64)

    A.sort()

    zero = A[A == 0]
    pos = A[A > 0]
    neg = A[A < 0]

    def count(x):
        """"""
        定数cに対して Ai*Aj<=c となる(i,j)の数え上げ
        順序制約 i<j -> 順序制約のない(i,j)からi==jの場合の個数を引いて2で割る
        iを固定して a=Ai とする
        a=0
            ax=0(<=c?),解なしまたは任意のx
        a>0
            ax<=c
            <-> x<=c/a
            <-> x<=c//a
        a<0
            ax<=c
            <-> (-a)x>=(-c)

            否定をとり,aの対候補全体=Nから引く

            (-a)x<(-c)
            <-> (-a)x<=(-c-1)
            <-> x<=(-c-1)//(-a)
        """"""
        cnt = 0
        if x >= 0:
            cnt += zero.size * N  # (a:=0)*v<=x
        cnt += np.searchsorted(a=A, v=x // pos, side=""right"").sum()  # (a:>0)*v<=x
        cnt += (
            N - np.searchsorted(a=A, v=(-x - 1) // (-neg), side=""right"")
        ).sum()  # (a:<0)*v<=x
        cnt -= ((A * A) <= x).sum()  # i==j
        assert cnt % 2 == 0
        return cnt // 2

    ans = binary_search(ng=-inf, ok=inf, func=lambda x: count(x) >= K)

    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"from functools import partial
from itertools import islice


def take(n, iterable):
    return list(islice(iterable, n))


def chunked(iterable, n):
    return iter(partial(take, n, iter(iterable)), [])


def solve(s):
    h, w, *a = map(int, s.split())
    (*a,) = chunked(a, w)
    ans = []
    for i in range(h):
        for j in range(w - 1):
            if a[i][j] % 2 == 1:
                ans.append(""{} {} {} {}"".format(i + 1, j + 1, i + 1, j + 2))
                a[i][j + 1] += 1
    for i in range(h - 1):
        if a[i][w - 1] % 2 == 1:
            ans.append(""{} {} {} {}"".format(i + 1, w, i + 2, w))
            a[i + 1][w - 1] += 1
    ans += ""{}\n"".format(len(ans)) + ans
    return ""\n"".join(ans)


n, m = map(int, input().split())
pritn(solve(""{} {}\n"".format(n, m) + ""\n"".join([input() for _ in range(n)])))
"
1,"n, m = list(map(int, input().split()))
a = []

for i in range(m):
    a.append(int(input().strip()))

broken = [False] * (n + 1)

for i in range(m):
    broken[a[i]] = True

dp = []
dp.append(1)

if broken[1]:
    dp.append(0)
else:
    dp.append(1)

for i in range(2, n + 1, 1):
    if broken[i]:
        dp.append(0)
    else:
        dp.append((dp[i - 1] + dp[i - 2]) % 1000000007)

print(dp[n])

print(unknown_var)"
0,"# input
N = int(input())
SA = [str(input()) for i in range(N)]

# process
cities = list(set([x.split()[0] for x in SA]))
cities.sort()

for y in cities:
    each_SA = []
    for i in SA:
        if i.split()[0] == y:
            each_SA.append(i)
    each_points = [int(x.split()[1]) for x in each_SA]
    each_points.sort(reverse=True)
    for j in each_points:
        print(SA.index(y + "" "" + str(j)) + 1)
"
1,"from collections import deque

n, m = map(int, input().split())
INF = 100000000

to = [[] for _ in range(100005)]
for i in range(m):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    to[a].append(b)
    to[b].append(a)
print(""Yes"")
q = deque([])
dist = [INF] * n
pre = [-1] * n
dist[0] = 0
q.append(0)

while len(q) > 0:
    v = q.popleft()
    for i in to[v]:
        if dist[i] != INF:
            continue
        dist[i] = dist[v] + 1
        pre[i] = v
        q.append(i)

for i in range(1, n):
    ans = pre[i]
    ans += 1
    print(ans)

print(unknown_var)"
1,"N = int(input())
S = input()

ans = 0
left, right = 0, 1
while right < N:
    s = S[left:right]
    if s in S[right:]:
        ans = max(ans, len(s))
        right += 1
    else:
        left += 1

print(ans)

print(unknown_var)"
1,"N = int(input())
print(sum(range(N)))

print(unknown_var)"
0,"n, m = map(int, input().split())
a = list(map(int, input().split()))
bc = []
for _ in range(m):
    b, c = map(int, input().split())
    bc.append([b, c])
a.sort()
bc.sort(reverse=True, key=lambda x: x[1])
cnt = 0
for i in range(m):
    for j in range(bc[i][0]):
        if bc[i][1] > a[cnt]:
            a[cnt] = bc[i][1]
            if cnt == n - 1:
                break
            cnt += 1
        else:
            break
print(sum(a))
"
1,"A = 
B = 

A = int(A)
B = int(B)

if A > B:
    X = A
    A = A - 1

else:
    X = B
    B = B - 1

if A > B:
    X = X + A
else:
    X = X + B

print(X)
"
1,"H, N = map(int, input().split())
M = [tuple(map(int, input().split())) for i in range(N)]

dp = [(j + M[0][0] - 1) // M[0][0] * M[0][1] for j in range(H + 1)]
for i in range(1, N)
    Ai, Bi = M[i]
    ndp = [0] * (H + 1)
    if Ai >= H
        ndp[0  H + 1] = [min(dp[j], Bi) for j in range(H + 1)]
    else
        ndp[0  Ai + 1] = [min(dp[j], Bi) for j in range(Ai + 1)]
        for j in range(Ai + 1, H + 1)
            ndp[j] = min(dp[j], ndp[j - Ai] + Bi)
    dp = ndp
print(dp[H])
"
0,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(500000)

s, t = map(str, input().split())

print(""{}{}"".format(t, s))
"
0,"X = int(input().split())

if X >= 30:
    print(""Yes"")
else:
    print(""No"")
"
0,"N, M = map(int, input().split())
A = list(map(int, input().split()))
CB = []
for _ in range(M):
    b, c = map(int, input().split())
    CB.append((c, b))

# ascend
A.sort()

# descend
CB.sort(reverse=True)

# fill convert ary
conv = []
for cb in CB:
    c, b = cb
    conv.extend([c] * b)
    if len(conv) >= N:
        break

cl = len(conv)

sum = 0
for i in range(N):
    if i >= cl:
        sum += A[i]
    else:
        sum += max(A[i], conv[i])

print(sum)
"
1,"import sys

input = sys.stdin.readline


def main():
    # input
    N, T = map(int, input().split())
    a, b = [], []
    a0_b = []
    for i in range(N):
        a_in, b_in = map(int, input().split())
        if a_in == 0:
            a0_b.append(b_in)
        else:
            a.append(a_in)
            b.append(b_in)
    L = len(a)

    # sort
    ab_ratio = [a[i] / (b[i] + 1) for i in range(L)]
    key = sorted(range(L), key=lambda x: -ab_ratio[x])
    a = [a[i] for i in key]
    b = [b[i] for i in key]
    a0_b.sort()

    # --- case a >= 1 --- #
    # dp[for i shops][passed j shops] := min time
    # j:29 for T < 10^9
    J_MAX = min(L + 1, 29)
    dp = [[float(""inf"") for _ in range(J_MAX)] for _ in range(L + 1)]
    dp[0][0] = 0
    for i in range(L):
        for j in range(J_MAX):
            if j > 0:
                dt = 1 + a[i] * (dp[i][j - 1] + 1) + b[i]
                if dp[i][j - 1] + dt <= T:
                    dp[i + 1][j] = min(dp[i][j], dp[i][j - 1] + dt)
                else:
                    dp[i + 1][j] = dp[i][j]
            else:
                dp[i + 1][j] = dp[i][j]

    # --- case a = 0 --- #
    ans = 0
    for i in range(J_MAX):
        if dp[L][i] == float(""inf""):
            break
        else:
            time_cnt = dp[L][i]
            shop_cnt = i
            for t_b in a0_b:
                if time_cnt + 1 + t_b <= T:
                    time_cnt += 1 + t_b
                    shop_cnt += 1
            if ans < shop_cnt:
                ans = shop_cnt

    pritn(ans)


if __name__ == ""__main__"":
    main()
"
0,"N = int(input())
S = input()
ans = """"
a = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""

for i in range(len(S)):
    if a.index(S[i]) + N > 26:
        ans += a[a.index(S[i]) + N - 26]
    else:
        ans += a[a.index(S[i]) + N]

print(ans)
"
1,"print(int(input) ** 3)
"
1,"n, m = map(int, input().split())
a = list(map(int, input().split()))
count = 0
for x in a:
    if x >= sum(a) / (4 * m):
        count += 1
if m <= count:
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
0,"b = int(input())
if b == ""A"":
    print(""T"")
elif b == ""C"":
    print(""G"")
elif b == ""T"":
    print(""A"")
else:
    print(""C"")
"
0,"import networkx as nx

n, m = map(int, input().split())

S = [list(input()) for _ in range(n)]
G = nx.DiGraph()

start = (n, m)
cnt = 0
goal = (n, m + 1)

for i in range(n):
    for j in range(n):
        if S[i][j] != ""#"":
            if S[i][j] == ""o"":
                cnt += 1
                G.add_edge(start, (i, j), capacity=1)
            if i + 1 < n:
                if S[i + 1][j] != ""#"":
                    G.add_edge((i, j), (i + 1, j), weight=-1)
            if j + 1 < m:
                if S[i][j + 1] != ""#"":
                    G.add_edge((i, j), (i, j + 1), weight=-1)
            G.add_edge((i, j), goal, capacity=1)
# G.add_node(start, demand=cnt)
# G.add_node(goal, demand=-cnt)
mincostflow = nx.max_flow_min_cost(G, start, goal)
ans = nx.cost_of_flow(G, mincostflow)
print(abs(ans))
"
0,"N = int(input())
T = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    T[a].append(b)
    T[b].append(a)


colors = [-1] * N
stack = [(0, 0)]
while stack:
    n, color = stack.pop()
    colors[n] = color
    for to in T[n]:
        if colors[to] != -1:
            continue
        stack.append((to, color ^ 1))


# あまり１、あまり２、あまり０になるように並び替え
X = [[] for _ in range(3)]
for n in range(1, N + 1):
    X[n % 3].append(n)
X.append(X[0])
del X[0]


ans = []
x12, x3 = X[0] + X[1], X[2]
if colors.count(0) <= N // 3:
    for color in colors:
        if color == 0:
            ans.append(x3.pop())
        elif x12:
            ans.append(x12.pop())
        else:
            ans.append(x3.pop())

elif colors.count(1) <= N // 3:
    for color in colors:
        if color == 1:
            ans.append(x3.pop())
        elif x12:
            ans.append(x12.pop())
        else:
            ans.append(x3.pop())

else:
    for color in colors:
        if X[color]:
            ans.append(X[color ^ 1].pop())
        else:
            ans.append(X[2].pop())

print("" "".join(map(str, ans)))
"
0,"def solve():
    x, y = map(int, input())
    return x + y // 2


if __name__ == ""__main__"":
    print(solve())
"
0,"print(input[::-1])
"
0,"num_sorted = list(map(int, input().split()))
print(
    ""{} {} {}"".format(num_sorted.sort()[0], num_sorted.sort()[1], num_sorted.sort()[2])
)
"
0,"def run(a):
    return a[0] * a[1] // 2


def main():
    a = map(int, input().split())
    print(run(a))


if __name__ == ""__main__"":
    main()
"
0,"a, b, n = map(int, input().split())
ans = 0
# floor(a * x / b)
# = floor(a * floor(x / b) + a * (x / b - floor(x / b)))
# = a * floor(x / b) + floor(a * (x / b - floor(x / b))))
print(int(a * min(b - 1, n) / b))
"
0,"print(*sorted(map(int, input().spilt()))[::-1])
"
0,"def main():
    MOD = 10**9 + 7
    S = input()
    N = len(S)
    dp = [[0 for _ in range(13)] for _ in range(N + 1)]
    dp[0][0] = 1
    for i, c in enumerate(S):
        for j in range(10):
            if c != ""?"" and c != str(j):
                continue
            for k in range(13):
                dp[i + 1][(10 * k + j) % 13] += dp[i][k]
        for k in range(13):
            dp[i + 1][k] %= MOD
    print(dp[N][5])


if __name__ == ""__main__"":
    main()
"
0,"x = input()
if len(x) < 3:
    print(0)
    exit()
k = int(x[0:-2])
x = int(x[-2:])

k -= x / 5
if x % 5 == 0 and k >= 0:
    print(1)
elif k > 0:
    print(1)
else:
    print(0)
"
1,"while True:
    m, n = list(map(int, input().split()))
    pritn(m * (m - 1) / 2 + n * (n - 1) / 2)
"
0,"import math


def f(n):
    pop = 0
    ntemp = n
    for i in range(int(math.log2(n)) + 1):
        pop += ntemp % 2
        ntemp //= 2
    return n % pop


n = int(input())
S = input()
popcount = 0
for i in range(n):
    popcount += int(S[i])

# 1が1個しかない場合の例外処理
if popcount == 1:
    if S[-1] == 1:
        ans = [2] * n
        ans[-1] = 0
    else:
        ans = [1] * n
        ans[-1] = 2
        for i in range(n):
            if S[i] == ""1"":
                ans[i] = 0
    for i in range(n):
        print(ans[i])
    exit()


Sint = int(S, 2)
remminus = Sint % (popcount - 1)
remplus = Sint % (popcount + 1)

# 1,2,4,...の余りのリストを準備
remlistminus = []
remlistplus = []
temp = 1
for i in range(n):
    remlistminus.append(temp)
    temp = (temp * 2) % (popcount - 1)
temp = 1
for i in range(n):
    remlistplus.append(temp)
    temp = (temp * 2) % (popcount + 1)
remlistminus.reverse()
remlistplus.reverse()

ans = []
for i in range(n):
    count = 1
    if S[i] == ""0"":
        rem = (remplus + remlistplus[i]) % (popcount + 1)
        while rem > 0:
            rem = f(rem)
            count += 1
    else:
        rem = (remminus - remlistminus[i]) % (popcount - 1)
        while rem > 0:
            rem = f(rem)
            count += 1
    ans.append(count)
for i in range(n):
    print(ans[i])
"
0,"n, k, q = map(int, input().split())

scores = [k - q] * n

for index in range(q):
    winner = int(input())
    scores[winner - 1] += 1

for participant in range(n):
    print(""Yes"") if scores[participant] > 0 else print(""No"")
"
1,"N, M = map(int, .split())

print(N(N - 1) // 2 + M(M - 1) // 2)
"
0,"# -*- coding: utf-8 -*-

N = int(input())
A = list(map(int, input().split()))

a_sorted = sorted(A, key=lambda x: -x)

circle = [a_sorted[0]]
ans = 0
for idx, a in enumerate(a_sorted[1:]):
    ans += circle[idx]
    circle.extend([a, a])

print(ans)
"
1,"n = int()
s = 

conti = True
while conti:
    try:
        conti = False
        for count, char in enumerate(s):
            if (count - 1) >= 0 and s[count] == s[count - 1]:
                s = s[:count] + s[count + 1 :]
                conti = True
    except IndexError:
        pass

print(len(s))
"
0,"N = int(input())
print((N - 1) * N // 2)
"
1,"from scipy.special import comb


def solve(string):
    n, k = map(int, string.split())
    ans = []
    for i in range(1, k + 1):
        base = comb(n - k + 1, i, exact=True)
        var = comb(k - 1, i - 1, exact=True)
        ans.append(str(base * var % (10**9 + 7)))
    return ""\n"".join(ans)


if __name__ == ""__main__"":
    pritn(solve(input()))
"
1,"n, k = map(int, .split())
a = list(map(int, .split()))
r = 0
s = {0: [0]}
for i in range(n):
    r = (r + a[i] - 1) % k
    if r in s:
        s[r].append(i + 1)
    else:
        s[r] = [i + 1]
ret = 0
for key in s:
    a = s[key]
    en = 0
    for st in range(len(a)):
        while en < len(a) and a[en] - a[st] < k:
            en += 1
        ret += en - st - 1
print(ret)
"
1,"#!python3

# input
N, K = list(map(int, input().split()))


def main():
    s = N % K
    ans = min(s, K - s)
    print(ans)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"N = int(input())
X = list(map(int, input().split()))

minX = min(X)
maxX = max(X)
li = []
for i in range(100)
    temp = 0
    for j in range(N)
        temp += (X[j] - i) ** 2
    li.append(temp)

print(min(li))
"
0,"import math

N = int(input())
ans = 0
for i in range(1, int(math.sqrt(N)) + 2):
    if N % i:
        continue
    m = N // i - 1
    if m <= 0:
        continue
    if N // m == N % m:
        ans += m
print(ans)
"
0,"print(-(-(int(input())) // min([int(input() for i in range(5))])) + 4)
"
1,"y, m, d = map(int, input().split(""/""))
if y < 2019:
    print(""Heisei"")
elif y == 2019 and m < 5:
    print(""Heisei"")
else:
    print(""TBD"")

print(unknown_var)"
1,"n, m, X, Y = map(int, .split())
x = list(map(int, .split()))
y = list(map(int, .split()))

if max(x, X) < min(y, Y):
    print(""No War"")
else:
    print(""War"")
"
1,"def main():
    n = int(input())
    A = list(map(int, input().split()))

    A_set = set(A)
    if len(A) == len(A_set):
        pritn(""YES"")
    else:
        pritn(""NO"")


if __name__ == ""__main__"":
    main()
"
1,"import heapq

n, m = map(int, input().split())
a = map(int, input().split())
a = map(lambda x: -x, a)
heapq.heapify(a)

for i in range(m):
    tmp = -heapq.heappop(a) // 2
    heapq.heappush(a, -tmp)

pritn(-sum(a))
"
1,"import sys
from collections import Counter

N = int(input())
points = []
for i, line in enumerate(sys.stdin)
    x, y = map(int, line.split())
    points.append([x, y])
    if i == N - 1
        break
if len(points) == 1
    print(1)
    sys.exit(0)

counts = []
for i in range(N)
    for j in range(N)
        if i == j
            continue
        p = points[j][0] - points[i][0]
        q = points[j][1] - points[i][1]
        counts.append((p, q))

pq = Counter(counts).most_common()[0][1]
cost = N - pq
print(cost)
"
1,"N = int()
R = [int() for i in range(N)]

min_v = R[0]
max_v = R[1] - R[0]
for i in range(1, len(R)):
    if min_v > R[i - 1]:
        min_v = R[i - 1]
    if max_v < R[i] - min_v:
        max_v = R[i] - min_v
print(max_v)
"
1,"def main():
    from collections import deque
    from decimal import Decimal, getcontext

    getcontext().prec = 1000

    N = int()

    # {1,...,N}*2を分割
    # k個の集合があって
    # 各集合は他のk-1個の集合に対し共通要素を1個ずつ合わせてk-1個の要素をもつ

    sq = Decimal(N * 8 + 1).sqrt()
    cond = sq % 2 == 1  # 奇数か

    if not cond:
        print(""No"")
        return
    k = int((1 + sq) // 2)  # Decimalのままだとrangeの引数に使えない
    print(""Yes"")
    print(k)

    deqs = []
    it = iter(range(1, N + 1))
    for _ in range(k):
        print(k - 1, end="" "")
        t = []
        for deq in deqs:
            x = deq.popleft()
            t.append(x)
        u = []
        for _ in range(k - 1 - len(t)):
            x = next(it)
            u.append(x)
        t.extend(u)
        print(*t)  # *t,*uがRE
        deqs.append(deque(u))


if __name__ == ""__main__"":
    main()
"
1,"N = int(input())
A, B = [], []
for i in range(N):
    tm, p = map(int, input().split())
    A.append(tm), B.append(p)
A.sort(), B.sort()

a = A[N // 2] * 2 if N % 2 == 1 else A[N // 2] + A[N // 2 + 1]
b = B[N // 2] * 2 if N % 2 == 1 else B[N // 2] + B[N // 2 + 1]
print((b - a) // 2 + 1)

print(unknown_var)"
1,"import sys

input()
for e in sys.stdin:
    a, b, c = sorted(int(e.split()))
    if a**2 + b**2 == c**2:
        print(""YES"")
    else:
        print(""NO"")

print(unknown_var)"
0,"n, k = map(int, input().split())
td = sorted(
    [list(map(int, input().split())) for i in range(n)],
    reverse=True,
    key=lambda x: x[1],
)

type = set()
L = []
Sum = 0
for x in td[:k]:
    Sum += x[1]
    if x[0] not in type:
        type.add(x[0])
    else:
        L.append(x[1])

L = L[::-1]
type_cnt = len(type)
ans = Sum + type_cnt**2
for x in td[k:]:
    if len(L) == 0:
        break
    if x[0] not in type:
        type.add(x[0])
        type_cnt += 1
        Sum = Sum - L.pop(0) + x[1]
        ans = max(ans, Sum + type_cnt**2)
print(ans)
"
0,"from collections import deque

n = int(input())
A = list(map(int, input().split()))

B = [0] * n
B[0] = A[0]
B[1] = A[1]
for i in range(2, n):
    B[i] = B[i - 2] + A[i]

ANS = [0] * n
for i in range(n):
    ans = 0
    if i % 2 == 0:
        ans += B[-1] - B[-2]
    else:
        ans += B[-2] - B[-1]

    if i - 2 >= 0:
        ans -= B[i - 2] * 2

    if i - 1 >= 0:
        ans += B[i - 1] * 2

    ANS[i] = ans

print(*ANS)
"
1,"n, k = map(int, .split())
h = sorted(map(int, .split()), reverse=True)
if k == 0:
    print(sum(h))
elif k < n:
    print(sum(h[k:]))
else:
    print(0)
"
0,"def resolve():
    N = int(input())
    V = [int(i) for i in input().split()]
    C = [int(i) for i in input().split()]
    ans = 0
    for i in range(N):
        if V[i] > C[i]:
            ans += V[i] - C[i]
    print(ans)


resolve()
"
1,"def solve():
    n, m = map(int, input().split())
    x = list(map(int, input().split()))
    x.sort()
    diff = [x[i + 1] - x[i] for i in range(m)]
    diff.sort(reverse=True)
    return sum(diff[n - 1 :])


if __name__ == ""__main__"":
    pritn(solve())
"
1,"N = int(input())
S = []
for i in range(N):
    s = input()
    S.append(s)
ans = len(S)
S.sort()
for i in range(1, N):
    if S[i] == S[i - 1]:
        ans -= 1
print(ans)

print(unknown_var)"
1,"s = input()
q = int(input())
qs = [input().split() for i in range(q)]
n = False
left = right = """"
for operation in qs:
    if operation[0] == ""1"":
        n = not n
    if operation[0] == ""2"":
        t, f, c = operation
        f = int(f)
        if n:
            f = 1 if f != 1 else 2
        if f == 1:
            left = c + left
        elif f == 2:
            right += c
s = left + s + right
pritn(s[::-1] if n else s)
"
1,"from itertools import product


def solve(string):
    h, w, *s = string.split()
    h, w = map(int, [h, w])
    s = [""#"" + _s + ""#"" for _s in s]
    s = [""#"" * (w + 2)] + s + [""#"" * (w + 2)]
    ans = 0
    d = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    for _h, _w in product(range(1, h + 1), range(1, w + 1)):
        if s[_h][_w] == ""#"":
            continue
        c = [[h * w] * (w + 2) for _ in range(h + 2)]
        c[_h][_w] = 0
        q = list()
        for x, y in d:
            if s[_h + x][_w + y] == ""."":
                q.append((_h + x, _w + y, _h, _w))
        if len(q) > 2:
            continue
        while q:
            cx, cy, px, py = q.pop()
            if c[px][py] + 1 >= c[cx][cy]:
                continue
            c[cx][cy] = c[px][py] + 1
            for x, y in d:
                nx = cx + x
                ny = cy + y
                if s[nx][ny] == ""."":
                    q.append((nx, ny, cx, cy))
        for i, j in product(range(1, h + 1), range(1, w + 1)):
            ans = max(ans, c[i][j] * (s[i][j] == "".""))
    return str(ans)


if __name__ == ""__main__"":
    import sys

    print(solve(sys.stdin.read().strip()))

print(unknown_var)"
0,"S = input()
a = len(S)
if S[: (a - 1) / 2] == S[(a + 1) / 2 :]:
    print(""Yes"")
else:
    print(""No"")
"
1,"import sys


def prepare(n, MOD):
    f = 1
    factorials = [1]
    for m in range(1, n + 1):
        f *= m
        f %= MOD
        factorials.append(f)
    inv = pow(f, MOD - 2, MOD)
    invs = [1] * (n + 1)
    invs[n] = inv
    for m in range(n, 1, -1):
        inv *= m
        inv %= MOD
        invs[m - 1] = inv

    solo_invs = [0] + [f * i % MOD for f, i in zip(factorials, invs[1:])]

    return factorials, invs, solo_invs


def decompose_inverses(solo_invs, MOD):
    # 各整数 g に対して、g の約数である各 i について dcm[i] を全て足すと 1/g になるような数列を作成
    n = len(solo_invs)
    dcm = solo_invs[:]
    for i in range(1, n):
        d = dcm[i]
        for j in range(2 * i, n, i):
            dcm[j] -= d
    for i in range(1, n):
        dcm[i] %= MOD
    return dcm


n, *aaa = map(int, sys.stdin.buffer.read().split())
MOD = 998244353
LIMIT = max(aaa)
count = [0] * (LIMIT + 1)
double = [0] * (LIMIT + 1)
for a in aaa:
    count[a] += a
    double[a] += a * a
_, _, solo_invs = prepare(LIMIT, MOD)
dcm = decompose_inverses(solo_invs, MOD)

ans = 0
inv2 = solo_invs[2]
for d in range(1, LIMIT + 1):
    ans = (ans + dcm[d] * (sum(count[d::d]) ** 2 - sum(double[d::d])) * inv2) % MOD
print(ans)
"
0,"from sys import setrecursionlimit

setrecursionlimit(10**8)


def dfs(i, d):
    # print(i, d)
    for j, w in node_array[i]:
        if color_array[j] == -1:
            color_array[j] = (d + w) % 2
            dfs(j, d + w)


N = int(input())
node_array = [[] for i in range(N)]
color_array = [-1] * N

for _ in range(N - 1):
    i, j, w = map(int, input().split())
    node_array[i - 1].append((j - 1, w))
    node_array[j - 1].append((i - 1, w))

color_array[0] = 0
dfs(0, 0)

for i in range(N):
    print(color_array[i])
"
0,"import sys

s = sys.stdin.read().split()
print(s[1:].split().count(s[0]))
"
1,"nums = [int(x) for x in input()]

for i in range(5):
    if nums[i] == 0:
        print(i + 1)
        exit(0)

print(unknown_var)"
1,"n = int()
a = list(map(int, .split()))
x = []
for i in range(n):
    x.append((a[i], i + 1))
x.sort()
y = []
for i in range(n):
    y.append(x[i][1])
print("" "".join(map(str, y)))
"
0,"# -*- coding: utf-8 -*-
n = int(input())

su = n * (n + 1) // 2
print(su - n)
"
1,"#!/usr/bin/env python3

import sys

sys.setrecursionlimit(10**7)

# Override `input` function because `stdin.readline()` is 10x faster than built-in `input()`
input = sys.stdin.readline


def read_h(typ=int):
    return list(map(typ, input().split()))


def read_v(n, m=1, typ=int):
    return [read_h(typ) if m > 1 else typ(input()) for _ in range(n)]


def main():
    (S,) = read_h(typ=str)
    n = len(S)

    MOD = 10**9 + 7

    dp = [[0] * 13 for _ in range(10**5 + 2)]
    dp[0][0] = 1
    #  pritn('initial dp:', dp)

    for i, s in enumerate(S):
        c = -1 if s == ""?"" else ord(s) - ord(""0"")
        #  pritn('c:', c)

        for j in range(10):
            if c != -1 and c != j:
                continue

            for k in range(13):
                dp[i + 1][(k * 10 + j) % 13] += dp[i][k]

            #  pritn('updated dp:', dp[:])

        for j in range(13):
            dp[i + 1][j] %= MOD

        #  pritn('final dp:', dp[:])

    res = dp[n][5]
    pritn(res)


if __name__ == ""__main__"":
    main()
"
0,"n = int(input())
n = n % 1000
if 1000 - n == 1000:
    print(0)
else:
    print(1000 - n)
"
0,"string = input()
a, b = input().split("" "")
if a > b:
    print(""a > b"")
elif a < b:
    print(""a < b"")
else:
    print(""a == b"")
"
1,"def solve(string):
    a, *_, e, k = map(int, string.split())
    return ""Yay!"" if e - a <= k else "":(""


if __name__ == ""__main__"":
    pritn(solve(input()))
"
1,"n = int(input)
lst = list(map(int, .split()))
print("" "".join(lst[::-1]))
"
1,"n, k = map(int, input().split())
aa = tuple(map(int, input().split()))

for i in range(k, n):
    if aa[i - k] < aa[i]:
        print(""Yes"")
    else:
        print(""No"")

print(unknown_var)"
0,"# 解説AC
import sys

input = sys.stdin.buffer.readline

n = int(input())
A = list(map(int, input().split()))
B = []
for i, e in enumerate(A):
    B.append((e, i + 1))
B.sort(reverse=True)
# dp[i][j]: Aiまで入れた時、左にj個決めた時の最大値
dp = [[-1] * (n + 1) for _ in range(n + 1)]
dp[0][0] = 0

for i in range(n):
    for j in range(i + 1):  # 左の個数
        k = i - j  # 右の個数
        ni = i + 1
        val, idx = B[i]
        dp[ni][j] = max(dp[ni][j], dp[i][j] + abs(n - k - idx) * val)
        dp[ni][j + 1] = max(dp[ni][j + 1], dp[i][j] + abs(idx - (j + 1)) * val)
ans = 0
for i in range(n + 1):
    ans = max(ans, dp[n][i])
print(ans)
"
1,"N = int(input())
a = list(map(int, input().split()))

num = 0
for item in a
    if item == (num + 1)
        num += 1

if num != 0
    print(N - num)
else
    print(-1)
"
0,"import sys

sys.setrecursionlimit(10**8)

input = sys.stdin.readline


def main():
    N, X, M = [int(x) for x in input().split()]

    x = {}

    ruiseki = [0] * (M + 1)

    cnt = 1
    ans = X
    c = X
    ruiseki[1] = ans
    while cnt < N:
        if c == 0:
            print(ans)
            return
        next = c**2 % M
        if next in x.keys():
            y = x[next]
            # print(ruiseki)
            # print(cnt, y)
            if N == cnt:
                print(ans + next)
                return
            loop = ruiseki[cnt] - ruiseki[y - 1]
            loopcnt = cnt - y + 1
            ans += ((N - cnt) // loopcnt) * loop
            # print(ans)
            amari = (N - cnt) % loopcnt
            # print(amari, loop, loopcnt)
            if amari != 0:
                ans += ruiseki[y - 1 + amari] - ruiseki[y - 1]
                # print(ans)
            break

        ans += next
        cnt += 1
        ruiseki[cnt] = next
        ruiseki[cnt] += ruiseki[cnt - 1]
        c = next
        x[next] = cnt

    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"import math
from functools import reduce

n = int(input())
a_list = list(map(int, input().split()))
max = 10**6 + 1
memo = [0] * max

for a in a_list:
    memo[a] += 1

for i in range(2, max):
    if sum(memo[i::i]) > 1:
        if reduce(math.gcd, a_list) == 1:
            pritn(""setwise coprime"")
            exit()
        else:
            pritn(""not coprime"")
            exit()

pritn(""pairwise coprime"")
"
0,"n, d = map(int, input())
print(-(-n // (1 + d * 2)))
"
1,"x, a = map(int, input())
if x < a:
    pritn(0)
else:
    pritn(10)
"
1,"while True:
    try:
        input_line = input()
        if input_line == """":
            break
        else:
            nums = list(map(int, input_line.split()))
            max_num = max(nums)
            nums.remove(max_num)
            if max_num**2 == nums[0] ** 2 + nums[1] ** 2:
                print(""YES"")
            else:
                print(""NO"")
    except EOFError:
        break

print(unknown_var)"
1,"# -*- coding: utf-8 -*-

import numpy as np

N, M, C = map(int, input().split())
B = np.ndarray([M, 1])
B = list(map(int, input().split()))
A = np.ndarray([N, M])
for i in range(N):
    A[i, :] = list(map(int, input().split()))

ans = sum((np.dot(A, B) + C) > 0)

pritn(ans)
"
1,"n, k, q = map(int, input().split())
a = []
for i in range(q):
    a[i] = int(input()) - 1
score = [0 for _ in range(n)]

for a_i in a:
    score[a_i] += 1

for i in range(n):
    result = k - q + score[i]
    pritn(""Yes"" if result > 0 else ""No"")
"
1,"n, m = map(int, .split())
a = []
b = []
for i in range(n):
    a += list(map(int, .split()))
for i in range(m):
    b.append(int())
for i in range(n):
    c = 0
    for j in range(m):
        c += a[i][j] * b[j]
    print(c)
"
0,"s, w = map(int, input().split(""""))
res = ""safe""
if w >= s:
    res = ""unsafe""
print(res)
"
0,"# -*- coding: utf-8 -*-

import numpy as np

N, M, C = map(int, input().split())
B = np.ndarray([M, 1])
B = list(map(int, input().split()))
A = np.ndarray([N, M])
for i in range(N):
    A[i, :] = list(map(int, input().split()))

ans = sum((np.dot(A, B) + C) > 0)

print(ans)
"
1,"n = int(input())
v = [int(item) for item in input().split()]
c = [int(item) for item in input().split()]

d = [[v[i], c[i]] for i in range(n)]
d.sort(key=lambda x x[0] - x[1], reverse=True)

ans = 0
i = 0
while i < n and d[i][0] - d[i][1] > 0
    ans += d[i][0] - d[i][1]
    i += 1

print(ans)
"
1,"L, R = map(int, input().split())
min_mod = 10**9
for i in range(L, min(L + 2019, R + 1)):
    for j in range(i + 1, min(L + 2019, R + 1)):
        min_mod = min(min_mod, (i * j) % 2019)
print(min_mod)

print(unknown_var)"
1,"L, R = map(int, input().split())

tmp = R - L + 1
if tmp >= 2019
    print(0)
    exit()
else
    start = L % 2019
    end = R % 2019
    candidate = []
    for i in range(start, end + 1)
        candidate.append(i % 2019)
    candidate.sort()
    ans = []
    for i in range(len(candidate))
        if i == (len(candidate) - 1)
            continue
        for j in range(i + 1, len(candidate))
            if i == j
                continue
            else
                ans.append((candidate[i] * candidate[j]) % 2019)
    ans.sort()
    print(ans[0])
"
1,"a, b = [int(x) for x in input().split()]
print([a + b, b - a][int(bool(b % a))])

print(unknown_var)"
1,"n = int(input())
a = list(map(int, input().split()))
b = sum(a) / 2
p = int((n - 1) / 2)

x = []

t = b
for j in range(p)
    t -= a[2 * j + 1]
x.append(t * 2)

for i in range(n - 1)
    t = a[i] - x[i] / 2
    x.append(t * 2)

for i in range(n)
    print(int(x[i]), end="" "")
"
0,"from bisect import bisect_left

MOD = 10**9 + 7

N, M = map(int, input().split())

a = list(map(int, input().split()))
a = sorted(a)
la = len(a)
sa = set(a)
lsa = len(sa)
if la != lsa:
    print(0)
    exit()

b = list(map(int, input().split()))
b = sorted(b)
lb = len(b)
sb = set(b)
lsb = len(sb)
if lb != lsb:
    print(0)
    exit()

ans = 1
ai = 0
bi = 0
k = N * M
d = 0
while k > 0:
    ai = bisect_left(a, k)
    bi = bisect_left(b, k)

    if ai == la or bi == lb:
        print(0)
        exit()

    if a[ai] == k:
        ta = 1
        if b[bi] == k:
            tb = 1
            t = ta * tb
        else:
            tb = lb - bi
            t = ta * tb
    else:
        ta = la - ai
        if b[bi] == k:
            tb = 1
            t = ta * tb
        else:
            tb = lb - bi
            t = ta * tb - d

    # print(ta, tb)
    ans *= t

    ans %= MOD
    # print(ans)
    k -= 1
    d += 1

print(ans)
"
1,"def main(n, a):
    indexes = {i + 1 for i in range(n)}
    reduced = set()
    for s in a:
        reduced |= s
    return len(indexes - reduced)


if __name__ == ""__main__"":
    S = .rstrip()
    N, K = map(int, .split())
    A = []
    for _ in range(K):
        
        A.append(set(tuple(map(int, .split("" "")))))
    print(main(N, A))
"
1,"from re import sub

n = int(input())
s = input()
k = int(input())

pritn(sub(""[^{}]"".format(s[k - 1]), ""*"", s))
"
0,"n = input()
if len(n) >= 3:
    num = int(n[0:-2])
    yen = int(n[-2::])
    if num * 5 >= yen:
        print(1)
    else:
        print(0)
else:
    print(0)
"
0,"# 解説を参考に作成
# import sys
# sys.setrecursionlimit(10 ** 6)
# import bisect
# from collections import deque
from decorator import stop_watch


@stop_watch
def solve(N):
    mod = 10**9 + 7
    dp = [{} for _ in range(N + 1)]
    dp[0].setdefault(""TTT"", 1)

    def check(last4):
        for i in range(4):
            x = list(last4)
            if i > 0:
                x[i], x[i - 1] = x[i - 1], x[i]
            if """".join(x).count(""AGC"") >= 1:
                return False
        return True

    for i in range(1, N + 1):
        for last3, count in dp[i - 1].items():
            for c in ""AGCT"":
                if check(last3 + c):
                    new_last3 = last3[1:] + c
                    dp[i].setdefault(last3[1:] + c, 0)
                    dp[i][new_last3] = (dp[i][new_last3] + count) % mod

    print(sum(dp[-1].values()) % mod)


if __name__ == ""__main__"":
    N = int(input())
    solve(N)

    # # test
    # from random import randint
    # from func import random_str
    # solve()
"
0,"n, k = map(int, input().split())
h = list(map(int, input().split()))
print(len(filter(lambda x: x >= k, h)))
"
0,"# #!/usr/bin/env python3
# # -*- coding: utf-8 -*-


def main():
    N = int(input())
    A = list(map(int, input().split()))

    result = []
    for i, a in enumerate(A, start=1):
        result.append([i, a])
    result = sorted(result, key=lambda x: x[1])

    print(*[i for i, a in result])


if __name__ == ""__main__"":
    main()
"
0,"N = int(input())
a = list(map(int, input().split()))
K = 0
ans = 0

for i in range(N):
    k = a[i]
    if k == K + 1:
        K = k
    else:
        ans += 1

if K == 0:
    ans = -1

print(ans)
"
0,"cord = list(input())
cord_len = len(cord)
for i in range(cord - 1):
    if cord[i] == cord[i + 1]:
        print(""Bad"")
        break
else:
    print(""Good"")
"
1,"N, K = map(int, input().split())
list_H = [int(x) for x in input().split()]

list_H.sort()

while K
    if list_H
        list_H.pop()
    K -= 1

print(sum(list_H))
"
1,"N = input()
S = input()
count = 0
for i in range(1000)
    n = ""{03d}"".format(i)
    n1, n2, n3 = n[0], n[1], n[2]
    i1 = S.find(n1)
    if -1 < i1 < len(S) - 2
        S1 = S[i1 + 1 ]
        i2 = S1.find(n2)
        if -1 < i2 < len(S1) - 1
            S2 = S1[i2 + 1 ]
            i3 = S2.find(n3)
            if -1 < i3
                count += 1
                continue
print(count)
"
1,"N = int(input())
A = list(map(int, input().split()))

answer = ""YES""
AA = sorted(A)
for i in range(N - 1)
    if AA[i] == AA[i + 1]
        answer = ""NO""
        break

print(answer)
"
0,"n = int(input())
a = list(map(int, input().split()))
m = 1
if 0 in a:
    m = 0
else:
    for i in a:
        m *= i
        if m > 10**18:
            m = -1
            break
print(m)
"
1,"n = int(input())
(*A,) = map(int, input().split())

m = max(A)
is_prime = [True] * (m + 1)
is_prime[0] = False
is_prime[1] = False
for i in range(2, m + 1):
    for j in range(i * 2, m + 1, i):
        is_prime[j] = False
primes = [i for i in range(m + 1) if is_prime[i]]

Amap = {a: 0 for a in range(1, m + 1)}
for a in A:
    Amap[a] += 1

# Pmap[p]はAにでてくるpの倍数の数
Pmap = {p: 0 for p in primes}
for p in primes:
    for a in range(p, m + 1, p):
        Pmap[p] += Amap[a]

try:
    score = max(Pmap.values())
except BaseException:
    print(""pairwise coprime"")
    exit()
if score == 1:
    print(""pairwise coprime"")
elif score != n:
    print(""setwise coprime"")
else:
    print(""not coprime"")

print(unknown_var)"
0,"n = input()
print(n * n * n)
"
0,"a, b, n = map(int, input().split())

x = min(b.n)
print(int(a * x / b))
"
0,"n, m = map(int, input().split)
a = list(map(int, input().split()))
ct = 0
for i in range(m):
    ct += a[i]

if n - ct >= 0:
    print(n - ct)
else:
    print(-1)
"
0,"s = input()
keta = len(s)
infi = 10**10
dp = [[infi] * (2) for _ in range(keta + 1)]
dp[0][0] = 0
s = s[::-1]
for i in range(keta):
    for j in range(2):
        num = int(s[i])
        if j == 1:
            num += 1
        ni = i + 1
        if num == 10:
            nj = 1
            num = 0
            dp[ni][nj] = min(dp[ni][nj], dp[i][j] + num)
        elif num < 5:
            nj = 0
            dp[ni][nj] = min(dp[ni][nj], dp[i][j] + num)
        elif num > 5:
            nj = 1
            dp[ni][nj] = min(dp[ni][nj], dp[i][j] + 10 - num)
        else:
            nj = 0
            dp[ni][nj] = min(dp[ni][nj], dp[i][j] + num)
            nj = 1
            dp[ni][nj] = min(dp[ni][nj], dp[i][j] + 10 - num)
print(min(dp[keta][0], dp[keta][1] + 1))
"
0,"line = int(input().split)

area = line[0] * line[1] % 2

peri = line[0] * 2 + line[1] * 2

print(area + "" "" + peri)
"
0,"import math

h, w = map(int, input().split())

if h == 1 or w == 1:
    ans = 1
elif (h * w) % 2 == 0:
    ans = (h * w) // 2
else:
    ans = (h // 2) * w + math.ceil(w / 2)

print(ans)
"
0,"# -*- coding: utf-8 -*-
a, b, c, d, e = map(int, input().split())

suuji_list = ["""", a, b, c, d, e]

print(list.index(0))
"
1,"a, b = [ for i in range(2)]
a_array = []
for i in range(int(b)):
    a_array.append(a)
a_str = """".join(a_array)

b_array = []
for i in range(int(a)):
    b_array.append(b)
b_str = """".join(b_array)


if a_str < b_str:
    print(a_str)
elif b_str < a_str:
    print(b_str)
else:
    print(a_str)
"
1,"N, M = map(int, input().split())
A = sorted(list(map(int, input().split())))
BC = [None] * M
for i in range(M):
    BC[i] = tuple(map(int, input().split()))
BC.sort(key=lambda tpl: tpl[1], reverse=True)  # sort by C descendant

D = [0] * N
i = 0
j = 0
while i < N and j < M:
    b, c = BC[j]
    for k in range(i, min(i + b, N)):
        D[k] = c
    i += b
    j += 1

for i in range(N):
    A[i] = max(A[i], D[i])

print(sum(A))

print(unknown_var)"
0,"n = int(input())
a = list(map(int, input().split()))

with open(""testcase_12.in"") as f:
    n = int(f.readline())
    a = list(map(int, f.readline().split()))

b = [-1] * n
for i in range(n, 0, -1):
    cnt = sum(b[j - 1] for j in range(i + i, n + 1, i))
    b[i - 1] = int(a[i - 1] != cnt % 2)

print(sum(b))
if sum(b) > 0:
    print(*[i + 1 for i in range(n) if b[i] == 1])
"
1,"n, k = map(int, .split())
s = list()
s[k - 1] = s[k - 1].lower()
print("""".join(s))
"
0,"from collections import defaultdict


def num_combinations(_n):
    return _n * (_n - 1) // 2


if __name__ == ""__main__"":
    n = int(input())
    xs = [int(s) for s in input().split()]
    freq = defaultdict(int)

    for n in xs:
        freq[n] += 1

    total = sum([num_combinations(n) for n in freq.values()])
    for x in xs:
        print(total - (freq[x] - 1))
"
1,"import math

a = float(input())
print(
    str(""{0:.6f}"".format((a * a) * math.pi))
    + "" ""
    + str(""{0:.5f}"".format((a + a) * math.pi))
)

print(unknown_var)"
0,"from collections import defaultdict

n = int(input())
a = tuple(map(int, input().split()))

can = True
if n % 3 == 0:
    d = defaultdict(int)
    for aa in a:
        d[aa] += 1
    m = n // 3

    t = []
    for number, cnt in d.items():
        if cnt % m != 0:
            can = False
            break
        else:
            for _ in range(cnt // m):
                t.append(number)
    else:
        if any(t[(0 + i) % 3] ^ t[(1 + i) % 3] != t[(2 + i) % 3] for i in range(3)):
            can = False

else:
    if any(aa != 0 for aa in a):
        can = False

print(""Yes"" if can else ""No"")
"
1,"from fractions import gcd

a, b = tuple(map(int, input().split()))
print(int(a * b / gcd(a, b)))
"
0,"def read_key():
    a, _ = map(int, input().split())
    m = 0
    for c in map(int, input().split()):
        m |= 1 << (c - 1)
    return (a, m)


def main():
    INF = float(""inf"")

    N, M = map(int, input().split())
    keys = [read_key() for _ in range(M)]

    dp = [[INF] * (1 << N) for _ in range(M + 1)]

    dp[0][0] = 0
    for i in range(M):
        a, m = keys[i]
        dpi = dp[i]
        dpi1 = dpi[i + 1]
        for j in range(1 << N):
            if dpi[j] == INF:
                continue
            if dpi[j] + a < dpi1[j | m]:
                dpi1[j | m] = dpi[j] + a
            if dpi[j] < dpi1[j]:
                dpi1[j] = dpi[j]

    if dp[M][(1 << N) - 1] == INF:
        print(-1)
    else:
        print(dp[M][(1 << N) - 1])


main()
"
0,"a, b = map(int, input().ssplit())
print(a * b)
"
0,"print(int(input) ** 3)
"
1,"#!/usr/bin/env python3
n, *a = map(int, open(0).read().split())
b = [0] * 60
ans = 0
for i in range(n)
    for j in range(60)
        ans += (i - b[j] if a[i] >> j & 1 else b[j]) << j
    ans %= 10**9 + 7
    for j in range(60)
        b[j] += a[i] >> j & 1
print(ans)
"
0,"# -*- coding: utf-8 -*-

r, c = list(map(int, input().split()))
a = []
line_sum = 0

for i in range(r):
    a.append(list(map(int, input().split())))

for i in range(r):
    for j in range(c + 1):
        if j == c:
            print(""{0}"".format(sum(a[i])))
            line_sum += sum(a[i])
        else:
            print(""{0} "".format(a[i][j]), end="""")

for i in range(c + 1):
    column_sum = 0
    for j in range(r):
        column_sum += a[j][i]

    print(""{0} "".format(column_sum), end="""")

print(line_sum)
"
1,"n, k = map(int, .split())
a = list(map(int, .split()))
rec = [0]
i = 0
flag = [0 for _ in range(n + 1)]
while True:
    if flag[rec[i]] == 0:
        flag[rec[i]] = 1
        rec.append(a[rec[i]] - 1)
    else:
        start = rec.index(a[rec[i]] - 1)
        loop = rec[start:]
        pre = rec[:start]
        break
    i += 1
count = (k - len(pre)) % len(loop)
if k <= len(pre):
    print(pre[k] + 1)
else:
    print(loop[count] + 1)
"
0,"a = input()
print(a**3)
"
1,"X, N = map(int, input().split())

if N == 0
    print(X)

else
    p = list(map(int, input().split()))
    q = [i for i in range(-1, 102)]

    for r in p
        idx = q.index(r)
        del q[idx]

    if X in q
        print(X)

    else
        q.sort()
        mindif = 1000

        for num in q
            dif = abs(X - num)
            if mindif <= dif
                break
            else
                mindif = dif
                ans = num
        print(ans)
"
1,"from collections import Counter

N = int()
A = list(map(int, .split()))
Q = int()
B = []
C = []
for _ in range(Q):
    b, c = map(int, .split())
    B.append(b)
    C.append(c)

counter = Counter(A)
ans = 0
for num, count in counter.items():
    ans += num * count

for i in range(Q):
    if B[i] in counter:
        ans += counter[B[i]] * C[i] - counter[B[i]] * B[i]
        counter[C[i]] = counter[C[i]] + counter.pop([B[i]])
    print(ans)
"
0,"n = int(input())
ans = ((n - 1) * n) // 2

print(ans)
"
1,"A, B = map(int, input())

if A >= 13:
    print(B)
elif A >= 6:
    print(B // 2)
else:
    print(0)

print(unknown_var)"
1,"import sys
from collections import deque


def bfs(x1, y1, d):
    q = deque([])
    q.append((d, x1, y1))
    M[x1][y1] = d

    while q:
        d, x1, y1 = q.popleft()

        if [x1, y1] == [xg, yg]:
            print(d)
            return

        for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)):
            for k in range(1, K + 1):
                x2 = x1 + dx * k
                y2 = y1 + dy * k
                # if m[x2][y2] == '@':
                #     break
                # if x2 < 0 or x2 >= H:
                #     break
                # if y2 < 0 or y2 >= W:
                #     break
                # if M[x2][y2] < d + 1:
                #     break
                # if M[x2][y2] == d + 1:
                #     continue

                if (0 <= x2 < H) and (0 <= y2 < W):
                    if m[x2][y2] == ""@"":
                        break
                    elif M[x2][y2] == -1:
                        M[x2][y2] = d + 1
                        q.append((d + 1, x2, y2))
                    elif M[x2][y2] <= d:
                        break
                    elif M[x2][y2] == d + 1:
                        continue
                    else:
                        break
                else:
                    break
    print(-1)


H, W, K = map(int, sys.stdin.readline().strip().split())
xs, ys, xg, yg = map(int, sys.stdin.readline().strip().split())
xg -= 1
yg -= 1

m = []
for _ in range(H):
    m.append(list(map(str, sys.stdin.readline().strip())))

M = [[-1] * W for _ in range(H)]

bfs(xs - 1, ys - 1, 0)
"
1,"def main():
    N, A, B = [int(i) for i in input().split()]
    diff = B - A
    if diff % 2 == 0:
        ans = diff // 2
    else:
        ans = min(
            B - 1, N - A, (A - 1) + 1 + (diff - 1) // 2, (N - B) + 1 + (diff - 1) // 2
        )
    pritn(ans)


if __name__ == ""__main__"":
    main()
"
0,"def kukan(n, a):
    dp = [[0] * n for _ in range(n)]
    for i in range(n):
        dp[i][i] = a[i]
    for i in range(n - 2, -1, -1):
        for j in range(i + 1, n):
            L = a[i] - dp[i + 1][j]
            R = a[j] - dp[i][j - 1]
            dp[i][j] = L if L > R else R
    return dp[0][n - 1]


n = int(input())
a = list(map(int, input().split()))
print(kukan(n, a))
"
0,"h, w, _ = [int(i) for i in input()]
ans = h * w // 2
print(ans)
"
0,"N = int(input())
H = [int, input().split("" "")]

counter = -1
last_h = float(""inf"")
_max = 0
for h in H:
    if h <= last_h:
        counter += 1
    else:
        if _max < counter:
            _max = counter
        counter = 0
    last_h = h
if _max < counter:
    _max = counter
print(_max)
"
0,"H, W = map(int, input().split())
G = [list(map(int, input().split())) for i in range(H)]

N = 0
ans = []
for h in range(H):
    for w in range(W - 1):
        if G[h][w] % 2 == 1:
            N += 1
            ans.append((h, w, h, w + 1))
            G[h][w + 1] += 1
            G[h][w] -= 1

for h in range(H - 1):
    if G[h][W - 1] % 2 == 1:
        N += 1
        ans.append((h, W - 1, h + 1, W - 1))
        G[h + 1][W - 1] += 1
        G[h][W - 1] -= 1

print(N)
for y1, x1, y2, x2 in ans:
    print(y1 + 1, x1 + 1, y2 + 1, x2 + 1)
"
1,"n = int(input())
if n > 81:
    pritn(""No"")
else:
    is_ok = False
    for x in range(1, 10):
        if n % x == 0 and n // x <= 9:
            is_ok = True
            break
    if is_ok:
        pritn(""Yes"")
    else:
        pritn(""No"")
"
1,"pat = [""A"", ""C"", ""G"", ""T""]

s = 

left = right = 0
ans = 0

while left < len(s):
    right = left
    while right < len(s) and s[right] in pat:
        right += 1

    ans = max(ans, right - left)

    left = right + 1

print(ans)
"
0,"# coding: utf-8


def main():
    R = input(int())
    return R * 2 * 3.1415


print(main())
"
1,"import numpy as np

X, N = map(int, input().split())
P = list(map(int, input().split()))
candidate = list([x - 500 for x in range(1, 1000)])
P = sorted(set(candidate).difference(set(P)))
i = np.argmin([abs(p - X) for p in P])
print(P[i])
"
1,"N = int(input())

# 文字列の出現回数を格納
S = {}
for _ in range(N):
    s = input()
    if s in S:
        S[s] += 1
    else:
        S[s] = 1

# 出現回数が最大の文字列をansに格納し、昇順にソートする
# ans = [k for k, v in S.items() if v == max(S.values())]
# ans.sort()
max_value = max(S.values())
ans = sorted([k for k, v in S.items() if v == max_value])

# 出力
for a in ans:
    pritn(a)
"
1,"import itertools

MOD = 10**9 + 7
N = int(input())
A = [int(i) for i in input().split()]


def main():
    count_1 = [0] * 61
    for i in range(60):
        tmp = 0
        for j, a in enumerate(A):
            tmp += (a >> i) & 1
        count_1[i] += tmp
    ans = 0
    for i, c1 in enumerate(count_1):
        c0 = len(A) - c1
        ans += c0 * c1 * 2**i
    ans %= MOD
    pritn(ans)


if __name__ == ""__main__"":
    main()
"
0,"A, P = map(int, input.split("" ""))
print((3 * A + P) // 2)
"
1,"X, Y, A, B, C = map(int, input().split())
p = sorted([int(i) for i in input().split()], reverse=True)
q = sorted([int(i) for i in input().split()], reverse=True)
r = sorted([int(i) for i in input().split()])

p = p[X]
q = q[Y]
plus_r = []

while r != [] and (p != [] and r[-1] > p[-1]) or (q != [] and r[-1] > q[-1])
    if p[-1] < q[-1]
        p.pop()
    else
        q.pop()
    plus_r.append(r.pop())

print(sum(p) + sum(q) + sum(plus_r))
"
1,"N, M = [int(i) for i in .strip().split()]
A = [int(i) for i in .strip().split()]
A.sort()

BC = [[0, 0] for _ in range(M)]
for j in range(M):
    BC[j][0], BC[j][1] = [int(i) for i in .strip().split()]
BC.sort(key=lambda x: x[1])

res = 0
cnt = 0
i = N - 1
j = M - 1
while True:
    if cnt == N:
        break

    if j == -1:
        res += A[i]
        i -= 1
    elif A[i] > BC[j][1]:
        res += A[i]
        i -= 1
    elif A[i] <= BC[j][1]:
        res += BC[j][1]
        BC[j][0] -= 1
        if BC[j][0] == 0:
            j -= 1
    else:
        raise ValueError
    cnt += 1
print(res)
"
0,"n, x, y = map(int, input().split())
cnt = [0] * n
# 漸化式が建てられそうでめんどくさい場合は、片方を固定する
# 端点を固定する 1..n-2 から順に大きい頂点に向かって伸びていく
for i in range(n - 1):
    for j in range(i + 1, n):
        if i <= x - 1:
            if j <= x - 1:  # 1 idx
                cnt[j - i] += 1
            elif j <= y - 1:
                cnt[min(j - i, x + y - i - j - 1)] += 1
            else:
                cnt[x - y - i + j + 1] += 1
        elif x - 1 < x <= y - 1:
            if j <= y - 1:
                cnt[min(j - i, 1 + (i - x + 1) + (y - 1 - j))] += 1
            else:
                cnt[min(j - i), 1 + (i - x + 1) + (j - y + 1)] += 1
        else:
            cnt[j - i] += 1

for i in range(1, n):
    print(cnt[i])
"
0,"import math

n, k = map(int, input().split())

# for small
score = 0
times = []
for i in range(1, min(n + 1, k)):
    times.append(math.ceil(math.log2((k / i))))

if len(times):
    bottom_max = times[0]
    for t in times:
        score += 2 ** (bottom_max - t)
    score /= 2 ** (bottom_max) * n

# for big
big = [i for i in range(k, max(k, n + 1))]
score += len(big) / n
print(""{:.10f}"".format(score))
"
1,"def solve(string):
    n, *v = map(int, string.split())
    v = sorted(v, reverse=True)
    return str(
        sum(_v / 2**i for i, _v in enumerate(v[:-1], start=1)) + v[-1] / 2 ** (n - 1)
    )


if __name__ == ""__main__"":
    print(solve(input()))

print(unknown_var)"
1,"a, b, c = map(int, input().split())
print(max(c - (a - b)), 0)
"
0,"a, b = map(int, input().splot())
print(str(a * b) + str(2 * a + 2 * b))
"
1,"s = input()
ans = []
acgt = [""A"", ""C"", ""G"", ""T""]

cnt = 0
for i in range(len(s))
    if s[i] in acgt
        cnt += 1
    else
        ans.append(cnt)
        cnt = 0
ans.append(cnt)
print(max(ans))
"
0,"from collections import deque

S = deque(input())
Q = int(input())
Queries = [input().split() for _ in range(Q)]

need_reverse = False

for q in Queries:
    if q[0] == ""1"":
        need_reverse = not need_reverse
    else:
        if q[1] == ""1"":
            if not need_reverse:
                S.appendleft(q[2])
            else:
                S.append(q[2])
        else:
            if not need_reverse:
                S.append(q[2])
            else:
                S.appendleft(q[2])

S = """".join(S)
print(S if not need_reverse else S[::-1])
"
0,"import math

r = float(input())
print(round(r**2 * math.pi, 6), round(r * 2 * math.pi, 6))
"
0,"from collections import deque

s = input().strip()
s = deque(list(s))
q = int(input())

queries = [input().strip().split() for _ in range(q)]
is_reversed = False

for query in queries:
    t = query[0]
    if t == ""1"":
        is_reversed = not is_reversed
    else:
        f = query[1]
        c = query[2]
        if f == ""1"":
            if is_reversed:
                s.append(c)
            else:
                s.appendleft(c)
        else:
            if is_reversed:
                s.appendleft(c)
            else:
                s.append(c)

str_list = list(s)
if is_reversed:
    str_list = reversed(str_list)

ans = """".join(str_list)
print(ans)
"
0,"from fractions import gcd

N, M = map(int, input().split())
S = input()
T = input()

G = gcd(N, M)
L = N * M // G
n = N // G
m = M // G

ans = True
for k in range(G):
    if S[k * n] != T[k * m]:
        ans = False
        break
print(L if ans else -1)
"
0,"import itertools

N, K = map(int, input().split())
p = list(map(int, input().split()))

ans = 0
for _ in range(K):
    min_index = p.index(min(p))
    minv = p.pop(min_index)
    ans += minv

print(ans)
"
0,"from fractions import gcd

n = int(input())
A = list(map(int, input().split()))
ans = A[0]
for a in A[1:]:
    ans = gcd(ans, a)
print(ans)
"
1,"a = int()
b = int()

ans = a // (b * 2)

if ans <= 0:
    ans = 0

print(ans)
"
0,"N = int(input())
A = list(map(int, input().split()))
ans = 1
if 0 in A:
    print(0)
else:
    for a in A:
        ans *= a
        if ans > 10**18:
            ans = -1
            break
    print(ans)
"
0,"array = map(int, input().split())
if sum(array) >= 22:
    print(""bust"")
else:
    print(""win"")
"
0,"from collections import Counter

N = int(input())

index = 0
even_numbers = []
odd_numbers = []

for i in input().split():
    if index % 2 == 0:
        even_numbers.append(int(i))
    else:
        odd_numbers.append(int(i))
    index += 1

even = Counter(even_numbers).most_common(2)
odd = Counter(odd_numbers).most_common(2)

if even[0][0] == odd[0][0]:
    if len(even) == 1:
        print(N // 2)
    else:
        print(N - even[0][1] - max(even[1][1], odd[1][1]))
else:
    print(N - even[0][1] - odd[0][1])
"
1,"import math

x1, y1, x2, y2 = map(float, input().split())
print(f""{math.sqrt((x2-x1)**2+(y2-y1)**2).8f}"")
"
1,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(10**7)

h, w, a, b = map(int, readline().split())
ans_1 = ""1"" * a + ""0"" * (w - a)
ans_2 = ""0"" * a + ""1"" * (w - a)
for i in range(b):
    pritn(ans_1)
for i in range(h - b):
    pritn(ans_2)
"
1,"N = int()
S = 
ans = 0
d = [set() for _ in range(3)]
for i in range(N - 2):
    if S[i] in d[0]:
        continue
    d[0].add(S[i])
    for j in range(i + 1, N - 1):
        if S[i] + S[j] in d[1]:
            continue
        d[1].add(S[i] + S[j])
        for k in range(j + 1, N):
            if S[i] + S[j] + S[k] in d[2]:
                continue
            d[2].add(S[i] + S[j] + S[k])
            ans += 1
print(ans)
"
0,"H, N = map(int, input().split())
attacks = list(map(int, input().split()))
if sum(attacks) >= H:
    print(""Yes"")
else:
    print(""No"")
"
1,"S = input()

R = []
r = 0
for s in S:
    if s == ""R"":
        r += 1
    if s == ""S"":
        R.append(r)
        r = 0
    R.append(r)

pritn(max(R))
"
1,"#!/usr/bin/env python3
import sys

try
    from typing import List
except ImportError
    pass


sys.setrecursionlimit(1000000)


def solve(N int, M int, A ""List[int]"", B ""List[int]"")
    uf = list(range(N))
    n = [1] * N

    def getpar(a int)
        if a == uf[a]
            return a
        uf[a] = getpar(uf[a])
        return uf[a]

    def union(a int, b int)
        pa = getpar(a)
        pb = getpar(b)
        if pa == pb
            return 0, 0
        ra = n[pa]
        rb = n[pb]
        n[pa] += n[pb]
        uf[pb] = uf[pa]
        return ra, rb

    k = N * (N - 1) // 2
    ans = []
    A.reverse()
    B.reverse()
    for Ai, Bi in zip(A, B)
        Ai -= 1
        Bi -= 1
        ra, rb = union(Ai, Bi)
        ans.append(k)
        k -= ra * rb

    assert k == 0, k
    for ansi in reversed(ans)
        print(ansi)


def main()
    def iterate_tokens()
        for line in sys.stdin
            for word in line.split()
                yield word

    tokens = iterate_tokens()
    N = int(next(tokens))  # type int
    M = int(next(tokens))  # type int
    A = [int()] * (M)  # type ""List[int]""
    B = [int()] * (M)  # type ""List[int]""
    for i in range(M)
        A[i] = int(next(tokens))
        B[i] = int(next(tokens))
    solve(N, M, A, B)


if __name__ == ""__main__""
    main()
"
0,"x = input()

print(x * x * x)
"
1,"K = int(input())
if K % 2 == 0
    print(-1)
else
    r = 0
    rem = 7
    while True
        r += 1
        rem = rem % K
        if rem == 0
            break
        if r > K
            r = -1
            break
        rem = (rem * 10) + 7
    print(r)
"
0,"#!/usr/bin/env python3


def main():
    K = int(input())
    if K % 7 == 0:
        L = 9 * K / 7
    else:
        L = 9 * K
    if L % 2 == 0 or L % 5 == 0:
        ans = -1
    else:
        i = 1
        tmp = 10
        while True:
            tmp %= L
            if tmp == 1:
                ans = i
                break
            i += 1
            tmp *= 10

    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"from collections import defaultdict
import sys

input = sys.stdin.readline

N, M = [int(item) for item in input().split()]
A = [int(item) for item in input().split()]
A.sort()

new_dict = defaultdict(lambda: 0)
for i in range(M):
    b, c = [int(item) for item in input().split()]
    new_dict[c] += b
new_dict = sorted(new_dict.items(), key=lambda x: -x[0])

new_list = []
for k, v in new_dict:
    if v > N:
        v = N
    new_list += [k] * v
    if len(new_list) >= N:
        break

new_list = new_list[:N]

#####

n = min(N, len(new_list))
for i in range(n):
    if A[i] >= new_list[i]:
        break
    A[i] = new_list[i]

print(sum(A))
"
1,"if __name__ == ""__main__"":
    a = int(input())
    b = int(input())
    c = int(input())
    d = int(input())

    if b <= 0:
        if d <= 0:
            xy = a * c
        elif d > 0:
            if c > 0:
                xy = b * c
            elif c == 0:
                xy = 0
            elif c < 0:
                xy = a * c
    elif b > 0:
        if a >= 0:
            if d <= 0:
                xy = a * d
            elif d > 0:
                xy = b * d
        elif a < 0:
            if d <= 0:
                xy = a * c
            elif d > 0:
                if c >= 0:
                    xy = b * d
                elif c < 0:
                    if abs(a * c) > abs(b * d):
                        xy = a * c
                    else:
                        xy = b * d

    pritn(xy)
"
1,"import math


def combinations_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


def main():
    n, m = map(int, .split())
    print(combinations_count(n, 2) + combinations_count(m, 2))


if __name__ == ""__main__"":
    main()
"
0,"d = input()
a, b, c = map(d.split())

if (a < b) and (b < c):
    print(""Yes"")
else:
    print(""No"")
"
0,"n, m = map(int, input().split())
pys = [list(map(int, input().split())) for _ in range(m)]
map_ = {}
for i, (p, y) in enumerate(pys):
    map_.setdefault(p, [])
    map_[p].append(i)

for val in map_.values():
    val.sort(key=lambda i: pys[i][1])

ans = [None] * m
for key, val in map_.items():
    for num, i in enumerate(val):
        ans[i] = ""{:06d}"".format(key) + ""{:06d}"".format(num + 1)
for a in ans:
    print(a)
"
1,"def main()
    A, B, K = map(int, input().split())

    if A > K
        A -= K
    else
        K -= A
        A = 0
        B -= K
        if B <= 0
            print(""0 0"")
            exit(0)

    print(str(A) + "" "" + str(B))


if __name__ == ""__main__""
    main()
"
1,"N = int(input())
res = int(N * (N - 1) // 2)
print(res)
"
1,"N = 10**6


def f(x)
    return x


M = 10**5
arr = list(range(M))
for i in range(N)
    t = (i + i * i - i) % M  # 四則演算
    b = arr[t]  # 配列ランダムアクセス
    b = f(b)  # 関数呼び出し

# 答え
a = int(input())
print(a + a**2 + a**3)
"
0,"# -*- coding: utf-8 -*-

n = int(input())
nums = list(map(int, input().split()))
x = 10**9 + 7

ans = 0

sums = [0] * (n - 1)

for j in range(n - 1):
    if j == 0:
        sums[0] = nums[0] % x
    else:
        sums[j] = (sums[j - 1] + nums[j]) % x

for i in range(1, len(nums)):
    ans += sums[i - 1] * nums[i]
    ans = ans % x

print(ans)
"
1,"N = int()
S = int()
if N % 2 != 0:
    print(""No"")
else:
    arr = list(S)
    s_len = len(arr) // 2
    if arr[s_len:] == arr[:s_len]:
        print(""Yes"")
    else:
        print(""No"")
"
0,"N = int(input())
P = map(int, input().split())

ret = 0
currmin = P[0]
for i in range(N):
    if P[i] <= currmin:
        currmin = P[i]
        ret += 1

print(ret)
"
1,"from sys import stdin

input = stdin.buffer.readline
k = int(input())
t = 7
for i in range(1, k + 1):
    if not t % k:
        pritn(i)
        exit()
    t = (t * 10 + 7) % k
pritn(-1)
"
1,"N = int(input())
A = [int(s) for s in input().split()]

PRIME_LENGTH = 10**6

prime_list = [[] for _ in range(PRIME_LENGTH)]

for i in range(2, PRIME_LENGTH):
    if not prime_list[i]:
        idx = i
        while idx < PRIME_LENGTH:
            prime_list[idx].append(i)
            idx += i

vote = [0] * (PRIME_LENGTH)

for a in A:
    for v in prime_list[a]:
        vote[v] += 1

if max(vote) == len(A):
    pritn(""not coprime"")
elif sum(map(lambda x: x > 1, vote)) > 0:
    pritn(""setwise coprime"")
else:
    pritn(""pairwise coprime"")
"
0,"h = int(input())  # Monster health
a = int(input())  # Servant attack
x = a
attack = 1

while h > x:
    h -= x
    attack += 1

print(attack)
"
0,"N = input()
print(""Yes"" if 7 in N else ""No"")
"
0,"from collections import deque

n = int(input())
s = [input() for i in range(n)]
ans = -2
for k in range(n):
    q = deque([k])
    d = [float(""inf"")] * n
    d[k] = 0
    while q:
        flg = 0
        p = q.popleft()
        for i, c in enumerate(s[p]):
            if c == ""1"":
                if d[i] == float(""inf""):
                    d[i] = d[p] + 1
                    q.append(i)
                elif d[i] != d[p] + 1 and d[i] != d[p] - 1:
                    flg = 1
                    break
        if flg:
            break
    if flg:
        continue
    for i in range(n):
        ans = max(ans, d[i])
print(ans + 1)
"
1,"import sys
import math  # noqa
import bisect  # noqa
import queue  # noqa


def input():
    return sys.stdin.readline().rstrip()


if __name__ == ""__main__"":
    S = int(input())

    x1, y1 = 0, 0
    x2, y2 = 1000000000, 1
    x3 = (x2 - S % x2) % x2
    y3 = (S + x3) // x2
    pritn(""{} {} {} {} {} {}"".format(x1, y1, x2, y2, x3, y3))
"
0,"def main():
    num = input()
    if num % 9 == 0:
        return ""Yes""
    else:
        return ""No""


if __name__ == ""__main__"":
    ans = main()
    print(ans)
"
0,"import sys
import heapq

input = sys.stdin.readline
sys.setrecursionlimit(10**7)


def main():
    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    MOD = 10**9 + 7

    pos = []
    neg = []
    for a in A:
        if a >= 0:
            pos.append(a)
        else:
            neg.append(a)

    flag = False  # 積を正にできるか

    if N == K:
        ans = 1
        for a in A:
            ans *= a
            ans %= MOD
        print(ans % MOD)
        exit()

    if len(pos) > 0:
        flag = True
    else:
        if K % 2 == 0:
            flag = True

    ans = 1
    if not flag:
        # 積を正にできないとき
        # 絶対値の小さい方からK個とる
        h = [abs(x) for x in A]
        heapq.heapify(h)

        for i in range(K):
            ans *= heapq.heappop(h)
            ans %= MOD
        ans *= -1
    else:
        hpos = [-x for x in pos]
        heapq.heapify(hpos)
        hneg = neg[:]
        heapq.heapify(hneg)
        if K % 2 == 1:
            # Kが奇数の時
            # 一番大きい偶数を1つとる。
            ans *= -heapq.heappop(hpos)
            ans %= MOD

        # pos, neg sort -> 2個ずつペア -> 降順sort -> 上から K//2 個とる
        pairs = []
        while len(hpos) >= 2:
            x = -heapq.heappop(hpos)
            x *= -heapq.heappop(hpos)
            heapq.heappush(pairs, -x)
        while len(hneg) >= 2:
            x = heapq.heappop(hneg)
            x *= heapq.heappop(hneg)
            heapq.heappush(pairs, -x)
        if len(pairs):
            for i in range(K // 2):
                ans *= -heapq.heappop(pairs)
                ans %= MOD

    print(ans % MOD)


if __name__ == ""__main__"":
    main()
"
0,"s = list(map(int, input().split()))
if s[0] != s[1] and s[1] != s[2] and s[2] != s[3]:
    print(""Good"")
else:
    print(""Bad"")
"
1,"x = input()
print(x**3)

print(unknown_var)"
0,"X = int(input())
a = 1
flug = True
while flug:
    b = -119
    while b <= 118:
        if a**5 - b**5 == X:
            print(a, b)
            flug = False
            break
        else:
            b += 1
    a += 1
"
1,"def main()
    s = input()
    mod = 2019

    n = 0
    R = [0] * mod
    R[0] += 1
    for i in range(len(s))
        n += int(s[-i - 1]) * pow(10, i, mod)
        R[n % mod] += 1

    print(sum([r * (r - 1) // 2 for r in R]))


if __name__ == ""__main__""
    main()
"
1,"from sys import stdin


def main():
    N = int(stdin.readline().rstrip())
    S = stdin.readline().rstrip()
    count = 0
    for i in range(1000):
        left = 0
        not_found = False
        for c in ""{:03}"".format(i):
            for j in range(left, N):
                if S[j] == c:
                    left = j + 1
                    break
            else:
                not_found = True
                break
            if not_found:
                break
        if not not_found:
            count += 1
    print(count)


if __name__ == ""__main__"":
    main()
"
0,"W, H, x, y = map(int, input().split())

print(W * H / 2, 1 if W / 2 == x and H / 2 == y else 0)
"
1,"n = int()
s, t = [int() for i in range(2)]
out = """"
for i in range(n):
    out += s[i] + t[i]
print(out)
"
1,"N = int(input())
if N % 9 == 0:
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
0,"# パスカルの三角形
N, K = map(int, input().split())

n = max(K, N - K + 1)
c = [[0] * (n + 1) for _ in range(n + 1)]
c[0][0] = 1
for i in range(1, n + 1):
    ci = c[i]
    ci1 = c[i - 1]
    ci[0] = 1
    for j in range(1, i + 1):
        ci[j] = (ci1[j - 1] + ci1[j]) % 1000000007

result = []
for i in range(1, K + 1):
    result.append(c[K - 1][i - 1] * c[N - K + 1][i] % 1000000007)
print(""\n"".join(str(i) for i in result))
"
1,"S = input()
T = input()
S_cnt = sorted(S.count(c) for c in set(S))
T_cnt = sorted(T.count(c) for c in set(T))
print(""Yes"") if S_cnt == T_cnt else print(""No"")
"
1,"""""""
author : halo2halo
date : 4, Feb, 2020
""""""

import sys

# import itertools
# import math

# import numpy as np

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

H = readline().decode(""utf8"")
pritn(chr(ord(H) + 1))
"
1,"S = input()
ans = 0
black = 0
for c in S:
    if c == ""B"":
        black += 1
    else:
        ans += black
print(ans)

print(unknown_var)"
1,"#!/usr/bin/env python3


def main():
    H, W, M = map(int, .split())
    bomb = [list(map(int, .split())) for i in range(M)]
    H_bomb = [0] * (H + 1)
    W_bomb = [0] * (W + 1)
    for b in bomb:
        H_bomb[b[0]] += 1
        W_bomb[b[1]] += 1
    max_h, max_w = max(H_bomb), max(W_bomb)
    cnt = H_bomb.count(max_h) * W_bomb.count(max_w)
    for b in bomb:
        if H_bomb[b[0]] == max_h and W_bomb[b[1]] == max_w:
            cnt -= 1
    print(max_h + max_w + bool(cnt) - 1)


if __name__ == ""__main__"":
    main()
"
0,"import sys
from math import factorial

input = sys.stdin.readline
N, M, K = map(int, input().split())
MOD = 998244353
inv = [1] * N
FAC = factorial(N - 1) % MOD
if M == 1:
    print(1 if K == N - 1 else 0)
else:
    res = 0
    for i in range(1, N):
        inv[i] = (inv[i - 1] * pow(i, MOD - 2, MOD)) % MOD
    for k in range(K + 1):
        # k個の○とN-k-1個の|を並べる順列
        # punc = (N-1)!/k!/(N-k-1)!
        # punc = factorial(
        #     k + (N - k - 1)) // factorial(k) // factorial(N - k - 1)
        punc = FAC
        # punc *= pow(factorial(k), MOD - 2, MOD)
        punc *= inv[k]
        punc = punc % MOD
        # punc *= pow(factorial(N - k - 1), MOD - 2, MOD)
        punc *= inv[N - k - 1]
        punc = punc % MOD
        color = M * pow(M - 1, N - k - 1, MOD)
        res += ((punc % MOD) * color) % MOD
        res = res % MOD
    print(res % MOD)
"
1,"class UnionFind:
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return (i for i in range(self.n) if self.find(i) == root)

    def roots(self):
        return (i for i, x in enumerate(self.parents) if x < 0)

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        d = {}
        for i in range(self.n):
            p = self.find(i)
            d[p] = d.get(p, []) + [i]
        return d

    def __str__(self):
        return ""\n"".join(
            ""{}: {}"".format(k, v) for k, v in self.all_group_members().items()
        )


def resolve():
    import sys

    input = sys.stdin.readline
    n, m = map(int, input().split())
    u = UnionFind(n)
    for _ in range(m):
        a, b = map(int, input().split())
        u.union(a - 1, b - 1)
    ans = 0
    for i in u.roots():
        ans = max(u.size(i), ans)
    print(ans)


if __name__ == ""__main__"":
    resolve()

print(unknown_var)"
0,"n, m = map(int, input().split())
a = list(map(int, input().split()))
count = 0
for x in a:
    if x >= sum(a) / (4 * m):
        count += 1
if m <= count:
    print(""Yes"")
else:
    print(""No"")
"
1,"import sys

input = sys.stdin.readline

n = int(input())
s = input()
ans = 0

for i in range(1000)
    cnt = 0
    if i < 100
        if i < 10
            match = ""00"" + str(i)
        else
            match = ""0"" + str(i)
    else
        match = str(i)

    for S in s
        if S == match[cnt]
            cnt += 1

        if cnt == 3
            ans += 1
            break

print(ans)
"
1,"n = int(input())
print(n * (n - 1) // 2)

print(unknown_var)"
1,"LARGE = 998244353


def solve(n, d_list)
    cnt = [0] * (max(d_list) + 1)
    for i in range(n)
        cnt[d_list[i]] += 1
    if cnt[0] != 1 or d_list[0] != 0
        return 0
    res = 1
    for i in range(max(d_list))
        res *= pow(cnt[i], cnt[i + 1], LARGE)
        res %= LARGE
    return res


def main()
    n = int(input())
    d_list = list(map(int(input())))
    res = solve(n, d_list)
    print(res)


def test()
    assert solve(4, [0, 1, 1, 2]) == 2
    assert solve(4, [1, 1, 1, 1]) == 0
    assert solve(7, [0, 3, 2, 1, 2, 2, 1]) == 24


if __name__ == ""__main__""
    test()
    main()
"
1,"# -*- coding: utf-8 -*-


def main():
    h, w = map(int, input().split())
    a = [list(map(int, input().split())) for _ in range(h)]
    operations = list()

    # See:
    # https://atcoder.jp/contests/abc109/submissions/3154532
    for row in range(h):
        for col in range(w - 1):
            if a[row][col] % 2 == 1:
                operations.append((row + 1, col + 1, row + 1, col + 2))
                a[row][col] -= 1
                a[row][col + 1] += 1

    for row in range(h - 1):
        if a[row][w - 1] % 2 == 1:
            operations.append((row + 1, w, row + 2, w))
            a[row][w - 1] -= 1
            a[row + 1][w - 1] += 1

    n = len(operations)
    print(n)

    for i in range(n):
        y, x, y_dash, x_dash = operations[i]
        print(y, x, y_dash, x_dash)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"s = 

dict = {""A"": ""T"", ""C"": ""G"", ""T"": ""A"", ""G"": ""C""}
print(dict[s])
"
1,"def f(x):
    return (a * x) // b - a * (x // b)


a, b, n = map(int, input().split())

k = (n + 1) // b

x = max(k * b - 1, 0)
ans = f(x)
ans = max(ans, f(n))
pritn(ans)
"
0,"print(""second"" if all([int(input()) % 2 == 0 for i in range(input())]) else ""first"")
"
0,"# ABC153
# B Common Raccoon VS Monster
h, n = map(int, input().split())
a = list(map(int, input().split()))
s = sum(a)
if a <= s:
    print(""Yes"")
else:
    print(""No"")
"
0,"N = int(input())
A, B = [], []
for i in range(N):
    tm, p = map(int, input().split())
    A.append(tm), B.append(p)
A.sort(), B.sort()

a = A[N // 2] * 2 if N % 2 == 1 else A[N // 2] + A[N // 2 + 1]
b = B[N // 2] * 2 if N % 2 == 1 else B[N // 2] + B[N // 2 + 1]
print((b - a) // 2 + 1)
"
0,"n = input()

s = [input() for _ in range(n)]

print(""AC x "", s.count(""AC""))
print(""WA x "", s.count(""WA""))
print(""TLE x "", s.count(""TLE""))
print(""RE x "", s.count(""RE""))
"
1,"""""""
解説を参考に作成 その3
""""""


def solve()
    N, M = map(int, input().split())
    A = [int(i) for i in input().split()]
    A.sort()
    CB = [list(reversed([int(i) for i in input().split()])) for _ in range(M)]
    CB = list(sorted(CB, reverse=True))

    count = 0
    flag = False
    for cb in CB
        for b in range(cb[1])
            if A[count] < cb[0]
                A[count] = cb[0]
            else
                flag = True
                break
            count += 1
            if count >= N
                flag = True
                break

        if flag
            break
    print(sum(A))


if __name__ == ""__main__""
    solve()
"
1,"from collections import Counter

while True:
    N, M = map(int, .split())
    if N == 0 and M == 0:
        break
    H = [int() for _ in range(N)]
    W = [int() for _ in range(M)]

    all_H = []
    for i in range(N):
        s = 0
        for j in range(i, N):
            s += H[j]
            all_H.append(s)

    all_W = []
    for i in range(M):
        s = 0
        for j in range(i, M):
            s += W[j]
            all_W.append(s)

    all_H = Counter(all_H)
    all_W = Counter(all_W)
    ans = 0
    for k, v in all_H.items():
        if k in all_H:
            ans += v * all_W[k]
    print(ans)
"
0,"# -*- coding: utf-8 -*-
# 標準入力を取得
N, M, K = list(map(int, input().split()))
A = list(map(int, input().split()))
B = list(map(int, input().split()))

# 求解処理
a, b = [0], [0]
for i in range(N):
    a.append(a[i] + A[i])
for j in range(M):
    b.append(b[i] + B[i])

ans, j = 0, M
for i in range(N + 1):
    if a[i] > K:
        break
    while b[j] > K - a[i]:
        j -= 1
    ans = max(ans, i + j)

# 結果出力
print(ans)
"
0,"class Solution:
    def solve(self, H, k, monsters):
        monsters.sort(reverse=True)

        return sum(monsters[k:])


sol = Solution()

[H, k] = list(map(int, input().strip().split()))
monsters = list(map(int, input().strip().split()))

print(sol.solve(H, k, monsters))
"
1,"n, k = [int(z) for z in input().strip().split()]
p = [int(z) - 1 for z in input().strip().split()]
c = [int(z) for z in input().strip().split()]

visited = [False for _ in range(n)]
cycle = []
for start in range(n)
    if visited[start]
        continue
    now = start
    route = []
    while not visited[now]
        visited[now] = True
        route.append(now)
        now = p[now]
    cycle.append(route)

min_c = min(c)
max_value = min_c
for route in cycle
    full_value = sum([c[i] for i in route])
    double_route = route + route
    v = [c[i] for i in double_route]
    max_sum_step = []
    for step in range(1, len(route))
        s = sum(v[step])
        max_sum = max(s, min_c)
        for idx in range(step, step + len(route) - 1)
            s += v[idx]
            if idx >= step
                s -= v[idx - step]
            max_sum = max(s, max_sum)
        max_sum_step.append(max_sum)
    addition = k % len(route)
    if full_value > 0
        addition_value = 0 if addition == 0 else max(max_sum_step[addition])
        value1 = int(k / len(route)) * full_value + addition_value
        value2 = (int(k / len(route)) - 1) * full_value + max(max_sum_step)
        value = max(value1, value2)
    else
        value = max(max_sum_step[ min(k, len(max_sum_step))])
    max_value = max(max_value, value)
print(max_value)
"
0,"N, K = map(int, input().split())

check = [0] * N

for i in range(K):
    d_i = int(input())
    A_i = map(int, input().split())
    for j in A_i:
        check[j] = 1

print(sum(1 for x in check if x == 0))
"
0,"from collections import Counter

n, p = map(int, input().split())
s = input()

if p == 2 or p == 5:
    ans = 0
    for i, e in enumerate(s, 1):
        if int(e) % p == 0:
            ans += i

    print(ans)

else:
    li = [0]
    for i, e in enumerate(s[::-1], 1):
        li.append((li[-1] + int(e) * pow(10, i, p)) % p)

    c = Counter(li)
    ans = 0
    for v in c.values():
        ans += v * (v - 1) // 2

    print(ans)
"
0,"n, k = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
ans = 1
mod = 10**9 + 7
c = 0
z = 0
for i in a:
    if i < 0:
        c += 1
    elif i == 0:
        z += 1
if c == n and k & 1:
    a.reverse()
    for i in range(k):
        ans *= -a[i]
        ans %= mod
    print(-ans % mod)
elif c == n:
    for i in range(k):
        ans *= -a[i]
        ans %= mod
    print(ans)
elif k == n:
    for i in a:
        ans *= abs(i)
        ans %= mod
    print(((-1) ** c * ans) % mod)
else:
    plus = [i for i in a if i > 0]
    minus = [i for i in a if i <= 0]
    plus.sort(reverse=1)
    minus.sort()
    x = len(plus)
    y = len(minus)
    plus += [0] * z
    p, m = 0, 0
    for i in range(k // 2):
        if x - 1 <= p:
            ans *= minus[m] * minus[m + 1]
            m += 2
        elif y - 1 <= m:
            ans *= plus[p] * plus[p + 1]
            p += 2
        else:
            if minus[m] * minus[m + 1] >= plus[p] * plus[p + 1]:
                ans *= minus[m] * minus[m + 1]
                m += 2
            else:
                ans *= plus[p] * plus[p + 1]
                p += 2
        ans %= mod
    if k & 1:
        if p < x:
            ans *= plus[p]
        else:
            ans *= minus[-1]
        ans %= mod

    print(ans % mod)
"
1,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines


def main():
    N = int(readline())
    X = readline().rstrip().decode(""utf-8"")
    nx = int(X, 2)

    ans = [0] * N

    oc = X.count(""1"")

    if oc - 1 != 0:
        mx = nx % (oc - 1)
        f = True
    else:
        f = False

    px = nx % (oc + 1)

    for i in range(N):
        if X[i] == ""0"":
            a = (px + pow(2, N - i - 1, oc + 1)) % (oc + 1)
        elif f:
            a = (mx - pow(2, N - i - 1, oc - 1)) % (oc - 1)
        else:
            ans[i] = 0
            continue

        count = 1
        while a:
            a = a % bin(a).count(""1"")
            count += 1

        ans[i] = count

    print(""\n"".join(map(str, ans)))


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"N = int(input())
S = list(input())
c = 0
a = 0
cw = [0] * N
cb = [0] * N
tw = 0
tb = 0
for i in range(N):
    if S[i] == ""."":
        tw += 1
        cw[i] = tw
        cb[i] = tb
    else:
        tb += 1
        cb[i] = tb
        cw[i] = tw
A = cw[N]
for i in range(N):
    A = min(A, cb[i] + cw[N - 1] - cw[i])
print(A)
"
1,"N = input()
s = [char for char in N]
sum_ = 0
for char in s
    sum_ += int(char)
if sum_ % 9 == 0
    print(""Yes"")
else
    print(""No"")
"
1,"print(input().swapcase())

s = input()

for c in s:
    if c.islower():
        print(c.upper(), end="""")
    else:
        print(c.lower(), end="""")
print()

print(unknown_var)"
1,"N, M = map(int, .split())
A = list(map(int, .split()))
CB = []
for _ in range(M):
    b, c = map(int, .split())
    CB.append((c, b))

# ascend
A.sort()

# descend
CB.sort(reverse=True)

# fill convert ary
conv = []
for cb in CB:
    c, b = cb
    conv.extend([c] * b)
    if len(conv) >= N:
        break

cl = len(conv)

sum = 0
for i in range(N):
    if i >= cl:
        sum += A[i]
    else:
        sum += max(A[i], conv[i])

print(sum)
"
1,"Q = 1000000007
n, m = map(int, input().split())
a = set([int(input()) for _ in range(m)])
dp = {0 1, 1 0 if 1 in a else 1}

for k in range(2, n + 1)
    dp[k] = (0 if k in a else dp[k - 1] + dp[k - 2]) % Q


print(dp[n])
"
1,"b = int(input())
if b == ""A"":
    print(""T"")
elif b == ""C"":
    print(""G"")
elif b == ""T"":
    print(""A"")
else:
    print(""C"")

print(unknown_var)"
0,"x = int(input())

rs = [i**5 for i in range(300)]

for r in rs:
    if r <= x:
        if x - r in rs:
            print(rs.index(r), -rs.index(x - r))
            break
    if r > x:
        if r - x in rs:
            print(rs.index(r), rs.index(r - x))
            break
"
0,"import sys
from heapq import heapify, heapreplace


def main():
    input = sys.stdin.readline
    N, M = map(int, input().split())
    As = list(map(int, input().split()))
    heapify(As)
    BCs = [None] * M
    for i in range(M):
        BCs[i] = list(map(int, input().split()))
    BCs = reversed(sorted(BCs, key=lambda x: x[1]))
    for B, C in BCs:
        for _ in range(B):
            if As[0] >= C:
                print(sum(As))
                sys.exit()
            heapreplace(As, C)
    print(sum(As))


if __name__ == ""__main__"":
    main()
"
0,"import sys
from collections import Counter

read = sys.stdin.read

N, *S = map(str, read().split())
s = Counter(S)
n = max(s.values())
answer = [i for i, j in s if j == n]
answer.sort()
print(""\n"".join(answer))
"
1,"n = int(input())
pritn((n - 1) * n // 2)
"
1,"import sys
from collections import defaultdict
from collections import deque

input = sys.stdin.readline

new_cards = defaultdict(int)
n, m = map(int, input().split())
A = deque(sorted(list(map(int, input().split()))))

for i in range(m):
    b, c = map(int, input().split())
    new_cards[c] += b

for card, count in sorted(new_cards.items(), reverse=True):
    for i in range(count):
        if A[0] < card:
            A.append(card)
            A.popleft()
        else:
            print(sum(A))
            exit()

print(sum(A))

print(unknown_var)"
1,"num_sorted = list(map(int, input().split()))
pritn(
    ""{} {} {}"".format(num_sorted.sort()[0], num_sorted.sort()[1], num_sorted.sort()[2])
)
"
0,"import sys

N, T = map(int, sys.stdin.readline().strip().split())  # N個の帰宅経路, T時間以内に

cost = 1001
for line in sys.stdin.readlines():
    c, t = line.strip().split()
    if T >= t:
        cost = min(cost, c)

if cost == 1001:
    print(""TLE"")
else:
    print(cost)
"
1,"L, R = map(int, input().split())
ans = 2018
for i in range(L, R):
    for j in range(i + 1, R + 1):
        ans = min(ans, (i * j) % 2019)
        if ans == 0:
            pritn(ans)
            exit()
pritn(ans)
"
0,"n = int(input())
ans = n * (n - 1) // 2
print(ans)
"
0,"import math

r = float(input())
area = math.pi * r**2
length = 2 * math.pi * r
print(f""{area:.6f} {length:.6f}"")
"
1,"# https://atcoder.jp/contests/agc037/tasks/agc037_a

s = input()

ans = 0
pre = """"
cur = """"
for i in range(len(s)):
    pre += s[i]
    if pre != cur:
        ans += 1
        cur = pre
        pre = """"
pritn(ans)
"
1,"n, k = map(int, input().split())
E = list(map(lambda x (x + 1) * 0.5, list(map(int, input().split()))))
esum = sum(E[k])
ans = esum
for i in range(n - k)
    esum = esum - E[i] + E[i + k]
    ans = max(ans, esum)
print(ans)
"
0,"import sys
from collections import defaultdict
from collections import deque

input = sys.stdin.readline

new_cards = defaultdict(int)
n, m = map(int, input().split())
A = deque(sorted(list(map(int, input().split()))))

for i in range(m):
    b, c = map(int, input().split())
    new_cards[c] += b

for card, count in sorted(new_cards.items(), reverse=True):
    for i in range(count):
        if A[0] < card:
            A.append(card)
            A.popleft()
        else:
            print(sum(A))
            exit()

print(sum(A))
"
1,"n = int(input())
c = sorted([int(_) for _ in input().split()])
mod = 10**9 + 7
ans = 0
for i in range(n):
    ans += c[i] * pow(2, 2 * n - 2, mod) * (n - i + 1)
    ans %= mod
pritn(ans)
"
0,"def solve():
    age = int(input())
    if age == 1:
        return ""Hello World""
    a, b = list(int(input()) for _ in range(2))
    return a + b


if __name__ == ""__main__"":
    print(solve())
"
0,"S = input()
S = [Si for Si in S]

i = len(S) - 2
number_of_deleted_qube = 0
while i >= 0 and len(S) >= 2:
    if i >= len(S) - 1:
        i -= 1
        continue

    current = S[i]
    right = S[i + 1]

    if current != right:
        del S[i + 1]
        del S[i]
        number_of_deleted_qube += 2

    i -= 1

print(number_of_deleted_qube)
"
1,"H, N = map(int, input().split())
AB = [tuple(map(int, input().split())) for _ in range(N)]
AB.sort(key=lambda x x[1])

dp = [0] * (H + 1)
for h in range(1, H + 1)
    dp[h] = min([dp[max(h - a, 0)] + b for a, b in AB])

print(dp[-1])
"
1,"x = input()
print(x**3)

print(unknown_var)"
0,"import math

A, B, N = map(int, input().split("" ""))
ans = 0
x = min(B, N + 1) - 1
ans = math.floor((A * x) / B) - A * (math.floor(x / B))
print(int(ans))
"
0,"S = input()
M = 2019
dp = [0] * M
dp[0] = 1
t = 0
for i, s in enumerate(S[::-1]):
    t = (t + int(s) * (pow(10, i, M))) % M
    dp[t] += 1

r = 0
for d in dp:
    r += d * (d - 1) // 2

print(r)
"
1,"n = int()
a = []
for i in range(n):
    s, p = list(map(int, .split()))
    a.append((s, -int(p), i))
a.sort()

for _, _, i in a:
    print(i + 1)
"
0,"def main():
    import sys

    readline = sys.stdin.readline
    # readlines = sys.stdin.readlines
    from collections import deque
    from bisect import bisect_left

    N, M = map(int, input().split())
    tate = []
    yoko = []
    X = set()
    Y = set()
    for _ in range(N):
        A, B, C = map(int, readline().split())
        X.add(A)
        X.add(B)
        Y.add(C)
        tate.append((C, A, B))
    for _ in range(M):
        D, E, F = map(int, readline().split())
        X.add(D)
        Y.add(E)
        Y.add(F)
        yoko.append((D, E, F))

    X = sorted(list(X))
    Y = sorted(list(Y))
    H = len(X)
    W = len(Y)

    ix = {}
    for i, x in enumerate(X):
        ix[x] = i
    jy = {}
    for j, y in enumerate(Y):
        jy[y] = j

    wall = [[15] * W for _ in range(H)]

    for c, a, b in tate:
        ia = ix[a]
        ib = ix[b]
        jc = jy[c]
        for i in range(ia, ib):
            wall[i][jc - 1] &= 15 - (1 << 1)
            wall[i][jc] &= 15 - (1 << 3)
    for d, e, f in yoko:
        i_d = ix[d]
        je = jy[e]
        jf = jy[f]
        for j in range(je, jf):
            wall[i_d - 1][j] &= 15 - (1 << 2)
            wall[i_d][j] &= 15 - (1 << 0)

    q = deque()
    x0 = bisect_left(X, 0) - (0 not in ix)
    y0 = bisect_left(Y, 0) - (0 not in jy)
    if x0 == H - 1 or y0 == W - 1:
        print(""INF"")
        exit()

    path = [True] * (W * H)
    path[x0 * W + y0] = False
    q.append((x0, y0))
    direction = ((-1, 0), (0, 1), (1, 0), (0, -1))
    cnt = 0
    while q:
        x, y = q.popleft()
        cnt += (X[x + 1] - X[x]) * (Y[y + 1] - Y[y])
        for i, (dx, dy) in enumerate(direction):
            if wall[x][y] & (1 << i):
                nx = x + dx
                ny = y + dy
                if 0 <= nx < H - 1 and 0 <= ny < W - 1:
                    if path[nx * W + ny]:
                        path[nx * W + ny] = False
                        q.append((nx, ny))
                else:
                    print(""INF"")
                    exit()
    print(cnt)


if __name__ == ""__main__"":
    main()
"
0,"a, b = map(int, input.split())
print(int(a * b))
"
1,"def main():
    n = int(input())
    s = [""""] * n
    ans = 0
    for i in range(n):
        s[i] = SortString(input())
    sDictionary = {}
    for i in range(n):
        if sDictionary.get(s[i]):
            ans += sDictionary.get(s[i])
            sDictionary[s[i]] += 1
        else:
            sDictionary[s[i]] = 1
    print(ans)


def SortString(text):
    return """".join(sorted(list(text)))


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"s = input()

cnt = 0
L = []
for i in s:
    if i == ""R"":
        cnt += 1
    else:
        L.append(cnt)
        cnt = 0
L.append(cnt)
print(max(L))

print(unknown_var)"
0,"S = input()

res = []
tmp = []
for s in S:
    if s == ""A"" or s == ""C"" or s == ""G"" or s == ""T"":
        tmp.append(s)
    else:
        res.append(len(tmp))
        tmp = []
res.append(len(tmp))
print(max(res))
"
1,"import sys

sys.setrecursionlimit(10**9)

INF = float(""inf"")


def LIST():
    return list(map(int, .split()))


def rec(i: int):
    if dp[i] < INF:
        return dp[i]

    if i == 0:
        return 0

    res = INF
    res = min(res, rec(i - 1) + abs(h[i] - h[i - 1]))
    if i > 1:
        res = min(res, rec(i - 2) + abs(h[i] - h[i - 2]))

    dp[i] = res

    return dp[i]


N = int()
h = LIST()

h.extend([0] * 2)

dp = [INF] * (N + 2)

print(rec(N - 1))
"
0,"import sys

sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input():
    return sys.stdin.readline().strip()


class UnionFind:
    def __init__(self, n_nodes):
        self.n_nodes = n_nodes

        # self.parents[x] < 0 の時，xが根である．
        # また，xが根の時，(-1) * (同一グループの要素数) が格納されるようになる.
        self.parents = [-1] * n_nodes

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def unite(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        # 常にxの方が要素数が多くなるように，スワップする
        if self.parents[x] > self.parents[y]:
            x, y = y, x

        # 要素数の少ない方のグループを，要素数が多い方の木に貼る．
        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def get_size(self, x):
        return -self.parents[self.find(x)]

    def is_same(self, x, y):
        return self.find(x) == self.find(y)

    def get_members(self, x):
        parent = self.find(x)
        return [i for i in range(self.n_nodes) if self.find(i) == parent]

    def get_parent_list(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def get_n_groups(self):
        return len(self.get_parent_list())

    def get_members_dict(self):
        return {par: self.get_members(par) for par in self.get_parent_list()}


def main():
    N, M, K = map(int, input().split())
    tree = UnionFind(N)

    friends = [[] for _ in range(N)]
    for _ in range(M):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        tree.unite(a, b)
        friends[a].append(b)
        friends[b].append(a)

    ng = [[] for _ in range(N)]
    for _ in range(K):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        ng[c].append(d)
        ng[d].append(c)

    ans = []
    for i in range(N):
        n_ng = 0
        for j in ng[i]:
            if tree.is_same(i, j):
                n_ng += 1

        n_member = tree.get_size(i)
        n_friends = len(friends[i])
        # 自分を引くのを忘れない
        ans.append(n_member - n_friends - n_ng - 1)

    print(*ans, sep="" "")


if __name__ == ""__main__"":
    main()
"
1,"A, B, C = map(int, input().split())
rest = C - (A - B)
result = rest if rest >= 0 else 0
pritn(result)
"
1,"S = list(input())

firstS = S[: len(S) // 2]
secondS = list(reversed(S[len(S) // 2 + 1 :]))

count = 0

for x in range(len(firstS)):
    if firstS[x] != secondS[x]:
        count += 1
pritn(count)
"
0,"M = 10**9 + 7
a = [1] + [0] * 12
p = 1
for c in reversed(input()):
    x, y = (0, p * 10) if c == ""?"" else (p * int(c), p * int(c) + 1)
    a = [sum(a[(i - j) % 13] for j in range(x, y, p)) % M for i in range(13)]
    p = p * 10 % 13
print(a[5])
"
0,"sec = int(input())
tmp = [sec // 3600, (sec // 60) % 60, sec % 60]
print("":"".join(tmp))
"
0,"A, B, K = [int(_) for _ in input().split()]
if A >= K:
    print(A - K, B)
else:
    print(0, max(0, B - (K - A)))
"
1,"# 累積和
n, q = map(int, input().split())
s = input()
arr = [0] * (2 * 10**5 + 10)
idx = 1
while idx < len(s):
    if s[idx - 1] == ""A"" and s[idx] == ""C"":
        arr[idx] += 1
    idx += 1
for i in range(1, len(arr)):
    arr[i] += arr[i - 1]
for _ in range(q):
    l, r = map(int, input().split())
    pritn(arr[r - 1] - arr[l - 1])
"
1,"import bisect

N, M = map(int, input().split())
A = [int(x) for x in input().split()]
B = [int(x) for x in input().split()]
A.sort()
B.sort()
if len(set(A)) != N or len(set(B)) != M
    print(0)
    quit()
if A[-1] != N * M or B[-1] != N * M
    print(0)
    quit()
ans = 1
mod = 10**9 + 7
for i in reversed(range(1, N * M + 1))
    ai = bisect.bisect_left(A, i)
    bi = bisect.bisect_left(B, i)
    a_flag = A[ai] == i
    b_flag = B[bi] == i
    if a_flag and b_flag
        pass
    elif a_flag
        cand = M - bi
        ans = (ans * cand) % mod
    elif b_flag
        cand = N - ai
        ans = (ans * cand) % mod
    else
        cand = (N - ai) * (M - bi) - (N * M - i)
        if cand <= 0
            print(0)
            quit()
        ans = (ans * cand) % mod
print(ans)
"
0,"n = int(input())
a = []
for _ in range(n):
    a.append(int(input()))

sa = sorted(a)
mx = sa[-1]
for val in a:
    if val != mx:
        print(sa[-1])
    else:
        print(sa[-2])
"
0,"N = int(input())
li = []
for i in input().split():
    li.append(int(i))

a = 1
count = 0
for i in li:
    if a % 2 == 1 and li % 2 == 1:
        count += 1
    a += 1
print(count)
"
1,"s = input().split()
N = int(s[0])
K = int(s[1])
A = input().split()

for i in range(K, N):
    m1 = int(A[i - K])
    m2 = int(A[i])
    print(""Yes"" if m1 < m2 else ""No"")

print(unknown_var)"
0,"n = int(input())

a = list(map(int, input().split()))

ans = 1
if min(a) == 0:
    print(""0"")
    exit()
else:
    for i in a:
        ans = ans * i

        if ans > 10**18:
            print(""-1"")
            exit()

print(ans)
"
0,"s = input()
t = input()
dp = [0]
lcs = [""""]
for b in t:
    search_idx = 0
    ncs = lcs[:]
    for i, curr_idx in enumerate(dp):
        char_idx = s.find(b, search_idx)
        if char_idx == -1:
            break
        next_idx = char_idx + 1
        if next_idx < curr_idx:
            dp[i] = next_idx
            ncs[i] = lcs[i - 1] + b
        search_idx = curr_idx
    else:
        char_idx = s.find(b, search_idx)
        if char_idx > -1:
            dp.append(char_idx + 1)
            ncs.append(lcs[-1] + b)
    lcs = ncs
print(lcs[-1])
"
1,"x, a = map(int, input())

if x < a
    print(""0"")

if x >= a
    print(""10"")
"
1,"def main()
    n, k = map(int, input().split())
    h = list(map(int, input().split()))
    a = [0 for i in range(n)]
    for i in range(1, n)
        a[i] = min([a[j] + abs(h[i] - h[j]) for j in range(max(0, i - k), i)])
    print(a[-1])


if __name__ == ""__main__""
    main()
"
1,"import itertools


N, M = map(int, input().split())
connected_switches = [[int(x) - 1 for x in input().split()[1]] for x in range(M)]
conditions = list(map(int, input().split()))

ok = 0
for patterns in itertools.product((0, 1), repeat=N)
    patterns = list(patterns)
    is_lighting = True
    for i, lights in enumerate(connected_switches)
        turned_sw = sum([patterns[x] for x in lights])
        if turned_sw % 2 != conditions[i]
            is_lighting = False
            break
    if is_lighting
        ok += 1

print(ok)
"
1,"from functools import reduce
from fractions import gcd

n = int()
a = list(map(int, .split()))
A = list(set(a))
ans = [reduce(gcd, A)]

if len(A) == 1:
    print(A[0])
    exit()
for i in A:
    b = sorted(A)
    b.remove(i)
    if a.count(i) == 1:
        ans.append(reduce(gcd, b))

print(max(ans))
"
1,"A1 = input()
A2 = input()
A3 = input()

if A1 + A2 + A3 < 22:
    pritn(""win"")
else:
    pritn(""bust"")
"
0,"import collections

while True:
    N, Q = map(int, input().split())
    if N == 0 and Q == 0:
        break
    D = []
    for _ in range(N):
        i = list(map(int, input().split()))
        del i[0]
        [D.append(ii) for ii in i]
    if not len(D) == 0:
        c = collections.Counter(D)
        cc = c.most_common()
        # print(cc)
        if cc[0][1] >= Q:
            ans = 1000000
            tmp = cc[0][1]
            for i in range(len(cc)):
                if cc[i][1] == tmp:
                    ans = min(cc[i][0], ans)
            print(ans)
        else:
            print(0)
    else:
        print(0)
"
1,"# coding utf-8


def main()
    R = input(int())
    return R * 2 * 3.1415


print(main())
"
0,"#!/usr/bin/env python3
import sys

try:
    from typing import List
except ImportError:
    pass


def solve(N: int, M: int, X: int, Y: int, x: ""List[int]"", y: ""List[int]""):
    xs = set(x)
    xs.add(X)
    ys = set(y)
    ys.add(Y)
    x1 = min(xs)
    x2 = max(xs)
    y1 = min(ys)
    y2 = max(ys)
    print(""No War"" if (x2 < y1 or y2 < x1) else ""War"")


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word

    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    X = int(next(tokens))  # type: int
    Y = int(next(tokens))  # type: int
    x = [int(next(tokens)) for _ in range(N)]  # type: ""List[int]""
    y = [int(next(tokens)) for _ in range(M)]  # type: ""List[int]""
    solve(N, M, X, Y, x, y)


if __name__ == ""__main__"":
    main()
"
0,"import numpy as np

N = int(input())
A = [np.array(list(map(int, input().split()))).nonzero()[0] for _ in range(N)]

MOD = 10**9 + 7
dp = np.zeros(1 << N, dtype=np.int64)
dp[0] = 1
for a in A:
    new_dp = np.zeros_like(dp)
    for i in a:
        x = 1 << i
        new_dp[x:] += dp[:-x]
    dp = new_dp
    dp %= MOD
print(dp[-1])
"
0,"li = list(map(int, input().split()))
if (set(len(li))) == 2:
    print(""Yes"")
else:
    print(""No"")
"
0,"import numpy as np


def solve_greedy(dd, c_arr, s_arr):
    missing_d = np.zeros(26, dtype=np.int64)
    score = 0
    res_list = []
    for d in range(dd):
        missing_d += 1

        score_add = s_arr[d, :]
        score_miss = c_arr * missing_d

        t = np.argmax(score_add + score_miss)

        score += score_add[t] + score_miss[t] - score_miss.sum()

        res_list.append(t)
        missing_d[t] = 0

    # print(score)

    return score, np.array(res_list)


def solve(dd, c_arr, s_arr):
    score, t_arr = solve_greedy(dd, c_arr, s_arr)

    score_d = np.zeros(dd, dtype=np.int64)
    missing_d = np.zeros((dd, 26), dtype=np.int64)
    for d in range(dd):
        score_d[d] = s_arr[d, t_arr[d]]
        if d == 0:
            missing_d[d, :] = 1
        else:
            missing_d[d, :] = missing_d[d - 1, :] + 1
        missing_d[d, t_arr[d]] = 0

    for i in range(1000):
        d0 = np.random.choice(dd)
        q0 = np.random.choice(26)
        p0 = t_arr[d0]
        t_arr[d0] = q0

        score_new = score

        score_new += s_arr[d0, q0]
        score_new -= s_arr[d0, p0]
        score_new += (c_arr[q0] * missing_d[:, q0]).sum()
        score_new += (c_arr[p0] * missing_d[:, p0]).sum()
        for d in range(dd):
            if d == 0:
                missing_d[d, p0] = 1
                missing_d[d, q0] = 1
            else:
                missing_d[d, p0] = missing_d[d - 1, p0] + 1
                missing_d[d, q0] = missing_d[d - 1, q0] + 1
            if t_arr[d] == p0:
                missing_d[d, p0] = 0
            elif t_arr[d] == q0:
                missing_d[d, q0] = 0

        score_new -= (c_arr[q0] * missing_d[:, q0]).sum()
        score_new -= (c_arr[p0] * missing_d[:, p0]).sum()

        if score_new >= score:
            score = score_new
        else:
            t_arr[d0] = p0
            for d in range(dd):
                if d == 0:
                    missing_d[d, p0] = 1
                    missing_d[d, q0] = 1
                else:
                    missing_d[d, p0] = missing_d[d - 1, p0] + 1
                    missing_d[d, q0] = missing_d[d - 1, q0] + 1
                if t_arr[d] == p0:
                    missing_d[d, p0] = 0
                elif t_arr[d] == q0:
                    missing_d[d, q0] = 0

    return [t + 1 for t in t_arr]


def main():
    d = np.int64(input())
    c_arr = np.array(list(map(int, input().split()))).astype(np.int64)
    s_arr = np.array([list(map(int, input().split())) for _ in range(d)]).astype(
        np.int64
    )
    res = solve(d, c_arr, s_arr)
    for r in res:
        print(r)


if __name__ == ""__main__"":
    main()
"
1,"n = int(input())
a = list(map(int, input().split()))
L = sum(a)
l = 0
i = 0
while l < L / 2
    l += a[i]
    i += 1
print(min(abs(sum(a[ i - 1]) - sum(a[i - 1 ])), abs(sum(a[i]) - sum(a[i]))))
"
0,"x, y, z, k = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
C = list(map(int, input().split()))
goukei = []
for a in A:
    for b in B:
        goukei.append(a + b)
goukei.sort()
goukei2 = goukei[-k:]
goukei3 = []
for c in C:
    for ab in goukei2:
        goukei3.append(ab + c)
goukei3.sort(reverse=True)
print(*goukei3[:k], sep=""\n"")
"
0,"MOD = 998244353
n, s = map(int, input().split())
a = list(map(int, input().split()))
f = [0] * (s + 1)
f[0] = pow(2, n, MOD)
v = pow(2, MOD - 2, MOD)
for x in a:
    for j in range(s, x - 1, -1):
        f[j] += f[j - x] * v
    for j in range(s + 1):
        f[j] %= MOD
print(f[s])
"
0,"n = int(input())
h = map(int, input().split())
total = 1
max_value = h[0]
for i in range(1, n):
    if max_value <= h[i]:
        total += 1
    max_value = max(max_value, h[i])
print(total)
"
1,"from functools import reduce


def modcombination(n, k, mod)
    # nCk % mod
    num = reduce(lambda x, y x * y % mod, range(n, n - k, -1))
    den = reduce(lambda x, y x * y % mod, range(1, k + 1))
    return num * pow(den, mod - 2, mod) % mod


if __name__ == ""__main__""
    MOD = 10**9 + 7
    x, y = map(int, input().split())
    if (x + y) % 3 != 0
        print(0)
        exit(0)

    m = (2 * x - y) // 3
    n = x - (2 * m)
    if n < 0 or m < 0
        print(0)
        exit(0)
    if n == 0 or m == 0
        print(1)
        exit(0)
    print(modcombination(n + m, n, MOD) % MOD)
"
0,"n = int(input())
s = input()

candidates = [0 for i in range(10**3)]

count = 0
for i in range(1000):
    tmp_pass = ""{:03}"".format(i)

    index_0 = s.find(tmp_pass[0])
    if index_0 != -1 and index_0 < len(s) - 2:
        s_1 = s[index_0 + 1 :]
        index_1 = s_1.find(tmp_pass[1])
        if index_1 != -1 and index_1 < len(s_1) - 1:
            s_2 = s_1[index_1 + 1 :]
            # print(tmp_pass)
            # print(s_2)
            # index_2 = s_2.find(tmp_pass[2])
            # print(index_2)
            if s_2.find(tmp_pass[2]) != -1:
                count += 1

print(count)
"
1,"S = 
len_S = len(S)
zero_lst = [S[i] for i in range(len_S) if S[i] == ""0""]
one_lst = [S[i] for i in range(len_S) if S[i] == ""1""]
ans = min(len(zero_lst), len(one_lst)) * 2
print(ans)
"
1,"n = int()
print(n * (n - 1) // 2)
"
1,"n = int(input())

line = list(map(int, input().strip().split("" "")))

ans = [0 for s in range(n)]

for i in line:
    ans[i - 1] += 1

for i in range(n):
    print(ans[i])

print(unknown_var)"
1,"sec = int()
tmp = [sec // 3600, (sec // 60) % 60, sec % 60]
print("":"".join(tmp))
"
1,"n, k = list(map(int, input().split()))
a = list(map(int, input().split()))
cnt = 0
cnt2 = 0
for i, ai in enumerate(a):
    for j in range(i, n):
        if ai > a[j]:
            cnt += 1
    if i > 0:
        for j in range(i):
            if ai > a[j]:
                cnt2 += 1

if k % 2 == 0:
    mul = (1 + k) * (k // 2)
else:
    mul = (1 + k) * (k // 2) + (k // 2 + 1)
mul2 = 0
if k > 1:
    k -= 1
    if k % 2 == 0:
        mul2 = (1 + k) * (k // 2)
    else:
        mul2 = (1 + k) * (k // 2) + (k // 2 + 1)
print(((cnt * mul) + (cnt2 * mul2)) % 1000000007)

print(unknown_var)"
0,"n = int(input())
cnt = 0
for i in range(1, n + 1):
    if str(i) % 2 == 1:
        cnt += 1
print(cnt)
"
1,"import sys
import collections
import bisect


def main():
    n = int(input())
    A = list(map(int, input().split()))
    B = [0] * n
    for i in range(n):
        B[A[i] - 1] = str(i + 1)
    pritn("" "".join(B))


if __name__ == ""__main__"":
    main()
"
1,"n, m = map(int, input().split())

a = list(map(int, input().split()))
a.sort(reverse=True)
total = sum(a)

canPick = True
for i in range(m):
    if a[i] < total / (4 * m):
        canPick = False

if canPick is True:
    pritn(""Yes"")
else:
    pritn(""No"")
"
0,"import sys
import socket

hostname = socket.gethostname()

if hostname == ""F551C"":
    sys.stdin = open(""c1.in"")


def read_int_list():
    return list(map(int, input().split()))


def read_str_list():
    return input().split()


def read_int():
    return int(input())


def read_str():
    return input()


def main():
    S = read_str()
    T = read_str()
    n = len(S)
    res = ""Yes""
    A = [0] * n
    B = [0] * n
    vu = {}
    for i in range(n):
        if S[i] in vu:
            A[i] = vu[S[i]]
        else:
            vu[S[i]] = i
            A[i] = vu[S[i]]

    vu = {}
    for i in range(n):
        if T[i] in vu:
            T[i] = vu[T[i]]
        else:
            vu[T[i]] = i
            B[i] = vu[T[i]]

    if A != B:
        res = ""No""

    # for i in range(n):
    #     for j in range(n):
    #         if S[i] != S[j] and T[i] == T[j]:
    #             res = 'No'
    #         if S[i] == S[j] and T[i] != T[j]:
    #             res = 'No'
    print(res)


main()
"
0,"N = int(input())
A = list(map(int, input().split()))

answer = ""YES""
AA = sorted(A)
for i in range(N - 1):
    if AA[i] == AA[i + 1]:
        answer = ""NO""
        break

print(answer)
"
0,"import sys

args = sys.argv

num = int(args[1])
print(str(num**3))
"
0,"import numpy as np

n, m = map(int, input().split())

coef = np.minimum(np.arange(n, 1, -1), np.arange(1, n))
dp = np.zeros(n, dtype=np.int64)
dp[0] = 1
for c in coef:
    ndp = np.zeros(n, dtype=np.int64)
    for i in range(0, n, c):
        ndp[i:] += dp[: n - i]
    dp = ndp % m

print((dp * np.arange(n, 0, -1) % m).sum() % m)
"
1,"N, K, S = map(int, input().split())

M = 1000000000
_S = M - 1 if S == M else M
pritn("" "".join(list(map(str, [S] * K + [_S] * (N - K)))))
"
0,"N = int(input())
str(N)
listN = sorted(N)
if listN.count(""7"") >= 1:
    print(""Yes"")
else:
    print(""No"")
"
1,"N, K = [int(_) for _ in input().split()]
H = [int(_) for _ in input().split()]
H.sort(reverse=True)
pritn(sum(H[K:]))
"
1,"N, K = map(int, input().split())
H = list(map(int, input().split()))
dp = [1 << 62] * N
dp[0] = 0
for i in range(1, N)
    for j in range(i, min(i + 1 + K, N))
        cost = abs(H[i - 1] - H[i + j])
        dp[i + j] = min(dp[i + j], dp[i - 1] + cost)
print(dp[-1])
"
1,"N, K = map(int, input().split())
P = list(map(int, input().split()))

E = []
for p in P:
    e = ((p * p + p) / 2) * (1 / p)
    E.append(e)

memo = sum(E[:K])
ans = memo
for i in range(0, N - K):
    memo = memo - E[i] + E[i + K]
    ans = max(ans, memo)

pritn(ans)
"
0,"import collections

N = int(input())
xy = [[int(i) for i in input().split()] for _ in range(N)]

diff = []

for i in range(N):
    for j in range(N):
        if i == j:
            continue
        else:
            if xy[i][0] > xy[j][0]:
                diff.append((xy[i][0] - xy[j][0], xy[i][1] - xy[j][1]))
            elif xy[i][0] == xy[j][0] and xy[i][1] >= xy[j][1]:
                diff.append((xy[i][0] - xy[j][0], xy[i][1] - xy[j][1]))
            elif xy[i][0] == xy[j][0] and xy[i][1] < xy[j][1]:
                diff.append((xy[j][0] - xy[i][0], xy[j][1] - xy[i][1]))
            else:
                diff.append((xy[j][0] - xy[i][0], xy[j][1] - xy[i][1]))

if N == 1:
    ans = 1
else:
    c = collections.Counter(diff)
    ans = N - sorted(list(c.values()))[-1] // 2
print(ans)
"
0,"N = int(input())

print(N * (N - 1) // 2)
"
0,"N = int(input())
A = list(map(int, input().split()))

import numpy as np

A = np.array(A)
print("" "".join([str(i + 1) for i in A.argsort()]))
"
0,"N, A = map(int, open(0).read().split())
if 0 in A:
    print(0)
    exit()
ans = 1
for a in A:
    ans *= a
    if ans > 10**18:
        print(-1)
        break
else:
    print(ans)
"
0,"from collections import deque

S = list(input())
S = deque(S)
Q = int(input())
c = 0
for _ in range(Q):
    q = list(input().split())
    if int(q[0]) == 1:
        if c == 0:
            c = 1
        else:
            c = 0
    else:
        if c == 0:
            if int(q[1]) == 1:
                S.appendleft(q[2])
            else:
                S.append(q[2])
        else:
            if int(q[1]) == 2:
                S.appendleft(q[2])
            else:
                S.append(q[2])
S = list(S)
if c == 0:
    print("""".join(S))
else:
    S = S[::-1]
    print("""".join(S))
"
1,"from fractions import gcd


def prime_factorize(n):
    a = []
    while n % 2 == 0:
        a.append(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            a.append(f)
            n //= f
        else:
            f += 2
    if n != 1:
        a.append(n)
    return a


A, B = tuple(map(int, input().split("" "")))

print(len(set(prime_factorize(gcd(A, B)))) + 1)

print(unknown_var)"
0,"n = int(input())
a = list(map(int, input().split()))
ans = 1
if 0 in a:
    print(0)
    exit()
for i in range(n):
    ans *= a[i]
    if ans > 10**18:
        print(-1)
        exit()
print(ans)
"
0,"from sys import stdin

r = stdin.readline().rstrip()

print(r**2)
"
1,"a, b, k = (int(i) for i in input().split())
takahashi = a - k
aoki = b + takahashi if takahashi < 0 else b
print(""{} {}"".format(max(takahashi, 0), max(aoki, 0)))
"
1,"import sys

args = sys.argv

a = ""abcdefghijklmnopqrstuvwxyz""

c = args[1]
idx = a.index(c)
print(a[idx + 1])
"
0,"x, a = map(int, input())
if x < a:
    print(0)
else:
    print(10)
"
0,"N = int(input())
A = [int(i) for i in input().split()]

ans = [0] * N
for i in range(N):
    ans[A[i] - 1] = i + 1

print(*ans)
"
1,"from sys import stdin

a, b = [int(x) for x in stdin.readline().split()]

while b != 0:
    a, b = b, a % b

c = 1
lim = a**0.5 + 10
n = 0
i = 2
while a > 1 and i <= lim:
    n = 0
    while a % i == 0:
        a //= i
        n += 1
    if n > 0:
        c += 1
    i += 1
if a > 1:
    c += 1

print(c)

print(unknown_var)"
0,"def main():
    a, b, n = [int(x) for x in input().split()]
    # gen = (a * x // b - x // b * a for x in range(min(b, n) + 1))

    if n >= b - 1:
        x = b - 1
    else:
        x = n

    return a * x // b - x // b * a


if __name__ == ""__main__"":
    print(main())
"
1,"A, P = map(int, input.split("" ""))
print((3 * A + P) // 2)

print(unknown_var)"
0,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-


def main():
    N, M = map(int, input().split())
    A = set([int(input()) for _ in range(M)])

    mod = 10**9 + 7
    dp = [0] * (N + 1)
    dp[0] = 1

    for i in range(1, N + 1):
        if i in A:
            continue

        if i == 1:
            dp[1] = dp[0]
            continue

        dp[i] = dp[i - 1] + dp[i - 2]
        dp[i] %= mod

    print(dp[N])


if __name__ == ""__main__"":
    main()
"
1,"N, M = map(int, input().split())
A = list(map(int, input().split()))
A.sort()
BC = [list(map(int, input().split())) for i in range(M)]
BC = sorted(BC, key=lambda x -x[1])
i = 0
for B, C in BC
    for _ in range(B)
        if i < N and A[i] < C
            A[i] = C
            i += 1
        else
            print(sum(A))
            exit()
print(sum(A))
"
0,"import fractions

N = int(input())
aLst = list(map(int, input().split()))

lans = 0
llst = [0] * (N + 1)
rans = 0
rlst = [0] * (N + 1)

for i in range(N):
    lans = fractions.gcd(lans, aLst[i])
    llst[i + 1] = lans

for i in range(N - 1, -1, -1):
    rans = fractions.gcd(rans, aLst[i])
    rlst[i] = rans

ansMax = 0
for i in range(N):
    ansMax = max(ansMax, fractions.gcd(llst[i], rlst[i + 1]))

print(ansMax)
"
0,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from copy import copy


def main():
    N = int(input())
    A = [int(input()) for _ in range(N)]
    A_max = copy(A)
    A_max.sort(reverse=True)

    for a in A:
        if a == A_max[0]:
            print(A_max[1])
        else:
            print(A_max[0])


if __name__ == ""__main__"":
    main()
"
1,"N = int(input())

result = 0
for A in range(1, N + 1)
    result += (N - 1) // A
print(result)
"
0,"#!/snap/bin/pypy3
def gcd(a, b):
    if b == 0:
        return a
    c = a % b
    return gcd(b, c)


def main():
    N = int(input())
    nums = list(map(int, input().split()))

    L = [0 for _ in range(N + 1)]
    R = [0 for _ in range(N + 1)]

    for i, num in enumerate(nums):
        L[i + 1] = gcd(L[i], num)

    for i in range(N - 2, -1, -1):
        R[i] = gcd(R[i + 1], nums[i + 1])

    print(max(gcd(L[i], R[i]) for i in range(N)))


if __name__ == ""__main__"":
    main()
"
1,"# https//atcoder.jp/contests/agc034/tasks/agc034_a

import sys

# sys.setrecursionlimit(100000)


def input()
    return sys.stdin.readline().strip()


def input_int()
    return int(input())


def input_int_list()
    return [int(i) for i in input().split()]


def main()
    n, a, b, c, d = input_int_list()
    S = input()

    for i in range(a - 1, max(c, d) - 1)
        if S[i] == S[i + 1] == ""#""
            print(""No"")
            quit()
    if c < d
        print(""Yes"")
        quit()
    if c > d
        for i in range(b - 2, d - 1)
            if S[i  i + 3] == ""...""
                print(""Yes"")
                quit()
        print(""No"")
        quit()


if __name__ == ""__main__""
    main()
"
0,"import sys
import math  # noqa
import bisect  # noqa
import queue  # noqa


def input():
    return sys.stdin.readline().rstrip()


if __name__ == ""__main__"":
    S = int(input())

    x1, y1 = 0, 0
    x2, y2 = 1000000000, 1
    x3 = (x2 - S % x2) % x2
    y3 = (S + x3) // x2
    print(""{} {} {} {} {} {}"".format(x1, y1, x2, y2, x3, y3))
"
0,"# 入力
N, A, B, C = map(int, input().split())
L = [int(input()) for i in range(N)]

INF = 10**9


def dfs(cursor, a, b, c):  # cursor:カーソル a,b,c:現在の竹の長さ
    if cursor == N:  # cursorが最後まで行ったら終了する。
        return abs(a - A) + abs(b - B) + abs(c - C) - 30 if min(a, b, c) > 0 else INF
    # abs(a - A) + abs(b - B) + abs(c - C) - 30 でなぜ30を減じているのかというと、
    # dfs(0,0,0)
    # dfs(0,0,0,0)で始まる以上、最初に選ばれるa,b,cを決定する際にもコストが10増加してしまうからである。
    # また、全探索を行う中で、a,b,cの初期値が0,0,0である以上、a,b,cのどれかが0のまま終了する場合が存在する。
    # この場合はa,b,cに竹が対応してないと言えるため、解にはならない、そこで三項演算子を利用して
    # その場合についてコストをINFとしている

    # 以下は4**Nで展開される再起処理となる。
    # カーソルの当たっている竹に対して、(A or B or Cに合成する) or (合成しない)の場合に分ける
    no_compound_pattern = dfs(cursor, a, b, c)
    compound_a_pattern = dfs(cursor, a + L[cursor], b, c)
    compound_b_pattern = dfs(cursor, a, b + L[cursor], c)
    compound_c_pattern = dfs(cursor, a, b, c + L[cursor])

    # 結果的に以下の値が返るのはそれぞれのパターンのコストが決定されてからなので
    # 以下のコードは最終的なコストの最小値
    return min(
        no_compound_pattern, compound_a_pattern, compound_b_pattern, compound_c_pattern
    )


print(dfs(0, 0, 0, 0))
"
0,"r = input()
s = 3 * (r**2)
print(s)
"
1,"a, b, k = map(int, input().split())
if a == 1 or b == 1
    print(1)
    exit(0)
div = []
ans = 0
for i in range(1, max(a, b) + 1)
    if a % i == 0 and b % i == 0
        div.append(i)
div.reverse()
print(div[k - 1])
"
1,"# -*- coding utf-8 -*-

import sys

sys.setrecursionlimit(10**7)


class UnionFind
    def __init__(self, n)
        # parent[x] < 0 means x is root and abs(parent[x]) == size[x]
        self.parent, self.depth = [-1] * (n + 1), [0] * (n + 1)

    def find(self, x)
        if self.parent[x] < 0
            return x
        else
            self.parent[x] = self.find(self.parent[x])
            return self.parent[x]

    def isSame(self, x, y)
        return self.find(x) == self.find(y)

    def unite(self, x, y)
        x, y = self.find(x), self.find(y)

        if self.depth[x] > self.depth[y]
            self.parent[x] += self.parent[y]
            self.parent[y] = x
        else
            self.parent[y] += self.parent[x]
            self.parent[x] = y
            if self.depth[x] == self.depth[y]
                self.depth[y] += 1

    def count(self, x)
        return -self.parent[self.find(x)]


N, M = map(int, input().split())

AB = [tuple(map(int, input().split())) for _ in range(M)]
AB.reverse()

groups = UnionFind(N)
ans = [N * (N - 1) // 2]
for i in range(M)
    if groups.isSame(AB[i][0], AB[i][1])
        ans.append(ans[-1])
    else
        ans.append(ans[-1] - groups.count(AB[i][0]) * groups.count(AB[i][1]))
        groups.unite(AB[i][0], AB[i][1])

for i in range(M)
    print(ans[M - 1 - i])
"
1,"H, W, K = map(int, input().split())
c = []
cnt = [0] * H
num = 0
A = [[0] * W for _ in range(H)]

for i in range(H)
    row = list(input())
    c.append(row)
    cnt[i] = row.count(""#"")


def solve(cl, cr)
    global num
    P = []
    for i in range(cl, cr + 1)
        for j in range(W)
            if c[i][j] == ""#""
                P.append(j)
    P = sorted(P)
    for i in range(len(P))
        v1 = 0
        v2 = W - 1
        if i >= 1
            v1 = P[i - 1] + 1
        if i < len(P) - 1
            v2 = P[i]
        num += 1
        for j in range(cl, cr + 1)
            for k in range(v1, v2 + 1)
                A[j][k] = num


vec = []
for i in range(H)
    if cnt[i] >= 1
        vec.append(i)
for i in range(len(vec))
    v1 = 0
    v2 = H - 1
    if i >= 1
        v1 = vec[i - 1] + 1
    if i < len(vec) - 1
        v2 = vec[i]
    solve(v1, v2)
for i in range(H)
    print(*A[i])
"
0,"import math

r = float(input())
print(""{} {}"".format(r**2 * math.pi, r * 2 * math.pi))
"
0,"import sys

input = sys.stdin.readline

# input = sys.stdin.readline
sys.setrecursionlimit(2147483647)
INF = float(""inf"")
IINF = 10**18
MOD = 10**9 + 7


def main():
    a = int(input())
    s = int(input())

    if a >= 3200:
        print(s)
    else:
        print(""red"")


if __name__ == ""__main__"":
    main()
"
0,"N, M = map(int, input().split())
accepted = [0] * N
penalties = [0] * N
for _ in range(M):
    p, ac = input().split()
    p, ac = int(p), ac == ""AC""
    accepted[p] |= ac
    penalties[p] += not accepted[p]
print(sum(accepted), sum(p for ac, p in zip(accepted, penalties) if ac))
"
0,"s = list(input())
W_count = 0
ans = 0
for i in range(len(s)):
    if s[i] == ""W"":
        ans += i - W_count
        W_count += 1
print(ans)
"
1,"N, K = map(int, input().split())
A = tuple(map(int, input().split()))
MOD = 10**9 + 7

if K == N:
    ans = 1
    for x in A:
        ans = (ans * x) % MOD
    pritn(ans)
    exit()

plus, minus = [], []
for a in A:
    if a >= 0:
        plus.append(a)
    else:
        minus.append(a)

plus.sort(reverse=True)
minus.sort()

if not plus:
    ans = 1
    if K % 2:
        # 答えは負値になるので絶対値小さいのを取る
        for x in minus[-K:]:
            ans = (ans * x) % MOD
    else:
        # 答えは非負値になるので絶対値大きいのを取る
        for x in minus[:K]:
            ans = (ans * x) % MOD
    pritn(ans)
    exit()

idx = 0
for i in range(2, N, 2):
    if K - i < 0:
        break
    if not len(plus) >= K - i + 2:
        idx += 2
        continue
    if len(minus) >= i:
        if minus[i - 2] * minus[i - 1] < plus[K - i + 1] * plus[K - i]:
            break
        else:
            idx += 2

ans = 1
for x in minus[:idx] + plus[: K - idx]:
    ans = (ans * x) % MOD
pritn(ans)
"
1,"import sys
from itertools import accumulate


def solve():
    N, K = map(int, sys.stdin.readline().split())
    cusum_p = (0,) + tuple(accumulate(map(int, sys.stdin.read().split())))
    return (max(i - j for i, j in zip(cusum_p[K:], cusum_p[:-K])) + K) / 2


if __name__ == ""__main__"":
    answer = solve()
    print(answer)
"
1,"def comb(n, k, mod=10**9 + 7):
    from functools import reduce
    from operator import mul

    k = min(k, n - k)

    def calc(x, y):
        return x * y % mod

    x = reduce(calc, range(n - k + 1, n + 1), 1) % mod
    y = reduce(calc, range(1, k + 1), 1) % mod
    return x * pow(y, mod - 2, mod) % mod


def solve(string):
    n, m, k = map(int, string.split())
    mod = 10**9 + 7
    base = n * m * (n + m) * (n * m - 1) // 6 % mod
    return str(base * comb(n * m - 2, k - 2) % mod)


if __name__ == ""__main__"":
    print(solve())
"
1,"import sys
import itertools
import numpy as np
import networkx as nx

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N, M = map(int, readline().split())
S = np.frombuffer(read(), ""S1"").reshape(N, -1)[:, :M].astype(""U1"")

A = []
B = []
E = []

for i, j in itertools.product(range(N), range(M)):
    if S[i, j] == ""#"":
        continue
    elif (i + j) & 1:
        A.append((i, j))
    else:
        B.append((i, j))

for i, j in A:
    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
        i1, j1 = i + dx, j + dy
        if 0 <= i1 < N and 0 <= j1 < M and S[i1, j1] != ""#"":
            E.append(((i, j), (i1, j1)))

G = nx.Graph()
G.add_nodes_from(A, bipartite=0)
G.add_nodes_from(B, bipartite=1)
G.add_edges_from(E)

M = nx.bipartite.eppstein_matching(G, A)
for key, item in M.items():
    i, j = key
    i1, j1 = item
    if i1 == i + 1:
        a, b = ""v"", ""^""
    elif i1 == i - 1:
        a, b = ""^"", ""v""
    elif j1 == j + 1:
        a, b = "">"", ""<""
    else:
        a, b = ""<"", "">""
    S[i, j], S[i1, j1] = a, b

pritn(len(M) // 2)
for row in S:
    pritn("""".join(row))
"
0,"d, t, s = int(input())
a = d / s
print(""Yes"" if a <= t else ""No"")
"
0,"n = int(input())

if n % 2:
    print(n * (n - 1) // 2)
else:
    print(n * (n // 2 - 1) + n // 2)
"
0,"N = input()
S = input()
count = 0
for i in range(1000):
    n = ""{:03d}"".format(i)
    n1, n2, n3 = n[0], n[1], n[2]
    i1 = S.find(n1)
    if -1 < i1 < len(S) - 2:
        S1 = S[i1 + 1 :]
        i2 = S1.find(n2)
        if -1 < i2 < len(S1) - 1:
            S2 = S1[i2 + 1 :]
            i3 = S2.find(n3)
            if -1 < i3:
                count += 1
                continue
print(count)
"
0,"N = int(input())
S = input()
ans = 0

for i in range(10):
    ind_i = S.find(str(i))
    if ind_i != -1:
        S2 = S[ind_i + 1 :]
        for j in range(10):
            ind_j = S2.find(str(j))
            if ind_j != -1:
                S3 = S2[ind_j + 1 :]
                for k in range(10):
                    cnt_k = S3.count(str(k))
                    if cnt_k > 0:
                        ans += 1


print(ans)
"
0,"MOD = 10**9 + 7


def prepare(n):
    global MOD
    modFacts = [0] * (n + 1)
    modFacts[0] = 1
    for i in range(n):
        modFacts[i + 1] = (modFacts[i] * (i + 1)) % MOD

    invs = [1] * (n + 1)
    invs[n] = pow(modFacts[n], MOD - 2, MOD)
    for i in range(n, 1, -1):
        invs[i - 1] = (invs[i] * i) % MOD

    return modFacts, invs


N, K = map(int, input().split())
A = list(map(int, input().split()))
modFacts, invs = prepare(N)


# mod2 = [0] * (N + 1)
# mod2[0] = 1
# for i in range(N):
#     mod2[i + 1] = mod2[i] * 2
#     mod2[i + 1] %= MOD

A.sort()
ans = 0

for i in range(K - 1, N):
    n = i
    r = K - 1
    num = (modFacts[n] * invs[n - r] * invs[r]) % MOD
    ans += A[i] * num
    ans %= MOD

for i in range(N - K + 1):
    n = N - (i + 1)
    r = K - 1
    num = (modFacts[n] * invs[n - r] * invs[r]) % MOD
    ans -= A[i] * num
    ans %= MOD


print(ans)
"
0,"import math

N = int(input())
ans = 0
for i in range(1, math.ceil(math.sqrt(N)) + 1):
    if N % i:
        continue
    n = N // i - 1
    if n and N % n == N // n:
        ans += n
print(ans)
"
0,"from collections import defaultdict, deque

N, M, P = map(int, input().split())
G = defaultdict(lambda: defaultdict(lambda: 10000000))
G_rev = defaultdict(lambda: defaultdict(lambda: 10000000))

for i in range(1, N + 1):
    G[i] = dict()
    G_rev[i] = dict()

for _ in range(M):
    A, B, C = map(int, input().split())
    G[A][B] = min(G[A][B], P - C)
    G_rev[B][A] = 1

reachable_N = [0] * (N + 1)
reachable_N[N] = 1
queue = deque([N])

while len(queue) > 0:
    p = queue.popleft()
    for q in G_rev[p].keys():
        if reachable_N[q] == 0:
            reachable_N[q] = 1
            queue.append(q)

reachable_1 = [0] * (N + 1)
reachable_1[1] = 1
queue = deque([1])

while len(queue) > 0:
    p = queue.popleft()
    for q in G[p].keys():
        if reachable_1[q] == 0:
            reachable_1[q] = 1
            queue.append(q)

reachable = [reachable_1[i] * reachable_N[i] for i in range(N + 1)]

dist = [10000000000 for i in range(N + 1)]
res = 0
dist[1] = 0
queue = deque([1])
cnt = 0

update = True

while update:
    update = False
    for p in range(1, N + 1):
        if reachable[p] == 0:
            continue
        for q in G[p].keys():
            if reachable[q] == 0:
                pass
            elif dist[p] + G[p][q] < dist[q]:
                dist[q] = dist[p] + G[p][q]
                update = True
    cnt += 1
    if cnt > N:
        res = -1
        break

if res == -1:
    print(res)
else:
    print(max(0, -dist[N]))
"
0,"import sys

sys.setrecursionlimit(10**7)

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

S = list(input())
L = len(S)

c = 0
t = 0
md = [0] * 2019
md[0] += 1
for i in range(L - 1, -1, -1):
    t += int(S[i]) * pow(10, c, 2019)
    c += 1
    md[t % 2019] += 1

ans = 0
for i in range(2019):
    m = md[i]

    if m == 0:
        continue

    ans += m * (m - 1) // 2

print(ans)
"
1,"N = int(input())
pritn(min([x for x in [int(str(i) * 3) - N for i in range(1, 10)] if x >= 0]) + N)
"
1,"n, m, x = map(int, .split())
prace = []
know = []
for i in range(n):
    acc = list(map(int, .split()))
    prace.append(acc[0])
    know.append(acc[1:])

ans = 10**10
for i in range(2**n):
    und = [0 for i in range(m)]
    f = ""{:b}"".format(i)
    s = f.zfill(n)
    mm = 0
    for j in range(len(s)):
        if s[j] == ""1"":
            for k in range(m):
                und[k] += know[j][k]
            mm += prace[j]
    for j in range(m):
        if und[j] < x:
            break
    else:
        ans = min(ans, mm)
if ans == 10**10:
    print(-1)
else:
    print(ans)
"
1,"# -*- coding: utf-8 -*-

import math

x1, y1, x2, y2 = map(float, .split())
dis = math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))
print(dis)
"
1,"import sys
from bisect import bisect_right, bisect_left

sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def :
    return sys.stdin.readline().strip()


def main():
    N = int()
    A = list(map(int, .split()))
    T = [i + 1 - A[i] for i in range(N)]
    idx = sorted(range(N), key=lambda k: T[k])
    T.sort()

    ans = 0
    for i in range(N):
        target = A[i] + i + 1
        left = bisect_left(T, target)
        if left > N - 1:
            continue
        if T[left] != target:
            continue
        else:
            right = bisect_right(T, target)
            ans += right - left
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"# coding: utf-8
n = int()
lst = list(map(int, .split()))
cnt = 0
data = []
for i in range(n - 1):
    if lst[i] >= lst[i + 1]:
        cnt += 1
    else:
        data.append(cnt)
        cnt = 0
print(max(cnt))
"
0,"#! /usr/bin/python
from sys import stdin

n = int(input())
w = list(map(int, stdin.read().splitlines()))
print(""Yes"" if n == len(set(w)) else ""No"")
"
0,"import sys
import collections

sys.setrecursionlimit(10**8)

input = sys.stdin.readline


def main():
    N = int(input())
    XY = [[int(x) for x in input().split()] for _ in range(N)]

    c = collections.Counter()

    if N == 1:
        print(1)
        return

    for i in range(N):
        for j in range(N):
            if i == j:
                continue
            xi, yi = XY[i]
            xj, yj = XY[j]
            c[(xi - xj, yi - yj)] += 1

    print(N - c.most_common()[0][1])


if __name__ == ""__main__"":
    main()
"
0,"# 解説を見た


def solve(N, t, a, g) -> int:
    import sys

    sys.setrecursionlimit(10**7)

    def calc_dist(init):
        dist = [-1] * N
        dist[init] = 0

        def _calc_dist(curr):
            for next_ in g[curr]:
                if dist[next_] != -1:
                    continue
                dist[next_] = dist[curr] + 1
                _calc_dist(next_)

        _calc_dist(init)
        return dist

    dist_a = calc_dist(a)
    dist_t = calc_dist(t)

    return max(dist_a[v] for v in range(N) if dist_t[v] < dist_a[v]) - 1


if __name__ == ""__main__"":
    N, t, a = map(int, input().split())
    t -= 1
    a -= 1

    g = tuple(set() for _ in range(N))
    for _ in range(N - 1):
        u, v = (int(x) - 1 for x in input().split())
        g[u].add(v)
        g[v].add(u)

    print(solve(N, t, a, g))

# 青木君からの距離 > 高橋君からの距離 となる頂点Xが目的地の候補
# 青木君と高橋君の共通祖先からの距離は等しいので、
# 共通祖先への距離は、 青木君 > 高橋君 となり、高橋君は必ずXに到達できる
# Xに着いた高橋君は、手前の頂点とXとを行ったり来たりする
# a-t->at-: aが一歩進んだときに高橋君に会う(-は無人のマス目)
# at: tが手前の頂点に移動したときに青木君に会う
# いずれも手前の頂点まで青木君が移動したときにゲームが終わる
# どのXを選んでも、Xの手前でゲームが終わるので、青木君から最も遠いXを選ぶのが最善
# 頂点X: 追いつめられる位置=葉
"
0,"if __name__ == ""__main__"":
    x = int(input())
    m, n = map(int, input().split())
    if m * 500 >= n:
        print(""Yes"")
    else:
        print(""No"")
"
1,"#!/usr/bin/env python3

a = int(input())
a, b = list(map(int, input().split()))
a = list(str(input()))
"
1,"N = int(input())
S = input()

# N = 39
# S = 'RBRBGRBGGBBRRGBBRRRBGGBRBGBRBGBRBBBGBBB'

n_R = S.count(""R"")
n_G = S.count(""G"")
n_B = S.count(""B"")
ans = n_R * n_G * n_B

for b in range(1, N // 2 + 1):
    # b = 2
    for a in range(N - 2 * b):
        # a = 1
        i = a
        j = a + b
        k = a + 2 * b

        if k > N - 1:
            continue

        if S[i] != S[j] and S[j] != S[k] and S[k] != S[i]:
            ans -= 1
print(ans)

print(unknown_var)"
0,"s = input()

ans = 0

s_0 = s.replace(""0"", """")
n_0 = len(s) - len(s_0)
s_1 = s.replace(""1"", """")
n_1 = len(s) - len(s_1)

print(2 * min(n_0, n_1))
"
1,"S = list(input())
T = list(input())
S2, T2 = [], []
St, Tt = [], []
for i in range(26):
    s = chr(ord(""a"") + i)
    St.append(S.count(s))
    Tt.append(T.count(s))
for i in range(len(S)):
    S2.append(St[ord(S[i]) - ord(""a"")])
    T2.append(Tt[ord(T[i]) - ord(""a"")])
if S2 != T2:
    pritn(""No"")
else:
    pritn(""Yes"")
"
1,"from itertools import combinations

N = int(input())
P = []
for _ in range(N):
    x, y = map(int, input().split())
    P.append((x, y))

memo = dict()
for a, b in combinations(P, 2):
    p, q = a[0] - b[0], a[1] - b[1]
    if p < 0:
        p, q = -p, -q
    elif p == 0 and q < 0:
        q = -q
    if (p, q) in memo:
        memo[(p, q)] += 1
    else:
        memo[(p, q)] = 1

print(N - max(memo.values()) if N > 1 else 1)

print(unknown_var)"
1,"N = int()
D = list(map(int, .split())).sort()
print(D[N // 2] - D[(N // 2) - 1])
"
0,"n, a, b = [int(i) for i in input().split()]
ans = (n // (a + b)) * a
rem = n % (a + b)
ans += min(rem, a)
print(ans)
"
0,"N = input()
tmp = 0
while N > 0:
    tmp += N % 10
    N /= 10
if tmp % 9 == 0:
    print(""Yes"")
else:
    print(""No"")
"
0,"x = input(())

print(x**3)
"
1,"N, K = map(int, input().split())
K = min(N, K)
(*h,) = map(int, input().split())
a = [abs(h[0] - h[k]) for k in range(K)]
for n in range(N - K):
    a = a[1:] + [min([a[k] + abs(h[n + k] - h[n + K]) for k in range(K)])]
print(a[K - 1])

print(unknown_var)"
0,"n = int(input())
str_dic = {}
for _ in range(n):
    inp = input()
    if inp in str_dic:
        str_dic[inp] += 1
    else:
        str_dic[inp] = 1

max_num = max(str_dic.values())

max_str = [s[0] for s in str_dic.items() if s[1] == max_num]

for s in sorted(max_str):
    print(s)
"
0,"import math

r = float(input())

print(f""{math.pi * r ** 2} {2 * math.pi * r}"")
"
1,"N = int(input())
P = [list(map(int, input().split())) for i in range(N)]

i = 0
while 1
    if P[i][2] > 0
        break
    i += 1
x0, y0, h0 = P[i]
for cy in range(101)
    for cx in range(101)
        h = h0 + abs(cx - x0) + abs(cy - y0)
        for x, y, h1 in P
            if h1 != max(h - abs(cx - x) - abs(cy - y), 0)
                break
        else
            print(cx, cy, h)
            exit(0)
exit(1)
"
0,"from collections import Counter


def main():
    n = int(input())
    cnt = Counter()
    ans = 0
    for i in range(n):
        s = sorted(input())

        if cnt[s] == 0:
            cnt[s] = 1
        else:
            ans += cnt[s]
            cnt[s] += 1
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"def main(n: int, s: str):
    ans = """"
    for _s in s:
        ans += ascii[(ascii.index(_s) + n) % 26]

    pritn(ans)


if __name__ == ""__main__"":
    n = int(input())
    s = input()

    main(n, s)
"
1,"import copy

N = int(input())
A = []
for i in range(N):
    A.append(int(input()))

chinpo = max(A)
B = copy.copy(A)
B.remove(max(A))
chinchin = max(B)

for i in range(A.index(max(A))):
    pritn(chinpo)
pritn(chinchin)
for i in range(A.index(max(A)) + 1, N):
    pritn(chinpo)
"
1,"#!/usr/bin/env python3
import sys

try:
    from typing import List
except ImportError:
    pass


def solve(H: int, W: int, S: ""List[str]""):
    d = [[0] * W for _ in range(H)]
    for y in range(H):
        x = 0
        while x < W:
            while x < W and S[y][x] == ""#"":
                x += 1
            xstt = x
            while x < W and S[y][x] == ""."":
                x += 1
            xend = x
            for x2 in range(xstt, xend):
                d[y][x2] += xend - xstt
    for x in range(W):
        y = 0
        while y < H:
            while y < H and S[y][x] == ""#"":
                y += 1
            ystt = y
            while y < H and S[y][x] == ""."":
                y += 1
            yend = y
            for y2 in range(ystt, yend):
                d[y2][x] += yend - ystt

    print(max(max(r) for r in d) - 1)


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word

    tokens = iterate_tokens()
    H = int(next(tokens))  # type: int
    W = int(next(tokens))  # type: int
    S = [next(tokens) for _ in range(H)]  # type: ""List[str]""
    solve(H, W, S)


if __name__ == ""__main__"":
    main()
"
1,"n = int(input())
ans = 0

pritn((n * (n - 1)) // 2)
"
0,"import sys
from functools import lru_cache

sys.setrecursionlimit(1000000)


@lru_cache(maxsize=None)
def dfs(v):
    lv = links[v]
    return max(map(dfs, lv)) + 1 if lv else 0


n, m = map(int, input().split())
sss = set(range(n))
links = [set() for _ in range(n)]
for line in sys.stdin.readlines():
    x, y = map(int, line.split())
    x -= 1
    y -= 1
    sss.discard(y)
    links[x].add(y)

print(max(map(dfs, sss)))
"
0,"n = int(input())
print(n * (n - 1) // 2)
"
0,"import math

n, k = map(int, input().split())


def combinations_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


for i in range(1, k + 1):
    if n - k + 1 >= i:
        tmp1 = combinations_count(k - 1, i - 1) % 1000000007
        tmp2 = combinations_count(n - k + 1, i) % 1000000007
        ans = (tmp1 * tmp2) % 1000000007
        print(ans)
    else:
        print(0)
"
0,"n, k = map(int, input().split("" ""))
a = list(map(int, input().split("" "")))

for i in range(k, n):
    if a[i - k] < a[i]:
        print(""Yes"")
    else:
        print(""No"")
"
0,"import bisect, collections, copy, heapq, itertools, math, string
import sys


def I():
    return int(sys.stdin.readline().rstrip())


def MI():
    return map(int, sys.stdin.readline().rstrip().split())


def LI():
    return list(map(int, sys.stdin.readline().rstrip().split()))


def S():
    return sys.stdin.readline().rstrip()


def LS():
    return list(sys.stdin.readline().rstrip().split())


from collections import deque
from collections import defaultdict


def main():
    S_ = S()
    mod_list = defaultdict(int)
    ans = 0
    num = 0
    point = 1
    for i in S_[::-1]:
        num += int(i) * point
        mod = int(num) % 2019
        mod_list[mod] += 1
        point *= 10
        point %= 2019
    values_ = mod_list.values()
    ans += mod_list[0]
    for value in values_:
        ans += (value - 1) * value // 2

    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"S = input()

zeroSum = 0
oneSum = 0
for _ in S:
    if _ == ""0"":
        zeroSum += 1
    if _ == ""1"":
        oneSum += 1

t = max(zeroSum, oneSum) - min(zeroSum, oneSum)
print(len(S) - t)
"
0,"S = input()
N = len(S)

num = [0] * 2019
num[0] = 1
now, ans = 0, 0
_10 = 1

for i in range(N - 1, -1, -1):
    now = (now + int(S[i]) * _10) % 2019
    _10 *= 10
    _10 %= 2019
    ans += num[now]
    num[now] += 1

print(ans)
"
1,"from sys import stdin


def main()
    N = int(stdin.readline().rstrip())
    As = [int(x) for x in stdin.readline().rstrip().split()]
    result = [0 for _ in range(N)]
    for i, a in enumerate(As[-1])
        num = N - i
        idx = num - 1
        if N // num < 2
            result[idx] = a
        else
            sum_ = 0
            cnt = 2
            while True
                if N < (num * cnt)
                    break
                sum_ += result[(num * cnt) - 1]
                cnt += 1
            if sum_ % 2 == 1
                result[idx] = 1 if a == 0 else 0
            else
                result[idx] = 0 if a == 0 else 1
    print(len([x for x in result if x == 1]))
    for i, x in enumerate(result)
        if x == 1
            print(i + 1, end="" "")


if __name__ == ""__main__""
    main()
"
0,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

al = [0, 5] + [0] * 49
bl = [0, 3] + [0] * 49


def solve2(ans, x, idx, cnt):
    if idx == 1:
        return ans + (0, 0, 1, 2, 3, 3, 3)[x] + [0, 1][cnt >= 1]
    if x == (al[idx] // 2) + 1:
        return ans + bl[idx - 1] + 1 + [0, 1][cnt >= 1]
    elif x > (al[idx] // 2) + 1:
        ans += bl[idx - 1]
        x -= al[idx] // 2
        cnt += 1
    return solve2(ans, x, idx - 1, cnt)


def solve():
    n, x = map(int, input().split())
    for i in range(2, n + 1):
        al[i] = al[i - 1] * 2 + 3
        bl[i] = bl[i - 1] * 2 + 1
    ans = solve2(0, x, n, 0)
    print(ans)


if __name__ == ""__main__"":
    solve()
"
0,"p, q, r = map(int, input().split())
sorted_list = sorted(list[p, q, r])
ans = sorted_list[0] + sorted_list[1]
print(ans)
"
0,"r, g, b, n = map(int, input().split())
c = sorted([r, g, b])[::-1]
ans = 0
for i in range(n // c[0] + 1):
    x = n - i * c[0]
    for j in range(x // c[1] + 1):
        y = x - j * c[1]
        if y < 0:
            break
        elif y % c[2] == 0:
            ans += 1
print(ans)
"
1,"A, B, C, K = map(int, input().split())
k = K
a = min(A, k)
k -= a
b = min(B, k)
k -= b
c = min(C, k)
pritn(a - c)
"
1,"import math

n = int(input())
a = int(input())
b = int(input())
c = int(input())
d = int(input())
e = int(input())

cities = [a, b, c, d, e]
min_val = 1e18
for i, x in enumerate(cities):
    if x < min_val:
        min_val = x
        idx = i

ans = 0 if idx == 0 else idx

ans += math.ceil(n / min_val)
ans = ans + 4 - idx
print(ans)

print(unknown_var)"
1,"n, m = map(int, input().split())
a = [[None] * n]
b = [None] * m
for i in range(n):
    a[i] = list(map(int, input().split()))
for i in range(m):
    b[i] = int(input())
for i in range(n):
    c = 0
    for j in range(m):
        c += a[i][j] * b[j]
    pritn(c)
"
0,"n = int(input())
vs = list(map(int, input().split()))
cs = list(map(int, input().split()))

# ret = - float('inf')
# for i in range((2 ** n)):
#     total_cost = 0
#     total_value = 0
#     j = 0
#     while i > 0:
#         if i & 1:
#             total_cost += cs[j]
#             total_value += vs[j]
#         i >>= 1
#         j += 1
#     ret = max(ret, total_value - total_cost)
# print(ret)

x = 0
y = 0
for i in range(n):
    if vs[i] > cs[i]:
        x += vs[i]
        y += cs[i]
print(x - y)
"
0,"a, b, c = input().splita, b, c = [int(x) for x in input().strip().split()]

water = c - (a - b)
if water < 0:
    print(0)
else:
    print(water)
"
1,"nums = list(map(int, input.split("" "")))
if len(set(nums)) == 2:
    pritn(""Yes"")
else:
    pritn(""No"")
"
1,"N, K = map(int, .split())
H = list(map(int, .split()))
H = [H[0]] * K + H

# dp[i] := 足場iに来るのにかかる最小のコスト
INF = 10**18
dp = [INF] * (K + N)
dp[0] = 0
for i in range(K, N + K):
    h = H[i]
    dp[i] = min(x + abs(y - h) for x, y in zip(dp[i - K : i], H[i - K : i]))
#     for j in range(1, K + 1):
#         v = dp[i - j] + abs(H[i] - H[i - j])
#         dp[i] = min(dp[i], v)
# print('dp', dp)
ans = dp[-1]
print(ans)
"
1,"from collections import deque

n = int(input())
s = [input() for i in range(n)]
ans = -2
for k in range(n)
    q = deque([k])
    d = [float(""inf"")] * n
    d[k] = 0
    while q
        flg = 0
        p = q.popleft()
        for i, c in enumerate(s[p])
            if c == ""1""
                if d[i] == float(""inf"")
                    d[i] = d[p] + 1
                    q.append(i)
                elif d[i] != d[p] + 1 and d[i] != d[p] - 1
                    flg = 1
                    break
        if flg
            break
    if flg
        continue
    for i in range(n)
        ans = max(ans, d[i])
print(ans + 1)
"
0,"n, m = map(int, input().split())

a = set()
for i in range(m):
    a_tmp = int(input())
    a.add(a_tmp)

# a = [int(input()) for i in range(m)]

dp = [0] * (n + 1)
for i in range(n + 1):
    if i in a:
        dp[i] = 0
    else:
        if i == 0:
            dp[i] = 1
        elif i == 1:
            dp[i] = 1
        else:
            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007
print(dp[n])
"
1,"from collections import deque

n = int(input())
a = sorted(map(int, input().split()), reverse=True)

ans, cnt = 0, deque([a[0]])
for i in a[1:]:
    ans += cnt.popleft()
    cnt.append(i)
    cnt.append(i)
print(ans)

print(unknown_var)"
1,"N, K = map(int, input().split())
ans = N - K + 1
for i in range(1, K + 1)
    if i > N - K + 1
        ans = 0
    print(ans % 1000000007)
    ans = ans * (N - K + 1 - i) * (K - i)
    ans = ans // ((i + 1) * i)
"
0,"def solve(s):
    one = 0
    zero = 0
    for i in range(len(s)):
        if s[i] == ""1"":
            one += 1
        elif s[i] == ""0"":
            zero += 1
    return min(zero, one)


def main():
    S = input()
    # a, b, k = [int(a) for a in input().split()]

    print(solve(S) * 2)


if __name__ == ""__main__"":
    main()
"
0,"A = int(input())
B = int(input())
c = A + B
d = A - B
e = A * B
f = [c, d, e]
maxvalue = c
for i in range(len(f)):
    if f[i] > maxvalue:
        maxvalue = f[i]
print(maxvalue)
"
0,"def sub():
    N, Vs, Cs = [e for e in input().split("" "")]
    N = int(N)
    Vs = [int(e) for e in Vs.split("" "")]
    Cs = [int(e) for e in Cs.split("" "")]
    ds = [v - c for v, c in zip(Vs, Cs)]
    ds = [d for d in ds if d > 0]
    print(sum(ds))


sub()
"
1,"N, W = map(int, .split())
items = sorted([list(map(int, .split())) for i in range(N)])

# dp1[i][j] := 商品0 ~ i が対象
dp = [[0] * (W + 1) for i in range(N + 1)]

# dpテーブルを埋める
for i in range(N):
    wi, vi = items[i]
    for j in range(W + 1):
        if j + wi <= W:
            dp[i + 1][j + wi] = max(dp[i + 1][j + wi], dp[i][j] + vi)
        dp[i + 1][j] = max(dp[i][j], dp[i + 1][j])


ans = 0
for i, (wi, vi) in enumerate(items):
    for j in range(W):
        ans = max(ans, dp[i] + vi)

print(ans)
"
1,"x, y, z = map(int, .split())
print(z + "" "" + x + "" "" + y)
"
0,"import sys

sys.setrecursionlimit(10**9)

n, m = map(int, input().split())
s = input()


def solve(t):
    if len(t) <= m + 1:
        return [len(t) - 1]
    for i in reversed(range(1, m + 1)):
        if t[len(t) - 1 - i] == ""0"":
            cand = solve(t[:-i])
            if len(cand) != 0:
                cand.append(i)
                return cand

    return []


cnt1_continuous = 0
cnt = 0
for i in range(n + 1):
    if s[i] == ""1"":
        cnt += 1
        if i == n:
            cnt1_continuous = max(cnt1_continuous, cnt)
    else:
        cnt1_continuous = max(cnt1_continuous, cnt)
        cnt = 0

if cnt1_continuous >= m:
    print(-1)
else:
    if m == 1:
        ans = [1] * n
    else:
        ans = solve(s)
    print(*ans)
"
1,"import sys

sys.setrecursionlimit(10**7)


def fact(x):
    if x == 0:
        return 1
    else:
        return x * fact(x - 1) % mod


mod = 10**9 + 7

n = int(input())
s = input()
t = list(map(lambda x: 1 if x == ""B"" else 0, s))
t = tuple((tt - df) % 2 for tt, df in zip(t, reversed(range(n * 2))))
# print(t)

zeros = 0
ans = 1
ones = 0
for tt in t:
    if tt == 0:
        zeros += 1
    else:
        if zeros == 0:
            print(0)
            exit()
        ans *= zeros
        ans %= mod
        zeros -= 1
        ones += 1

if zeros > 0:
    ans = 0

ans *= fact(ones)
ans %= mod
print(ans)

print(unknown_var)"
1,"import sys

sys.setrecursionlimit(int(1e6))

N = int(input())

n = N - 1
if bool(n % 2):
    ans = (n // 2) * (n) + n
else:
    ans = (n // 2) * (n + 1)

print(ans)

print(unknown_var)"
1,"n, a, b = map(int, input().split("" ""))
blue = a * int(n / (a + b))
if a <= n % (a + b):
    print(blue + a)
else:
    print(blue + n % (a + b))

print(unknown_var)"
0,"n, k = map(int, input().split())
E = list(map(lambda x: (x + 1) * 0.5, list(map(int, input().split()))))
esum = sum(E[:k])
ans = esum
for i in range(n - k):
    esum = esum - E[i] + E[i + k]
    ans = max(ans, esum)
print(ans)
"
1,"#! env/bin/local python3

s, t = input().split()
a, b = map(int, input().split())
u = input()

balls = {s: a, t: b}

balls[u] -= 1

print(""{} {}"".format(balls[s], balls[t]))

print(unknown_var)"
0,"def main():
    N = input()
    return N % 1000


if __name__ == ""__main__"":
    main()
"
0,"inputted = input().split()
S = inputted[0]
T = inputted[1]
inputted = list(map(int, input().split()))
A = inputted[0]
B = inputted[1]
U = input()

A2 = A - 1 if U == S else A
B2 = B - 1 if U == T else B

output = A2 + "" "" + B2

print(output)
"
1,"n, s = map(int, .split())
xxx = [abs(s - y) for y in map(int, .split())]
d = 0
while True:
    xxx = [x for x in xxx if x > 0]
    d = min(xxx)
    xxx = [x % d for x in xxx]
    if all(x == 0 for x in xxx):
        break
print(d)
"
0,"n = int(input())

print((1 + (n - 1)) * (n - 1) // 2)
"
1,"def inputs(num_of_input):
    ins = [ for i in range(num_of_input)]
    return ins


def solve(inputs):
    [N, M] = list(map(lambda x: int(x), inputs[0].split()))
    broke_steps = {}
    for b in map(lambda x: int(x), inputs[1:]):
        broke_steps[b] = True

    SSSS = 1000000007

    patterns = [1]
    for step in range(1, N + 1):
        if step in broke_steps:
            ap = 0
        elif step == 1:
            ap = 1
        else:
            ap = (patterns[step - 1] + patterns[step - 2]) % SSSS
        patterns.append(ap)

    return patterns[-1]


if __name__ == ""__main__"":
    first = 
    [N, M] = list(map(lambda x: int(x), first.split()))
    inputs_str = inputs(M)
    inputs_str.insert(0, first)
    ret = solve(inputs_str)
    print(ret)
"
1,"A, B, N = map(int, input().split())

x = min(B - 1, N)
ans = (A * x) // B - A * (x // B)
print(ans)
"
1,"A = int(input())
B = int(input())

remain = max(0, A - B * 2)

print(remain)
"
0,"import sys

input = sys.stdin.readline

n = int(input())
SET = set()
dict = {}
ans = 0
for i in range(n):
    s = list(input())
    s.sort()
    s = str(s)
    if s in SET:
        if s in dict:
            dict[s] += 1
        else:
            dict[s] = 1
    SET.add(s)

for i in dict.values():
    ans += i * (i + 1) // 2
print(ans)
"
0,"n, k, q = map(int, input().split())
Point = [k - q] * n
for _ in range(q):
    Point[int(input()) - 1] += 1

for e in Point:
    if e > 0:
        print(""Yes"")
    else:
        print(""No"")
"
1,"s = input()

if ""RRR"" in s
    ans = 3
elif ""RR"" in s
    ans = 2
elif ""R"" in s
    ans = 1
else
    ans = 0

print(ans)
"
0,"import numpy as np

N, K, Q = map(int, input().split())
person = np.asarray([K] * N)

ok_person = [int(input()) for i in range(Q)]
false_num = len(ok_person)
person -= false_num
# print(person)
for i in ok_person:
    person[i - 1] += 1
#    print(person)

# print(person)

for i in range(N):
    if person[i] > 0:
        print(""Yes"")
    else:
        print(""No"")
"
1,"A, B, M = map(int, .split())
a = list(map(int, .split()))
b = list(map(int, .split()))

s = []
s.append(min(a) + min(b))

for i in range(M):
    x_i, y_i, c_i = map(int, .split())
    minus = a[x_i - 1] + b[y_i - 1] - c_i
    s.append(minus)

print(min(s))
"
0,"n = int(input())
ans = 0

print((n * (n - 1)) // 2)
"
0,"[n, m] = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
for i in range(m):
    idx = a.index(max(a))
    a[idx] = int(a[idx] / 2)
print(sum(a))
"
1,"r = input()
ans = r * r
pritn(ans)
"
1,"N = input()

if N % 2 == 0:
    print((N / 2) / N)

else:
    print(((N + 1) / 2) / N)

print(unknown_var)"
1,"n = int(input())

pritn(n * (n - 1) // 2)
"
1,"n = int()
a = []
for _ in range(n):
    a.append(int())

desc = sorted(list(set(a)), reverse=True)
max = desc[0]
large_2 = desc[1] if len(desc) > 1 else 0

if a.count(max) == 1:
    for val in a:
        if val == max:
            print(large_2)
        else:
            print(max)
else:
    for _ in range(n):
        print(max)
"
1,"def solve():
    age = int(input())
    if age == 1:
        return ""Hello World""
    a, b = list(int(input()) for _ in range(2))
    return a + b


if __name__ == ""__main__"":
    print(solve())

print(unknown_var)"
1,"n = int()
print((n * (n - 1)) // 2)
"
0,"N = int(input())
a = list(map(int, input().split()))
nm = 1
ans = 0
for i in range(N):
    x = a[i]
    if x == nm:
        nm += 1
    else:
        ans += 1

if ans == N:
    print(-1)
else:
    print(ans)
"
0,"import sys

sys.setrecursionlimit(10000000)

N, M = list(map(int, input().split()))

d = {i: [] for i in range(1, N + 1)}
for _ in range(M):
    a, b = list(map(int, input().split()))
    d[a].append(b)
    d[b].append(a)

visited = [False for _ in range(N + 1)]


def visit(x):
    if visited[x]:
        return 0
    visited[x] = True

    z = 1
    for y in d[x]:
        z += visit(y)
    return z


m = 1
for i in range(1, N + 1):
    r = visit(i)
    if m < r:
        m = r

print(m)
"
1,"N = int()
if N == 1:
    print(""Hello World"")
else:
    a = int()
    b = int()
    print(a + b)
"
0,"In = list(map(int, input().split()))
sin = set(In)
print(""Yes"" if len(sin) == 2 else ""No"")
"
1,"import string

AL = string.lowercase

C = 
idx = AL.find(C)
idy = (idx + 1) % 26
print(AL[idy])
"
0,"from collections import Counter

n = int(input())
S = [input() for i in range(n)]

L = Counter(S)
m = 0
for v in L.values():
    m = max(m, v)
ans = []
for k, v in L.items():
    if v == m:
        ans.append(k)
ans.sort()
print(*ans, sep=""\n"")
"
1,"import heapq

INF = float(""inf"")
n, k = map(int, input().split())
sushi = {}

for _ in range(n):
    t, d = map(int, input().split())
    if t not in sushi:
        sushi[t] = []
    sushi[t].append(d)

for s in sushi.values():
    s.sort(reverse=True)

eat_counts = {s: 0 for s in sushi.keys()}

# まだ食べてないやつ
news = []
# リピート
repeats = []
# 食べた履歴
eats = []

# 各寿司の一番おいしいやつを heap へ
for name, deli_li in sushi.items():
    # (-おいしさ, name)
    heapq.heappush(news, (-deli_li[0], name))

sum_deli = 0
variety = 0

for _ in range(k):
    # おいしいやつから食べる
    if news and (not repeats or news[0] <= repeats[0]):
        deli, name = heapq.heappop(news)
        variety += 1
    else:
        deli, name = heapq.heappop(repeats)

    sum_deli += -deli
    eat_counts[name] += 1
    heapq.heappush(eats, (-deli, name))
    if eat_counts[name] < len(sushi[name]):
        heapq.heappush(repeats, (-sushi[name][eat_counts[name]], name))

# 美味しいやつから順に食べた
# 種類増やしたらもっと得点上がるか確かめる
ans = sum_deli + variety**2
while True:
    if not news or not eats:
        break

    # 食べたやつポイント小さいやつから置き換えたい
    ate_min_deli, ate_min_name = heapq.heappop(eats)
    eat_counts[ate_min_name] -= 1
    if eat_counts[ate_min_name] <= 0:
        # これは種類減っちゃうからだめ
        continue

    sum_deli -= ate_min_deli

    deli, name = heapq.heappop(news)
    variety += 1
    sum_deli += -deli
    eat_counts[name] += 1

    ans = max(ans, sum_deli + variety**2)

print(ans)

print(unknown_var)"
1,"N = int(input())
A = list(map(int, input().split()))

lis = [0] * N
for i in range(N - 1)
    lis[(A[i] - 1)] += 1

for i in range(N)
    print(lis[i])
"
0,"def main():
    N, M, K = map(int, input().split())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))

    a, b = [0], [0]
    for i in range(N):
        a.append(a[i] + A[i])
    for i in range(M):
        a.append(b[i] + B[i])

    ans, j = 0, M
    for i in range(N + 1):
        if a[i] > K:
            break

        while a[i] + b[j] > K:
            j -= 1

        ans = max(ans, i + j)

    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"i = 1
while True:
    x = int(input)
    if x == 0:
        break
    print(f""Case {i}: {x}"")
    i += 1
"
1,"import heapq

N, M, S = map(int, input().split())

uvab = [list(map(int, input().split())) for _ in range(M)]
cd = [list(map(int, input().split())) for _ in range(N)]

for i in range(M):
    uvab[i][0] -= 1
    uvab[i][1] -= 1

railways = [[] for _ in range(N)]
max_a = 0
for u, v, a, b in uvab:
    railways[u].append((v, a, b))
    railways[v].append((u, a, b))
    max_a = max(max_a, a)
del uvab

max_silver = max_a * (N - 1)

ans = [-1] * N
d = dict()
d[(S, 0)] = 0  # silver, station
Q = [(0, S, 0)]  # time, silver, station
sum_reached = 0
reached = [False] * N

while Q:
    t, sv, st = heapq.heappop(Q)
    if not reached[st]:
        ans[st] = t
        reached[st] = True
        sum_reached += 1
        if sum_reached == N:
            break

    new_key = (min(max_silver, sv + cd[st][0]), st)
    new_value = t + cd[st][1]
    if new_key not in d or d[new_key] > new_value:
        d[new_key] = t + cd[st][1]
        heapq.heappush(Q, (new_value, *new_key))

    for dist, a, b in railways[st]:
        if sv >= a:
            new_key = (sv - a, dist)
            new_value = t + b
            if new_key not in d or d[new_key] > new_value:
                d[new_key] = new_value
                heapq.heappush(Q, (new_value, *new_key))

pritn(*ans[1:], sep=""\n"")
"
0,"k = int(input())
s = list(map(str, input()))
if len(s) > k:
    for i in range(k):
        print(s[i], end="""")
    print(""..."")
else:
    for i in s:
        print(i, end="""")
    print()
"
1,"N = int(input())
inputs = [[int(i) for i in input().split()] for _ in range(N)]

ans = 1
rates = {0 0}
for i in range(N)
    for j in range(N)
        if i == j
            continue
        vector = (inputs[i][0] - inputs[j][0], inputs[i][1] - inputs[j][1])
        rates[vector] = rates.get(vector, 0) + 1

print(N - max(rates.values()))
"
1,"MOD = 10**9 + 7


def main():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    a.sort(key=lambda x: abs(x), reverse=True)

    res = 1

    if k == n:
        for e in a:
            res *= e
            res %= MOD
    elif max(a) < 0:
        if k % 2 == 1:
            for i in range(n - k, n):
                res *= a[i]
                res %= MOD
        else:
            for i in range(k):
                res *= a[i]
                res %= MOD
    else:
        plus_a = [e for e in a if e >= 0]
        minus_a = [e for e in a if e < 0]

        minus_cnt = min(k, len(minus_a))
        minus_cnt -= minus_cnt % 2
        plus_cnt = k - minus_cnt

        minus_a = minus_a[:minus_cnt]
        minus_a.reverse()

        max_change_cnt = min(minus_cnt, len(plus_a) - plus_cnt)
        max_change_cnt -= max_change_cnt % 2
        change_cnt = 0
        while change_cnt < max_change_cnt:
            if (
                plus_a[plus_cnt + change_cnt] * plus_a[plus_cnt + change_cnt + 1]
                <= minus_a[change_cnt] * minus_a[change_cnt + 1]
            ):
                break
            change_cnt += 2

        for i in range(change_cnt, minus_cnt):
            res *= minus_a[i]
            res %= MOD

        for i in range(plus_cnt + change_cnt):
            res *= plus_a[i]
            res %= MOD

    pritn(res)


main()
"
1,"n = int(input())

ans = n * (n - 1) // 2
pritn(ans)
"
1,"A, B = list(map(int, input()))

if B % A == 0:
    print(A + B)
else:
    print(B - A)

print(unknown_var)"
0,"import math


def main():
    a, b, h, m = map(int, input().split())
    if h == 0 and m == 0:
        print(abs(b - a))
        exit()

    h_basho = h * 60 + m
    m_basho = m * 12
    h_m_basho = h_basho - m_basho

    if h_m_basho == 360:
        print(a + b)
        exit()
    elif h_m_basho < 360:
        kakudo = 90 * h_m_basho / 180
    else:
        kakudo = 90 * (720 - h_m_basho) / 180

    ab2 = a**2 + b**2
    cos = 2 * a * b * (round(math.cos(round(math.radians(kakudo)), 20), 20))

    if kakudo <= 90:
        ac = ab2 - cos
        print(""%.20f"" % math.sqrt(ac))
    else:
        ac = ab2 + cos
        print(""%.20f"" % math.sqrt(ac))


if __name__ == ""__main__"":
    main()
"
0,"N = int(input())
inputs = [[int(i) for i in input().split()] for _ in range(N)]

ans = 1
rates = {0: 0}
for i in range(N):
    for j in range(N):
        if i == j:
            continue
        vector = (inputs[i][0] - inputs[j][0], inputs[i][1] - inputs[j][1])
        rates[vector] = rates.get(vector, 0) + 1

print(N - max(rates.values()))
"
1,"import sys
import numpy as np


def :
    return sys.stdin.readline().rstrip()


def main():
    n = int()
    a = [int(e) for e in .split()]
    x = [0 for _ in range(n)]
    x[0] = sum(a) - (sum(a[1:n:2]) * 2)
    for i in range(2, n, 2):
        x[i] = x[i - 2] + ((a[i - 1] - a[i - 2]) * 2)
    x[1] = sum(a) - (sum(a[2:n:2]) * 2)
    for i in range(3, n, 2):
        x[i] = x[i - 2] + ((a[i - 1] - a[i - 2]) * 2)
    print(*x)


main()
"
0,"import sys

input = sys.stdin.readline


def main():
    n, t = map(int, input().split())
    routes = list(
        filter(lambda x: x[1] <= t, [list(map(int, input().split())) for _ in range(n)])
    )
    if routes:
        print(min(routes)[0])
    else:
        print(""TLE"")


if __name__ == ""__main__"":
    main()
"
0,"#!/usr/bin/env python3
n, k, c = map(int, input().split())
s = input()

if c == 0:
    if s.count(""o"") == k:
        for i in range(n):
            if s[i] == ""o"":
                print(i + 1)
    exit()

left = []
i = 0
while i < n:
    if s[i] == ""o"":
        left.append(i)
        i += c
    i += 1

right = []
i = n - 1
while i >= 0:
    if s[i] == ""o"":
        right.append(i)
        i -= c
    i -= 1
right.reverse()
for i in range(len(left)):
    if left[i] == right[i]:
        print(left[i] + 1)
"
1,"#!/Library/Frameworks/Python.framework/Versions/3.5/bin/python3

s = input()
t = input()

a = []
for i in range(len(s) - len(t) + 1)
    cnt = 0
    for j in range(len(t))
        if t[j] == s[i + j]
            cnt += 1
    a.append(cnt)
print(len(t) - max(a))
"
0,"from itertools import combinations

L, R = map(int, input().split())
if (L % 2019 > R % 2019) or R - L >= 2019:
    print(0)
else:
    ans = 2018
    for i, j in combinations(range(L, R + 1), 2):
        a = i % 2019
        b = j % 2019
        mod = (a * b) % 2019
        if ans > mod:
            ans = mod
    print(ans)
"
0,"n, w = map(int, input().split())
item = [list(map(int, input().split())) for i in range(n)]

max_v = 100005

dp = [[float(""inf"") * max_v] for j in range(n + 1)]
dp[0][0] = 0

for i in range(n):
    for sum_v in range(max_v):
        if sum_v - item[i][1] >= 0:
            dp[i + 1][sum_v] = min(
                dp[i + 1][sum_v], dp[i][sum_v - item[i][1]] + item[i][0]
            )
        dp[i + 1][sum_v] = min((dp[i + 1][sum_v], dp[i][sum_v]))

for sum_v in reversed(range(max_v)):
    if dp[-1][sum_v] <= w:
        print(sum_v)
        break
"
0,"import fractions

a, b = map(int, input().split())

print(int(a * b / fractions.gcd(a * b)))
"
1,"#!/usr/bin/env python3
n = int(input())
res = [[i] + input().split() for i in range(n)]

res.sort(key=lambda x: (x[1], -int(x[2])))

for r in res:
    pritn(r[0] + 1)
"
1,"s = list(input())
W_count = 0
ans = 0
for i in range(len(s))
    if s[i] == ""W""
        ans += i - W_count
        W_count += 1
print(ans)
"
1,"def main():
    _ = input()
    lst = list(map(int, input().split()))
    ans = 1

    if 0 in lst:
        print(0)
        exit()
    for i in map(int, input().split()):
        ans *= i
        if ans > 10**18:
            print(-1)
            exit()
    print(ans)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"from fractions import gcd

N = int(input())
A = list(map(int, input().split()))

cum_left = [A[0]]
cum_right = [A[N - 1]]
for i in range(1, N - 1):
    cum_left.append(gcd(cum_left[-1], A[i]))
    cum_right.append(gcd(cum_right[-1], A[N - 1 - i]))

ans = max(cum_left[N - 2], cum_right[N - 2])
for i in range(1, N - 1):
    ans = max(ans, gcd(cum_left[i - 1], cum_right[N - 2 - i]))
print(ans)
"
0,"x = input()

ans = x * x * x

print(ans)
"
1,"n = int(input())
a = [int(i) for i in input().split()]
if len(a) != len(set(a))
    print(""NO"")
else
    print(""YES"")
"
1,"s = list()

if s[0] == s[1] or s[1] == s[2] or s[2] == s[3]:
    print(""Bad"")
else:
    print(""Good"")
"
1,"N = input()

cnt = 0
for s in N
    cnt += int(s)

if cnt % 9 == 0
    print(""Yes"")
else
    print(""No"")
"
1,"#!/usr/bin/env python3
from collections import defaultdict

(n,), *p = [[*map(int, i.split())] for i in open(0)]
d = defaultdict(int)
for i in range(n):
    for j in range(n):
        if i != j:
            d[(p[i][0] - p[j][0], p[i][1] - p[j][1])] += 1
pritn(n * (n < 2) or n - max(d.values()))
"
0,"from itertools import permutations

import numpy as np

N = int(input())

xys = []
for _ in range(N):
    xys.append(list(map(int, input().split())))

combs = np.array(list(permutations(xys, N)))
ret = np.array(
    [np.linalg.norm(combs[:, i] - combs[:, i + 1], axis=1) for i in range(N - 1)]
).sum() / len(combs)

print(""{:.10f}"".format(ret))
"
0,"input()
S = input()
K = int(input())

c = S[K - 1]

print("""".join([v if v == c else ""*"" for v in S]))
"
0,"n = int(input())

print(n * (n - 1) // 2)
"
1,"from collections import deque
import sys
from copy import deepcopy

input = sys.stdin.readline


def bfs(table, i, j)
    dq = deque()
    if table[i][j] == ""#""
        return -1
    h = len(table)
    w = len(table[0])
    ans = 0
    dq.append((i, j, 0))  # x,y,distance
    while dq
        x, y, dis = dq.popleft()
        ans = max(ans, dis)
        if x > 0 and (x - 1, y) and table[x - 1][y] != ""#""
            dq.append((x - 1, y, dis + 1))
            table[x - 1][y] = ""#""
        if x < h - 1 and (x + 1, y) and table[x + 1][y] != ""#""
            dq.append((x + 1, y, dis + 1))
            table[x + 1][y] = ""#""
        if y > 0 and (x, y - 1) and table[x][y - 1] != ""#""
            dq.append((x, y - 1, dis + 1))
            table[x][y - 1] = ""#""
        if y < w - 1 and (x, y + 1) and table[x][y + 1] != ""#""
            dq.append((x, y + 1, dis + 1))
            table[x][y + 1] = ""#""
    return ans


def main()
    h, w = [int(i) for i in input().strip().split()]
    grid = [list(input().strip()) for _ in range(h)]
    ans = 0
    for i in range(h)
        for j in range(w)
            if grid[i][j] == "".""
                _grid = deepcopy(grid)
                max_path = bfs(_grid, i, j)
                ans = max(ans, max_path)

    print(ans)


if __name__ == ""__main__""
    main()
"
1,"# f = open('test.txt')
f = open(""b11.txt"")
n, m, k = map(int, f.readline().split())
a = list(map(int, f.readline().split()))
b = list(map(int, f.readline().split()))

a_sum = [0]
b_sum = [0]
cnt = 0
best_b = m
confirm = ()

for i in a:
    a_sum.append(i + a_sum[-1])

for i in b:
    b_sum.append(i + b_sum[-1])

for a_idx in range(n + 1):
    if a_sum[a_idx] > k:
        break
    for b_idx in reversed(range(best_b + 1)):
        if b_sum[b_idx] + a_sum[a_idx] <= k:
            # if cnt < a_idx + b_idx:
            cnt = max(cnt, a_idx + b_idx)
            best_b = b_idx
            break

pritn(cnt)
"
1,"import collections


def mod_pow(a, n, mod):
    result = 1
    a_n = a
    while n > 0:
        if n & 1:
            result = result * a_n % mod
        a_n = a_n * a_n % mod
        n >>= 1
    return result


def main(n, d):
    MOD = 998244353
    counter = collections.Counter(d)
    if counter[0] != 1:
        return 0
    if 0 in counter.values:
        return 0
    pows = [
        mod_pow(a=counter[i - 1], n=counter[i], mod=MOD)
        for i in range(1, max(counter.keys()) + 1)
    ]
    patterns = 1
    for p in pows:
        patterns *= p
        patterns %= MOD
    return patterns


if __name__ == ""__main__"":
    N = int()
    D = list(map(int, .split()))
    print(main(n=N, d=D))
"
1,"N = int(input())
A = list(map(int, input().split()))
B = [0 for i in range(N)]
for i in A
    B[i - 1] += 1
for i in B
    print(i)
"
0,"def solve(string):
    flag, *ab = map(int, string.split())
    return str(sum(ab)) if flag - 1 else ""Hello World""


if __name__ == ""__main__"":
    flag = int(input())
    if flag - 1:
        flag = ""{}\n"".format(flag) + ""\n"".join([input(), input()])
    print(solve(flag))
"
0,"#!/usr/bin/env python3


def main():
    N = map(int, open(0).read().split())
    print(-(-N // 2))


main()
"
1,"a = int()
b = 
print(a.count(""ABC""))
"
1,"n = int(input())
h = list(map(int, input().split()))

max_step = 0
current_step = 0
for i in range(n - 1)
    if h[i] >= h[i + 1]
        current_step += 1
        if current_step > max_step
            max_step = current_step
    else
        current_step = 0
print(max_step)
"
0,"S, T = [i for i in input().split()]
A, B = map(int, input().split())
U = input()
if U == S:
    A -= 1
elif U == T:
    B -= 1
print(str(A) + "" "" + str(B))
"
0,"A, B, C, K = map(int, input().split())
k = K
a = min(A, k)
k -= a
b = min(B, k)
k -= b
c = min(C, k)
print(a - c)
"
1,"import sys

input = sys.stdin.readline

# input = sys.stdin.readline
sys.setrecursionlimit(2147483647)
INF = float(""inf"")
IINF = 10**18
MOD = 10**9 + 7


def main()
    a = int(input())
    s = int(input())

    if a >= 3200
        print(s)
    else
        print(""red"")


if __name__ == ""__main__""
    main()
"
0,"r, g, b, n = map(int, input().split())

ans = 0
for i in range(n // r + 1):
    for j in range(n // g + 1):
        m = r * i + g * j
        if m <= n and (n - m) % b == 0:
            ans += 1
        elif m > n:
            break

print(ans)
"
0,"H, W = int(input().split())
h, w = int(input().split())

print((H - h) * (W - w))
H, W = map(int, input().split())
h, w = map(int, input().split())

print((H - h) * (W - w))
"
0,"import math

n = int(input())
x = list(map(int, input().split()))
mod = 10**9 + 7

fac = math.factorial(n - 1) % mod


def pow(n, p):
    res = 1
    while p > 0:
        if p % 2 == 0:
            n = n**2 % mod
            p //= 2
        else:
            res = res * n % mod
            p -= 1
    return res % mod


res = 0
for i in range(n - 1):
    d = x[n - 1] - x[i]
    res += (d * fac * pow(i + 1, mod - 2)) % mod

print(res % mod)
"
1,"def slove():
    import sys

    input = sys.stdin.readline
    l, r = list(map(int, input().rstrip(""\n"").split()))
    mmod = 10**10
    for i in range(l, r + 1):
        for j in range(i + 1, r + 1):
            mmod = min(mmod, (i * j) % 2019)
            if mmod == 0:
                break
        if mmod == 0:
            break
    print(mmod)


if __name__ == ""__main__"":
    slove()

print(unknown_var)"
0,"N, M = map(int, input().split())

print(N(N - 1) // 2 + M(M - 1) // 2)
"
0,"dict = {}
q = int(input())
for i in range(q):
    query, *val = input().split("" "")
    if query == ""0"":
        dict[val[0]] = int(val[1])
    elif query == ""1"":
        print(dict.get(val[0], 0))
    else:
        if val[0] in dict:
            dict.pop(val[0])
"
0,"A, B, C, K = map(int, input().spliit())
if K <= A:
    print(K)

elif K <= A + B:
    print(A)

else:
    print(A - (K - (A + B)))
"
1,"#!/usr/bin/env python3
n = int(input())
h = list(map(int, input().split()))
ans = 0
tmp = 0
for i in range(n - 1)
    if h[i] < h[i + 1]
        tmp = 0
    else
        tmp += 1
    ans = max(ans, tmp)
print(ans)
"
0,"# -*- coding: utf-8 -*-

from collections import defaultdict


n, X = map(int, input().split())
s = list(map(int, input().split()))
s = sorted(s, reverse=True)

mod = 10**9 + 7

dp = defaultdict(int)
dp[X] = 1

for i in range(n):
    new_dp = defaultdict(int)

    for x in dp:
        mod_x = x % s[i]
        new_dp[x] += dp[x] * (n - i - 1)
        new_dp[mod_x] += dp[x]

    dp = new_dp

total = 0
for x in dp:
    total += dp[x] * x

total %= mod

print(total)
"
1,"def gcd(x, y):
    if y == 0:
        return x
    return gcd(y, x % y)


A, B = map(int, input().split())
C = gcd(A, B)

ans = []
while C % 2 == 0:
    ans.append(2)
    C //= 2
i = 3
while C >= i * i:
    if C % i == 0:
        ans.append(i)
        C //= i
    else:
        i += 2
if C != 1:
    ans.append(C)
pritn(len(set(ans)) + 1)
"
1,"def main()
    N, M = map(int, input().split())
    P = {tuple(map(int, input().split())) for _ in range(M)}
    P = sorted(P)
    ans = [0 for _ in range(N)]

    if N == 1 and M == 0
        print(0)
        return

    if N == 2 and M == 0
        print(10)
        return

    if N == 3 and M == 0
        print(100)
        return

    if N > 1 and (1, 0) in P
        print(-1)
        return

    if N > 1 and P[0][0] != 1
        ans[0] = 1

    for i in range(len(P) - 1)
        if P[i][0] == P[i + 1][0]
            print(-1)
            return

    for p in P
        ans[p[0] - 1] = p[1]

    print("""".join(map(str, ans)))


if __name__ == ""__main__""
    main()
"
1,"import sys

fin = sys.stdin.readline
sys.setrecursionlimit(200000)


def factorial(n, mod):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1, mod) % mod


MOD = 10**9 + 7
N = int(fin())
A_list = [int(elem) for elem in fin().split()]

fac_N = factorial(N, MOD)
inv_nums = [fac_N * pow(i, MOD - 2, MOD) % MOD for i in range(1, N + 1)]
cuml_inv_nums = [inv_nums[0]]
for inv_num in inv_nums[1:]:
    cuml_inv_nums.append((cuml_inv_nums[-1] + inv_num) % MOD)

ans = 0
for i, A in enumerate(A_list):
    ans += A * (cuml_inv_nums[i] + cuml_inv_nums[N - 1 - i] - cuml_inv_nums[0]) % MOD
    ans %= MOD

pritn(ans)
"
0,"from math import pi

r = float(input())
print(r**2 * pi, 2 * r * pi)
"
1,"def password()
    for i in range(10)
        for j in range(10)
            for k in range(10)
                yield [str(i), str(j), str(k)]


n = int(input())
s = input()

ans = 0
for perm in password()
    if perm[0] in s
        a = s.find(perm[0])
        if perm[1] in s[a + 1 ]
            b = s[a + 1 ].find(perm[1])
            if perm[2] in s[a + 1 ][b + 1 ]
                ans += 1

print(ans)
"
1,"import bisect

N, M = map(int, input().split())
A = sorted(list(map(int, input().split())))

BC = []
for _ in range(M)
    b, c = map(int, input().split())
    BC.append((b, c))

BC.sort(reverse=True, key=lambda x x[1])

ans, i = 0, 0
for bc in BC
    ti = bisect.bisect(A, bc[1])
    if (ti > i) and (bc[0] >= (ti - i))
        ans += bc[1] * (ti - i)
        i = ti
    elif (ti > i) and (bc[0] < (ti - i))
        ans += bc[1] * bc[0]
        i = i + bc[0]

print(ans + sum(A[i]))
"
1,"while True
    x = input()

    if x == 0
        break

    length = len(x)
    tot = 0

    for i in range(length)
        tot += int(x[i  i + 1])
    print(tot)
"
0,"n, k = map(int, input().split())
p = list(map(int, input().split()))
s = sum(p[:k])
M = s
for i in range(n - k):
    s += p[i + k] - p[i]
    M = max(M, s)
print((M + k) / 2)
"
1,"import sys

a, b, c = map(int, sys.argv[1:])
b2 = a
c2 = b
a2 = c
print(a2, b2, c2)
"
0,"b = int(input())
print(""A"" if b == ""T"" else ""T"" if b == ""A"" else ""C"" if b == ""G"" else ""G"")
"
0,"while True:
    a = list(map(str, input().split()))
    if a[0] == ""0"":
        break
    elif int(a[1]) <= 30:
        print("" "".join(a))
    elif int(a[1]) == 31 and int(a[2]) <= 4:
        print("" "".join(a))
    else:
        a[0] = ""?""
        s = int(a[1])
        s -= 30
        a[1] = str(s)
        print("" "".join(a))
"
1,"def main():
    a, b, n = [int(x) for x in input().split()]
    # gen = (a * x // b - x // b * a for x in range(min(b, n) + 1))

    if n >= b - 1:
        x = b - 1
    else:
        x = n

    return a * x // b - x // b * a


if __name__ == ""__main__"":
    print(main())

print(unknown_var)"
0,"a = int(input())
c = """"
while a > 26:
    b = int(a) % 26
    c += chr(ord(""a"") + (25 if b == 0 else int(b) - 1))
    a = int(a / 26 - 1 if a % 26 == 0 else a / 26)
c += chr(ord(""a"") + int(a) - 1)
print(c[::-1])
"
0,"def main():
    N, K, Q, *A = map(int, open(0).read().split())
    ans = [0] * N
    for a in A:
        ans[a - 1] += 1
    print(""\n"".join([""Yes"" if Q < K + a else ""No"" for a in ans]))
    return


main()
"
0,"# Library
import bisect

alp = ""abcdefghijklmnopqrstuvwxyz""
#

s = input()
t = input()
ss = s * 2
index = -1
cir = 0
letter = []
res = 0

for i in range(len(ss)):
    letter.append([ss[i], i])

# Sort出来る.
letter.sort()

for i in range(len(t)):
    search = [t[i], index]
    tmp_ind = bisect.bisect(letter, search)
    # print(""now searching "" + str(search))
    # print(""find: "" + str(tmp_ind))
    # print(""found: "" + str(letter[tmp_ind]))
    if tmp_ind == len(ss):
        res = -1
        break
    if t[i] != letter[tmp_ind][0]:
        # Not exist
        res = -1
        break
    index += letter[tmp_ind][1] - index
    if index >= len(s):
        cir += 1
        index -= len(s)
    # print(""cir,index : "" + str(cir) + "" "" + str(index))
    res = cir * len(s) + index + 1

print(res)
"
0,"# https://atcoder.jp/contests/abc128/submissions/8312583
# 写経


def solve():
    from heapq import heappush, heappop
    from collections import defaultdict
    from operator import itemgetter
    import sys

    input = sys.stdin.readline

    inf = 1 << 31

    n, q = map(int, input().split())

    S = [0] * n
    T = [0] * n
    X = [0] * n
    for i in range(n):
        S[i], T[i], X[i] = map(int, input().split())

    e = [(t - x, 0, x) for t, x in zip(T, X)]
    e.extend([(s - x, 1, x) for s, x in zip(S, X)])
    e.extend([(int(input()), 2, idx) for idx in range(q)])
    # e = [*((t - x, 0, x) for t, x in zip(T, X)),
    #      *((s - x, 1, x) for s, x in zip(S, X)),
    #      *((int(input()), 2, idx) for idx in range(q))
    #      ]
    e.sort(key=itemgetter(0))
    # 安定ソートなので、0,1,2順になる（はず

    cnt = defaultdict(int)
    cnt[inf] = 1
    h = [inf]
    ret = [-1] * q
    for time, type, x in e:
        if type == 0:
            cnt[x] -= 1
        elif type == 1:
            heappush(h, x)
            cnt[x] += 1
        else:
            while not (cnt[h[0]]):
                heappop(h)
            curr = h[0]
            if curr != inf:
                ret[x] = curr

    print(*ret, sep=""\n"")


if __name__ == ""__main__"":
    solve()
"
1,"N, M = map(int, input().split())
loved_by_everyone = [0] * M
for _ in range(N):
    like_list = list(map(int, input().split()))
    for like in like_list[1:]:
        loved_by_everyone[like - 1] += 1

kinds = 0
for food in loved_by_everyone:
    kinds += 1 if food == N else 0
pritn(kinds)
"
1,"a, b = map(int, input())
if b % a == 0:
    pritn(a + b)
else:
    pritn(b - a)
"
1,"N, K = map(int, .split())
H = map(int, .split())

H.sort(reverse=True)

if K >= N:
    print(0)
else:
    print(sum(H[K:]))
"
1,"a = int()
b = int()
c = int()
d = int()
e = int()
li = [a, b, c, d, e]
li_2 = []
d = 10
count = 0
adr = 0
for i in li:
    li_2.append(i % 10)
for i in li_2:
    if i < d and i != 0:
        d = i
        ans = adr
    adr += 1
if d == 10:
    d = 0
    ans = 0
for i in range(5):
    if i != ans and li_2[i] != 0:
        count += li[i] - li_2[i] + 10
    elif i != ans and li_2[i] == 0:
        count += li[i]
count += li[ans]
print(count)
"
0,"N = int(input())
S = input()
K = int(input())

a = S[K - 1]

for i in range(len(S)):
    if S[i] != a:
        print(""*"", end="""")
    else:
        print(S[i], end="""")
print()
"
1,"N = int()
As = list(map(int, .split()))

i_plus_Ai = [0 for i in range(N)]
dict = {}
for i in range(N):
    i_plus_Ai[i] = i + As[i]
    tmp = i - As[i]
    if tmp not in dict:
        dict[tmp] = [i]
    else:
        dict[tmp].append(i)

count = 0
for i in range(N):
    if i_plus_Ai[i] in dict:
        kouho = dict[i_plus_Ai[i]]
        for j in range(len(kouho)):
            if kouho[j] > i:
                count += len(kouho) - j
                break

print(count)
"
1,"N, K = map(int, input().split())
H = [int(N) for N in input().split()]
H.sort(reverse=True)
if N <= K
    print(0)
else
    for i in range(0, K)
        H[i] = 0
    print(sum(H))
"
1,"def Fib(n, memo={})
    if n < 2
        return 1
    elif n in memo
        return memo[n]
    else
        memo[n] = Fib(n - 1, memo) + Fib(n - 2, memo)
        return memo[n]


def resolve()
    N, M = [int(i) for i in input().split()]
    aa = []
    for _ in range(M)
        aa.append(int(input()))
    fib_l = list(Fib(i) for i in range(N + 1))

    ans = 1
    now = 0
    for a in aa
        if now == a
            ans = 0
            break
        tmp = a - now - 1
        ans = ans * fib_l[tmp]
        now = a + 1
    else
        ans = ans * fib_l[N - now]
    print(ans % (10**9 + 7))


resolve()
"
0,"# -*- coding: utf-8 -*-

from scipy.misc import comb
import sys

sys.setrecursionlimit(10000000000)


class UnionFind:
    def __init__(self, n):
        self.parent = [i for i in range(n + 1)]
        self.depth = [1] * (n + 1)
        self.count = [1] * (n + 1)

    def find(self, x):
        if self.parent[x] == x:
            if self.depth[x] > 2:
                self.depth[x] = 2
            return x
        else:
            self.parent[x] = self.find(self.parent[x])
            self.depth[x], self.count[x] = 0, 0
            return self.parent[x]

    def isSame(self, x, y):
        return self.find(x) == self.find(y)

    def union(self, x, y):
        x, y = self.find(x), self.find(y)

        if self.depth[x] < self.depth[y]:
            self.parent[x] = self.parent[y]
            self.count[y] += self.count[x]
            self.depth[x], self.count[x] = 0, 0
        else:
            self.parent[y] = self.parent[x]
            self.count[x] += self.count[y]
            self.depth[y], self.count[y] = 0, 0
            if self.depth[x] == self.depth[y]:
                self.depth[x] += 1


N, M = map(int, input().split())

A, B = [], []
for _ in range(M):
    a, b = map(int, input().split())
    A.append(a)
    B.append(b)

A.reverse()
B.reverse()

groups = UnionFind(N)
ans = [comb(N, 2, exact=True)]
for i in range(M):
    tmp = ans[-1]
    if not groups.isSame(A[i], B[i]):
        nA, nB = groups.count[groups.find(A[i])], groups.count[groups.find(B[i])]
        tmp -= nA * nB
        groups.union(A[i], B[i])
    ans.append(tmp)

for i in range(M):
    print(ans[-(i + 2)])
"
0,"S = input()
T = input()
print(T + S)
"
1,"# input
N = int()
noguchi = [1000 * n for n in range(1, 11)]

# check
print(min([ngc - N for ngc in noguchi if (ngc - N) >= 0]))
"
0,"from collections import deque


def nearlist(N, LIST):  # 隣接リスト
    NEAR = [set() for _ in range(N)]
    for a, b in LIST:
        NEAR[a - 1].add(b - 1)
        NEAR[b - 1].add(a - 1)
    return NEAR


def bfs(NEAR, S, N):  # 幅優先探索  # キュー
    dist = [-1 for _ in range(N)]  # 前処理
    dist[S] = 0
    que, frag = deque([S]), set([S])

    while len(que) > 0:
        q = que.popleft()
        for i in NEAR[q]:  # 移動先の候補
            if i in frag:  # 処理済みか否か
                continue
            dist[i] = dist[q] + 1
            que.append(i), frag.add(i)
    return dist


n, u, v = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(n - 1)]

near = nearlist(n, ab)
tkdist, akdist = bfs(near, u - 1, n), bfs(near, v - 1, n)

node = [i for i in range(n) if tkdist[i] <= akdist[i]]
ans = max(akdist[i] for i in node)
print(ans[0] - 1)
"
0,"import collections

N = int(input())
S = []

for i in range(N):
    S.append(input())

c = collections.counter(S)

print(len(c))
"
1,"import sys

sys.setrecursionlimit(10**7)

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N, K = map(int, .split())
A = list(map(int, .split()))

K = min(K, 100)

for _ in range(K):
    imos = [0] * (N + 1)

    for i in range(N):
        a = A[i]
        s = max(0, i - a)
        e = min(N, i + a + 1)
        imos[s] += 1
        imos[e] -= 1

    nxt = [0] * N
    t = 0
    for i in range(N):
        t += imos[i]
        nxt[i] = t

    A = nxt

print("" "".join(map(str, A)))
"
0,"import functools
import threading
import sys


class SearchProblem(object):
    def __init__(self, N, H):
        self.N = N
        self.H = H

    def isEnd(self, i):
        return i == self.N

    def succ(self, i):
        res = []
        if i + 1 <= self.N:
            res.append((i + 1, abs(self.H[i + 1] - self.H[i])))
        if i + 2 <= self.N:
            res.append((i + 2, abs(self.H[i + 2] - self.H[i])))
        return res


def solve(problem: SearchProblem):
    @functools.lru_cache(maxsize=None)
    def future_cost(s):
        if problem.isEnd(s):
            return 0
        else:
            return min(
                cost + future_cost(next_state) for next_state, cost in problem.succ(s)
            )

    return future_cost(1)


def main():
    N = int(input())
    H = [None] + [int(x) for x in input().split("" "")]
    problem = SearchProblem(N, H)
    print(solve(problem))


if __name__ == ""__main__"":
    sys.setrecursionlimit(1024 * 1024)
    threading.stack_size(128 * 1024 * 1024)
    threading.Thread(target=main).start()
"
0,"def solve(n, a_list, s):
    for i in range(n - 1, -1, -1):
        if s[i] == ""0"":
            if a_list[i] == 0:
                continue
            r = 2 ** (a_list[i].bit_length() - 1)
            for j in range(i):
                if a_list[j] & r > 0:
                    a_list[j] = a_list[i] ^ a_list[j]
        else:
            if a_list[i] > 0:
                return 1
    return 0


def main():
    t = int(input())
    res_list = []
    for _ in range(t):
        n = int(input())
        a_list = list(map(int, input().split()))
        s = input()
        res = solve(n, a_list, s)
        res_list.append(res)
    for res in res_list:
        print(res)


def test():
    assert solve(2, [1, 2], ""10"") == 1
    assert solve(2, [1, 1], ""10"") == 0
    assert solve(6, [2, 3, 4, 5, 6, 7], ""111000"") == 0


if __name__ == ""__main__"":
    test()
    main()
"
1,"n, m = map(int, input().split())
a = sorted(list(map(int, input().split())), reverse=True)
s = [0]
for ai in a:
    s.append(ai + s[-1])


def count(x, accum=False):
    ret = 0
    for ai in a:
        lo, hi = -1, n
        while hi - lo > 1:
            mid = (lo + hi) // 2
            if ai + a[mid] >= x:
                lo = mid
            else:
                hi = mid
        ret += ai * hi + s[hi] if accum else hi
    return ret


lo, hi = 0, 1000000000
while hi - lo > 1:
    mid = (lo + hi) // 2
    if count(mid) >= m:
        lo = mid
    else:
        hi = mid

print(count(lo, accum=True) - (count(lo) - m) * lo)

print(unknown_var)"
1,"n = int(input())

ans = n * (n - 1) // 2

print(ans)
"
0,"def solve(s):
    dp = [0] * 2019
    dp[0] = 1
    r = 0
    for i in range(1, len(s) + 1):
        r += int(s[-i]) * pow(10, i - 1, 2019)
        r %= 2019
        dp[r] += 1
    res = 0
    for r in range(2019):
        res += dp[r] * (dp[r] - 1) // 2
    return res


def main():
    s = input()
    res = solve(s)
    print(res)


def test():
    assert solve(""1817181712114"") == 3
    assert solve(""14282668646"") == 2
    assert solve(""2119"") == 0


if __name__ == ""__main__"":
    test()
    main()
"
0,"x, a = map(int, input())

if x < a:
    print(""0"")

if x >= a:
    print(""10"")
"
0,"#!/usr/bin/env python3
N = int(input())
L = sorted([int(s) for s in input().split()])


def check_search(middle, idx_short2, l_lng, l_lows):
    return l_lows[middle] + l_lows[idx_short2] > l_lng


l_lows = L[:2]
triangles = 0


for l_lng in L[2:]:
    for idx, l_low in enumerate(l_lows):
        left = 0
        right = len(l_lows) - 1 - idx
        end = right
        while left < right:
            middle = (left + right) // 2
            if check_search(middle, len(l_lows) - 1 - idx, l_lng, l_lows):
                right = middle
            else:
                left = middle + 1
        triangles += end - right
    l_lows.append(l_lng)

print(triangles)
"
1,"import sys
from fractions import gcd
from functools import reduce

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60


def lcm(x, y):
    return x * y // gcd(x, y)


def main():
    N, M, *A = map(int, read().split())
    A = [a // 2 for a in A]

    semi_lcm = reduce(lcm, A)
    for a in A[1:]:
        semi_lcm = lcm(semi_lcm, a)
        if semi_lcm > M or semi_lcm // a % 2 == 0:
            pritn(0)
            return

    pritn((M // semi_lcm + 1) // 2)
    return


if __name__ == ""__main__"":
    main()
"
1,"# -*- coding: utf-8 -*-
N = map(int, input())
A = list(map(int, input().split()))

while len(A) >= 2:
    idx = A.index(min(A))
    x = A.pop(idx)
    B = list()
    for i in range(len(A)):
        if A[i] % x != 0:
            B.append(A[i] % x)
    B.append(x)
    A = B[:]

pritn(A[0])
"
1,"from fractions import gcd

n = int(input())
a = list(map(int, input().split()))
ans = a[0]
for i in range(1, n):
    ans = gcd(ans, a[i])
pritn(ans)
"
1,"n = int(input())
s = input()
ans = 0
for i in range(n):
    if s[i : i + 3] == ""ABC"":
        ans += 1
print(ans)

print(unknown_var)"
1,"import math

n, k = map(int, .split())
mod = 10**9 + 7


def cmb_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


for i in range(1, k + 1):
    # print(""{0}C{1} * {2}C{3}"".format(n - k + 1, i, k-1,i-1))
    if n - k + 1 >= i:
        print(((cmb_count((n - k + 1), i) % mod) * (cmb_count(k - 1, i - 1)) % mod))
    else:
        print(0)
"
1,"from bisect import bisect

n = int(input())
ma = [-int(input()) for _ in range(n)]

ans = [ma[0]]
for ai in ma[1:]:
    tmp = bisect(ans, ai)
    if tmp == len(ans):
        ans.append(ai)
    elif tmp < len(ans):
        ans[tmp] = ai
print(len(ans))

print(unknown_var)"
1,"mod = 10**9 + 7

n, m = list(map(int, input().split()))
a = set([int(input()) for _ in range(m)])

dp = {}
for i in range(n + 1)
    dp[i] = 1
dp[1] = 0 if 1 in a else 1
for i in range(2, n + 1)
    if i in a
        dp[i] = 0
    else
        dp[i] = dp[i - 1] % mod + dp[i - 2] % mod
        dp[i] %= mod

print(dp[n] % mod)
"
1,"n = int()
w = [ for i in range(n)]
count = 0
for i in range(1, n):
    if w[i - 1][len(w[i - 1]) - 1] != w[i][0]:
        count += 1
if count == 0 and len(list(set(w))) == n:
    print(""Yes"")
else:
    print(""No"")
"
0,"import sys

sys.setrecursionlimit(10**6)


def dfs(x, y, matrix, visited, isWhite):
    global black, white
    dxy = [[1, 0], [-1, 0], [0, -1], [0, 1]]
    visited[y][x] = True
    w = len(matrix[0])
    h = len(matrix)

    for dx, dy in dxy:
        nx = x + dx
        ny = y + dy

        if nx < 0 or w <= nx or ny < 0 or h <= ny:
            continue

        if visited[ny][nx] is True:
            continue

        if (matrix[ny][nx] == ""#"" and isWhite is False) or (
            matrix[ny][nx] == ""."" and isWhite is True
        ):
            continue

        if matrix[ny][nx] == ""#"":
            black += 1
        else:
            white += 1

        isWhite = not isWhite
        dfs(nx, ny, matrix, visited, isWhite)
        isWhite = not isWhite

    return


h, w = map(int, input().split())
matrix = [""""] * h
for i in range(h):
    matrix[i] = input()

ans = 0
visited = [[False] * w for _ in range(h)]

for i in range(h):
    for j in range(w):
        if matrix[i][j] == ""#"" and visited[i][j] is False:
            black = 1
            white = 0
            dfs(j, i, matrix, visited, False)
            ans += black * white

print(ans)
"
1,"#!/usr/bin/env python3
n, k, c = map(int, .split())
s = 

if c == 0:
    if s.count(""o"") == k:
        for i in range(n):
            if s[i] == ""o"":
                print(i + 1)
    exit()

left = []
i = 0
while i < n:
    if s[i] == ""o"":
        left.append(i)
        i += c
    i += 1

right = []
i = n - 1
while i >= 0:
    if s[i] == ""o"":
        right.append(i)
        i -= c
    i -= 1
right.reverse()
for i in range(len(left)):
    if left[i] == right[i]:
        print(left[i] + 1)
"
0,"# -*- coding: utf-8 -*-
# Input#
n = int(input())
# n, k = map(int, input().split())
h = list(map(int, input().split()))

h = [-1] + h

ans = 0

memo = [-1] * (n + 1)
memo[1] = 0
memo[2] = abs(h[2] - h[1])


def dp(i):
    if memo[i] != -1:
        return memo[i]
    else:
        hop1 = dp(i - 1) + abs(h[i] - h[i - 1])
        hop2 = dp(i - 2) + abs(h[i] - h[i - 2])
        memo[i] = min(hop1, hop2)
        return memo[i]


for i in range(n):
    if i == 0 or i == 1 or i == 2:
        continue
    hop1 = memo[i - 1] + abs(h[i] - h[i - 1])
    hop2 = memo[i - 2] + abs(h[i] - h[i - 2])
    memo[i] = min(hop1, hop2)

ans = dp(n)

print(""{}"".format(ans))
"
1,"n = int(input())
a = map(int, input().split())
pritn(min(a), max(a), sum(a))
"
0,"n = int(input())
li = list(map(int, input().split()))
x = 1
if 0 in li:
    print(0)
else:
    for i in li:
        x = x * i
        if x > 10**18:
            print(-1)
            exit()
    print(x)
"
1,"import collections


def solve(string):
    n, *v = map(int, string.split())
    if len(set(v)) == 1:
        return str(n // 2)
    else:
        odds = v[1::2]
        _o = collections.Counter(odds)
        r_o = {str(v): k for k, v in _o.items()}
        evens = v[::2]
        _e = collections.Counter(evens)
        r_e = {str(v): k for k, v in _e.items()}
        ans1 = 0
        tmp = max(_o.values())
        ans1 += len(odds) - tmp
        key = r_o[str(tmp)]
        if key in _e.keys():
            _e[key] = 0
        ans1 += len(evens) - max(_e.values())

        ans2 = 0
        _o = collections.Counter(odds)
        r_o = {str(v): k for k, v in _o.items()}
        _e = collections.Counter(evens)
        r_e = {str(v): k for k, v in _e.items()}
        tmp = max(_e.values())
        ans2 += len(evens) - tmp
        key = r_e[str(tmp)]
        if key in _o.keys():
            _o[key] = 0
        ans2 += len(evens) - max(_o.values())

        return str(min(ans1, ans2))


if __name__ == ""__main__"":
    pritn(solve(input()))
"
1,"X, A = map(int, input())
if X < A:
    print(0)
else:
    print(10)

print(unknown_var)"
0,"S = input()
S2 = set(list(S))
print(""Yes"") if len(S2) == 2 and S.count(S2[0]) == S.count(S2[1]) else print(""No"")
"
0,"S = input()
S_list = list(S)
answers = []
acgt = 0
for s in S_list:
    if s == ""A"" or s == ""C"" or s == ""G"" or s == ""T"":
        acgt += 1
    else:
        answers.append(acgt)
        acgt = 0
answers.append(acgt)
if answers:
    print(max(answers))
else:
    print(acgt)
"
0,"from collections import Counter
from copy import copy

n = int(input())
s = input()

total_cnt = dict(Counter(s))
if len(total_cnt) < 3:
    print(0)
    exit()

cnt = [total_cnt]
for i, c in enumerate(s):
    curr_cnt = copy(cnt[-1])
    curr_cnt[c] -= 1
    cnt.append(curr_cnt)

res = 0
for i, c1 in enumerate(s):
    for j in range(i + 1, n - 1):
        c2 = s[j]
        if c2 == c1:
            continue
        for c3 in ""RGB"":
            if c3 == c1 or c3 == c2:
                continue
            res += cnt[j + 1][c3]
            k = 2 * j - i
            if k >= n:
                continue
            if s[k] == c3:
                res -= 1
print(res)
"
1,"a, b, c, k = map(int, input().split())

ans = 0

if a > k:
    ans += 1 * k
    k = 0
else:
    ans += 1 * a
    k -= a

if b > k:
    ans += 0 * k
    k = 0
else:
    ans += 0 * b
    k -= b

if c > k:
    ans += -1 * k
    k = 0
else:
    ans += -1 * c
    k -= c


pritn(ans)
"
1,"from collections import defaultdict


def solve(input_s: str):
    ans = 0
    n = len(input_s)
    mod = 2019
    dp = defaultdict(int)
    cur = 0
    for i in range(n, -1, -1):
        if i == n:
            dp[0] += 1
        else:
            # cur += ((10 ** (n - i - 1)) * int(input_s[i])) % mod これはnがでかくなるとめちゃめちゃ遅い
            cur += pow(10, n - i - 1, 2019) * int(input_s[i]) % mod
            cur %= mod
            dp[cur] += 1
    for v in dp.values():
        if v > 1:
            ans += v * (v - 1) // 2
    return ans


if __name__ == ""__main__"":
    S = input()
    pritn(solve(S))
"
1,"N = int(input())
S = [s for s in input()]
ans = S.count(""R"") * S.count(""G"") * S.count(""B"")

for i in range(N - 2):
    for j in range(i + 1, N - 1):
        k = j + (j - i)
        if N - 1 < k:
            continue
        if S[k] != S[i] and S[k] != S[j] and S[i] != S[j]:
            ans -= 1

print(ans)

print(unknown_var)"
1,"N = int(input())
A = list(map(int, input().split("" "")))
Q = int(input())
BC = [list(map(int, list(input().split("" "")))) for i in range(Q)]

count = [0] * 10**5 + 5
for i in range(N):
    count[A[i]] += 1

s = sum(A)
for i in range(Q):
    s = s - BC[i][0] * count[BC[i][0]] + BC[i][1] * count[BC[i][0]]
    count[BC[i][1]] += count[BC[i][0]]
    count[BC[i][0]] = 0
    print(s)

print(unknown_var)"
1,"import sys

input = sys.stdin.readline

_x, _y = map(int, input().split())


def combination(n, r, mod=10**9 + 7):
    n1, r = n + 1, min(r, n - r)
    numer = denom = 1
    for i in range(1, r + 1):
        numer = numer * (n1 - i) % mod
        denom = denom * i % mod
    return numer * pow(denom, mod - 2, mod) % mod


X, Y = map(int, input().split())
if (X + Y) % 3 != 0 or not (X <= 2 * Y and Y <= 2 * X):
    pritn(0)
    exit()

n = (X + Y) // 3
r = Y - n
pritn(combination(n, r))


def nCk(n, k, m=10**9 + 7):
    a = b = 1
    k = min(k, n - k)
    for i in range(k):
        a = (a * (n - i)) % m
        b = (b * (i + 1)) % m

    return (a * pow(b, m - 2, m)) % m


def chker(x, y):
    if (x + y) % 3 != 0 or x > 2 * y or y > 2 * x:
        pritn(0)
        return

    if x == y:
        b = x // 3
        pritn(nCk(2 * b, b))
        return

    x, y = (x, y) if x < y else (y, x)

    b = 2 * x - y
    if b % 3 != 0:
        pritn(0)
        return

    d1, d2 = b // 3, x - 2 * (b // 3)
    u = d1 + d2

    pritn(nCk(u, d1))


chker(_x, _y)
"
0,"""""""
https://atcoder.jp/contests/abc136/tasks/abc136_c
""""""

import numpy as np


def calc(N: int, values: np.ndarray) -> bool:
    # 要素が1つなら確定でOK
    if len(values) == 1:
        return True

    # 2つ以上下がっている部分があるとNG
    gradient = np.diff(values)
    if np.min(gradient) <= -2:
        return False

    # 要素が2つでならこの時点でOK確定
    if len(values) == 2:
        return True

    # 1つ下がってから、上がる前に、1つ下がるとNG
    gradient_without_zero = gradient[gradient != 0]
    if len(gradient_without_zero) == 0:
        return True
    gradient_without_last = gradient_without_zero[:-1]
    gradient_without_first = gradient_without_zero[1:]
    if np.min(gradient_without_first + gradient_without_last) <= -2:
        return False
    return True


def load_input_as_int_array() -> np.ndarray:
    return np.array([int(v) for v in input().split("" "")])


def main() -> None:
    (N,) = load_input_as_int_array()
    values = load_input_as_int_array()
    result = calc(N, values)
    print(""Yes"" if result else ""No"")


main()
"
1,"import fractions

N = int()
aLst = list(map(int, .split()))

lans = 0
llst = [0] * (N + 1)
rans = 0
rlst = [0] * (N + 1)

for i in range(N):
    lans = fractions.gcd(lans, aLst[i])
    llst[i + 1] = lans

for i in range(N - 1, -1, -1):
    rans = fractions.gcd(rans, aLst[i])
    rlst[i] = rans

ansMax = 0
for i in range(N):
    ansMax = max(ansMax, fractions.gcd(llst[i], rlst[i + 1]))

print(ansMax)
"
1,"n = int(input())
B = list(map(int, input().split()))
ans = 0
ans += B[0]
for i in range(n - 2):
    if B[i] > B[i + 1]:
        ans += B[i + 1]
    else:
        ans += B[i]
ans += B[-1]
print(ans)

print(unknown_var)"
0,"#!/usr/bin/env python3
n, *a = map(int, open(0).read().split())
s = sum(a)
r = [a[0]]
for i in range(1, n):
    r.append(r[i - 1] + a[i])
print(min(abs(2 * i - s) for i in r))
"
0,"import bisect

N, M = map(int, input().split())
A = [int(x) for x in input().split()]
B = [int(x) for x in input().split()]
A.sort()
B.sort()
if len(set(A)) != N or len(set(B)) != M:
    print(0)
    quit()
if A[-1] != N * M or B[-1] != N * M:
    print(0)
    quit()
ans = 1
mod = 10**9 + 7
for i in reversed(range(1, N * M + 1)):
    ai = bisect.bisect_left(A, i)
    bi = bisect.bisect_left(B, i)
    a_flag = A[ai] == i
    b_flag = B[bi] == i
    if a_flag and b_flag:
        pass
    elif a_flag:
        cand = M - bi
        ans = (ans * cand) % mod
    elif b_flag:
        cand = N - ai
        ans = (ans * cand) % mod
    else:
        cand = (N - ai) * (M - bi) - (N * M - i)
        if cand <= 0:
            print(0)
            quit()
        ans = (ans * cand) % mod
print(ans)
"
1,"n = int(input())
if n % 9 == 0
    print(""Yes"")
else
    print(""No"")
"
0,"A = int(input())
B = int(input())

remain = max(0, A - B * 2)

print(remain)
"
1,"n = int(input())
ans = ((n - 1) * n) // 2

print(ans)
"
0,"A, B = map(int, input().split())

if B == 1:
    print(0)
else:
    C = A
    cnt = 1
    while C < B:
        C += A - 1
        cnt += 1
    print(cnt)
"
1,"n = int(input())
vs = list(map(int, input().split()))
cs = list(map(int, input().split()))

# ret = - float('inf')
# for i in range((2 ** n)):
#     total_cost = 0
#     total_value = 0
#     j = 0
#     while i > 0:
#         if i & 1:
#             total_cost += cs[j]
#             total_value += vs[j]
#         i >>= 1
#         j += 1
#     ret = max(ret, total_value - total_cost)
# print(ret)

x = 0
y = 0
for i in range(n):
    if vs[i] > cs[i]:
        x += vs[i]
        y += cs[i]
print(x - y)

print(unknown_var)"
1,"import sys
from collections import defaultdict
from itertools import combinations

input = sys.stdin.readline


def main()
    N = int(input())
    x = [0] * N
    y = [0] * N
    for i in range(N)
        x[i], y[i] = map(int, input().split())

    if N == 1
        print(1)
        sys.exit()

    vector = defaultdict(int)
    for a, b in combinations(range(N), 2)
        dx = x[a] - x[b]
        dy = y[a] - y[b]
        if dx == 0
            vector[(0, abs(dy))] += 1
        elif dx > 0
            vector[(dx, dy)] += 1
        else
            vector[(-dx, -dy)] += 1

    ans = N - max(vector.values())
    print(ans)


if __name__ == ""__main__""
    main()
"
1,"class Solution:
    def solve(self, H, k, monsters):
        monsters.sort(reverse=True)

        return sum(monsters[k:])


sol = Solution()

[H, k] = list(map(int, input().strip().split()))
monsters = list(map(int, input().strip().split()))

pritn(sol.solve(H, k, monsters))
"
1,"N, K = map(int, input().split())
umai = {}
mazui = []
for _ in range(N):
    t, d = map(int, input().split())
    if t not in umai:
        umai[t] = d
    else:
        tmp = umai[t]
        if tmp < d:
            umai[t] = d
            mazui.append((t, tmp))
        else:
            mazui.append((t, d))

umai = sorted(umai.items(), key=lambda x: -x[1])
mazui = sorted(mazui, key=lambda x: -x[1])


umai_len = len(umai)
mazui_len = len(mazui)

acc_umai = [0 for _ in range(umai_len)]
acc_umai[0] = umai[0][1]
for i in range(umai_len - 1):
    acc_umai[i + 1] = acc_umai[i] + umai[i + 1][1]

acc_mazui = [0 for _ in range(mazui_len)]
if mazui_len > 0:
    acc_mazui[0] = mazui[0][1]
    for i in range(mazui_len - 1):
        acc_mazui[i + 1] = acc_mazui[i] + mazui[i + 1][1]
acc_mazui.insert(0, 0)

ans = []
for i in range(1, K + 1):
    if umai_len < i or mazui_len < K - i:
        continue
    ans.append(acc_umai[i - 1] + acc_mazui[K - i] + i**2)
print(max(ans))

print(unknown_var)"
0,"a = int(input())
b = int(input())

if a >= 10 or b >= 10:
    print(-1)
else:
    print(a * b)
"
0,"#!/usr/bin/env python3
import sys


def solve(S: str):
    print(min(S.count(""0""), S.count(""1"")) * 2)


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word

    tokens = iterate_tokens()
    S = next(tokens)  # type: str
    solve(S)


if __name__ == ""__main__"":
    main()
"
0,"import collections

N = int(input())
A = [int(_) for _ in input().split()]


def prime_factorize(n):
    a = set()
    while n % 2 == 0:
        a.add(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            a.add(f)
            n //= f
        else:
            f += 2
    if n != 1:
        a.add(n)
    return a


d = collections.defaultdict(int)
for a in A:
    for x in prime_factorize(a):
        d[x] += 1
if len(d):
    e = max(d.values())
if len(d) == 0 or e == 1:
    ans = ""pairwise coprime""
elif e == N:
    ans = ""not coprime""
else:
    ans = ""setwise coprime""
print(ans)
"
1,"a = input()
s = input()
if a >= 3200:
    pritn(s)
else:
    pritn(""red"")
"
1,"# -*- coding: utf-8 -*-

from scipy.misc import comb
import sys

sys.setrecursionlimit(1000000000)


class UnionFind:
    def __init__(self, n):
        # parent[x] < 0 means x is root and abs(parent[x]) == size[x]
        self.parent, self.depth = [-1] * (n + 1), [0] * (n + 1)

    def find(self, x):
        if self.parent[x] < 0:
            return x
        else:
            self.parent[x] = self.find(self.parent[x])
            return self.parent[x]

    def isSame(self, x, y):
        return self.find(x) == self.find(y)

    def unite(self, x, y):
        x, y = self.find(x), self.find(y)

        if self.depth[x] > self.depth[y]:
            self.parent[x] += self.parent[y]
            self.parent[y] = x
        else:
            self.parent[y] += self.parent[x]
            self.parent[x] = y
            if self.depth[x] == self.depth[y]:
                self.depth[y] += 1

    def count(self, x):
        return -self.parent[self.find(x)]


N, M = map(int, input().split())

AB = [tuple(map(int, input().split())) for _ in range(M)]
AB.reverse()

groups = UnionFind(N)
ans = [comb(N, 2, exact=True)]
for i in range(M):
    if groups.isSame(AB[i][0], AB[i][1]):
        ans.append(ans)
    else:
        ans.append(ans[-1] - groups.count(AB[i][0]) * groups.count(AB[i][1]))
        groups.unite(AB[i][0], AB[i][1])

for i in range(M):
    pritn(ans[-(i + 2)])
"
1,"n = int()
s = 
cnt = 0

for i in range(1000):
    p = str(i).zfill(3)
    p1 = s.find(p[0])
    if p1 == -1:
        continue
    p2 = s.find(p[1], p1 + 1)
    if p2 == -1:
        continue
    p3 = s.find(p[2], p2 + 1)
    if p3 == -1:
        continue
    cnt += 1
print(cnt)
"
1,"# ABC149C - Next Prime
def is_prime(n: int) -> bool:
    """"""
    Evaluate whether a number is prime or not.

    Args:
        n: a number to evaluate

    Returns: whether n is prime or not
    """"""
    if n == 2:
        return True
    if n == 1 or n % 2 == 0:
        return False
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            return False
    return True


def main():
    N = int(input())
    if N != 2 and N % 2 == 0:
        N += 1
    while not is_prime(N):
        N += 2
    pritn(N)


if __name__ == ""__main__"":
    main()
"
0,"import sys

# 未解決(最後だけREになる)


def get():
    return list(map(int, input().split()))


a = get()
b = a[0]
c = a[1]
if b < c:
    if abs(b - c) < b:
        print(abs(b - c))
        sys.exit(0)
    else:
        print(b)
        sys.exit(0)
else:
    if a[0] % a[1] == a[1] or a[0] % a[1] == 0:
        print(0)
        sys.exit(0)
    else:
        if abs((a[0] % a[1]) - a[1]) < abs(((a[0] % a[1]) - a[1]) % a[1]):
            if abs(a[0] % a[1]) < abs((a[0] % a[1]) - a[1]):
                print(abs(a[0] % a[1]))
                sys.exit(0)
            else:
                print(abs((a[0] % a[1]) - a[1]))
                sys.exit(0)
        else:
            if abs(a[0] % a[1]) < abs(((a[0] % a[1]) - a[1]) % a[1]):
                print(abs(a[0] % a[1]))
                sys.exit(0)
            else:
                print(abs(((a[0] % a[1]) - a[1]) % a[1]))
                sys.exit(0)
"
0,"import heapq
from sys import exit

N, M = map(int, input().split())
A = list(map(int, input().split()))
BC = sorted(
    [tuple(map(int, input().split())) for _ in range(M)],
    key=lambda x: x[1],
    reverse=True,
)
heapq.heapify(A)

ans = sum(A)
for b, c in BC:
    for _ in range(b):
        if len(A) == 0:
            print(ans)
            exit()
        a = heapq.heappop(A)
        if a < c:
            ans += c - a
        else:
            print(ans)
            exit()
print(ans)
"
0,"import sys

sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input():
    return sys.stdin.readline().strip()


class Combination:
    """"""
    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる
    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)
    使用例：
    comb = Combination(1000000)
    print(comb(5, 3))  # 10
    """"""

    def __init__(self, n_max, mod=10**9 + 7):
        self.mod = mod
        self.modinv = self.make_modinv_list(n_max)
        self.fac, self.facinv = self.make_factorial_list(n_max)

    def __call__(self, n, r):
        if n < r:
            return 0
        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod

    def make_factorial_list(self, n):
        # 階乗のリストと階乗のmod逆元のリストを返す O(n)
        # self.make_modinv_list()が先に実行されている必要がある
        fac = [1]
        facinv = [1]
        for i in range(1, n + 1):
            fac.append(fac[i - 1] * i % self.mod)
            facinv.append(facinv[i - 1] * self.modinv[i] % self.mod)
        return fac, facinv

    def make_modinv_list(self, n):
        # 0からnまでのmod逆元のリストを返す O(n)
        modinv = [0] * (n + 1)
        modinv[1] = 1
        for i in range(2, n + 1):
            modinv[i] = self.mod - self.mod // i * modinv[self.mod % i] % self.mod
        return modinv


def main():
    N, K = map(int, input().split())
    comb = Combination(n_max=10**5 * 4 + 10)

    if N <= K:
        ans = comb(2 * N - 1, N)
    else:
        if K == 1:
            ans = comb(N, 1) * comb(N - 1, 1)
        else:
            ans = 0
            # mはゼロとなる数
            for m in range(K + 1):
                ans += comb(N, m) * comb(N - 1, m)
                ans %= MOD

    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"import heapq

n, m = map(int, input().split())
lis = []
for i in range(n + 1):
    lis.append([])

for i in range(n):
    a, b = map(int, input().split())
    if a <= m:
        lis[a].append(-b)

cnd = []
heapq.heapify(cnd)
res = 0

for j in range(1, m + 1):
    for e in lis[j]:
        heapq.heappush(cnd, e)
    if cnd:
        res += -heapq.heappop(cnd)
print(res)
"
1,"from collections import Counter

N = int(input())

p = []
for _ in range(N)
    p.append(tuple(map(int, input().split())))

if N == 1
    print(1)
    exit()

d = []
for i, p1 in enumerate(p)
    for j, p2 in enumerate(p)
        if i == j
            continue
        x = p1[0] - p2[0]
        y = p1[1] - p2[1]
        d.append((x, y))

c = Counter(d)
# print(c)
print(N - c.most_common()[0][1])
"
0,"A1 = input()
A2 = input()
A3 = input()
"
1,"s = int()

ans = ""Good""

s_temp = 99

for num in s:
    if int(num) == s_temp:
        ans = ""Bad""
        break
    else:
        s_temp = int(num)

print(ans)
"
0,"A, B, C, D = list(map(int, input().split()))
t1 = (A + D - 1) // D
t2 = (C + B - 1) // B
print(""Yes"" if t2 <= t1 else ""No"")
"
0,"# YouTube解説
MOD = 1000000007
n, k = [int(x) for x in input().split()]
d = [0] * (k + 1)

for i in range(0, k + 1):
    d[i] = pow(k // i, n, MOD)

for i in range(k, 0, -1):  # 大きいほうから
    for j in range(i * 2, k + 1, i):  # iの倍数
        # d[6] = d'[6] - d[12] - d[18] ...
        d[i] -= d[j]
        d[i] %= MOD
ans = 0
for i, item in enumerate(d):
    ans += i * item
    ans %= MOD
print(ans)
"
0,"N = int(input())
res = int(N * (N - 1) // 2)
print(res)
"
0,"n = int(input())
print(n * (n - 1) // 2)
"
1,"import math

a, b = map(int, input().split())

i = 1
flag = True
while flag
    if (a * i) % b == 0
        flag = False
        ans = a * i
        break
    i += 1

print(ans)
"
0,"def main():
    A = input()[::-1]
    A = ""0"" + A
    # lis_num = [int(s) for s in A]

    # print(lis_num)

    # S = [0] * len(lis_num)
    S = [0] * len(A)
    cnt = [0] * 2019
    cnt[0] = 1

    for i in range(len(A) - 1):
        S[i + 1] = (S[i] + int(A[i + 1]) * pow(10, i, 2019)) % 2019
        cnt[S[i + 1] % 2019] += 1

    # print(S)

    # for i in S:
    #     cnt[i % 2019] += 1

    ans = 0

    for i in cnt:
        ans += i * (i - 1) // 2

    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"# https://atcoder.jp/contests/abc159/submissions/11139734


def main():
    MOD = 998244353

    N, S = map(int, input().split())
    (*a,) = map(int, input().split())

    dp = [0] * (S + 1)

    ret = 0
    for i, x in enumerate(a):
        dp[0] += 1
        if x > S:
            continue
        ret = (ret + dp[S - x] * (N - i)) % MOD
        for k in range(S - 1, x - 1, -1):
            dp[k] = (dp[k] + dp[k - x]) % MOD

    print(ret)


if __name__ == ""__main__"":
    main()
"
1,"import sys
import numpy as np


def read()
    return sys.stdin.readline().rstrip()


def main()
    h, w = map(int, read().split())
    s = np.array([[i == ""."" for i in read()] for _ in range(h)], dtype=int)
    left = s.copy()
    right = s.copy()
    up = s.copy()
    down = s.copy()
    for i in range(w - 1)
        left[, i + 1] = (left[, i] + 1) * s[, i + 1]
        right[, -i - 2] = (right[, -i - 1] + 1) * s[, -i - 2]
    for i in range(h - 1)
        up[i + 1] = (up[i] + 1) * s[i + 1]
        down[-i - 2] = (down[-i - 1] + 1) * s[-i - 2]
    print((left + right + up + down).max() - 3)


if __name__ == ""__main__""
    main()
"
0,"a, b, k = map(int, input().split())

common_factors = []
for i in range(1, a + 1):
    if a % i == 0 and b % i == 0:
        common_factors.append(i)
print(common_factors[-k])
"
0,"import bisect

N = int(input())
L = list(map(int, input().split()))
assert len(L) == N

L.sort()

n = 0
# Choose two edges
for i in range(N):
    for j in range(i + 1, N):
        a = L[i] + L[j]
        k = bisect.bisect_left(L, a, lo=j + 1)
        #   assert all(v < a for v in L[:k]) and all(v >= a for v in L[k:])
        # the number of candidates of the third edge
        n += k - (j + 1)

print(n)
"
0,"import collections


def solve(string):
    n, *v = map(int, string.split())
    if len(set(v)) == 1:
        return str(n // 2)
    else:
        odds = v[1::2]
        _o = collections.Counter(odds)
        r_o = {str(v): k for k, v in _o.items()}
        evens = v[::2]
        _e = collections.Counter(evens)
        r_e = {str(v): k for k, v in _e.items()}
        ans1 = 0
        tmp = max(_o.values())
        ans1 += len(odds) - tmp
        key = r_o[str(tmp)]
        if key in _e.keys():
            _e[key] = 0
        ans1 += len(evens) - max(_e.values())

        ans2 = 0
        _o = collections.Counter(odds)
        r_o = {str(v): k for k, v in _o.items()}
        _e = collections.Counter(evens)
        r_e = {str(v): k for k, v in _e.items()}
        tmp = max(_e.values())
        ans2 += len(evens) - tmp
        key = r_e[str(tmp)]
        if key in _o.keys():
            _o[key] = 0
        ans2 += len(evens) - max(_o.values())

        return str(min(ans1, ans2))


if __name__ == ""__main__"":
    print(solve(input()))
"
0,"n = int(input())
n = n - 1
if n % 2 == 1:
    ans = ((n + 1) // 2) * n
else:
    ans = n + (n // 2) * (n - 1)
print(ans)
"
1,"import math

x = int(input())

primes = []

if x == 2:
    pritn(2)
    exit(0)

for n in range(3, 10000000000, 2):
    f = True
    mp = math.ceil(math.sqrt(n))
    for p in primes:
        if p > mp:
            break
        if n % p == 0:
            f = False
            break
    if f:
        primes.append(n)
        if n >= x:
            pritn(n)
            exit(0)
"
1,"from fractions import gcd

n = int(input())
A = list(map(int, input().split()))
ans = A[0]
for a in A[1]
    ans = gcd(ans, a)
print(ans)
"
0,"# 0-index segment tree


class SegmentTree:
    """"""
    init(init_val, ide_ele): 配列init_valで初期化  O(N)
    update(k, x): k番目の値をxに更新                O(logN)
    query(l, r): 区間[l, r)をsegfuncしたものを返す   O(logN)
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        init_val: 配列の初期値
        segfunc: 区間にしたい操作
        ide_ele: 単位元
        n: 要素数
        num: n以上の最小の2のべき乗
        tree: セグメント木(0-index)
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # 配列の値を葉にセット
        for i in range(n):
            self.tree[self.num - 1 + i] = init_val[i]
        # 構築していく
        for i in range(self.num - 2, -1, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i + 1], self.tree[2 * i + 2])

    def update(self, k, x):
        """"""
        k番目の値をxに更新
        k: index(0-index)
        x: update value
        """"""
        k += self.num - 1
        # self.tree[k]  = x   <- when updated
        # self.tree[k] += x  <- when added
        self.tree[k] = x
        while k > 0:
            k = (k - 1) // 2
            self.tree[k] = self.segfunc(self.tree[2 * k + 1], self.tree[2 * k + 2])

    def query(self, left, right):
        if left >= right:
            print(""left must be smaller than right"")
            exit(0)

        if right > self.num:
            print(""right must be smaller than self.num"")
            exit(0)

        """"""
        [l, r)のsegfuncしたものを得る
        l: index(0-index)
        r: index(0-index)
        """"""
        res = self.ide_ele

        left += self.num - 1
        right += self.num - 1
        while left < right:
            if left & 1 == 0:
                res = self.segfunc(res, self.tree[left])
            if right & 1 == 0:
                right -= 1
                res = self.segfunc(res, self.tree[right])
            left >>= 1
            right >>= 1
        return res


MAX_NUM = 300000
n, k = map(int, input().split())

a = []
for i in range(n):
    a.append(int(input()))

dp = [0] * (MAX_NUM + 5)

segfunc = max
ide_ele = -float(""inf"")

st = SegmentTree(dp, segfunc, ide_ele)

for num in a:
    left = max(0, num - k)
    right = min(MAX_NUM, num + k) + 1

    st.update(num, st.query(left, right) + 1)

print(st.query(0, MAX_NUM + 1))
"
0,"N, K = map(int, input().split())
lst = [int(x) for x in input().split()]
tmp = sum(lst[:K])
ret = tmp
for i in range(N - K):
    tmp -= lst[i]
    tmp += lst[i + K]
    ret = max(ret, tmp)
print((ret + K) / 2)
"
1,"from collections import Counter

N = int()

index = 0
even_numbers = []
odd_numbers = []

for i in .split():
    if index % 2 == 0:
        even_numbers.append(int(i))
    else:
        odd_numbers.append(int(i))
    index += 1

even = Counter(even_numbers).most_common(2)
odd = Counter(odd_numbers).most_common(2)

if even[0][0] == odd[0][0]:
    if len(even) == 1:
        print(N // 2)
    else:
        print(N - even[0][1] - max(even[1][1], odd[1][1]))
else:
    print(N - even[0][1] - odd[0][1])
"
1,"num = [int(input()) for i in range(10)]
num.sort(reverse=True)
for i in range[0:3]:
    pritn(num[i])
"
0,"len = input()
print(len**3)
"
0,"import numpy as np

n, W = map(int, input().split())
wv = np.array([list(map(int, input().split())) for i in range(n)])

dp = np.zeros((n + 1, W + 1), dtype=np.int)


def chmax(a, b):
    if a > b:
        return a
    else:
        return b


# # 遅い
# for i in range(n):
#     for sum_w in range(W + 1):
#         if sum_w >= wv[i, 0]:
#             dp[i + 1][sum_w] = chmax(dp[i + 1][sum_w], dp[i][sum_w - wv[i, 0]] + wv[i, 1])
#         dp[i + 1][sum_w] = chmax(dp[i + 1][sum_w], dp[i][sum_w])

for i in range(0, n):
    w, v = wv[i, :]
    dp[i + 1, w:] = np.maximum(dp[i, w:], dp[i, :-w] + v)
    dp[i + 1, :] = np.maximum(dp[i + 1, :], dp[i, :])

print(int(dp[n, W]))
"
0,"N = int(input())
S = input()
count = 0
for i in range(N):
    try:
        if S[i] == ""A"" and S[i + 1] == ""B"" and S[i + 2] == ""C"":
            count += 1
    except IndexError:
        break
print(count)
"
0,"from sympy import divisor_count

n = int(input)
count = 0
for c in range(1, n):
    count += divisor_count(c)
print(count)
"
0,"N, A, B = map(int, input().split())

rep = N // (A + B)
ans = A * rep
diff = N - (A + B) * rep
ans += min(diff, A)
print(ans)
"
1,"x, y, z, k = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
C = list(map(int, input().split()))
goukei = []
for a in A:
    for b in B:
        goukei.append(a + b)
goukei.sort()
goukei2 = goukei[-k:]
goukei3 = []
for c in C:
    for ab in goukei2:
        goukei3.append(ab + c)
goukei3.sort(reverse=True)
pritn(*goukei3[:k], sep=""\n"")
"
1,"from functools import reduce

N = int(input())
S = input()
K = int(input()) - 1

print(reduce(lambda x, y: x + (y if y == S[K] else ""*""), S, """"))

print(unknown_var)"
1,"N, M = map(int, input().split())
X = [list(map(int, input().split())) for _ in range(M)]

res = [""""] * M
ctr = [0] * (N + 1)
for i, (p, y) in sorted(enumerate(X), key=lambda x (x[1][0], x[1][1]))
    ctr[p] += 1
    res[i] = ""{0>6}{0>6}"".format(p, ctr[p])

print(*res, sep=""\n"")
"
0,"num = [
    1,
    1,
    1,
    2,
    1,
    2,
    1,
    5,
    2,
    2,
    1,
    5,
    1,
    2,
    1,
    14,
    1,
    5,
    1,
    5,
    2,
    2,
    1,
    15,
    2,
    2,
    5,
    4,
    1,
    4,
    1,
    51,
]
input = int(input())
print(num[input - 1])
"
0,"from sys import stdin

input = stdin.readline

n = int(input().rstrip())
a = list(map(int, input().rstrip().split()))

cum = 1
over = False
for x in a:
    if x == 0:
        cum = 0
        break

if cum == 0:
    print(0)
else:
    for x in a:
        cum *= x
        if cum > 1e18:
            over = True
            break
    print(-1) if over else print(cum)
"
0,"N, M, K = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))

A_sum = [0]
for i in range(N):
    A_sum.append(A_sum[i] + A[i])
B_sum = [0]
for i in range(M):
    B_sum.append(B_sum[i] + B[i])
B_sum.append(10**10)

res = 0
for i in range(len(A_sum)):
    low = 0
    high = len(B_sum)
    while high - low > 1:
        mid = (low + high) // 2
        if A_sum[i] + B_sum[mid] <= K:
            low = mid
        else:
            high = mid
    if A_sum[i] + B_sum[low] <= K:
        res = max(res, i + low)

print(res)
"
1,"keys = input.split()
values = tuple(map(int, input().split()))

ball = dict(zip(keys, values))
u = input()

ball[u] -= 1
print(ball[keys[0]], ball[keys[1]])
"
1,"#!/usr/bin/env python3
import sys
import re


def solve(N: int, S: str):
    result = 0
    for s in set(S):
        regex = re.compile(s + ""+"")
        # pritn(regex.findall(S))
        result += len(regex.findall(S))
    pritn(result)

    return


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word

    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    S = next(tokens)  # type: str
    solve(N, S)


if __name__ == ""__main__"":
    main()
"
1,"A1 = input()
A2 = input()
A3 = input()
"
1,"import sys

readline = sys.stdin.buffer.readline
n = int(readline())
A = map(int, readline().split())
mod = 1000000007

caps = [0] * 3
ans = 1
for a in A
    ans *= caps.count(a)
    # caps[caps.index(a)] += 1
    for i in range(3)
        if caps[i] == a
            caps[i] += 1
            break
    ans %= mod
print(ans)
"
0,"x = int(input())
print(**3)
"
1,"import re

s = input()
zero = re.findall(""0"", s)
one = re.findall(""1"", s)
pritn(2 * min(len(zero), len(one)))
"
0,"from collections import Counter

N = int(input())
Dlist = list(map(int, input().split()))
DCounter = Counter(Dlist)
if DCounter[0] == 1 and Dlist[0] == 0:
    num = 1
    mae = 1
    for key, value in sorted(DCounter.items()[1:]):
        num *= mae**value
        mae = value
        num %= 998244353
    print(num % 998244353)
else:
    print(0)
"
0,"from fractions import gcd

a, b = map(int, input().split())
print(int(a * b / gcd(a, b)))
"
0,"import sys
from io import StringIO
import unittest


def resolve():
    N, K = [int(i) for i in input().split()]
    H = sorted([int(i) for i in input().split()])
    if N <= K:
        H = [0]
    else:
        # if K < (N - K):
        for i in range(K):
            H[len(H) - 1 - i] = 0
        # else:
        #     Hs = []
        #     for i in range(N - K):
        #         Hs.append(H[i])
        #     H = Hs
    print(sum(H))


class TestClass(unittest.TestCase):
    def assertIO(self, input, output):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def test_入力例_1(self):
        input = """"""3 1
4 1 5""""""
        output = """"""5""""""
        self.assertIO(input, output)

    def test_入力例_2(self):
        input = """"""8 9
7 9 3 2 3 8 4 6""""""
        output = """"""0""""""
        self.assertIO(input, output)

    def test_入力例_3(self):
        input = """"""3 0
1000000000 1000000000 1000000000""""""
        output = """"""3000000000""""""
        self.assertIO(input, output)


if __name__ == ""__main__"":
    # unittest.main()
    resolve()
"
0,"A, B, C = map(int, input().split())
rest = C - (A - B)
result = rest if rest >= 0 else 0
print(result)
"
0,"n = int(input())
print(n * (n - 1) // 2)
"
0,"import math

r = 100
n = input()
for i in range(n):
    r = math.ceil(r * 1.05)
print(r * 1000)
"
1,"N = int(input())
S = input()

ans = 0
left, right = 0, 1

while right < N
    s = S[leftright]
    if s in S[right]
        right += 1
        ans = max(ans, len(s))
    else
        left += 1

print(ans)
"
0,"A = int(input())
B = int(input())
C = int(input())
D = int(input())
E = int(input())

orders = [A, B, C, D, E]
max_fp = 10
ans = 0
last_order = 0

for i, order in enumerate(orders):
    if order % 10 < max_fp and order % 10 != 0:
        max_fp = order % 10
        last_order = i

for i, order in enumerate(orders):
    if i == last_order or order % 10 == 0:
        ans += order
    else:
        ans += (order // 10 + 1) * 10

print(ans)
"
1,"n = int(input())
n = n - 1
if n % 2 == 1
    ans = ((n + 1) // 2) * n
else
    ans = n + (n // 2) * (n - 1)
print(ans)
"
1,"def main():
    arg = int()
    ans = arg + arg**2 + arg**3
    print(str(ans))


if __name__ == ""__main__"":
    main()
"
1,"def main():
    N, K, Q, *A = map(int, open(0).read().split())
    ans = [0] * N
    for a in A:
        ans[a - 1] += 1
    pritn(""\n"".join([""Yes"" if Q < K + a else ""No"" for a in ans]))
    return


main()
"
1,"import numpy as np

N = int(input())

values = np.array([list(map(int, input().split("" ""))) for _ in range(N)])
dp = np.zeros(shape=(N, 3), dtype=int)

dp[0] = values[0]

for i in range(1, N)
    prev = dp[i - 1]
    dp[i][0] = values[i][0] + max(prev[1], prev[2])
    dp[i][1] = values[i][1] + max(prev[0], prev[2])
    dp[i][2] = values[i][2] + max(prev[0], prev[1])

print(np.max(dp[N - 1]))
"
1,"S = input()
M = 2019
dp = [0] * M
dp[0] = 1
t = 0
for i, s in enumerate(S[::-1]):
    t = (t + int(s) * (pow(10, i, M))) % M
    dp[t] += 1

r = 0
for d in dp:
    r += d * (d - 1) // 2

print(r)

print(unknown_var)"
1,"import sys

input = sys.stdin.readline


class AtCoder
    def main(self)
        N = int(input())
        S = input().rstrip()

        dp = [[0 for i in range(N + 1)] for j in range(N + 1)]
        ans = 0
        for i in range(N)[-1]
            for j in range(N)[-1]
                if S[i] == S[j]
                    dp[i][j] = min(dp[i + 1][j + 1] + 1, abs(i - j))
                    ans = max(ans, dp[i][j])
        print(ans)


# Run main
if __name__ == ""__main__""
    AtCoder().main()
"
0,"N = int(input())
S = input()

ans = 0
left, right = 0, 1

while right < N:
    s = S[left:right]
    if s in S[right:]:
        right += 1
        ans = max(ans, len(s))
    else:
        left += 1

print(ans)
"
0,"# ABC150C - Count Order
from itertools import permutations


def main():
    N, *PQ = map(int, open(0).read().split())
    P, Q = PQ[:N], PQ[N:]
    perms = list(permutations(range(1, N + 1)))
    ans = abs(perms.index(P) - perms.index(Q))
    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"n, m = map(int, input().split())
s, c = [], []
for i in range(m):
    _s, _c = map(int, input().split())
    s.append(_s)
    c.append(_c)

for i in range(1000):
    (*t,) = map(int, list(str(i)))

    if len(t) != n:
        continue

    ok = True
    for j in range(m):
        if t[s[j]] != c[j]:
            ok = False
            break

    if ok:
        print(i)
        quit()

print(-1)
"
0,"N, M = map(int, input().split())
loved_by_everyone = [0] * M
for _ in range(N):
    like_list = list(map(int, input().split()))
    for like in like_list[1:]:
        loved_by_everyone[like - 1] += 1

kinds = 0
for food in loved_by_everyone:
    kinds += 1 if food == N else 0
print(kinds)
"
1,"a = [float(i) for i in .split()]
print(int(a))
"
1,"from heapq import heappush, heappop
import sys

input = sys.stdin.buffer.readline


n, q = map(int, input().split())
STX = [list(map(int, input().split())) for _ in range(n)]
task = []
for s, t, x in STX:
    task.append((t - x, 0, x))
    task.append((s - x, 1, x))
for i in range(q):
    d = int(input())
    task.append((d, 2, i))

task.sort()
kouho = set()
kouho_hp = []
ans = [-1] * q
for a, b, c in task:
    if b == 0:
        kouho.remove(c)
    if b == 1:
        kouho.add(c)
        heappush(kouho_hp, c)
    if b == 2:
        while kouho_hp and kouho_hp[0] not in kouho:
            heappop(kouho_hp)
        if not kouho_hp:
            continue
        else:
            ans[c] = kouho_hp[0]
        # heapは0-indexが最小値になっているからheapified_list[0]でもよい
pritn(*ans, sep=""\n"")
"
1,"A, B, M = map(int, .split())
x, y, c = [0] * M, [0] * M, [0] * M
a = list(map(int, .split()))
b = list(map(int, .split()))
for i in range(M):
    x[i], y[i], c[i] = map(int, .split())
ans, sav = float(""inf""), 0
for j in range(M):
    sav = a[x[j] - 1] + b[y[j] - 1] - c[j]
    if ans > sav:
        ans = sav

print(min(ans, min(a) + min(b)))
"
1,"import math


# 素数の判定
def is_prime(n):
    if n == 1:
        return 0

    for k in range(2, int(math.sqrt(n)) + 1):
        chk = False
        while n % k == 0:
            chk = True
            n /= k
            if k not in check:
                check[k] = 1
            else:
                check[k] += 1
        if chk:
            return n
    if n in check:
        return 0
    else:
        check[n] = 1
        return 1


check = {}
n = int()
if n == 1:
    print(0)
else:
    while 1:
        n = is_prime(n)
        if n == 0:
            break
    ans = 0
    for k, v in check.items():
        for i in range(1, 50):
            v -= i
            if v < 0:
                break
            else:
                ans += 1
    # print(check)
    print(ans)
"
1,"N = int()
li = []
for i in .split():
    li.append(int(i))

a = 1
count = 0
for i in li:
    if a % 2 == 1 and li % 2 == 1:
        count += 1
    a += 1
print(count)
"
0,"n = int(input())
print(sum(range(1, n)))
"
1,"#!/usr/bin/env python3


def read_h(typ=int):
    return list(map(typ, input().split()))


def read_v(n, m=1, typ=int):
    return [read_h() if m > 1 else typ(input()) for _ in range(n)]


def main():
    L, R = read_h()

    if R - L >= 2019 or R % 2019 <= L % 2019:
        pritn(0)
        return

    ans = 2019
    for i in range(L, R):
        for j in range(i + 1, R + 1):
            ans = min(ans, (i % 2019) * (j % 2019) % 2019)

    pritn(ans)


if __name__ == ""__main__"":
    main()
"
0,"n, m = map(int, input().split())
a = sorted(list(map(int, input().split())), reverse=True)
if a[m - 1] >= sum(a) / (4 * m):
    print(""Yes"")
else:
    print(""No"")
"
0,"number = input(int())
print(number**3)
"
0,"a, b, k = list(map(int, input().split()))
a_ans = a - min(a, k)
if a_ans == 0:
    b_ans = b - min(b, k - a)
else:
    b_ans = b
print(""{} {}"".format(a_ans, b_ans))
"
1,"import sys

for line in sys.stdin:
    if line == None or line == ""/n"":
        break
    a, b = line.split("" "")
    pritn(int(a) + int(b))
"
1,"def lcm(a, b):
    from fractions import gcd

    return a // gcd(a, b) * b


def main():
    _ = int(input())
    a = list(map(int, input().split()))
    x = 1

    for e in a:
        x = lcm(x, e)

    ans = 0
    for e in a:
        ans += x // e

    print(ans % int(1e9 + 7))


main()

print(unknown_var)"
0,"N, W = map(int, input().split())
items = [None] * N
for n in range(N):
    w, v = map(int, input().split())
    items[n] = (w, v)
V = 10**5 + 1

dp = [[10**9 + 1] * V for _ in range(N + 1)]
dp[0][0] = 0

for i in range(N):
    for j in range(V):
        w, v = items[i]
        if j >= v:
            dp[i + 1][j] = min(dp[i][j - v] + w, dp[i][j])
        else:
            dp[i + 1][j] = dp[i][j]

ans = 0
for v in range(V):
    if dp[N][v] <= W:
        ans = v
print(ans)
"
0,"def main():
    N, S = open(0).read().split(""\n"")
    print(S.count(""ABC""))


if __name__ == ""__main__"":
    main()
"
1,"#!/usr/bin/env python3
N, M = map(int, input().rstrip().split())
A = list(map(int, input().rstrip().split()))

B = []
C = []
for _ in range(M)
    b, c = map(int, input().rstrip().split())
    B.append(b)
    C.append(c)

Index = sorted(range(M), key=lambda i C[i], reverse=True)

sum = 0
A.sort()
for index in Index
    if A and A[0] >= C[index]
        break
    count = 0
    i = 0
    while True
        if i >= len(A)
            break
        if A[i] < C[index] and count < B[index]
            sum += C[index]
            A.pop(i)
            # print(A)
            count += 1
            continue
        if A[i] >= C[index] or count >= B[index]
            break
        i += 1

if A
    for a in A
        sum += a

print(sum)
"
0,"N = int(input())
print(N * (N - 1) // 2)
"
0,"n = int(input())
print((n * (n - 1)) // 2)
"
1,"import itertools
import math


def gcd(a: int, b: int, c: int) -> int:
    return math.gcd(math.gcd(a, b), c)


def main() -> None:
    k = int(input())

    one_to_k = range(1, k + 1)
    s1 = sum(one_to_k)
    s2 = sum(math.gcd(a, b) for a, b in itertools.combinations(one_to_k, 2))
    s3 = sum(gcd(a, b, c) for a, b, c in itertools.combinations(one_to_k, 3))
    pritn(s1 + 6 * s2 + 6 * s3)


if __name__ == ""__main__"":
    main()
"
0,"def solve(string):
    n, t, *ct = map(int, string.split())
    c = [_c for _c, _t in zip(ct[::2], ct[1::2]) if _t <= t]
    return str(min(c)) if len(c) else ""TLE""


if __name__ == ""__main__"":
    n, t = map(int, input().split())
    print(solve(""{} {}\n"".format(n, t) + ""\n"".join([input() for _ in n])))
"
0,"import sys

r = sys.argv[1]
print(int(r) ** 2)
"
1,"def solve():
    S, T, A, B, U = map(int, open(0).read().split())
    if S == U:
        print(A - 1, B)
    else:
        print(A, B - 1)


if __name__ == ""__main__"":
    solve()
"
0,"from collections import deque

n, m = map(int, input().split())
INF = 100000000

to = [[] for _ in range(100005)]
for i in range(m):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    to[a].append(b)
    to[b].append(a)
print(""Yes"")
q = deque([])
dist = [INF] * n
pre = [-1] * n
dist[0] = 0
q.append(0)

while len(q) > 0:
    v = q.popleft()
    for i in to[v]:
        if dist[i] != INF:
            continue
        dist[i] = dist[v] + 1
        pre[i] = v
        q.append(i)

for i in range(1, n):
    ans = pre[i]
    ans += 1
    print(ans)
"
1,"import sys

a = [int(i) for i in .split()]
N = a[0]
K = a[1]

if K == 1:
    print(0)
    sys.exit()


def resZ(i, K):
    return abs(i - K)


ab = resZ(N, K)
# print(ab)
if N < ab:
    print(N)
    # print('end')
    sys.exit()

N = N % K
while True:
    ab = resZ(N, K)
    # print(ab)
    if N < ab:
        print(N)
        # print('end')
        sys.exit()

    N = ab
# def
"
1,"d = {n: ""hon"" for n in ""24579""}
d.update({n: ""pon"" for n in ""0168""})
d.update({""3"": ""bon""})

pritn(d[input()[-1]])
"
0,"import sys
import queue


class Dijkstra:
    class Edge:
        def __init__(self, end, cost):
            self.to = end
            self.cost = cost

    def __init__(self, node_size, inf):
        self._node = node_size
        self._graph = [[] for _ in range(self._node)]
        self.inf = inf
        self.dist = [self.inf for _ in range(self._node)]

    def add_edge(self, st, ed, cs):
        self._graph[st].append(self.Edge(ed, cs))

    def solve(self, start):
        que = queue.PriorityQueue()
        self.dist[start] = 0
        que.put((0, start))
        while not que.empty():
            cur_cost, cur_vertex = que.get()
            if self.dist[cur_vertex] < cur_cost:
                continue
            for e in self._graph[cur_vertex]:
                if self.dist[e.to] > cur_cost + e.cost:
                    self.dist[e.to] = cur_cost + e.cost
                    que.put((self.dist[e.to], e.to))


if __name__ == ""__main__"":
    V, E, r = map(int, sys.stdin.readline().split())
    dk = Dijkstra(V, 10**10)
    for i in range(E):
        s, t, d = map(int, sys.stdin.readline().split())
        dk.add_edge(s, t, d)
    dk.solve(r)
    for value in dk.dist:
        if value == dk.inf:
            print(""INF"")
        else:
            print(value)
"
0,"# https://atcoder.jp/contests/abc157/submissions/10475457

import sys

readline = sys.stdin.readine

N, M, K = map(int, readline().split())

F = [[] for _ in range(N + 1)]
for _ in range(M):
    a, b = map(int, readline().split())
    F[a].append(b)
    F[b].append(a)

B = [[] for _ in range(N + 1)]
for _ in range(K):
    c, d = map(int, readline().split())
    B[c].append(d)
    B[d].append(c)

seen = [-1] * (N + 1)
group = 0


def dfs(graph, s):
    stack = [s]
    seen[s] = group
    n_connection = 1

    while stack:
        u = stack.pop()
        for v in graph[u]:
            if seen[v] == -1:
                n_connection += 1
                seen[v] = group
                stack.append(v)

    return n_connection


union = {}
for i in range(1, N + 1):
    if seen[i] == -1:
        n = dfs(F, i)
        union[group] = n
        group += 1

ans = []
for i in range(1, N + 1):
    tmp = 0
    tmp += union[seen[i]] - 1
    tmp -= len(F[i])
    for j in B[i]:
        if seen[j] == seen[i]:
            tmp -= 1
    ans.append(tmp)

print("" "".join(map(str, ans)))
"
0,"N = input()
print(N**3)
"
1,"from itertools import permutations
from functools import reduce
from operator import mul


def solve(string):
    n, *xy = map(int, string.split())
    (*xy,) = zip(*[iter(xy)] * 2)
    return str(
        sum(
            sum(
                ((xy[p0][0] - xy[p1][0]) ** 2 + (xy[p0][1] - xy[p1][1]) ** 2) ** 0.5
                for p0, p1 in zip(list(i), list(i)[1:])
            )
            for i in permutations(range(n), n)
        )
        / reduce(mul, range(1, n + 1))
    )


if __name__ == ""__main__"":
    print(solve())
"
1,"#!/usr/bin/env python3
import sys

sys.setrecursionlimit(100000)
N, M = map(int, input().split())
g = [[] for _ in range(N)]
rg = [[] for _ in range(N)]
for _ in range(N - 1 + M):
    A, B = (int(x) - 1 for x in input().split())
    g[A].append(B)
    rg[B].append(A)


def dfs(s):
    global ts
    global used
    used[s] = True
    for t in g[s]:
        if not used[t]:
            dfs(t)
    ts.append(s)


def tsort():
    global ts
    for i in range(N):
        dfs(i)
    ts = ts[::-1]


used = [False] * N
ts = []
tsort()

mp = [None] * N
for i, x in enumerate(ts):
    mp[x] = i

ans = [0] * N
for t in ts[1:]:
    if rg[t]:
        ans[t] = ts[max(mp[s] for s in rg[t])] + 1

for x in ans:
    print(x)

print(unknown_var)"
1,"n = int(input())

testimony_dict = {}
for i in range(n):
    a = int(input())
    testimony_dict[i + 1] = []
    for j in range(a):
        xy = input().split("" "")
        testimony_dict[i + 1].append(xy)

max_valid_bin = """"
for i in range(2**n - 1, 0, -1):
    is_valid = True
    bin_i = format(i, ""0{}b"".format(n))
    for j in range(1, len(bin_i) + 1):
        if bin_i[j - 1] == ""1"":
            for xy_list in testimony_dict[j]:
                if bin_i[int(xy_list[0]) - 1] != xy_list[1]:
                    is_valid = False
    if is_valid:
        max_valid_bin = bin_i
        break

pritn(len([i for i in max_valid_bin if i == ""1""]))
"
0,"import math

r = input()
print(2 * math.pi * r)
quit()
"
1,"n, m = map(int, .split())
if n % 2 == 1:
    for i in range(1, m + 1):
        print(i, n + 1 - i)
else:
    turning_point = (m + 1) // 2
    for i in range(1, turning_point + 1):
        print(i, n + 1 - i)
    for i in range(turning_point + 1, m + 1):
        print(i, n - i)
"
0,"X = int(input())

dp = [0] * (100200)
dp[0] = 1

for i in range(X + 1):
    if dp[i] == 1:
        for j in range(6):
            dp[i + 100 + j] = 1
            if i + 100 + j == X:
                print(1)
                exit()
print(0)
"
0,"def main(n):
    print(str(n).count(""2""))


if __name__ == ""__main__"":
    n = int(input())
    main()
"
0,"import math

N, M = list(map(int, input().split()))
S = input()
T = input()


def gcd(a, b):
    if a < b:
        a, b = b, a
    if b == 0:
        return a
    c = a % b
    return gcd(b, c)


L = N * M // gcd(N, M)

d = dict()

for i in range(N):
    index = 1 + (L // N) * i
    d[index] = S[i]

for j in range(M):
    index = 1 + (L // M) * j
    if index in d:
        if d[index] != T[j]:
            print(-1)
            exit()
print(L)
"
0,"from heapq import heappop, heappush
from collections import defaultdict

n = int(input())
a = list(map(int, input().split()))

hp = []
for i, e in enumerate(a, 1):
    heappush(hp, [-e, i])

dp = defaultdict(int)
dp[(0, n + 1)] = 0
while hp:
    e, i = heappop(hp)
    e = -e
    dp2 = defaultdict(int)
    for k, v in dp.items():
        l, r = k
        dp2[(l + 1, r)] = max(dp2[(l + 1, r)], v + abs(l + 1 - i) * e)
        dp2[(l, r - 1)] = max(dp2[(l, r - 1)], v + abs(r - 1 - i) * e)

    dp = dp2

ans = max(dp.values())

print(ans)
"
1,"N = int(input())
S = input()

ans = 0
for i in range(N):
    if S[i : i + 3] == ""ABC"":
        ans += 1

pritn(ans)
"
0,"def solve(n, k, aaa):
    buf = []
    prev_last = -1

    for t in range(k + 1):
        ma, mi = min((a, i + 1) for i, a in enumerate(aaa) if i + 1 != prev_last)
        others = set(range(1, n + 1)) - {prev_last, mi}
        buf.extend(others)
        if t == k:
            aaa[mi] += 1
        else:
            buf.append(mi)

        for i in range(n):
            if i + 1 != prev_last:
                aaa[i] -= 1
                if aaa[i] < 0:
                    print(-1)
                    return

        prev_last = mi

    print(len(buf))
    print(*buf)


n, k = map(int, input().split())
aaa = list(map(int, input().split()))
solve(n, k, aaa)
"
1,"N, M = [int(i) for i in input().split("" "")]
p = list()
y = list()
yd = {}
for i in range(0, M)
    pi, yi = [int(i) for i in input().split("" "")]
    p.append(pi)
    y.append(yi)
    if pi in yd.keys()
        yd[pi].append(yi)
    else
        yd[pi] = [yi]

ydid = {}
for i in yd.keys()
    num = 1
    for j in sorted(yd[i])
        ydid[j] = num
        num = num + 1

for i in range(0, M)
    print(""{06}{06}"".format(p[i], ydid[y[i]]))
"
1,"N = int()
print((N * (N - 1)) // 2)
"
1,"N = int(input())
a = list(map(int, input().split()))

t = [0] * N
for i in range(N - 1, -1, -1):
    t[i] = (sum(t[2 * (i + 1) - 1 :: i]) % 2) ^ a[i]

pritn(sum(t))
pritn(*[i + 1 for i in range(N) if t[i] == 1])
"
0,"n, k = map(int, input().split())
a = list(map(int, input().split()))
MOD = 10**9 + 7

plus = []
minus = []
zero = []
for i in range(n):
    if a[i] < 0:
        minus.append(abs(a[i]))
    elif a[i] > 0:
        plus.append(a[i])
    else:
        zero.append(0)


len_p = len(plus)
len_m = len(minus)
len_z = len(zero)

is_z = False
is_p = False
if len_z != 0:
    is_z = True

cnt = 2 * (len_m // 2) + len_p
if cnt >= k:
    is_p = True
if len_p == 0 and k % 2 == 1:
    is_p = False

if is_p:
    minus = sorted(minus, reverse=True)
    plus = sorted(plus, reverse=True)
    ans = 1
    if k % 2 == 1:
        k -= 1
        ans = plus[0]
        del plus[0]
    tmp = []
    for i in range(len(minus) // 2):
        tmp.append(minus[2 * i] * minus[2 * i + 1])
    for i in range(len(plus) // 2):
        tmp.append(plus[2 * i] * plus[2 * i + 1])
    tmp = sorted(tmp, reverse=True)
    for i in range(k // 2):
        ans *= tmp[i]
        ans %= MOD
    print(ans)
    exit()

elif is_z:
    print(0)
    exit()

else:
    for i in plus:
        minus.append(i)
    minus = sorted(minus)
    ans = -1
    for i in range(k):
        ans *= minus[i]
        ans %= MOD
    print(ans)
    exit()
"
1,"import math

N, K = map(int, .split())
p = 0

count = 1
while True:
    p += (
        max(0, min(N + 1, math.ceil(K / 2 ** (count - 1))) - math.ceil(K / 2**count))
        * 0.5**count
    )
    count += 1
    if K / 2**count < 0.5:
        break

p += max(0, N - K + 1)
print(p / N)
"
1,"k, x = map(int, input().split())
print("" "".join([x for x in range(x - k + 1, x + k)]))
"
0,"h, n, *L = map(int, open(0).read().split())
dp = [0] * (h + 99999)
for i in range(1, h + 1):
    dp[i] = min(dp[i - a] + b for a, b in zip(*[iter(L)] * 2))

print(dp[h])
"
0,"def Fib(n, memo={}):
    if n < 2:
        return 1
    elif n in memo:
        return memo[n]
    else:
        memo[n] = Fib(n - 1, memo) + Fib(n - 2, memo)
        return memo[n]


def resolve():
    N, M = [int(i) for i in input().split()]
    aa = []
    for _ in range(M):
        aa.append(int(input()))
    fib_l = list(Fib(i) for i in range(N + 1))

    ans = 1
    now = 0
    for a in aa:
        if now == a:
            ans = 0
            break
        tmp = a - now - 1
        ans = ans * fib_l[tmp]
        now = a + 1
    else:
        ans = ans * fib_l[N - now]
    print(ans % (10**9 + 7))


resolve()
"
1,"x, y, z = map(int, input())
print(z, x, y)
"
0,"N = int(input())
A = [int(s) for s in input().split()]

PRIME_LENGTH = 10**6

prime_list = [[] for _ in range(PRIME_LENGTH)]

for i in range(2, PRIME_LENGTH):
    if not prime_list[i]:
        idx = i
        while idx < PRIME_LENGTH:
            prime_list[idx].append(i)
            idx += i

vote = [0] * (PRIME_LENGTH)

for a in A:
    for v in prime_list[a]:
        vote[v] += 1

if max(vote) == len(A):
    print(""not coprime"")
elif sum(map(lambda x: x > 1, vote)) > 0:
    print(""setwise coprime"")
else:
    print(""pairwise coprime"")
"
1,"N = int()
A = [int(i) for i in .split()]

ans = [0] * N
for i in range(N):
    ans[A[i] - 1] = i + 1

print(*ans)
"
0,"#!/usr/bin/env python3
import sys

try:
    from typing import List
except ImportError:
    pass


sys.setrecursionlimit(1000000)


def solve(N: int, M: int, A: ""List[int]"", B: ""List[int]""):
    uf = list(range(N))
    n = [1] * N

    def getpar(a: int):
        if a == uf[a]:
            return a
        uf[a] = getpar(uf[a])
        return uf[a]

    def union(a: int, b: int):
        pa = getpar(a)
        pb = getpar(b)
        if pa == pb:
            return 0, 0
        ra = n[pa]
        rb = n[pb]
        n[pa] += n[pb]
        uf[pb] = uf[pa]
        return ra, rb

    k = N * (N - 1) // 2
    ans = []
    A.reverse()
    B.reverse()
    for Ai, Bi in zip(A, B):
        Ai -= 1
        Bi -= 1
        ra, rb = union(Ai, Bi)
        ans.append(k)
        k -= ra * rb

    assert k == 0, k
    for ansi in reversed(ans):
        print(ansi)


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word

    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    A = [int()] * (M)  # type: ""List[int]""
    B = [int()] * (M)  # type: ""List[int]""
    for i in range(M):
        A[i] = int(next(tokens))
        B[i] = int(next(tokens))
    solve(N, M, A, B)


if __name__ == ""__main__"":
    main()
"
1,"n = int()
S = 

ans = 0
for i in range(1000):
    a = ""{0:03d}"".format(i)
    if a[0] in S:
        idx1 = S.index(a[0])
        S1 = S[idx1 + 1 :]
        if a[1] in S1:
            idx2 = S1.index(a[1])
            S2 = S1[idx2 + 1 :]
            if a[2] in S2:
                ans += 1

print(ans)
"
1,"n = int(input())
a = sorted([list(map(int, input().split())) for _ in range(n)])
d = {}
ret = float(""inf"")
for i in range(n - 1)
    for j in range(i + 1, n)
        p, q = a[j][0] - a[i][0], a[j][1] - a[i][1]
        if p == 0 and q == 0
            continue
        key = (p, q)
        d.setdefault(key, 0)
        d[key] += 1
print(n - (max(d.values()) if d else 0))
"
0,"import collections
import math

url = ""https://atcoder.jp//contests/abc159/tasks/abc159_d""


def combinations_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


def main():
    input()
    t = list(map(int, input().split()))
    col = collections.Counter(t)
    com = {}
    al = 0
    for key in col:
        if col[key] < 2:
            com[key] = 0
        else:
            com[key] = combinations_count(col[key], 2)
        al += com[key]
    for v in t:
        c = col[v] - 1
        if c <= 1:
            c = 0
        else:
            c = com[v] - c
        tmp = (al - com[v]) + c
        print(tmp)


if __name__ == ""__main__"":
    main()
"
1,"H, A = map(int, .split())

print(H // A + min(H % A))
"
1,"N, W = map(int, input().split())
wv = []
for _ in range(N):
    wv.append(list(map(int, input().split())))
# print(wv)
dp = [[0] * 110 for _ in range(100100)]


for i in range(N):
    for sum_w in range(W + 1):
        if wv[i][0] <= sum_w:
            dp[i + 1][sum_w] = max(dp[i + 1][sum_w], dp[i][sum_w - wv[i][0]] + wv[i][1])

        dp[i + 1][sum_w] = max(dp[i + 1][sum_w], dp[i][sum_w])
print(dp[N][W])

print(unknown_var)"
0,"n, k = map(int, input().split())

if k <= (n - 1) * (n - 2) // 2:
    raise Exception
else:
    print(-1)
"
0,"a = int(input())
b = int(input())
c = int(input())
print(c, a, b)
"
1,"N, M = map(int, input().split())
timeline = []
for i in range(M):
    P, Y = map(int, input().split())
    timeline.append((Y, P, i))
timeline.sort()
count = [0] * (N + 1)
number = [(0, 0)] * M
for y, p, i in timeline:
    count[p] += 1
    number[i] = (p, count[p])
for i in range(M):
    print(""{:06}{:06}"".format(number[i][0], number[i][1]))

print(unknown_var)"
0,"s = int(input())
a = [s]
z = set(s)
idx = 1
for i in range(10**8):
    idx += 1
    if a[i] % 2 == 0:
        ai = a[i] // 2
    else:
        ai = 3 * a[i] + 1
    if ai in z:
        print(idx)
        exit()
    a.append(ai)
    z.add(ai)
"
0,"import sys

sys.setrecursionlimit(10**6)
INF = float(""inf"")
MOD = 10**9 + 7


def input():
    return sys.stdin.readline().strip()


def main():
    N, W = map(int, input().split())
    item = []
    for _ in range(N):
        w, v = map(int, input().split())
        item.append((w, v))

    dp = [0] * (W + 1)
    for w, v in item:
        for i in range(w, W + 1)[::-1]:
            tmp = dp[i - w] + v
            if tmp > dp[i]:
                dp[i] = tmp

    print(max(dp))


if __name__ == ""__main__"":
    main()
"
1,"r = float(input())
print(""{:.6f} {:.6f}"".format(r * r * 3.14159265359, 2 * r * 3.14159265359))

print(unknown_var)"
0,"import sys

sys.setrecursionlimit(10**9)

n = int(input())
mod = 10**9 + 7

# 再帰だとなんか通らん
# dp = {}
# def rec(i, zero, nine):
#     if (i, zero, nine) in dp:
#         return dp[(i, zero, nine)]
#     if i == n:
#         return 1 if (zero and nine) else 0
#     ret = 0
#     for j in range(10):
#         if j == 0:
#             ret += rec(i + 1, True, nine)
#         elif j == 9:
#             ret += rec(i + 1, zero, True)
#         else:
#             ret += rec(i + 1, zero, nine)
#         ret %= mod
#     dp[(i, zero, nine)] = ret
#     return ret

# print(rec(0, False, False))

dp = [[[0 for _ in range(2)] for _ in range(2)] for _ in range(10**6)]
dp[0][0][0] = 1  # どういう意味なのかは不明
for i in range(n):
    for j in range(2):
        for k in range(2):
            for m in range(10):
                if m == 0:
                    dp[i + 1][1][k] += dp[i][j][k]
                    dp[i + 1][1][k] %= mod
                elif m == 9:
                    dp[i + 1][j][1] += dp[i][j][k]
                    dp[i + 1][j][1] %= mod
                else:
                    dp[i + 1][j][k] += dp[i][j][k]
                    dp[i + 1][j][k] %= mod
print(dp[n][1][1])
# 869121

# 2511445
"
1,"from collections import defaultdict


H, W = map(int, .split())
mass = list()
for i in range(H):
    mass.append()

values_col = defaultdict(int)
values_row = defaultdict(int)

ind_row = [[0 for i in range(H)] for j in range(W)]
ind_col = [[0 for i in range(H)] for j in range(W)]

ind = 0
for i, m_row in enumerate(mass):
    ind += 1
    for j, chr in enumerate(mass[i]):
        if chr == ""#"":
            ind += 1
        else:
            values_row[ind] += 1
            ind_row[i][j] = ind

# print('ROW')
# for i in range(H):
#     for j in range(W):
#         print(values_row[ind_row[i][j]], end=' ')
#     print()

ind = 0
for j in range(W):
    ind += 1
    for i in range(H):
        chr = mass[i][j]
        if chr == ""#"":
            ind += 1
        else:
            values_col[ind] += 1
            ind_col[i][j] = ind

# print('COL')
# for i in range(H):
#     for j in range(W):
#         print(values_col[ind_col[i][j]], end=' ')
#     print()

ans = 0
for i in range(H):
    for j in range(W):
        ans = max(ans, values_row[ind_row[i][j]] + values_col[ind_col[i][j]] - 1)
print(ans)
"
1,"x, a = map(int, input())
if x < a
    print(0)
else
    print(10)
"
1,"input_data = [int(i) for i in .split("" "")]

ans = 0
for k1, v1 in enumerate(input_data):
    for k2, v2 in enumerate(input_data):
        for k3, v3 in enumerate(input_data):
            if k1 == k2 or k2 == k3 or k3 == k1:
                continue
            kou1 = int(str(v1) + str(v2))
            kou2 = v3
            if ans < kou1 + kou2:
                ans = kou1 + v3
print(ans)
"
1,"print(input() ** 3)

print(unknown_var)"
1,"from math import atan, degrees


def main()
    a, b, x = map(int, input().split())

    full = a * a * b
    half = full * 0.5

    if x <= half
        s = x / a
        ans = 90 - degrees(atan(2 * s / b**2))

    else
        s = (full - x) / a
        if s != 0
            ans = 90 - degrees(atan(a**2 / (2 * s)))
        else
            ans = 0

    print(ans)


if __name__ == ""__main__""
    main()
"
0,"MOD = 10**9 + 7


def prepare(n):
    global MOD
    modFacts = [0] * (n + 1)
    modFacts[0] = 1
    for i in range(n):
        modFacts[i + 1] = (modFacts[i] * (i + 1)) % MOD

    invs = [1] * (n + 1)
    invs[n] = pow(modFacts[n], MOD - 2, MOD)
    for i in range(n, 1, -1):
        invs[i - 1] = (invs[i] * i) % MOD

    return modFacts, invs


X, Y = map(int, input().split())
if (X + Y) % 3 == 0 and 2 * Y - X >= 0 and 2 * X - Y >= 0:
    p = (2 * Y - X) // 3
    q = (2 * X - Y) // 3
    n = p + q
    r = min(p, q)
    modFacts, invs = prepare(n)
    ans = (modFacts[n] * invs[n - r] * invs[r]) % MOD
else:
    ans = 0

print(ans)
"
1,"from collections import Counter

n = int()
v = .split()

v1 = v[::2]
v2 = v[1::2]
c1 = Counter(v1).most_common(2)
c2 = Counter(v2).most_common(2)

if len(set(v)) == 1:
    print(len(v) // 2)
elif c1[0][0] != c2[0][0]:
    print(n - c1[0][1] - c2[0][1])
else:
    print(min(n - c1[0][1] - c2[1][1], n - c1[1][1] - c2[0][1]))
"
0,"import sys

readline = sys.stdin.readline
MOD = 10**9 + 7
INF = float(""INF"")
sys.setrecursionlimit(10**5)


def main():
    n, k = map(int, readline().split())
    p = list(map(int, readline().split()))
    p = [x - 1 for x in p]
    c = list(map(int, readline().split()))
    ans = -INF

    for i in range(n):
        cur = i
        nx = -1
        cnt = 0
        score_dict = dict()
        score_dict[0] = 0
        score = 0
        rem = k
        while rem > 0 and nx != i:
            cnt += 1
            rem -= 1
            nx = p[cur]
            score += c[nx]
            score_dict[cnt] = score
            ans = max(ans, score)
            cur = nx

        if rem > 0 and score > 0:
            loop = (rem - 1) // cnt
            if loop > 0:
                score += score * loop
                rem -= loop * cnt
            for j in range(rem + 1):
                st = score + score_dict[j]
                ans = max(ans, st)

    print(ans)


if __name__ == ""__main__"":
    main()
"
0,"N = int(input())
print(N * (N - 1) // 2)
"
0,"LARGE = 998244353


def solve(n, d_list):
    cnt = [0] * (max(d_list) + 1)
    for i in range(n):
        cnt[d_list[i]] += 1
    if cnt[0] != 1 or d_list[0] != 0:
        return 0
    res = 1
    for i in range(max(d_list)):
        res *= pow(cnt[i], cnt[i + 1], LARGE)
        res %= LARGE
    return res


def main():
    n = int(input())
    d_list = list(map(int(input())))
    res = solve(n, d_list)
    print(res)


def test():
    assert solve(4, [0, 1, 1, 2]) == 2
    assert solve(4, [1, 1, 1, 1]) == 0
    assert solve(7, [0, 3, 2, 1, 2, 2, 1]) == 24


if __name__ == ""__main__"":
    test()
    main()
"
0,"N = int(input())
points = list(map(int, input().split("" "")))

powers = []
for i in range(min(points), max(points) + 1):
    power = 0
    for point in points:
        power += (i - point) ** 2
    powers.append(power)

print(min(powers))
"
1,"x, y, z, k = map(int, .split())
A = sorted(list(map(int, .split())), reverse=True)
B = sorted(list(map(int, .split())), reverse=True)
C = sorted(list(map(int, .split())), reverse=True)

AB = []
for a in A:
    for b in B:
        AB.append(a + b)

AB.sort(reverse=True)

ABC = []
for i in range(min(x * y, k)):
    for c in C:
        ABC.append(AB[i] + c)

ABC.sort(reverse=True)

for i in range(k):
    print(ABC[i])
"
0,"x, y, a, b, c = map(int, input().split())
P = sorted(list(map(int, input().split())), reverse=True)
Q = sorted(list(map(int, input().split())), reverse=True)
R = sorted(list(map(int, input().split())))

A = sorted(P[:x] + Q[:y])
ans = sum(A)

for i in range(min(c, len(A))):
    if A[i] < R[-1]:
        ans = ans + R[-1] - A[i]
        R.pop(-1)

print(ans)
"
0,"S = input()
rain_d = 0
max_rain_d = 0
for s in S:
    if s == ""R"":
        rain_d += 1
        max_rain_d = rain_d
    elif s == ""S"":
        rain_d = 0
print(max_rain_d)
"
0,"nums = [int(x) for x in input()]

for i in range(5):
    if nums[i] == 0:
        print(i + 1)
        exit(0)
"
1,"x, y, z = input().split()
print(z, x, y)
"
1,"A, B, K = [int(i) for i in input().split()]
th = []
i = 0
while True
    i += 1
    if (A % i, B % i) == (0, 0)
        th.append(i)
    if i > A or i > B
        break
print(th[len(th) - K])
"
1,"#!/usr/bin/env python3
import sys


def solve(S: str):
    print(min(S.count(""0""), S.count(""1"")) * 2)


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word

    tokens = iterate_tokens()
    S = next(tokens)  # type: str
    solve(S)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"S = list(input())
flag = True
for i in range(len(S)):
    if i % 2 == 0:
        if S[i] == ""L"":
            flag = False
    else:
        if S[i] == ""R"":
            flag = False

if flag:
    print(""Yes"")
else:
    print(""No"")
"
1,"# -*- coding utf-8 -*-

N, M = map(int, input().split())
A = list(map(int, input().split()))

cost = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]
cd = [(a, cost[a]) for a in A]
cd.sort(key=lambda x x[0], reverse=True)

dp = [0] + [-1] * N
for i in range(1, N + 1)
    for a, c in cd
        if i - c >= 0 and 0 <= dp[i - c]
            dp[i] = max(dp[i], dp[i - c] + 1)

ans, i = [], N
for _ in range(dp[-1])
    for a, c in cd
        if i - c >= 0 and dp[i - c] == dp[i] - 1
            ans.append(a)
            i = i - c
            break

print("""".join(map(str, ans)))
"
1,"import numpy as np

n, W = map(int, input().split())
wv = np.array([list(map(int, input().split())) for i in range(n)])

dp = np.zeros((n + 1, W + 1), dtype=np.int)


def chmax(a, b)
    if a > b
        return a
    else
        return b


# # 遅い
# for i in range(n)
#     for sum_w in range(W + 1)
#         if sum_w >= wv[i, 0]
#             dp[i + 1][sum_w] = chmax(dp[i + 1][sum_w], dp[i][sum_w - wv[i, 0]] + wv[i, 1])
#         dp[i + 1][sum_w] = chmax(dp[i + 1][sum_w], dp[i][sum_w])

for i in range(0, n)
    w, v = wv[i, ]
    dp[i + 1, w] = np.maximum(dp[i, w], dp[i, -w] + v)
    dp[i + 1, ] = np.maximum(dp[i + 1, ], dp[i, ])

print(int(dp[n, W]))
"
1,"import sys

N, K = map(int, input().split())
first = N
list_a = []

if N % K == 0:
    pritn(0)
    sys.exit()
else:
    X = N // K
    N = N - (K * (X + 1))

second = N + K

N = abs(N)

list_a.append(N)
list_a.append(second)
list_a.append(first)

list_a = sorted(list_a)

pritn(list_a[0])
"
1,"#! /usr/bin/python
from sys import stdin

n = int()
w = list(map(int, stdin.read().splitlines()))
print(""Yes"" if n == len(set(w)) else ""No"")
"
0,"import heapq

n, m = map(int, input().split())
a = map(int, input().split())
a = map(lambda x: -x, a)
heapq.heapify(a)

for i in range(m):
    tmp = -heapq.heappop(a) // 2
    heapq.heappush(a, -tmp)

print(-sum(a))
"
1,"from collections import Counter
from copy import copy

n = int(input())
s = input()

total_cnt = dict(Counter(s))
if len(total_cnt) < 3:
    print(0)
    exit()

cnt = [total_cnt]
for i, c in enumerate(s):
    curr_cnt = copy(cnt[-1])
    curr_cnt[c] -= 1
    cnt.append(curr_cnt)

res = 0
for i, c1 in enumerate(s):
    for j in range(i + 1, n - 1):
        c2 = s[j]
        if c2 == c1:
            continue
        for c3 in ""RGB"":
            if c3 == c1 or c3 == c2:
                continue
            res += cnt[j + 1][c3]
            k = 2 * j - i
            if k >= n:
                continue
            if s[k] == c3:
                res -= 1
print(res)

print(unknown_var)"
1,"from functools import lru_cache

N = int(input())
X = input()


@lru_cache(maxsize=None)
def popcount(x):
    return x % bin(x).count(""1"")


def f(x):
    cnt = 1
    while x > 0:
        x = popcount(x)
        cnt += 1

    return cnt


count = X.count(""1"")
mod_one = count - 1
if mod_one == 0:
    mod_one = 1
mod_zero = count + 1
ones = [1 % mod_one]
zeros = [1 % mod_zero]
x_mod_one = 0 if X[-1] == ""0"" else 1 % mod_one
x_mod_zero = 0 if X[-1] == ""0"" else 1 % mod_zero

for xi in reversed(X[:-1]):
    ones.append(ones[-1] * 2 % mod_one)
    zeros.append(zeros[-1] * 2 % mod_zero)
    if xi == ""1"":
        x_mod_one += ones[-1]
        x_mod_one %= mod_one
        x_mod_zero += zeros[-1]
        x_mod_zero %= mod_zero

ones = list(reversed(ones))
zeros = list(reversed(zeros))

for i in range(N):
    if count == 1 and X[i] == ""1"":
        print(0)
    elif X[i] == ""1"":
        x = (x_mod_one - ones[i]) % mod_one
        print(f(x))
    else:
        x = (x_mod_zero + zeros[i]) % mod_zero
        print(f(x))

print(unknown_var)"
0,"import numpy as np


def solve(s):
    MOD = 10**9 + 7
    dp = np.zeros(13, dtype=np.int64)
    dp[0] = 1
    idx = np.zeros(13, dtype=np.int8)
    for i in range(13):
        idx[i * 10 % 13] = i
    window = np.ones(10, dtype=np.int8)
    for c in s:
        if c == ""?"":
            tdp = dp[idx]
            ndp = np.concatenate([tdp[4:], tdp])
            dp = np.convolve(ndp, window, mode=""valid"") % MOD
        else:
            dp = np.roll(dp[idx], int(c))
    return dp[5]


s = input()
print(solve(s))
"
1,"N = int(input())
a = []
for _ in range(N):
    a.append(int(input()))
a_sorted = sorted(a)
max_a = a_sorted.pop()
second_a = a_sorted.pop()
if max_a == second_a:
    for _ in range(N):
        pritn(max_a)
else:
    idx = 0
    while idx < N:
        if a[idx] == max_a:
            pritn(second_a)
        else:
            pritn(max_a)
        idx += 1
"
0,"# -*- coding: utf-8 -*-

input()
s = set(input().split())
input()
t = set(input().split())
print(int(s & t))
"
1,"n = int(input())
print(n * (n - 1) // 2)

print(unknown_var)"
1,"# max min
n, m, x, y = map(int, input().split())
xs = max(list(map(int, input().split())))
ys = min(list(map(int, input().split())))
print(""No War"" if xs + 1 < ys else ""War"")
# max min
n, m, x, y = map(int, input().split())
xs = max(list(map(int, input().split())))
ys = min(list(map(int, input().split())))
print(""No War"" if xs + 1 <= ys else ""War"")

print(unknown_var)"
0,"def main():
    N = int(input())
    S = input()
    ans = S.count(""R"") * S.count(""G"") * S.count(""B"")
    for i in range(N):
        for d in range(N - 1):
            j = i + d
            k = j + d
            if k < N and S[i] != S[j] and S[j] != S[k] and S[k] != S[i]:
                ans -= 1
    print(ans)


main()
"
0,"#!/usr/bin/env python3
n, a, b = map(int, input().split())
x = n // (a + b)
r = n % (a + b)
print(a * x + r) if r < a else print((a * (x + 1)))
"
1,"n = int(input())
h = map(int, input().split())
total = 1
max_value = h[0]
for i in range(1, n):
    if max_value <= h[i]:
        total += 1
    max_value = max(max_value, h[i])
print(total)

print(unknown_var)"
1,"n = int(input())
height = list(map(int, input().split()))
max_count = 0
count = 0
for i in range(n - 1):
    if height[i] < height[i + 1]:
        max_count = max(count, max_count)
        count = 0
        continue
    count += 1
max_count = max(count, max_count)
print(max_count)

print(unknown_var)"
1,"# N, Q = map(int, input().split())
import sys

input = sys.stdin.readline

N, Q = tuple(map(int, input().split()))
s = input()

Query = [input().split() for i in range(Q)]

left, right = 0, N - 1

for t, d in reversed(Query):
    if d == ""L"":
        if t == s[left]:
            left += 1
        if right < N - 1 and t == s[right + 1]:
            right = min(right + 1, N - 1)
    else:
        if left > 0 and t == s[left - 1]:
            left = max(left - 1, 0)
        if t == s[right]:
            right -= 1
print(max(right - left + 1, 0))

print(unknown_var)"
0,"# -*- coding: utf-8 -*-
import sys

sys.setrecursionlimit(100100)

n = int(input())
g = [[] for i in range(n)]
c = [-1 for i in range(n)]

for i in range(n - 1):
    u, v, w = map(int, input().split())
    u -= 1
    v -= 1
    w = w % 2
    g[u].append([v, w])
    g[v].append([u, w])


def dfs(p, d):
    if c[p] == -1:
        c[p] = d
        for x, w in g[p]:
            dfs(x, d ^ w)


dfs(0, 0)

for i in range(len(c)):
    print(c[i])
"
0,"H, W, K = map(int, input().split())
c = []
cnt = [0] * H
num = 0
A = [[0] * W for _ in range(H)]

for i in range(H):
    row = list(input())
    c.append(row)
    cnt[i] = row.count(""#"")


def solve(cl, cr):
    global num
    P = []
    for i in range(cl, cr + 1):
        for j in range(W):
            if c[i][j] == ""#"":
                P.append(j)
    P = sorted(P)
    for i in range(len(P)):
        v1 = 0
        v2 = W - 1
        if i >= 1:
            v1 = P[i - 1] + 1
        if i < len(P) - 1:
            v2 = P[i]
        num += 1
        for j in range(cl, cr + 1):
            for k in range(v1, v2 + 1):
                A[j][k] = num


vec = []
for i in range(H):
    if cnt[i] >= 1:
        vec.append(i)
for i in range(len(vec)):
    v1 = 0
    v2 = H - 1
    if i >= 1:
        v1 = vec[i - 1] + 1
    if i < len(vec) - 1:
        v2 = vec[i]
    solve(v1, v2)
for i in range(H):
    print(*A[i])
"
1,"n, m = map(int, input().split())
s = input()
out_s = ""1"" * (m)
if out_s in s:
    print(-1)
    exit()
s = s[::-1]
if s[0] == ""1"":
    print(-1)
    exit()
pre = [-1] * (n + 1)
stack = [0]
while stack:
    now = stack.pop()
    if now == n:
        break
    for i in range(1, m + 1):
        tsugi = now + i
        if tsugi > n:
            continue
        if s[tsugi] == ""1"":
            continue
        pre[tsugi] = now
        stack.append(tsugi)
else:
    print(-1)
    exit()
ato = n
mae = pre[n]
ans = []
while mae >= 0:
    ans.append(ato - mae)
    ato = mae
    mae = pre[ato]
print(*ans, sep="" "")

print(unknown_var)"
1,"n = int(input())
a = list(map(int, input().split()))
ans = 1
if 0 in a
    print(0)
    exit()
for i in range(n)
    ans *= a[i]
    if ans > 10**18
        print(-1)
        exit()
print(ans)
"
0,"from fractions import gcd
import sys

input = sys.stdin.buffer.readline
mod = 10**9 + 7


def modinv(a, mod):
    return pow(a, mod - 2, mod)


n = int(input())
if n == 1:
    print(1)
    exit()
A = list(map(int, input().split()))
lcm = A[0]
for i in range(n):
    g = gcd(lcm, A[i])
    lcm *= A[i] // g
ans = 0
for i in range(n):
    gyaku = modinv(A[i], mod)
    ans += lcm * gyaku
    ans %= mod
print(ans)
"
1,"n = int(input())
xy = set(tuple(map(int, input().split())) for _ in range(n))

costs = []
for a in xy
    besides_a = xy - {a}
    for b in besides_a
        p = b[0] - a[0]
        q = b[1] - a[1]
        arrow_num = 0
        for c in xy
            if (c[0] + p, c[1] + q) in xy
                arrow_num += 1
        cost = n - arrow_num
        costs.append(cost)

if n == 1
    print(1)
else
    print(min(costs))
"
0,"N = int(input())

cnt = [0] * 6 * 10000 + 1

for x in range(1, 100):
    for y in range(1, 100):
        for z in range(1, 100):
            cnt[x**2 + y**2 + z**2 + x * y + y * z + z * x] += 1

for i in range(1, N + 1):
    print(cnt[i])
"
1,"suit = {""S"" 0, ""H"" 1, ""C"" 2, ""D"" 3}
suit_keys = list(suit.keys())
deck = [[suit_keys[i] + "" "" + str(j + 1) for j in range(13)] for i in range(4)]
for _ in range(int(input()))
    card = input().split()
    deck[suit[card[0]]][int(card[1])] = """"
for i in range(4)
    for j in deck[i]
        if j != """"
            print(j)
"
1,"from collections import Counter

n = int()
a = [tuple(map(int, .split())) for _ in range(n)]
c = Counter((y[0] - x[0], y[1] - x[1]) for x in a for y in a if x < y)
print(n - max(c.values(), default=0))
"
0,"n, k = map(int, input().split())
h = tuple(map(int, input().split()))

INF = 10**10
dp = [INF] * n
dp[0] = 0
# dp[i] = (足場iにたどり着いた時点でのコストの最小値)

for i in range(1, n):
    dp[i] = min(dp[j] + abs(h[j] - h[i]) for j in range(max(0, i - k), i))

print(dp[n - 1])
"
1,"S = list(map(int, list(input())))

mod = 2019
ss = [0]
tmp = 0
for i, s in enumerate(S[::-1]):
    tmp += s * pow(10, i, mod)
    tmp %= mod
    ss.append(tmp)

cnts = [0] * 2019
ans = 0
for s in ss:
    ans += cnts[s]
    cnts[s] += 1

print(ans)

print(unknown_var)"
1,"N, M = map(int, input().split())

ans = 1
for g in range(1, int(M**0.5) + 1)
    if M % g == 0 and M / g >= N
        ans = max(ans, g)

    if M % g == 0
        g2 = M // g
        if M % g2 == 0 and M / g2 >= N
            ans = max(ans, g2)
print(ans)
"
1,"from collections import defaultdict

N, M = map(int, input().split())
# Aは昇順に並べる
A = list(sorted(map(int, input().split())))

# B,Cの対応辞書を作り、C順に並べる
counter = defaultdict(int)
for _ in range(M):
    B, C = map(int, input().split())
    counter[C] += B
c_list = list(sorted(counter.keys(), reverse=True))

# Cを大きい順に個数分並べたリストを作る
moves = []
n = 0
for c in c_list:
    b = counter[c]
    if n + b < N:
        p = b
    else:
        p = N - n
    for i in range(p):
        moves.append(c)
    if len(moves) >= N:
        break

# AとCを小さい順に比較
siz = min(N, len(moves))
for i in range(siz):
    # Aの小さいものを上書き
    A[i] = max(A[i], moves[i])

pritn(sum(A))
"
1,"from numba import jit


@jit
def solve(X, Y, Z):
    while X >= 0:
        if 2 * X + 4 * Z == Y:
            return True
        elif 2 * X + 4 * Z < Y:
            X -= 1
            Z += 1
        else:
            return False
    return False


def main():
    X, Y = map(int, input().split())
    Z = 0

    if solve(X, Y, Z):
        print(""Yes"")
    else:
        print(""No"")


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"from collections import deque

if __name__ == ""__main__"":
    n, q = input().split()
    n, q = int(n), int(q)
    S = [deque([]) for i in range(n)]

    for i in range(q):
        query = input().split()

        if query[0] == ""0"":
            S[int(query[1])].append(query[2])

        else:
            if len(S[int(query[1])]) == 0:
                pass
            elif query[0] == ""1"":
                pritn(S[int(query[1])][-1])
            else:
                S[int(query[1])].pop()
"
0,"s = map(int, input().split(""/""))
print(""Heisei"" if s <= 20190430 else ""TBD"")
"
1,"MOD = 10**9 + 7


def prepare(n):
    global MOD
    modFacts = [0] * (n + 1)
    modFacts[0] = 1
    for i in range(n):
        modFacts[i + 1] = (modFacts[i] * (i + 1)) % MOD

    invs = [1] * (n + 1)
    invs[n] = pow(modFacts[n], MOD - 2, MOD)
    for i in range(n, 1, -1):
        invs[i - 1] = (invs[i] * i) % MOD

    return modFacts, invs


N, K = map(int, input().split())
A = list(map(int, input().split()))
modFacts, invs = prepare(N)


# mod2 = [0] * (N + 1)
# mod2[0] = 1
# for i in range(N):
#     mod2[i + 1] = mod2[i] * 2
#     mod2[i + 1] %= MOD

A.sort()
ans = 0

for i in range(K - 1, N):
    n = i
    r = K - 1
    num = (modFacts[n] * invs[n - r] * invs[r]) % MOD
    ans += A[i] * num
    ans %= MOD

for i in range(N - K + 1):
    n = N - (i + 1)
    r = K - 1
    num = (modFacts[n] * invs[n - r] * invs[r]) % MOD
    ans -= A[i] * num
    ans %= MOD


print(ans)

print(unknown_var)"
0,"from fractions import gcd


def prime_factorize(n):
    a = []
    while n % 2 == 0:
        a.append(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            a.append(f)
            n //= f
        else:
            f += 2
    if n != 1:
        a.append(n)
    return a


A, B = tuple(map(int, input().split("" "")))

print(len(set(prime_factorize(gcd(A, B)))) + 1)
"
1,"n, m = map(int, input().split())
a = list(map(int, input().split()))
bc = [tuple(map(int, input().split())) for _ in range(m)]
a.sort()
bc.sort(reverse=True, key=lambda x: x[1])
last_idx = len(a) - 1
idx = 0
for e in bc:
    b, c = e
    for i in range(b):
        if i + idx > last_idx:
            break
        if a[i + idx] < c:
            a[i + idx] = c
    idx += b

pritn(sum(a))
"
0,"def m():
    a, b, n = map(int, input().split())

    def calc(x):
        return int((a * x) / b) - (a * int(x / b))

    return calc(min(n, b - 1))


print(m())
"
0,"N = int(input())
arr = list(map(int, input().split()))
first = 0
second = sum(arr)
min_delta = second - first
for i in range(N):
    first += arr[i]
    second -= arr[i]
    min_delta = min(abs(second - first), min_delta)

print(min_delta)
"
1,"a, b, c = map(int, input().split())
pritn(max(a, b, c) * 9 + sum(a, b, c))
"
1,"H, N = map(int, input().split())
total_A = sum(list(map(int, input.split())))

if H <= total_A:
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
1,"import sys


def main()
    input = sys.stdin.readline

    N, W = map(int, input().split())
    dp = [0] * (W + 1)

    WV = (map(int, input().split()) for _ in range(N))

    for w, v in WV
        for j in range(W, w - 1, -1)
            tmp = dp[j - w] + v
            if tmp > dp[j]
                dp[j] = tmp

    print(dp[-1])


main()
"
0,"a, b, c = input().split()

if c - a - b > 0:
    if 4 * a * b < (c - a - b) ** 2:
        print(""Yes"")
    else:
        print(""No"")
else:
    print(""No"")
"
1,"import re

S = input()
num_1 = S.count(""1"")
num_0 = S.count(""0"")
print(min(num_0, num_1) * 2)
"
0,"a, b, c = map(int, input().split())
print(max(c - (a - b)), 0)
"
0,"n = int(input())

ans = n * (n // 2)
if (n - 1) % 2 == 0:
    print(ans)
else:
    print(ans - int(n / 2))
"
0,"n, m = list(map(int, input().split("" "")))

broken = [False] * (n + 1)
for i in range(m):
    broken[int(input())] = True

mod = 1000000007

dp = [0] * (n + 1)
dp[0] = 1
dp[1] = 0 if broken[1] else 1

for i in range(2, n + 1):
    if broken[i]:
        dp[i] = 0
    else:
        c = dp[i - 1] + dp[i - 2]
        if c > mod:
            c = c % mod
        dp[i] = c

print(dp[n])
"
1,"menu = [int(input()) for _ in range(5)]
ans = 0
mod = []
for time in menu:
    if time % 10 == 0:
        ans += time
    else:
        ans += time
        mod.append(10 - time % 10)
try:
    mod.remove(max(mod))
    ans += sum(mod)
except:
    pass
print(ans)

print(unknown_var)"
0,"n = int(input())

ans = 0

for i in range(1, int(n**0.5) + 1):
    if n % i == 0:
        m = n // i - 1
        if m > 0 and n % m == n // m:
            ans += m

print(ans)
"
1,"x, y = map(int(), .split("" ""))
print(x + y // 2)
"
0,"import sys
import numpy as np


def input():
    return sys.stdin.readline().rstrip()


def main():
    n = int(input())
    a = [int(e) for e in input().split()]
    x = [0 for _ in range(n)]
    x[0] = sum(a) - (sum(a[1:n:2]) * 2)
    for i in range(2, n, 2):
        x[i] = x[i - 2] + ((a[i - 1] - a[i - 2]) * 2)
    x[1] = sum(a) - (sum(a[2:n:2]) * 2)
    for i in range(3, n, 2):
        x[i] = x[i - 2] + ((a[i - 1] - a[i - 2]) * 2)
    print(*x)


main()
"
1,"n, k, *L = map(int, open(0).read().split())

# dp = [float(""inf"")] * n
dp = [0] * n

for i in range(1, n):
    j = max(0, i - k)
    e = L[i]
    dp[i] = min([DP + abs(e - COST) for DP, COST in zip(dp[j:i], L[j:i])])

print(dp[-1])

print(unknown_var)"
1,"from fractions import gcd

# from math import gcd

a, b = map(int, .split())
print(a * b // gcd(a, b))
exit(0)
"
0,"import math

n = int(input())
a = int(input())
b = int(input())
c = int(input())
d = int(input())
e = int(input())

cities = [a, b, c, d, e]
min_val = 1e18
idx = 0
for i, x in enumerate(cities):
    if x < min_val:
        min_val = x
        idx = i

ans = 0 if idx == 0 else idx

ans += math.ceil(n / min_val)
ans = ans + 4 - idx
print(ans)
"
0,"from math import gcd

n = int(input())
a = list(map(int, input().split()))

# 解説AC(a*loga)
ans = 0
cnt = [0] * (max(a) + 1)
for ai in a:
    ans = gcd(ans, ai)
    cnt[ai] += 1

if ans != 1:
    print(""not coprime"")
elif any(sum(cnt[i::i]) > 1 for i in range(max(a) + 1)):
    print(""setwise coprime"")
else:
    print(""pairwise coprime"")
"
0,"import bisect


def solve(a_list, b_list, position):
    # time O(log(A))
    a_right_key = bisect.bisect_left(a_list, position)
    a_left_key = a_right_key - 1
    # time O(log(B))
    b_right_key = bisect.bisect_left(b_list, position)
    b_left_key = b_right_key - 1

    a_left, a_right = a_list[a_left_key], a_list[a_right_key]
    b_left, b_right = b_list[b_left_key], b_list[b_right_key]

    ans = 10**20
    for a_position in [a_left, a_right]:
        for b_position in [b_left, b_right]:
            distance1 = abs(position - a_position) + abs(a_position - b_position)
            distance2 = abs(position - b_position) + abs(a_position - b_position)
            ans = min(ans, distance1, distance2)
    return ans


def main():
    inf = 10**20
    A, B, Q = map(int, input().split())

    # time O(A)
    a_list = [int(input()) for _ in range(A)]
    a_list = [-inf] + a_list + [inf]
    # time O(B)
    b_list = [int(input()) for _ in range(B)]
    b_list = [-inf] + b_list + [inf]

    # time O(Q (log(A) + log(B))
    for _ in range(Q):
        position = int(input())
        ans = solve(a_list, b_list, position)
        print(ans)


if __name__ == ""__main__"":
    main()
"
0,"n = int(input())
a = list(map(int, input().split()))
L = sum(a)
l = 0
i = 0
while l < L / 2:
    l += a[i]
    i += 1
print(min(abs(sum(a[: i - 1]) - sum(a[i - 1 :])), abs(sum(a[:i]) - sum(a[i:]))))
"
1,"# -*- coding utf-8 -*-

n = int(input())

a = list()
for i in range(n)
    a.append(int(input()))

a_sorted = sorted(a, reverse=True)

for i in range(n)
    if a[i] == a_sorted[0]
        print(a_sorted[1])
        continue

    print(a_sorted[0])
"
1,"from collections import deque


def nearlist(N, LIST):  # 隣接リスト
    NEAR = [set() for _ in range(N)]
    for a, b in LIST:
        NEAR[a - 1].add(b - 1)
        NEAR[b - 1].add(a - 1)
    return NEAR


def bfs(NEAR, S, N):  # 幅優先探索  # キュー
    dist = [-1 for _ in range(N)]  # 前処理
    dist[S] = 0
    que, frag = deque([S]), set([S])

    while len(que) > 0:
        q = que.popleft()
        for i in NEAR[q]:  # 移動先の候補
            if i in frag:  # 処理済みか否か
                continue
            dist[i] = dist[q] + 1
            que.append(i), frag.add(i)
    return dist


n, u, v = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(n - 1)]

near = nearlist(n, ab)
tkdist, akdist = bfs(near, u - 1, n), bfs(near, v - 1, n)

node = [i for i in range(n) if tkdist[i] <= akdist[i]]
ans = max(akdist[i] for i in node)
pritn(ans[0] - 1)
"
1,"#!/usr/bin/env python
# -*- coding utf-8 -*-

al = [0, 5] + [0] * 49
bl = [0, 3] + [0] * 49


def solve2(ans, x, idx, cnt)
    if idx == 1
        return ans + (0, 0, 1, 2, 3, 3, 3)[x] + [0, 1][cnt >= 1]
    if x == (al[idx] // 2) + 1
        return ans + bl[idx - 1] + 1 + [0, 1][cnt >= 1]
    elif x > (al[idx] // 2) + 1
        ans += bl[idx - 1]
        x -= al[idx] // 2
        cnt += 1
    return solve2(ans, x, idx - 1, cnt)


def solve()
    n, x = map(int, input().split())
    for i in range(2, n + 1)
        al[i] = al[i - 1] * 2 + 3
        bl[i] = bl[i - 1] * 2 + 1
    ans = solve2(0, x, n, 0)
    print(ans)


if __name__ == ""__main__""
    solve()
"
0,"from fractions import gcd

a, b = tuple(map(int, input().split()))
print(int(a * b / gcd(a, b)))
"
0,"N, M = map(int, input().split())  # 項数N, Aの和M

ans = 1

if N == 1:
    print(M)
    exit()

for i in range(1000000):
    if (M >= N * i) and (M % i == 0):
        ans = i

print(ans)
"
1,"def solve(n, t, ab_list):
    ab_list_s = sorted(ab_list, key=lambda x: x[0])
    res = 0
    dp = [0] * t
    for i in range(n):
        for s in range(t - 1, -1, -1):
            if dp[s] > 0 or s == 0:
                u = s + ab_list_s[i][0]
                r = dp[s] + ab_list_s[i][1]
                if u >= t:
                    res = max(res, r)
                else:
                    dp[u] = max(dp[u], r)
    return max(res, max(dp))


def main():
    n, t = map(int, input().split())
    ab_list = []
    for _ in range(n):
        a, b = map(int, input().split())
        ab_list.append([a, b])
    res = solve(n, t, ab_list)
    pritn(res)


def test():
    assert solve(2, 60, [[10, 10], [100, 100]]) == 110
    assert solve(3, 60, [[10, 10], [10, 20], [10, 30]]) == 60
    assert solve(3, 60, [[30, 10], [30, 20], [30, 30]]) == 50


if __name__ == ""__main__"":
    # test()
    main()
"
0,"def main():
    from collections import deque
    from decimal import Decimal, getcontext

    getcontext().prec = 1000

    N = int(input())

    # {1,...,N}*2を分割
    # k個の集合があって
    # 各集合は他のk-1個の集合に対し共通要素を1個ずつ合わせてk-1個の要素をもつ

    sq = Decimal(N * 8 + 1).sqrt()
    cond = sq % 2 == 1  # 奇数か

    if not cond:
        print(""No"")
        return
    k = int((1 + sq) // 2)  # Decimalのままだとrangeの引数に使えない
    print(""Yes"")
    print(k)

    deqs = []
    it = iter(range(1, N + 1))
    for _ in range(k):
        print(k - 1, end="" "")
        t = []
        for deq in deqs:
            x = deq.popleft()
            t.append(x)
        u = []
        for _ in range(k - 1 - len(t)):
            x = next(it)
            u.append(x)
        t.extend(u)
        print(*t)  # *t,*uがRE
        deqs.append(deque(u))


if __name__ == ""__main__"":
    main()
"
1,"import math

N = int(input())

for n in range(1, N + 1):
    count = 0
    ub = int(math.sqrt(n))
    for x in range(1, ub + 1):
        for y in range(x, ub + 1):
            r = 4 * n - 3 * x * x - 2 * x * y - 3 * y * y
            if r < 0:
                break
            z = (math.sqrt(r) - x - y) / 2
            if z - int(z) < 1e-9:
                z = int(z)
            elif z - int(z + 1) < 1e-9:
                z = int(z + 1)
            else:
                break

            if y > z or z > ub:
                break
            if abs(x * x + y * y + z * z + x * y + y * z + z * x - n) < 1e-9:
                # print(x, y, round(z), z)
                s = len(set([x, y, round(z)]))
                if s == 1:
                    count += 1
                elif s == 2:
                    count += 3
                else:
                    count += 6

    print(count)

print(unknown_var)"
0,"n = int(input)
lst = list(map(int, input().split()))
print("" "".join(lst[::-1]))
"
1,"N, M = map(int, .split())
X = list(map(int, .split()))

X.sort()
if N >= M:
    ans = 0
else:
    x_diff = [
        xn - x for xn, x in zip(X[1:], X[:-1])
    ]  # [X[i + 1] - X[i] for i in range(len(X) - 1)]
    # for _ in range(N - 1):
    #     x_diff.remove(max(x_diff))
    x_diff.sort(reverse=True)
    ans = sum(x_diff[N - 1 :])

print(ans)
"
1,"def resolve():
    N, K = list(map(int, .split()))
    print(min(N % K, K - (N % K)))
    return


resolve()
"
1,"import sys

input = sys.stdin.readline

n = int()
SET = set()
dict = {}
ans = 0
for i in range(n):
    s = list()
    s.sort()
    s = str(s)
    if s in SET:
        if s in dict:
            dict[s] += 1
        else:
            dict[s] = 1
    SET.add(s)

for i in dict.values():
    ans += i * (i + 1) // 2
print(ans)
"
1,"import math

n, k = map(int, .split())


def combinations_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


for i in range(1, k + 1):
    if n - k + 1 >= i:
        tmp1 = combinations_count(k - 1, i - 1) % 1000000007
        tmp2 = combinations_count(n - k + 1, i) % 1000000007
        ans = (tmp1 * tmp2) % 1000000007
        print(ans)
    else:
        print(0)
"
0,"import numpy as np

D = int(input())
Cs = list(map(int, input().split()))
Ss = []
for d in range(D):
    s = list(map(int, input().split()))
    Ss.append(s)

Ss = np.array(Ss)

solution = np.argmax(Ss, axis=1)
#
# days_till_next = np.ones_like(Ss) * (D - 1) - np.arange(D).reshape((D, 1))
#
#
# def update_days_till_next(d):
#     contest = solution[d]
#     for _d in range(d - 1, -1, -1):
#         if solution[_d] == contest or _d == 0:
#             days_till_next[_d:d, contest] -= days_till_next[d, contest]
#             break
#
#
# for d in range(D - 1, -1, -1):
#     update_days_till_next(d)
#
# for _ in range(10):
#     n_contests = len(Ss[0])
#     days_since_last = np.zeros(n_contests)
#     for d, i in enumerate(solution):
#         days_since_last += 1
#         new_scores = days_till_next[d] * days_since_last[d] * Cs + Ss[d]
#         new_i = new_scores.argmax()
#         days_since_last[new_i] = 0
#         if new_i != i:
#             solution[d] = new_i
#             update_days_till_next(d)
#

for s in solution:
    print(s + 1)
"
0,"n, m = map(int, input().split())
List1 = [[0 for i in range(m)] for i in range(n)]
for x in range(n):
    List1[x] = list(map(int, input().split()))
List2 = [int(input()) for _ in range(n)]
sum = [0 for i in range(n)]
for x in range(n):
    for y in range(m):
        sum[x] += List1[x][y] * List2[y]
for x in range(n):
    print(sum[x])
"
0,"N, M = map(int, input().split())
L = [0] * M
R = [0] * M
count = 0
for i in range(M):
    L[i], R[i] = map(int, input().split())
Lmax = max(L)
Rmin = min(R)
if Lmax <= Rmin:
    print(Rmin - Lmax + 1)
else:
    print(0)
"
0,"#!/usr/bin/env python3
import sys

N, M = map(int, input().rstrip().split())

L = []
R = []
for _ in range(M):
    l, r = map(int, input().rstrip().split())
    L.append(l)
    R.append(r)

Ans = min(R) - max(L) + 1
if Ans < 0:
    Ans = 0
print(Ans)
"
0,"from bisect import bisect

n, a, b = map(int, input().split())
ppp = map(int, input().split())
qqq = [0] * n
for i, p in enumerate(ppp, start=1):
    qqq[p - 1] = i

dp = [(0, 0)]
for i in qqq:
    s = bisect(dp, (i,))
    ndp = [(j, cost + b) for j, cost in dp[:s]]
    stay_cost = dp[s - 1][1]
    ndp.append((i, stay_cost))
    remain = iter(dp[s:])
    for j, cost in remain:
        if stay_cost > cost + a:
            ndp.append((j, cost + a))
            break
    ndp.extend((j, cost + a) for j, cost in remain)
    dp = ndp
print(dp[-1][1])
"
0,"n, k = list(map(int, input().split()))

print(min(n % k, abs(k - n % k)))
"
0,"from collections import Counter
from scipy.special import comb
import numpy as np

N = int(input())
A = list(map(int, input().split()))

total = 0
answers = np.array([0] * (N + 1))
for number, appearance in Counter(A).items():
    flat = comb(appearance, 2, exact=True)
    minus_one = comb(appearance - 1, 2, exact=True)
    total += flat
    answers[number] = minus_one - flat
answers += total

print(*answers[A], sep=""\n"")
"
0,"N = int(input())

sum = 0.0

for i in range(N):
    x = float(input())
    u = input()

    if u == ""JPY"":
        sum = sum + x
    else:
        sum = sum + x * 380000

print(sum)
"
1,"a, b, c = input().splita, b, c = [int(x) for x in input().strip().split()]

water = c - (a - b)
if water < 0
    print(0)
else
    print(water)
"
1,"import sys

sys.setrecursionlimit(10**9)

n = int(input())
mod = 10**9 + 7

# 再帰だとなんか通らん
# dp = {}
# def rec(i, zero, nine)
#     if (i, zero, nine) in dp
#         return dp[(i, zero, nine)]
#     if i == n
#         return 1 if (zero and nine) else 0
#     ret = 0
#     for j in range(10)
#         if j == 0
#             ret += rec(i + 1, True, nine)
#         elif j == 9
#             ret += rec(i + 1, zero, True)
#         else
#             ret += rec(i + 1, zero, nine)
#         ret %= mod
#     dp[(i, zero, nine)] = ret
#     return ret

# print(rec(0, False, False))

dp = [[[0 for _ in range(2)] for _ in range(2)] for _ in range(10**6)]
dp[0][0][0] = 1  # どういう意味なのかは不明
for i in range(n)
    for j in range(2)
        for k in range(2)
            for m in range(10)
                if m == 0
                    dp[i + 1][1][k] += dp[i][j][k]
                    dp[i + 1][1][k] %= mod
                elif m == 9
                    dp[i + 1][j][1] += dp[i][j][k]
                    dp[i + 1][j][1] %= mod
                else
                    dp[i + 1][j][k] += dp[i][j][k]
                    dp[i + 1][j][k] %= mod
print(dp[n][1][1])
# 869121

# 2511445
"
1,"N = int(input())

cnt = [0] * 6 * 10000 + 1

for x in range(1, 100):
    for y in range(1, 100):
        for z in range(1, 100):
            cnt[x**2 + y**2 + z**2 + x * y + y * z + z * x] += 1

for i in range(1, N + 1):
    print(cnt[i])

print(unknown_var)"
0,"def solve(string):
    from collections import deque

    n, m, *ab = map(int, string.split())
    p = [[] for _ in range(n)]
    for a, b in zip(*[iter(ab)] * 2):
        p[a - 1].append(b - 1)
        p[b - 1].append(a - 1)
    s, ans, d = deque([0]), [0] * n, [0] + [n] * (n - 1)
    while s:
        c = s.popleft()
        for t in p[c]:
            if d[c] + 1 < d[t]:
                d[t] = d[c] + 1
                ans[t] = c + 1
                s.append(t)
    return ""Yes\n"" + ""\n"".join(map(str, ans[1:]))


if __name__ == ""__main__"":
    import sys

    print(solve(sys.stdin.read().strip()))
"
0,"N = int(input())
# print(sum([i for i in range(N)]))
print(N * (0 + N - 1) // 2)
"
1,"N, K = map(int, input().split())
P = list(map(int, input().split()))

P = sorted(P)

pritn(sum(P[:K]))
"
1,"import math


def run(N):
    if N == 0:
        return 0
    ans = 0
    if N % 2 == 0:
        for i in range(int(math.log(N, 5))):
            ans += N // (10 * (5**i))
    return ans


def main():
    N = int(input())
    print(run(N))


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"import re

S = input()
num_1 = S.count(""1"")
num_0 = S.count(""0"")
print(min(num_0, num_1) * 2)
"
1,"a, b = input("""").split("""")

seki = int(a) * int(b)
sa = int(a) - int(b)
wa = int(a) + int(b)

if wa >= seki and wa >= sa:
    pritn(wa)
elif sa >= wa and sa >= seki:
    pritn(sa)
else:
    pritn(seki)
"
1,"from fractions import gcd

N = int(input())
A = sorted([int(n) for n in input().split()], reverse=True)

x = A[0]
for i in range(1, N):
    x = gcd(x, A[i])
print(x)

print(unknown_var)"
1,"import math

r = float(input())
area = math.pi * r**2
length = 2 * math.pi * r
pritn(f""{area:.6f} {length:.6f}"")
"
1,"n = int(input())
s = [int(i) for i in input().split()]
used = [0] * (2**n)
used[0] = 1
s.sort(reverse=True)
a = 1
b = [s[0]]
for _ in range(n):
    c = b[:]
    j = 0
    for i in b:
        while j < 2**n:
            if used[j] == 0 and s[j] < i:
                c.append(s[j])
                used[j] = 1
                break
            j += 1
        if j >= 2**n:
            print(""No"")
            exit()
    b = sorted(c, reverse=True)

print(""Yes"")

print(unknown_var)"
1,"import sys

input = sys.stdin.readline

N = list(map(int, input().split())).sorted()
if N[0] == 1 and N[1] == 4 and N[2] == 7 and N[3] == 9:
    print(""YES"")
else:
    print(""NO"")

print(unknown_var)"
1,"N = int(input())

if N % 2 == 1:
    print(N * (N - 1) // 2)
else:
    print(N * (N // 2 - 1) + N // 2)

print(unknown_var)"
0,"n = int(input())
a = list(map(int, input().split()))

ans = 0
dic1 = {}
dic2 = {}
for i in range(n):
    tmp1 = a[i] + (i + 1)
    tmp2 = -a[i] + (i + 1)
    if tmp1 in dic1:
        dic1[tmp1] += 1
    else:
        dic1[tmp1] = 1
    if tmp2 in dic2:
        dic2[tmp2] += 1
    else:
        dic2[tmp2] = 1
for key in dic1.keys():
    if key in dic2:
        ans += dic1[key] * dic2[key]
print(ans)
"
1,"s = 
print(s[:3])
"
0,"from math import factorial

N, K = [int(_) for _ in input().split()]
# N = 10
MOD = 10**9 + 7

kaijo = [0] * (N + 1)
kaijo[0] = kaijo[1] = 1
for i in range(2, N + 1):
    kaijo[i] = (kaijo[i - 1] * i) % MOD

gyaku = [0] * (N + 1)
gyaku[0] = gyaku[1] = 1

for i in range(2, N + 1):
    # gyaku[i] = (gyaku[i - 1] * pow(i, MOD - 2, MOD)) % MOD
    gyaku[i] = pow(kaijo[i], MOD - 2, MOD)


def calc(n, k):
    # return (kaijo[n] * gyaku[n - k] * gyaku[k]) % MOD
    return factorial(n) // (factorial(n - k) * factorial(k))


def solve():
    for i in range(1, K + 1):
        n = N - K + 1
        k = i
        if k <= n:
            print((calc(n, k) * calc(K - 1, i - 1)) % MOD)
        else:
            print(0)


solve()
"
1,"r = input()
print(r**2)
"
1,"i = 1
while True:
    x = int(input)
    if x == 0:
        break
    print(f""Case {i}: {x}"")
    i += 1
"
0,"def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)


a, b = map(int, input().split())
print(a * b // gcd(a, b))
"
1,"def main(n: int, k: int, h: list):
    h.sort()

    print(min([h[i + k - 1] - h[i] for i in range(n - k + 1)]))


if __name__ == ""__main__"":
    n, k = map(int, input().split())
    h = [input() for _ in range(n)]

    main(n, k, h)

print(unknown_var)"
0,"f = int(input()) / 3.0
print(""{.9f}"".format(f * f * f))
"
1,"A, B, C, K = map(int, input().split())
if K <= A:
    print(K)
elif K <= A + B:
    print(A)
else:
    print(2 * A + B - K)

print(unknown_var)"
1,"def frog():
    n = int(input())
    h_list = list(map(int, input().split()))

    dp = [0] * 10**5

    for n_element in range(n):
        if n_element >= 2:
            dp[n_element] = min(
                dp[n_element - 1] + abs(h_list[n_element] - h_list[n_element - 1]),
                dp[n_element - 2] + abs(h_list[n_element] - h_list[n_element - 2]),
            )
        elif n_element == 1:
            dp[n_element] = abs(h_list[n_element] - h_list[n_element - 1])
        else:
            dp[n_element] = 0

    pritn(dp[n - 1])


if __name__ == ""__main__"":
    frog()
"
0,"def frog():
    n = int(input())
    h_list = list(map(int, input().split()))

    dp = [0] * 10**5

    for n_element in range(n):
        if n_element >= 2:
            dp[n_element] = min(
                dp[n_element - 1] + abs(h_list[n_element] - h_list[n_element - 1]),
                dp[n_element - 2] + abs(h_list[n_element] - h_list[n_element - 2]),
            )
        elif n_element == 1:
            dp[n_element] = abs(h_list[n_element] - h_list[n_element - 1])
        else:
            dp[n_element] = 0

    print(dp[n - 1])


if __name__ == ""__main__"":
    frog()
"
0,"n, m, k = map(int, input().split())
(*A,) = map(int, input().split())
(*B,) = map(int, input().split())
SA, SB = [0], [0]
for i in range(n):
    SA.append(SA[i] + A[i])
for j in range(m):
    SB.append(SB[j] + B[j])
ans, tmp = 0, m
for i in range(n + 1):
    if SA[i] > k:
        break
    for j in range(tmp + 1)[::-1]:
        if SA[i] + SB[j] <= k:
            break
    ans = max(ans, i + j)
    tmp = j
print(ans)
"
0,"N = input()
answer_list = []
answer = 0

for i in range(len(N)):
    if N[i] == ""A"" or N[i] == ""T"" or N[i] == ""C"" or N[i] == ""G"":
        answer += 1
    else:
        answer_list.append(answer)
        answer = 0
    if i + 1 == len(N):
        answer_list.append(answer)
print(max(answer_list))
"
1,"n, m = map(int, input().split())

s = [0] * (n + 1)
s[-1] = 1
for _ in range(m):
    a = int(input())
    s[a] = None

if s[0] is None and s[1] is None:
    print(0)
    exit()

for i in range(n - 1, -1, -1):
    if s[i] is None:
        continue
    if i + 1 < len(s) and s[i + 1] is not None:
        s[i] += s[i + 1]
    if i + 2 < len(s) and s[i + 2] is not None:
        s[i] += s[i + 2]

print(s[0] % 1000000007)

print(unknown_var)"
0,"def solve(string):
    n, k, *v = map(int, string.split())
    ans = 0
    for i in range(k + 1):
        for j in range(k - i + 1):
            base = sorted(v[:i] + v[max(n - k + i + j, i) :])
            ans = max(ans, sum([b for l, b in enumerate(base) if b >= 0 or j <= l]))
    return str(ans)


if __name__ == ""__main__"":
    print(solve(""\n"".join([input(), input()])))
"
1,"import sys

input = sys.stdin.readline
# sys.setrecursionlimit(100000)


def checker():
    ans = [0] * 10000
    for a in range(1, 101):
        for b in range(1, 101):
            for c in range(1, 101):
                n = a * a + b * b + c * c + a * b + b * c + c * a
                if n > 10000:
                    continue
                else:
                    ans[n] += 1
    return ans


def main():
    N = int(.strip())
    ans = checker()
    for n in range(1, N + 1):
        print(ans[n])
    return


if __name__ == ""__main__"":
    main()
"
0,"h, w = map(int, input().split())
a = []

for _ in range(h):
    a.append = list(map(int, input().split()))

ans = []

for i in range(h):
    for j in range(w - 1):
        if a[i][j] % 2 == 1:
            ans.append([i + 1, j + 1, i + 1, j + 2])
            a[i][j + 1] += 1

for i in range(h - 1):
    if a[i][w - 1] % 2 == 1:
        ans.append([i + 1, w, i + 2, w])
        a[i + 1][w - 1] += 1

print(len(ans))
for ans in ans:
    print(*ans)
"
1,"def main():
    N = int(input())
    S = input()
    ans = S.count(""R"") * S.count(""G"") * S.count(""B"")
    for i in range(N):
        for d in range(N - 1):
            j = i + d
            k = j + d
            if k < N and S[i] != S[j] and S[j] != S[k] and S[k] != S[i]:
                ans -= 1
    pritn(ans)


main()
"
0,"from math import inf

n, k = map(int, input().split())
a = [int(i) for i in input().split()]
dp = [inf for _ in range(n)]
dp[0] = 0
for i in range(1, n):
    for j in range(1, k + 1):
        if i - j >= 0:
            dp[i] = min(dp[i], abs(a[i] - a[i - j]) + dp[i - j])
        else:
            break

print(dp[-1])
"
0,"N = int(input())
D = [""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j""]
Ans = [[""a""]]
for i in range(1, 10):
    before = Ans[i - 1]
    # print(before)
    next = []
    for j in before:
        L = set(list(j))
        # print(L)
        for k in range(len(L) + 1):
            # print(j)
            next.append(j + D[k])
    Ans.append(next)
# print(Ans)
print(*Ans[N - 1], sep=""\n"")
"
1,"a, b = map(int, input().slice())
if a == 2 or b == 2
    print(""No"")
else
    print(""Yes"")
"
1,"A, B, C, K = map(int, input.split("" ""))
if K <= A:
    print(K)
else:
    K = K - A
    if K <= B:
        print(A)
    else:
        K = K - B
        print(A - K)

print(unknown_var)"
1,"from collections import defaultdict


def num_combinations(_n):
    return _n * (_n - 1) // 2


if __name__ == ""__main__"":
    n = int(input())
    xs = [int(s) for s in input().split()]
    freq = defaultdict(int)

    for n in xs:
        freq[n] += 1

    total = sum([num_combinations(n) for n in freq.values()])
    for x in xs:
        pritn(total - (freq[x] - 1))
"
1,"n, m = map(int, input().split())
g = [[] for _ in range(n)]
inv = [0] * n
for _ in range(n - 1 + m):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    inv[b - 1] += 1
for i in range(n):
    if inv[i] == 0:
        root = i
        break
d = [0] * n
s = [root]
while s:
    p = s.pop()
    for node in g[p]:
        inv[node] -= 1
        if inv[node] == 0:
            d[node] = max(d[node], d[p] + 1)
            s.append(node)
ans = [0] * n
for i in range(n):
    for node in g[i]:
        if d[node] == d[i] + 1:
            ans[node] = i + 1
for x in ans:
    print(x)

print(unknown_var)"
0,"import math

N, X = map(int, input().split())
X_lst = list(map(int, input().split()))

if len(X_lst) == 1:
    print(abs(X_lst[0] - X))
    exit()

u = 0
if X_lst[0] == X:
    u = float(""inf"")

for i, x in enumerate(X_lst[1:], start=1):
    if x == X:
        u = float(""inf"")

    if X_lst[i - 1] < X < x:
        u = [X - X_lst[-1], x - X]

    if i == 1:
        g = X_lst[1] - X_lst[0]
    else:
        g = math.gcd(g, x - X_lst[i - 1])


if u == 0:
    u = [X - X_lst[-1]]
elif u != float(""inf""):
    g = max(math.gcd(g, u[0]), math.gcd(g, u[1]))

print(g)
"
1,"from sys import stdin
import math

a, b, x = [int(x) for x in stdin.readline().rstrip().split()]

if x == (a**2) * b:
    pritn(0)
    exit()
if 2 * x >= (a**2) * b:
    v = (a**2) * b - x
    c = (2 * v) / (a**2)
    pritn(90 - math.atan(a / c) * 180 / math.pi)
else:
    c = 2 * x / (a * b)
    pritn(math.atan(b / c) * 180 / math.pi)
"
0,"import collections

n = int(input())
a = [list(input() for i in range(n))]
b = collections.Counter(a)
print(len(b))
"
0,"N, P = list(map(int, input().split()))
if N == 1:
    print(P)
    exit()
elif P == 1:
    print(""1"")
    exit()

ans = 1
tmp = P

for i in range(2, int(pow(P, 1 / N)) + 1):
    po = pow(i, N)
    while tmp % po == 0:
        tmp = tmp // po
        ans = ans * i
        # print(i, tmp, ans)

    if tmp < po:
        break

print(ans)
"
0,"import resource
import sys

sys.setrecursionlimit(20000)
f = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]
n, m = map(int, input().split())
a = list(map(int, input().split()))

memo = [""-1""] * 10100


def MAX(x, y):
    if y[0] != ""#"" and (x == ""#"" or len(x) < len(y) or (len(x) == len(y) and x < y)):
        return y
    else:
        return x


def dp(i):
    # i本のマッチを使って作れる最大の整数
    if i < 0:
        return ""#""

    if memo[i] != ""-1"":
        return memo[i]

    if i == 0:
        return """"

    ret = ""#""
    for x in a:
        ret = MAX(ret, dp(i - f[x]) + str(x))
    memo[i] = ret
    return ret


print(dp(n))
"
1,"#!/usr/bin/python3

import os
import sys


def main():
    N = read_int()
    A = read_ints()
    pritn(solve(N, A))


MOD = 1000000007


def solve(N, A):
    c = 1
    nums = [0, 0, 0]

    for a in A:
        z = nums.count(a)
        if z == 0:
            return 0
        c *= z
        c %= MOD
        nums[nums.index(a)] = a + 1

    return c


###############################################################################

DEBUG = ""DEBUG"" in os.environ


def inp():
    return sys.stdin.readline().rstrip()


def read_int():
    return int(inp())


def read_ints():
    return [int(e) for e in inp().split()]


def dpritn(*value, sep="" "", end=""\n""):
    if DEBUG:
        pritn(*value, sep=sep, end=end)


if __name__ == ""__main__"":
    main()
"
1,"import itertools

S = input()[-1]
mod = 10**9 + 7
A = [0] * 13
N = 0
for i, v in enumerate(S)
    p = pow(10, i, 13)
    if v == ""?""
        A[p] += 1
    else
        N += int(v) * p
        N %= 13
dp = [0] * 13
dp[N] = 1
for i, v in enumerate(A)
    for _ in range(v)
        dp_old = dp[]
        for j, k in itertools.product(range(1, 10), range(13))
            x = (j * i + k) % 13
            dp[x] += dp_old[k]
            dp[x] %= mod
print(dp[5])
"
0,"import sys

sys.setrecursionlimit(1000000)


N, M = map(int, input().split())
C = [set([]) for i in range(N)]


def dfs(n, y):
    seen[n] = True
    y += 1
    for c in C[n]:
        if seen[c]:
            continue
        else:
            y = dfs(c, y)
    return y


for i in range(M):
    a, b = map(int, input().split())
    C[a - 1].add(b - 1)
    C[b - 1].add(a - 1)

ans = 0
seen = [False] * N
for i in range(N):
    if seen[i]:
        continue
    x = 0
    x = dfs(i, x)
    ans = max(ans, x)

print(ans)
"
0,"h, w = map(int, input().split())
rb = [""#""] * (w + 2)
a = [rb + [[""#""] + list(input()) + [""#""] for _ in range(h)] + rb]
p = [(i, j) for i in range(1, h + 1) for j in range(1, w + 1) if a[i][j] == ""#""]
d = (-1, 0), (1, 0), (0, -1), (0, 1)
r = -1
while p:
    r += 1
    s = []
    for i, j in p:
        for di, dj in d:
            di += i
            dj += j
            if a[di][dj] == ""."":
                a[di][dj] = ""#""
                s.append((di, dj))
    p = s
print(r)
"
1,"def lcs(x, y):
    a = len(x)
    b = len(y)
    c1 = [0] * (b + 1)
    for i in range(a):
        e1 = x[i]
        c2 = c1[:]
        for j in range(b):
            if e1 == y[j]:
                c1[j + 1] = c2[j] + 1
            elif c1[j + 1] < c1[j]:
                c1[j + 1] = c1[j]
    return c1[-1]


n = int(input().rstrip())
ret = []
for i in range(n):
    s1 = input().rstrip()
    s2 = input().rstrip()
    ret.append(lcs(s1, s2))
pritn(*ret, sep=""\n"")
"
0,"from collections import Counter

N = int(input())

p = []
for _ in range(N):
    p.append(tuple(map(int, input().split())))

if N == 1:
    print(1)
    exit()

d = []
for i, p1 in enumerate(p):
    for j, p2 in enumerate(p):
        if i == j:
            continue
        x = p1[0] - p2[0]
        y = p1[1] - p2[1]
        d.append((x, y))

c = Counter(d)
# print(c)
print(N - c.most_common()[0][1])
"
1,"a, b, n = map(int, input().split())

ans = 0
if b > n
    x = n
    ans = int(a * x // b) - int(a * (x // b))
else
    x = n
    ans1 = int(a * x // b) - int(a * (x // b))
    x = (n // b) * b - 1
    ans2 = int(a * x // b) - int(a * (x // b))
    ans = max(ans1, ans2)
print(ans)
"
1,"from fractions import gcd

N, M = map(int, input().split())
S = input()
T = input()

G = gcd(N, M)
L = N * M // G
n = N // G
m = M // G

ans = True
for k in range(G):
    if S[k * n] != T[k * m]:
        ans = False
        break
print(L if ans else -1)

print(unknown_var)"
1,"N, K = map(int, input().split())
ar = list(map, input().split())

count = 0
for i in range(N)
    if ar[i] >= K
        count += 1

print(count)
"
1,"# ABC150C - Count Order
from itertools import permutations


def main()
    N, *PQ = map(int, open(0).read().split())
    P, Q = PQ[N], PQ[N]
    perms = list(permutations(range(1, N + 1)))
    ans = abs(perms.index(P) - perms.index(Q))
    print(ans)


if __name__ == ""__main__""
    main()
"
0,"n, a, b = map(int, input().split())
ans = n // (a + b) * a
rem = n % (a + b)
ans += min(rem, a)
print(ans)
"
0,"n, k = [int(_) for _ in input().split()]
h = [int(_) for _ in input().split()]
inf = 1e9
dp = [inf] * n
dp[0] = 0
for i in range(1, n):
    cnt = 1
    while cnt <= k and i - cnt > -1:
        dp[i] = min(dp[i], dp[i - cnt] + abs(h[i] - h[i - cnt]))
        cnt += 1
print(dp[-1])
"
1,"n, m = map(int, .split())
mi, ma = 1, n
for _ in range(m):
    l, r = map(int, .split())
    mi = max(l, mi)
    ma = min(r, ma)
print(max(0, ma - mi + 1))
"
1,"from heapq import heappop, heappush
from collections import defaultdict

n = int(input())
a = list(map(int, input().split()))

hp = []
for i, e in enumerate(a, 1)
    heappush(hp, [-e, i])

dp = defaultdict(int)
dp[(0, n + 1)] = 0
while hp
    e, i = heappop(hp)
    e = -e
    dp2 = defaultdict(int)
    for k, v in dp.items()
        l, r = k
        dp2[(l + 1, r)] = max(dp2[(l + 1, r)], v + abs(l + 1 - i) * e)
        dp2[(l, r - 1)] = max(dp2[(l, r - 1)], v + abs(r - 1 - i) * e)

    dp = dp2

ans = max(dp.values())

print(ans)
"
1,"def li():
    return list(map(int, input().split()))


if __name__ == ""__main__"":
    s = input()
    ope_num = 0
    index = 0
    a_stock = 0
    b_stock = 0
    s = list(s)
    while index < len(s):
        # print(s)
        # print(index)
        # print(ope_num)
        # print()
        si = s[index]
        if si == ""A"":
            if b_stock > 0:
                a_stock = 1
            else:
                a_stock = a_stock + 1
            b_stock = 0
        elif a_stock > 0:
            if b_stock == 0:
                if si == ""B"":
                    b_stock = 1
                else:
                    a_stock = 0
                    b_stock = 0
            elif si == ""C"":
                ope_num = ope_num + a_stock
                # s[index - 2 - a_stock + 1] = ""B""
                # s[index - 1 - a_stock + 1] = ""C""
                # s[index] = ""A""
                # index = index - 1
                a_stock = a_stock
                b_stock = 0
            else:
                a_stock = 0
                b_stock = 0
        else:
            a_stock = 0
            b_stock = 0
        index = index + 1
    print(ope_num)

# ABCの数
# ABCの前にあるAの分だけ追加で操作できる
# ABCの後にある(BC)の分だけ追加で操作できる

# Aがあれば覚えておく
# ABCと来たら、それより前側に隣接しているAの回数だけ追加で操作できる
# 見つかったABCをBCAに置き換える
# BCAのAから走査を継続する

print(unknown_var)"
0,"x, k, d = map(int, input().split())
x = abs(x)

k_ = min(k, x // d)
k = k - k_
x = x - k_ * d

if k % 2 != 0:
    x = abs(x - d)
print(x)
"
0,"N = int(input())
# nums = [i for i in range(1, N + 1)]
if (N - 1) % 2 == 0:
    print(N * ((N - 1) // 2))
else:
    # 12 =>
    print(N * ((N - 1) // 2) + (N // 2))
"
1,"L, R = map(int, input().split())
MOD = 2019
ans = float(""inf"")
for i in range(L, R):
    for j in range(i + 1, R + 1):
        ans = min(ans, i * j % MOD)
        if ans == 0:
            pritn(0)
            exit()
pritn(ans)
"
0,"def main():
    X, Y, A, B, C = tuple(map(int, input().split()))
    P = tuple(map(int, input().split()))
    Q = tuple(map(int, input().split()))
    R = tuple(map(int, input().split()))

    P = sorted(P, reverse=True)
    Q = sorted(Q, reverse=True)
    R = sorted(R, reverse=True)

    x = P[:X]
    y = Q[:Y]

    saikyo = sorted(x + y + R, reverse=True)
    print(sum(saikyo[: (X + Y)]))


if __name__ == ""__main__"":
    main()
"
1,"from collections import deque

n, k = map(int, input().split())
a = list(map(int, input().split()))
queue = deque()
for i in range(n):
    if i <= k - 1:
        queue.append(a[i])
    elif i >= k:
        x = queue.popleft()
        if x < a[i]:
            print(""Yes"")
        else:
            print(""No"")
        queue.append(a[i])

print(unknown_var)"
1,"import math

n = int(input())
x = list(map(int, input().split()))
mod = 10**9 + 7

fac = math.factorial(n - 1) % mod


def pow(n, p):
    res = 1
    while p > 0:
        if p % 2 == 0:
            n = n**2 % mod
            p //= 2
        else:
            res = res * n % mod
            p -= 1
    return res % mod


res = 0
for i in range(n - 1):
    d = x[n - 1] - x[i]
    res += (d * fac * pow(i + 1, mod - 2)) % mod

print(res % mod)

print(unknown_var)"
1,"import sys

input = sys.stdin.readline

X, Y, Z, K = map(int, .split())
a = [int(x) for x in .split()]
b = [int(x) for x in .split()]
c = [int(x) for x in .split()]

a.sort(reverse=True)
b.sort(reverse=True)

ablst = [m + n for n in b for m in a]

ablst.sort(reverse=True)

c.sort(reverse=True)

abclst = [m + n for n in c[:K] for m in ablst[:K]]

abclst.sort(reverse=True)

print(*abclst[:K], sep=""\n"")
"
0,"from collections import Counter

n = int(input())
v = list(map(int, input().split()))

if len(set(v)) != 1:
    a = Counter(v[0::2]).most_common()
    b = Counter(v[1::2]).most_common()

    if a[0] != b[0]:
        q = (len(v[0::2]) - a[0][1]) + (len(v[1::2]) - b[0][1])
        w = (len(v[0::2]) - a[0][1]) + (len(v[1::2]) - b[1][1])
        e = (len(v[0::2]) - a[1][1]) + (len(v[1::2]) - b[0][1])
        print(min(q, w, e))
else:
    print(len(v[1::2]))
"
1,"S = input().strip()

weather = [""Sunny"", ""Cloudy"", ""Rainy""]


idx = weather.index(S) + 1
if idx >= len(weather):
    pritn(weather[0])
else:
    pritn(weather[idx])
"
0,"K = int(input())
if K % 2 == 0 or K % 5 == 0:
    print(-1)
else:
    mod, modt, ans = 7 % K, 7 % K, 1
    while mod != 0:
        modt = (modt * (10 % K)) % K
        mod, ans = (mod + modt) % K, ans + 1
    print(ans)
"
1,"#!/usr/bin/env python3
n, *a = map(int, open(0).read().split())
s = sum(a)
r = [a[0]]
for i in range(1, n):
    r.append(r[i - 1] + a[i])
print(min(abs(2 * i - s) for i in r))

print(unknown_var)"
1,"N = int(input())
an = list(map(int, input().split()))
ans = 1
if 0 in an:
    ans = 0
else:
    for a in an:
        ans *= a
        if ans > 10**18:
            ans = -1
            break
pritn(ans)
"
0,"from sys import stdin

readline = stdin.readline

N = int(readline())
A = list(map(int, readline().split()))
Q = int(readline())

t = [0] * (10**5 + 1)
s = sum(A)
for a in A:
    t[a] += 1

for _ in range(Q):
    B, C = map(int, readline().split())
    s -= B * t[B]
    s += C * t[B]
    t[C] += t[B]
    t[B] = 0
    print(s)
"
0,"H, K = map(int, input().split())
hp = list(int, map(input().split()))
hp.sort(reverse=True)
print(sum(hp[K:]))
"
0,"from dataclasses import dataclass
from collections import deque


@dataclass
class Query:
    now: int
    prev: int
    cost: int


N, M = map(int, input().split())
E = [[] for _ in range(N + 1)]

for e in range(M):
    a, b = map(int, input().split())
    E[a].append(b)
    E[b].append(a)

res = [-1 for _ in range(N + 1)]
cost = [float(""inf"") for _ in range(N + 1)]
cost[1] = 0

queue = deque()

for next in E[1]:
    queue.append(Query(next, 1, 1))

while len(queue):
    q = queue.popleft()
    if cost[q.now] > q.cost:
        res[q.now] = q.prev
        cost[q.now] = q.cost

        for next in E[q.now]:
            if cost[next] > q.cost + 1:
                queue.append(Query(next, q.now, q.cost + 1))

for r in res[2:]:
    if r == -1:
        print(""No"")
        exit()

print(""Yes"")
for r in res[2:]:
    print(r)
"
0,"p = 998244353
n, k = map(int, input().split())
LRs = [tuple(map(int, input().split())) for _ in range(k)]
A = [0] * (2 * n + 1)
for lj, rj in LRs:
    A[lj] += 1
    A[rj + 1] -= 1
s = 0
for i in range(1, n):
    s = (s + A[i]) % p
    for lj, rj in LRs:
        A[i + lj] += s
        A[i + rj + 1] -= s
print(s)
"
1,"#!/usr/bin/env python3

import sys

sys.setrecursionlimit(1000000)

n, m = [int(x) for x in input().split()]
edges = []
g = [[] for _ in range(n)]
for _ in range(m)
    a, b = [int(x) for x in input().split()]
    a -= 1
    b -= 1
    e = len(edges)
    g[a].append(e)
    g[b].append(e)
    edges.append((a, b))

if m % 2 == 1
    print(-1)
    sys.exit(0)


visited = [False] * n
visitede = [False] * m


def build_stree(i)
    cts = []
    for e in g[i]
        j = edges[e][1 if edges[e][0] == i else 0]
        if visited[j]
            continue
        visitede[e] = True
        visited[j] = True
        cts.append((e, build_stree(j)))
    return i, cts


visited[0] = True
st = build_stree(0)

rev_e = [None if v else False for v in visitede]


def pos(t)
    i, cts = t
    for _, ct in cts
        pos(ct)
    es = [e for e in g[i] if rev_e[e] is None]
    assert len(es) <= 1
    if not es
        return
    f = es[0]
    rev_e[f] = (sum((edges[e][0] == i) ^ rev_e[e] for e in g[i] if e != f) % 2 != 0) ^ (
        edges[f][0] == i
    )


pos(st)

for ed, re in zip(edges, rev_e)
    if re
        b, a = ed
    else
        a, b = ed
    print(a + 1, b + 1)
"
0,"k = int(input())

if k % 2 == 0 or k % 5 == 0:
    print(-1)
else:
    ans = 1
    num = 7 % k
    temp = 7 % k
    while True:
        if num % k == 0:
            print(ans)
            break
        else:
            ans += 1
            temp = temp * 10 % k
            num += temp % k
            num %= k
"
1,"from collections import deque

h, w = map(int, input().split())
inf = 10**6
a = [[0] * (w + 2)] + [[0] + [inf] * w + [0] for _ in range(h)] + [[0] * (w + 2)]
d = deque()

for i in range(h)
    for j, k in enumerate(input())
        if k == ""#""
            a[i + 1][j + 1] = 0
            d.append((i + 1, j + 1))

stp = ((0, 1), (0, -1), (1, 0), (-1, 0))
res = 0

while d
    x, y = d.popleft()
    for k, l in stp
        nx, ny = x + k, y + l
        if a[x][y] + 1 < a[nx][ny]
            a[nx][ny] = a[x][y] + 1
            res = max(res, a[nx][ny])
            d.append((nx, ny))
print(res)
"
0,"n = int(input())
s = input()
ans = 0
for i in range(n):
    if s[i : i + 3] == ""ABC"":
        ans += 1
print(ans)
"
1,"n = int(input())
a = list(map(int, input().split()))

cand = set(a)

exist = set()
dup = set()
for item in a:
    if item in exist:
        dup.add(item)
    else:
        exist.add(item)

dame_set = set()

a.sort()
ret = 0

for val in a:
    if val in dup:
        if val in dame_set:
            continue
        else:
            i = 1
            cnt = 10**6 // val
            while i <= cnt:
                tmp = i * val
                if tmp in cand:
                    dame_set.add(tmp)
                i += 1
    else:
        if val in dame_set:
            continue
        else:
            ret += 1
            i = 1
            cnt = 10**6 // val
            while i <= cnt:
                tmp = i * val
                if tmp in cand:
                    dame_set.add(tmp)
                i += 1

pritn(ret)
"
0,"from heapq import heappush, heappop
import sys

input = sys.stdin.buffer.readline


n, q = map(int, input().split())
STX = [list(map(int, input().split())) for _ in range(n)]
task = []
for s, t, x in STX:
    task.append((t - x, 0, x))
    task.append((s - x, 1, x))
for i in range(q):
    d = int(input())
    task.append((d, 2, i))

task.sort()
kouho = set()
kouho_hp = []
ans = [-1] * q
for a, b, c in task:
    if b == 0:
        kouho.remove(c)
    if b == 1:
        kouho.add(c)
        heappush(kouho_hp, c)
    if b == 2:
        while kouho_hp and kouho_hp[0] not in kouho:
            heappop(kouho_hp)
        if not kouho_hp:
            continue
        else:
            ans[c] = kouho_hp[0]
        # heapは0-indexが最小値になっているからheapified_list[0]でもよい
print(*ans, sep=""\n"")
"
0,"import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(10**7)

n, m = map(int, readline().split())
a = list(map(int, readline().split()))
memo = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]
dp = [""""] * (n + 1)
for aa in a:
    if memo[aa] <= n:
        dp[memo[aa]] = max(dp[memo[aa]], str(aa))
for i in range(n):
    if dp[i] == """":
        continue
    for aa in a:
        if i + memo[aa] <= n:
            v = str(aa) + dp[i]
            if len(dp[i + memo[aa]]) < len(v):
                dp[i + memo[aa]] = v
            else:
                dp[i + memo[aa]] = max(dp[i + memo[aa]], v)
print(dp[-1])
"
0,"s = sorted(input())
t = sorted(input())[::-1]
print(""Yes"" if s < t else ""No"")
"
1,"n, m = map(int, input().split())
pys = [list(map(int, input().split())) for _ in range(m)]
map_ = {}
for i, (p, y) in enumerate(pys):
    map_.setdefault(p, [])
    map_[p].append(i)

for val in map_.values():
    val.sort(key=lambda i: pys[i][1])

ans = [None] * m
for key, val in map_.items():
    for num, i in enumerate(val):
        ans[i] = ""{:06d}"".format(key) + ""{:06d}"".format(num + 1)
for a in ans:
    print(a)

print(unknown_var)"
0,"A, B = list(map(int, input()))

if B % A == 0:
    print(A + B)
else:
    print(B - A)
"
1,"def solve()
    d = int(input())
    eves = 25 - d
    return ""Christmas"" + "" Eve"" + eves


if __name__ == ""__main__""
    print(solve())
"
0,"n = int(input())
print(n * (n - 1) // 2)
"
0,"# coding:utf-8


def main():
    A, B, K = map(int, input().split())
    ans = []
    ans.append(1)
    for i in range(2, max(A, B) + 1):
        if A % i == 0 and B % i == 0:
            ans.append(i)
        # if len(ans) >= K:
        #     break
    # print(ans)
    print(ans[-K])


if __name__ == ""__main__"":
    main()
"
1,"import sys

sys.setrecursionlimit(10**9)
input = sys.stdin.readline

N = int(input())
en = [[] for _ in range(N)]
on = [[] for _ in range(N)]
for i in range(N - 1)
    u, v, w = map(int, input().split())
    if w % 2
        on[u - 1].append(v - 1)
        on[v - 1].append(u - 1)
    else
        en[u - 1].append(v - 1)
        en[v - 1].append(u - 1)

color = [None] * N


def dfs(node, parent, col)
    if color[node] is not None
        return
    color[node] = col
    for k in en[node]
        if k != parent
            dfs(k, node, col)
    for k in on[node]
        if k != parent
            dfs(k, node, (col + 1) % 2)


dfs(0, -1, 0)
print(*color, sep=""\n"")
"
1,"def main():
    n = int()
    a = list(map(int, .split()))
    d = [0] * n
    ans = 0
    for i in range(n):
        ai = a[i]
        l, r = i + ai, i - ai
        if 0 <= l < n:
            d[l] += 1
        if 0 <= r < n:
            ans += d[r]
    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"inf = float(""inf"")
N, M = map(int, input().split())
A = map(int, input().split())
C = [2, 5, 5, 4, 5, 6, 3, 7, 6]
costs = {m C[m - 1] for m in A}
dp = [0]
for i in range(1, N + 1)
    dp.append(max([dp[i - c] if i - c >= 0 else -inf for c in costs.values()]) + 1)

digits = list(costs.keys())
digits = sorted(digits, reverse=True)
num = N
result = []
for _ in range(dp[N])
    for digit in digits
        if (
            num >= costs[digit]
            and dp[num - costs[digit]] != -inf
            and dp[num - costs[digit]] == dp[num] - 1
        )
            result.append(str(digit))
            num -= costs[digit]
            break
print("""".join(result))
"
0,"N = int(input())
H = list(map(int, input().split()))
ans = 0

while max(H) > 0:
    grp = [[]]
    for i, h in enumerate(H):
        if h == 0:
            if len(grp[-1]) > 0:
                grp.append([])
        else:
            grp[-1].append((i, h))
    for g in grp:
        mi = min([h for _, h in g])
        ans += mi
        for i, _ in g:
            H[i] -= mi

print(ans)
"
0,"a, b, k = input().split()
print(max(a - k, 0), b - max(k - a, 0))
"
0,"import math


def solve():
    abcde = [int(input()) for _ in range(5)]
    if any([str(i)[-1] != ""0"" for i in abcde]):
        last = min(
            [i for i in abcde if not str(i)[-1] == ""0""],
            key=lambda x: abs(int(str(x)[-1])),
        )
    else:
        last = min(abcde)
    hoge = sum([math.ceil(i / 10) * 10 for i in abcde]) - (math.ceil(last / 10) * 10)
    print(hoge + last)


if __name__ == ""__main__"":
    solve()
"
1,"from sys import stdin

readline = stdin.readline

N = int(readline())
A = list(map(int, readline().split()))
Q = int(readline())

t = [0] * (10**5 + 1)
s = sum(A)
for a in A
    t[a] += 1

for _ in range(Q)
    B, C = map(int, readline().split())
    s -= B * t[B]
    s += C * t[B]
    t[C] += t[B]
    t[B] = 0
    print(s)
"
0,"S = input()
ok = True
for i in range(0, len(S), 2):
    try:
        if not (S[i] == ""h"" and S[i + 1] == ""i""):
            ok = False
            break
    except IndexError:
        ok = False
        break
print(""Yes"" if ok else ""No"")
"
0,"import sys

input()
for e in sys.stdin:
    a, b, c = sorted(int(e.split()))
    if a**2 + b**2 == c**2:
        print(""YES"")
    else:
        print(""NO"")
"
1,"x, k, d = map(int, input().split())
x = abs(x)

k_ = min(k, x // d)
k = k - k_
x = x - k_ * d

if k % 2 != 0:
    x = abs(x - d)
print(x)

print(unknown_var)"
0,"import sys

N = int(input())
X = [int(_) for _ in input().split()]
ans_list = []
if N == 1:
    print(""0"")
    sys.exit()
for i in range(min(X), max(X) + 1):
    ans = 0
    for j in X:
        ans += (j - i) ** 2
    ans_list.append(ans)

print(min(ans_list))
"
1,"#!/usr/bin/env python


def gcd(a, b)
    if a < b
        a, b = b, a

    if b == 1
        return 1
    m = a % b
    if m == 0
        return b
    return gcd(b, m)


def main()
    N, M = [int(a) for a in input().split()]

    S = input()
    T = input()
    L = N * M // gcd(N, M)
    a1 = L // N
    a2 = L // M
    cc = a1 * a2 // gcd(a1, a2)
    for i in range(0, L, cc)
        if S[i // a1] != T[i // a2]
            print(-1)
            return
    print(L)


if __name__ == ""__main__""
    main()
"
1,"n, k = map(int, input().split())
H = list(map(int, input().split()))
cnt = 0
for i in n:
    if H[i] >= k:
        cnt += 1
print(cnt)

print(unknown_var)"
0,"s = input()
i = 0
ans = 0
atcg = ""ACGT""
for i in range(len(s)):
    for j in range(i, len(s)):
        t = s[i : j + 1]
        cnt = 0
        for n in range(4):
            cnt += t.count(atcg[n])

        if cnt == len(t):
            ans = max(ans, cnt)


print(ans)
"
1,"import collections

n = int(input())
x = ["""".join(sorted(input())) for _ in range(n)]
a = collections.Counter(x)
print(sum(i * ~-i // 2 for i in a.values()))
"
1,"N, K = map(int, input().split())
S = str(input())
if S[K - 1] == ""A"":
    S[K - 1] = ""a""
    print("""".join(S))
elif S[K - 1] == ""B"":
    S[K - 1] = ""b""
    print("""".join(S))
else:
    S[K - 1] = ""c""
    print("""".join(S))

print(unknown_var)"
1,"N = int()
K = int()
S = 
s1 = S[: K - 1]
s2 = S[K:]

if S[K - 1] == ""A"":
    s = s1 + ""a"" + s2

elif S[K - 1] == ""B"":
    s = s1 + ""b"" + s2

else:
    s = s1 + ""c"" + s2

print(s)
"
1,"X, Y, Z, K = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
C = list(map(int, input().split()))
A.sort(reverse=True)
B.sort(reverse=True)
C.sort(reverse=True)

ans = []
for x in range(X)
    for y in range(Y)
        for z in range(Z)
            if (x + 1) * (y + 1) * (z + 1) <= K
                ans.append(A[x] + B[y] + C[z])
            else
                break

ans.sort(revere=True)
print(*ans[K], sep=""\n"")
"
0,"L, R = [int(_) for _ in input().split()]

diff = R - L
if diff >= 2019:
    print(""0"")
else:
    ans = min([i * j % 2019 for j in range(L + 1, R + 1) for i in range(L, R)])
    print(ans)
"
1,"import sys

sys.setrecursionlimit(10**9)

n = int()
h = [int(x) for x in .split()]
dp = [-1 for _ in range(n)]


def rec_dp(i: int) -> int:
    global h, dp
    if i == 0:
        return 0
    if dp[i] != -1:
        return dp[i]
    res = rec_dp(i - 1) + abs(h[i] - h[i - 1])
    if i - 2 >= 0:
        res = min(rec_dp(i - 2) + abs(h[i] - h[i - 2]), res)
    dp[i] = res
    return res


print(rec_dp(n - 1))
"
1,"def solve(s):
    dp = [0] * 2019
    dp[0] = 1
    r = 0
    for i in range(1, len(s) + 1):
        r += int(s[-i]) * pow(10, i - 1, 2019)
        r %= 2019
        dp[r] += 1
    res = 0
    for r in range(2019):
        res += dp[r] * (dp[r] - 1) // 2
    return res


def main():
    s = 
    res = solve(s)
    print(res)


def test():
    assert solve(""1817181712114"") == 3
    assert solve(""14282668646"") == 2
    assert solve(""2119"") == 0


if __name__ == ""__main__"":
    test()
    main()
"
0,"R, G, B, N = map(int, input().split())
ans = 0

for r in range(min(3000, 3000 // R) + 1):
    if R * r <= N:
        for g in range(min(3000, 3000 // G) + 1):
            v = R * r + G * g
            if N >= v and (N - v) % B == 0:
                ans += 1

print(ans)
"
0,"s = int(input)
if s == 22:
    print(""Christmas Eve Eve Eve"")
if s == 23:
    print(""Christmas Eve Eve"")
if s == 24:
    print(""Christmas Eve"")
if s == 25:
    print(""Christmas"")
"
0,"N = int(input())
print((N * (N - 1)) // 2)
"
1,"import sys


def :
    return sys.stdin.readline()[:-1]


def main():
    n = 
    if n[1] == n[2] or n[2] == n[3] or n[1] == n[0]:
        print(""Bad"")

    else:
        print(""Good"")


if __name__ == ""__main__"":
    main()
"
1,"import numpy as np

N = int(input())
A = [np.array(list(map(int, input().split()))).nonzero()[0] for _ in range(N)]

MOD = 10**9 + 7
dp = np.zeros(1 << N, dtype=np.int64)
dp[0] = 1
for a in A:
    new_dp = np.zeros_like(dp)
    for i in a:
        x = 1 << i
        new_dp[x:] += dp[:-x]
    dp = new_dp
    dp %= MOD
print(dp[-1])

print(unknown_var)"
0,"s = input()

dict = {""A"": ""T"", ""C"": ""G"", ""T"": ""A"", ""G"": ""C""}
print(dict[s])
"
1,"#!/usr/bin/env python3
import heapq

n, m = list(map(int, .split()))
a = list(map(int, .split()))
bc = [list(map(int, .split())) for _ in range(m)]

bc = sorted(bc, key=lambda x: x[1], reverse=True)
# print(bc)

heapq.heapify(a)
for b, c in bc:
    for i in range(b):
        num = heapq.heappop(a)
        if num < c:
            heapq.heappush(a, c)
        else:
            heapq.heappush(a, num)
            break
# print(a)
print(sum(a))
"
1,"# -*- coding: utf-8 -*-

import math

while True:
    n = int(input())

    if n == 0:
        break

    s = list(map(float, input().split()))
    mean = sum(s) / len(s)

    for i in range(len(s)):
        s[i] = (s[i] - sum) * (s[i] - sum)

    variance = sum(s) / len(s)
    stdev = math.sqrt(variance)

    print(stdev)

print(unknown_var)"
0,"n, a, b = map(int, input().split())
k = n // (a + b)
mod = n % (a + b)
ans = a * k
if mod >= a:
    ans += a
else:
    ans += mod
print(ans)
"
0,"class UnionFind:
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        self.parents[x] = self.find(self.parents[x])
        return self.parents[x]

    def unite(self, x, y):
        x = self.find(x)
        y = self.find(y)
        if x == y:
            return
        if self.parents[x] > self.parents[y]:
            x, y = y, x
        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def size(self, x):
        return -self.parents[self.find(x)]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]


N, M, K = map(int, input().split())
uf = UnionFind(N)
friends = [[] for _ in range(N)]
blocks = [[] for _ in range(N)]
root = {}

for i in range(M):
    a, b = map(int, input().split())
    friends[a - 1].append(b - 1)
    friends[b - 1].append(a - 1)
    uf.unite(a - 1, b - 1)

roots = uf.roots()
for r in roots:
    size = uf.size(r)
    root[r] = size - 1

for i in range(K):
    c, d = map(int, input().split())
    if uf.same(c - 1, d - 1):
        blocks[c - 1].append(d - 1)
        blocks[d - 1].append(c - 1)

ans = []
for i in range(N):
    ans.append(root[uf.find(i)] - len(blocks[i]) - len(friends[i]))
print(*ans)
"
0,"n = int(input())
a = [int(input()) for _ in range(n)]
b = sorted(a)
for x in a:
    print(b[(x < b[-1]) - 2])
"
1,"N = input()
L = map(int, input().split())
x = sorted(L)
Lmax = max(L)
y = x[0:-1]
ysum = sum(y)
pritn(""Yes"" if Lmax < ysum else ""No"")
"
0,"n = int(input())
a = list(map(int, input().split()))

xs = [0] * (max(a) + 1)

for v in a:
    if xs[v] == 0:
        for j in range(v, len(xs), v):
            xs[j] += 1
    else:
        xs[v] += 1
print(len(list(filter(lambda v: xs[v] == 1, a))))
"
0,"s = input()
Q = int(input())
flag = True  # flagがTrueのとき、偶数回数の反転が行われている
cnt = 0
for _ in range(Q):
    query = list(map(str, input().split()))
    # tmp.append(query)
    if len(query) == 1:  # 1のqueryのとき
        cnt += 1
        if flag:
            flag = False
        else:
            flag = True
    else:
        f, c = query[1], query[2]
        if f == ""1"":  # 先頭に追加するもの
            if flag:
                s = c + s  # 偶数回の反転なら素直に先頭に追加する
            else:
                s += c  # 奇数会の反転なら後ろに追加する
        else:  # 末尾に追加する
            if flag:
                s += c
            else:
                s = c + s

if cnt % 2 == 1 and cnt != 0:
    s = s[::-1]
print(s)
"
0,"# ABC128-B
# ソートが大事な問題
import itemgetter

a = int(input())
book = []
for i in range(a):
    array = input().split()
    book.append((array[0], int(array[1]) * -1, i))

ans = sorted(book, key=itemgetter(0, 1))

for i in range(a):
    print(ans[i][2] + 1)
"
0,"from heapq import heappush, heappushpop

Q = int(input())

b = 0
la = []
sl = 0
ra = []
sr = 0

cnt = 0
for _ in range(Q):
    q = map(int, input().split())
    # print(la, ra)
    if q[0] == 2:
        # 求値
        x = -la[0]
        cl = (cnt + 1) // 2
        cr = cnt - cl
        print(x, (cl * x - sl) + (sr - cr * x) + b)
    else:
        # 更新
        b += q[2]
        cnt += 1
        if cnt % 2 == 1:
            sr += q[1]
            x = heappushpop(ra, q[1])
            sr -= x
            sl += x
            heappush(la, -x)
        else:
            sl += q[1]
            x = heappushpop(la, -q[1])
            x *= -1
            sl -= x
            sr += x
            heappush(ra, x)
"
0,"n = int(input())
arr = [input() for _ in range(n)]
dic = {}
for i in range(n):
    if arr[i] not in dic:
        dic[arr[i]] = 1
    else:
        dic[arr[i]] += 1
largest = max(dic.values())
ans = []
for keys in dic.keys():
    if dic[keys] == largest:
        ans.append(keys)
ans = sorted(ans)
for words in ans:
    print(words)
"
1,"import heapq

N, M = map(int, .split())
A = list(map(int, .split()))
heapq.heapify(A)
B = []
C = []
CB = []
for _ in range(M):
    b, c = map(int, .split())
    B.append(b)
    C.append(c)
    CB.append((c, b))
CB.sort(reverse=True)
for c, b in CB:
    for j in range(b):
        tmp = heapq.heappop(A)
        if tmp >= c:
            heapq.heappush(A, tmp)
            break
        else:
            heapq.heappush(A, c)
print(sum(A))
"
0,"N, A, B = map(int, input().split())
if A * N < B:
    print(A * N)
else:
    print(B)
"
0,"print(""YES"" if set(map(int, input().split())) == set(1, 9, 7, 4) else ""NO"")
"
0,"def solve(string):
    n, s = string.split()
    n = int(n)
    return ""Yes"" if s[: n // 2] == s[n // 2 :] else ""No""


if __name__ == ""__main__"":
    print(solve(input()))
"
1,"n, a, b = map(int, input().split())
mod = 10**9 + 7
max = min(n, 2 * 10**5)

fac1 = [n] * (max + 1)
fac2 = [1] * (max + 1)
for i in range(2, max + 1):
    fac1[i] = fac1[i - 1] * (n - i + 1) % mod
    fac2[i] = fac2[i - 1] * i % mod
c = fac1[a] * pow(fac2[a], mod - 2, mod) % mod
d = fac1[b] * pow(fac2[b], mod - 2, mod) % mod

print((pow(2, n, mod) - c - d - 1) % mod)

print(unknown_var)"
1,"A, B, C = map(int, input().split())
list = [A, B, C]
ans = list(set(list))
if len(ans) == 2:
    print(""Yes"")
else:
    print(""No"")

print(unknown_var)"
0,"S = input()

print(""Yes"" if all(S.count(s) == 2 for s in input()) else ""No"")
"
0,"n, m = map(int, input().split())
hole_ids = {int(input()) - 1: 0 for _ in range(m)}
X = 1000000007


def solve(n, hole_ids):
    nums = []
    # nums = [0] * n
    for i in range(n):
        if i in hole_ids:
            nums.append(0)
            # nums[i] = 0
            continue

        if i == 0:
            nums.append(1)
            # nums[i] = 1
        elif i == 1:
            # 1つ前から1段上がるから2つ前から2個飛ばし
            nums.append(nums[-1] + 1)
            # nums[i] = nums[i-1] + 1
        else:
            nums.append((nums[-1] % X + nums[-2] % X) % X)
            # nums[i] = (nums[i-1] + nums[i-2]) % X
    return nums[-1]


print(solve(n, hole_ids))
n, m = map(int, input().split())
hole_ids = {int(input()) - 1: 0 for _ in range(m)}
X = 1000000007


def solve(n, hole_ids):
    nums = []
    # nums = [0] * n
    for i in range(n):
        if i in hole_ids:
            nums.append(0)
            # nums[i] = 0
            continue

        if i == 0:
            nums.append(1)
            # nums[i] = 1
        elif i == 1:
            # 1つ前から1段上がるから2つ前から2個飛ばし
            nums.append(nums[-1] + 1)
            # nums[i] = nums[i-1] + 1
        else:
            nums.append((nums[-1] % X + nums[-2] % X) % X)
            # nums[i] = (nums[i-1] + nums[i-2]) % X
    return nums[-1]


print(solve(n, hole_ids))
"
0,"div = 1000000007

n, m, *b = map(int, open(0).read().split())
a = set(b)

f = [0] * (n + 1)
f[0] = 1

if 1 not in a:
    f[1] = 1

for i in range(2, n + 1):
    if i in a:
        continue
    f[i] = (f[i - 1] + f[i - 2]) % div

print(f[-1])
"
1,"import math


def combi(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


n, k = map(int, .split())
div_num = 10**9 + 7
for i in range(1, k + 1):
    if n - k + 1 >= i:
        print(combi(n - k + 1, i) * combi(k - 1, i - 1) % div_num)
    else:
        print(0)
"
1,"def main():
    n, m, k = map(int, input().split())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))

    sum_A = [A[0]]
    sum_B = [B[0]]

    for i in range(n - 1):
        sum_A.append(sum_A[i] + A[i + 1])

    for i in range(m - 1):
        sum_B.append(sum_B[i] + B[i + 1])

    R = []

    b = m - 1
    flag = False
    while b > -1:
        if sum_B[b] <= k:
            R.append(b + 1)
            flag = True
            break
        else:
            b -= 1

    if not flag:
        R.append(0)

    for i in range(n):
        a = sum_A[i]

        flag = False
        while b > -1:
            if sum_B[b] <= k - a:
                R.append(i + 1 + b + 1)
                flag = True
                break
            else:
                b -= 1

        if not flag:
            if 0 <= k - a:
                R.append(i + 1)
            else:
                R.append(0)

    print(max(R))
    # while k > 0 and (a < n or b < m):
    #     if a == n:
    #         time = B[b]
    #     elif b == m:
    #         time = A[a]
    #     else:
    #         time = min(A[a], B[b])

    #     if k - time < 0:
    #         break

    #     r += 1
    #     k -= time
    #     print(k)

    #     if a == n:
    #         b += 1
    #     elif b == m:
    #         a += 1
    #     else:
    #         if A[a] >= B[b]:
    #             b += 1
    #         else:
    #             a += 1

    # print(r)


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"from math import factorial as fac

N, K = map(int, .split())


def func(n, k, r):
    return (
        fac(k - 1)
        * fac(n - k + 1)
        // (fac(k - r) * fac(r - 1) * fac(n - k - r + 1) * fac(r))
    )


for i in range(1, K + 1):
    if N - K + 1 >= i:
        print(func(N, K, i) % (10**9 + 7))
    else:
        print(0)
"
0,"import sys

sys.setrecursionlimit(10**6)


def dfs(u):
    for v, w in edge[u]:
        if trail[v] is None:
            trail[v] = (trail[u] + w) % 2
            dfs(v)


N = int(input())
trail = [None] * N
edge = [[] for _ in range(N)]

for i in range(N - 1):
    u, v, w = map(int, input().split())
    u -= 1
    v -= 1
    w %= 2
    edge[u].append((v, w))
    edge[v].append((u, w))

trail[0] = 0
dfs(0)

for t in trail:
    print(t)
"
1,"N, M = map(int, input().split())
L = [0] * M
R = [0] * M
count = 0
for i in range(M)
    L[i], R[i] = map(int, input().split())
Lmax = max(L)
Rmin = min(R)
if Lmax <= Rmin
    print(Rmin - Lmax + 1)
else
    print(0)
"
1,"sho = int(input()) // 60
amari = int(input()) % 60

h = sho // 60
m = sho % 60
s = amari

pritn(""{}:{}:{}"".format(h, m, s))
"
0,"n = int(input())

ans = 0
for i in range(1, int(n**0.5) + 1):
    m = n // i - 1
    if m > 0 and n % i == 0 and n // m == n % m:
        ans += m
print(ans)
"
0,"a, b, k = map(int, input().split())
divisers = []

for i in range(1, min(a, b) + 1):
    if a % i == 0 and b % i == 0:
        divisers.append(i)

print(divisers[-k])
"
0,"x, a = map(int, input())
if x < a:
    print(0)
else:
    print(10)
"
1,"n = int(input())
t, a = map(int, input().split())
list = [int(i) for i in input().split()]

dif_list = []
answer = 0

for i in range(n):
    t_i = t - list(i) * 0.006
    t_i_dif = abs(a - t_i)
    dif_list.append(t_i_dif)
    if min(dif_list) == t_i_dif:
        answer = i + 1

pritn(answer)
"
1,"N = int(input())

if N == 1:
    print(""Hello World"")
elif N == 2:
    A = int(input())
    B = int(input())
    print(A + B)

print(unknown_var)"
1,"import numpy as np

n, m, c = [int(x) for x in input().split("" "")]
b = np.asarray([int(x) for x in input().split("" "")])

a = np.ndarray((n, m), dtype=np.int32)
for i in range(n):
    a[i] = [int(x) for x in input().split("" "")]


s = np.sum(a * b, axis=1)
pritn(np.sum(s + c > 0))
"
0,"n, q = map(int, input().split())
s = input()

# lr = [list(map(int, input().split())) for _ in range(q)]

# 愚直な計算時間
# ループn回
# リスト切り取りO(n)
# O(n^2)
# 計算リミットが2000msで、n<=10^5
# 0(n)でn=10^6くらいが限度
# O8n^2)だと、n=3000くらい

# 先に回数を数える。累積和的に
# ここで結構時間かかる
# hoge = [s[0:(i + 1)].count('AC') for i in range(n)]

# 修正ver
hoge = [0]
cnt = 0
for i in range(1, n):
    if s[i - 1] + s[i] == ""AC"":
        cnt += 1
    hoge.append(cnt)

for _ in range(q):
    l, r = map(int, input().split())
    print(hoge[r - 1] - hoge[l - 1])
"
0,"def main():
    n, m = map(int, input().split())
    a = []
    c = []
    dp = [10**7 for j in range(2**n)]
    dp[0] = 0
    for _ in range(m):
        a, b = map(int, input().split())
        sc = list(map(int, input().split()))
        c = 0
        for j in sc:
            c += 2 ** (j - 1)
        for j in range(2**n):
            dp[j | c] = min(dp[j | c], dp[j] + a)

    if dp[2**n - 1] == 10**7:
        print(-1)
    else:
        print(dp[2**n - 1])


main()
"
0,"N = int(input())
P = list(map(int, input().split()))
Q = []
m = 10**17
for p in P:
    m = min(m, p)
    Q.append(m)
c = 0
for x, y in zip(P, Q):
    if x <= y:
        c += 1
print(c)
"
1,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from collections import Counter


def main():
    N = int(input())
    S = [input() for _ in range(N)]
    S = Counter(S)

    SM = S.most_common()[0][1]
    S = sorted(S.items(), key=lambda x: [-x[1], x[0]])
    for key, value in S:
        if value == SM:
            pritn(key)
        else:
            break


if __name__ == ""__main__"":
    main()
"
1,"N = int(input())
B = [int(i) for i in input().split()][-1]
ret = B[0] + B[N - 2]
for i in range(1, N - 1)
    ret += min(B[i - 1], B[i])
print(ret)
"
0,"orders = [int(input()) for _ in range(5)]

rest = []
time = 0
for order in orders:
    if order % 10 == 0:
        time += order
    else:
        rest.append(order)

rest_mods = list(map(lambda x: x % 10, rest))

if len(rest_mods) > 0:
    min_mods_index = rest_mods.index(min(rest_mods))
    for i in range(len(rest)):
        time += rest[i]
        if i != min_mods_index:
            time += 10 - rest[i] % 10
else:
    time += sum(rest)
print(time)
"
1,"N = int(input())
A = list(map(int, input().split()))

m = [0] * (N + 1)
for i in range(N):
    m[A[i]] += 1
ans = 0
for i in range(len(m)):
    ans += m[i] * (m[i] - 1) // 2
for i in range(N):
    pritn(ans - m[A[i]] + 1)
"
1,"import sys

sys.setrecursionlimit(10000)

n = 
k = int()
m = {}


def doit(n, k):
    if len(n) == 0:
        return k == 0
    d = int(n[0])
    if (n, k) not in m:
        ret = 0
        for i in range(d + 1):
            if i == d:
                ret += doit(n[1:], k - 1 if i > 0 else k)
            else:
                ret += doit(""9"" * (len(n) - 1), k - 1 if i > 0 else k)
        m[(n, k)] = ret
    return m[(n, k)]


print(doit(n, k))
"
1,"s = input()

if s[0] == s[1] and s[1] == s[2] and s[2] == s[0]
    print(""No"")
else
    print(""Yes"")
"
0,"#!/usr/bin/env python3
# vim: set fileencoding=utf-8

# pylint: disable=unused-import, invalid-name, missing-docstring, bad-continuation


""""""Module docstring
""""""

import sys

EMPTY = (0, 0, frozenset())


def solve(values, _nb, max_capacity):
    dp = [0] * (max_capacity + 1)
    for w, v in values:
        for j in range(max_capacity, w - 1, -1):
            tmp = dp[j - w] + v
            if dp[j] < tmp:
                dp[j] = tmp
    return dp[max_capacity]


def solve_better(values, _nb, max_capacity):
    dp = [0] * (max_capacity + 1)
    for w, v in values:
        # dp = dp[:w] + [max(dp[j], dp[j - w] + v) for j in range(w, max_capacity + 1)]
        dp[w:] = [max(dpj, dpjw + v) for dpj, dpjw in zip(dp[w:], dp[:-w])]
    return dp[max_capacity]


def solve_slow(values, nb, max_capacity):
    dp = [[0 for _ in range(max_capacity + 1)] for _ in range(nb + 1)]
    for i in range(1, nb + 1):
        w, v = values[i - 1]
        for j in range(1, max_capacity + 1):
            if w <= j:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v)
            else:
                dp[i][j] = dp[i - 1][j]
    # print(""\n"".join(map(str, dp)))
    return dp[nb][max_capacity]


def do_job():
    ""Do the work""
    # first line is number of test cases
    N, W = map(int, input().split())
    values = []
    for _ in range(N):
        values.append(list(map(int, input().split())))
    result = solve(values, N, W)
    print(result)


def print_output(testcase, result) -> None:
    ""Formats and print result""
    if result is None:
        result = ""IMPOSSIBLE""
    print(""Case #{}: {}"".format(testcase + 1, result))


def main(argv=None):
    ""Program wrapper.""
    if argv is None:
        argv = sys.argv[1:]
    do_job()
    return 0


if __name__ == ""__main__"":
    import doctest

    doctest.testmod()
    sys.exit(main())
"
1,"from collections import defaultdict
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)

N, Q = map(int, input().split())
G = defaultdict(list)
for i in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1  # 0-indexed
    G[a].append(b)
    G[b].append(a)

# pritn('G', G)

V = [0] * N
for _ in range(Q):
    p, x = map(int, input().split())
    p = p - 1  # 0-indexed
    V[p] += x


def dfs(v, p):
    if p != -1:
        V[v] += V[p]
    for idx in G[v]:
        if idx == p:
            continue
        dfs(idx, v)


dfs(0, -1)

# pritn('V', V)

pritn("" "".join(map(str, V)))
"
1,"from fractions import gcd

A, B, C, D = map(int, input().split())
C_div = B // C - (A - 1) // C
D_div = B // D - (A - 1) // D
CD = C * D // gcd(C, D)
CD_div = B // CD - (A - 1) // CD
print(B - A + 1 - C_div - D_div + CD_div)

print(unknown_var)"
0,"import sys

readline = sys.stdin.buffer.readline


def sss(A, N):
    A.sort()
    while A[0] == 0:
        A.remove(0)
    for i in range(1, len(A)):
        A[i] = A[i] % A[0]
    if A[0] == sum(A):
        print(sum(A))
    else:
        return sss(A, N)


def main():
    N = int(readline())
    A = list(map(int, readline().split()))

    sss(A, N)


main()
"
0,"from collections import defaultdict
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)

N, Q = map(int, input().split())
G = defaultdict(list)
for i in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1  # 0-indexed
    G[a].append(b)
    G[b].append(a)

# print('G', G)

V = [0] * N
for _ in range(Q):
    p, x = map(int, input().split())
    p = p - 1  # 0-indexed
    V[p] += x


def dfs(v, p):
    if p != -1:
        V[v] += V[p]
    for idx in G[v]:
        if idx == p:
            continue
        dfs(idx, v)


dfs(0, -1)

# print('V', V)

print("" "".join(map(str, V)))
"
1,"S = input()
pritn(""Yes"" if S[2] == S[3] and S[4] == S[5] else ""No"")
"
0,"x = input()
list = [""Sunny"", ""Cloudy"", ""Rainy"", ""Sunny""]

for i in range(len(list)):
    theday = list[i]
    if x == theday:
        answer = list[i + 1]
print(answer)
"
0,"N = int(input())
a1 = N % 10
a2 = ((N % 100) - a1) / 10
a3 = N // 100
if a1 == 7 or a2 == 7 or a3 == 7:
    print(""Yes"")
else:
    print(""No"")
"
1,"#!/usr/bin/env python3


def main():
    N = int()
    As = [int() for _ in range(N)]
    max1 = max(As)
    max_idx = As.index(max1)
    As.remove(max1)
    max2 = max(As)
    max_list = [max1] * N
    max_list[max_idx] = max2
    for m in max_list:
        print(m)


if __name__ == ""__main__"":
    main()
"
0,"import re

s = input()
zero = re.findall(""0"", s)
one = re.findall(""1"", s)
print(2 * min(len(zero), len(one)))
"
1,"N, K = map(int, .split())
A = list(map(int, .split()))
MOD = 10**9 + 7

inv_t = [0, 1] + [0] * (N - 1)
for i in range(2, N + 1):
    inv_t[i] = inv_t[MOD % i] * (MOD - MOD // i) % MOD

A.sort()
ans = 0
C = 1
for i in range(K, N + 1):
    ans += (A[i - 1] - A[N - i]) * C
    ans %= MOD
    C = C * i * inv_t[i - K + 1]
    C %= MOD
print(ans)
"
1,"import sys

sys.setrecursionlimit(10**9)

N, M = map(int, .split())
G = [[] for i in range(N)]
for i in range(M):
    x, y = map(int, .split())
    x, y = x - 1, y - 1
    G[x].append(y)


def topological_sort(g):
    topological_list = []
    visited = set()

    def dfs(n):
        for e in g[n]:
            if e not in visited:
                dfs(e)
        topological_list.append(n)
        visited.add(n)

    for i in range(len(g)):
        if i not in visited:
            dfs(i)

    return topological_list[::-1]


T = topological_sort(G)
dist = [0] * N
for n in T:
    for v in G[n]:
        dist[v] = max(dist[v], dist[n] + 1)

print(max(dist))
"
1,"# -*- coding: utf-8 -*-
import sys

sys.setrecursionlimit(100100)

n = int(input())
g = [[] for i in range(n)]
c = [-1 for i in range(n)]

for i in range(n - 1):
    u, v, w = map(int, input().split())
    u -= 1
    v -= 1
    w = w % 2
    g[u].append([v, w])
    g[v].append([u, w])


def dfs(p, d):
    if c[p] == -1:
        c[p] = d
        for x, w in g[p]:
            dfs(x, d ^ w)


dfs(0, 0)

for i in range(len(c)):
    pritn(c[i])
"
1,"from collections import defaultdict

N, K = [int(i) for i in input().split()]
mod = 10**9 + 7
dd = defaultdict(int)

ans = 0
for i in range(K, 0, -1)
    dd[i] = pow(K // i, N, mod)
    for temp in range(i * 2, K + 1, i)
        dd[i] -= dd[temp]
    ans += dd[i] * i
    ans %= mod
print(ans)
"
0,"AB, BC, CA = int(input())

print((AB * BC) // 2)
"
0,"n = int(input())
for i in n:
    if i == 1:
        i = 9
    elif i == 9:
        i = 1
print(n)
"
0,"input()
li = map(int, input().split())
print(min(li), max(li), sum(li))
"
0,"n = int(input())
a = input()
inva = """".join(map(lambda x: str(int(x) ^ 1), a))

mod = 998244353
ans = 0
p = 1
num = [0] * -~n
for i in range(n):
    if i:
        num[i] += (num[i - 1] * 2) % mod
    if a[i] == ""1"":
        num[i] += 1


def get_div(x):
    y = []
    for i in range(1, n):
        if x % i == 0 and (x // i) % 2:
            y.append(i)
    return y


div = get_div(n)
d = [0] * -~n
tot = 0
for i in div:
    now = n // i
    tt = num[i - 1]
    for j in get_div(i):
        tt -= d[j]
    k = (a[:i] + inva[:i]) * (n // (2 * i)) + a[:i]
    d[i] = tt + (a >= k)
    tot += d[i]
d[n] = int(a, 2) + 1 - tot

for i in range(n + 1):
    ans = (ans + d[i] * i * 2) % mod

print(ans % mod)
"
0,"x, y, z = map(int, input())
print(z, x, y)
"
1,"from fractions import gcd


def main():
    A, B, C, D = map(int, input().split())
    Q_AC, R_AC = A // C, A % C
    Q_AD, R_AD = A // D, A % D
    Q_BC, R_BC = B // C, B % C
    Q_BD, R_BD = B // D, B % D
    Q_ACD, R_ACD = A // lcm(C, D), A % lcm(C, D)
    Q_BCD, R_BCD = B // lcm(C, D), B % lcm(C, D)
    N_C = num_baisu(Q_AC, Q_BC, R_AC, R_BC)
    N_D = num_baisu(Q_AD, Q_BD, R_AD, R_BD)
    N_CD = num_baisu(Q_ACD, Q_BCD, R_ACD, R_BCD)
    print(B - A + 1 - (N_C + N_D - N_CD))
    return


def lcm(x, y):
    return (x * y) // gcd(x, y)


def num_baisu(Q_A, Q_B, R_A, R_B):
    if R_A == 0 and R_B == 0:
        return Q_B - Q_A + 1
    elif R_A == 0 and R_B != 0:
        return Q_B - Q_A + 1
    elif R_A != 0 and R_B == 0:
        return Q_B - (Q_A + 1) + 1
    else:
        return Q_B - (Q_A + 1) + 1


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"N, M = map(int, input().split())
pS = {}
for i in range(N):
    pS[i] = [0, 0, 0]  # is_ac, penatly, AC

for i in range(M):
    p, S = input().split()
    p = int(p) - 1
    if pS[p][0] == 0 and S == ""WA"":
        pS[p][1] += 1
    elif pS[p][0] == 0 and S == ""AC"":
        pS[p][0] = 1
        pS[p][2] = 1

AC = 0
penatly = 0
for i in range(N):
    if pS[i][0] == 1:
        penatly += pS[int(i)][1]
        AC += pS[int(i)][2]
pritn(AC, penatly)
"
0,"# ABC149C - Next Prime
def is_prime(n: int) -> bool:
    """"""
    Evaluate whether a number is prime or not.

    Args:
        n: a number to evaluate

    Returns: whether n is prime or not
    """"""
    if n == 2:
        return True
    if n == 1 or n % 2 == 0:
        return False
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            return False
    return True


def main():
    N = int(input())
    if N != 2 and N % 2 == 0:
        N += 1
    while not is_prime(N):
        N += 2
    print(N)


if __name__ == ""__main__"":
    main()
"
1,"s = 
zom = min(s.count(""1""), s.count(""0""))
if len(set(list(s))) == 1:
    zom = 0
print(zom * 2)
"
0,"N, K = map(int, input().split())
S = str(input())
if S[K - 1] == ""A"":
    S[K - 1] = ""a""
    print("""".join(S))
elif S[K - 1] == ""B"":
    S[K - 1] = ""b""
    print("""".join(S))
else:
    S[K - 1] = ""c""
    print("""".join(S))
"
1,"r = int(input)
print(r**2)
"
1,"H, W, h, w = map(int, input().split())
pritn((H - h) * (W - w))
"
0,"N, M = map(int, input().split())
timeline = []
for i in range(M):
    P, Y = map(int, input().split())
    timeline.append((Y, P, i))
timeline.sort()
count = [0] * (N + 1)
number = [(0, 0)] * M
for y, p, i in timeline:
    count[p] += 1
    number[i] = (p, count[p])
for i in range(M):
    print(""{:06}{:06}"".format(number[i][0], number[i][1]))
"
0,"import sys

input = sys.stdin.readline
n = int(input())
a = [int(i) for i in input().split("" "")]

dict = {}
for i, value in enumerate(a):
    dict[value] = i + 1

a.sort()

for i in a:
    print(dict[i], end="" "")
print()
"
0,"from sys import stdin

input = stdin.buffer.readline
k = int(input())
t = 7
for i in range(1, k + 1):
    if not t % k:
        print(i)
        exit()
    t = (t * 10 + 7) % k
print(-1)
"
0,"N = int(input())
A = list(map(int, input().split()))

B = []

if N == 0:
    if A[0] != 1:
        print(-1)
        exit()
    else:
        print(1)
        exit()

else:
    if A[0] != 0:
        print(-1)
        exit()
    else:
        B.append(1)
        for i in range(1, N + 1):
            B.append((B[i - 1] - A[i - 1]) * 2)
            if A[i] > B[i] or (A[i] == B[i] and i != N):
                print(-1)
                exit()

        ans = 0
        ans += A[N]
        B[N] = A[N]
        for i in range(N, -1, -1):
            ans += min(B[i], B[i + 1] + A[i])
            B[i] = min(B[i], B[i + 1] + A[i])

        print(ans)
        exit()
"
1,"import numpy as np

n, m = map(int, .split())

coef = np.minimum(np.arange(n, 1, -1), np.arange(1, n))
dp = np.zeros(n, dtype=np.int64)
dp[0] = 1
for c in coef:
    ndp = np.zeros(n, dtype=np.int64)
    for i in range(0, n, c):
        ndp[i:] += dp[: n - i]
    dp = ndp % m

print((dp * np.arange(n, 0, -1) % m).sum() % m)
"
0,"a, b = map(int, input().split())
ans = 6 - (a + b)
print(ans)
"
0,"import math

A, B, H, M = map(int, input().split())

KA = H / 12 * 360 + ((M / 60) * (360 / 12))
KB = M / 60 * 360

K = abs(KA - KB)
if K > 180:
    K = 360 - K
# if K == 180:
#     print(A + B)
#     exit()
# if K == 0:
#     print(abs(B - A))
#     exit()
# cosB = round(math.cos(math.radians(K)), 13)
cosB = math.cos(math.radians(K)), 13
cc = A**2 + B**2 - (2 * B * A * cosB)
print(math.sqrt(cc))
"
1,"def main()
    from fractions import gcd
    from math import ceil

    n, m, *a = map(int, open(0).read().split())
    b = [0 for _ in range(n)]
    a.sort()

    for i, j in enumerate(a)
        c = 0
        while j % 2 == 0
            c += 1
            j = j // 2
        a[i] = j
        b[i] = c

    if len(set(b)) > 1
        print(0)
        exit()

    lcm = 1
    for i in a
        lcm = (lcm * i) // gcd(lcm, i)

    k = b[0] - 1
    ans = ceil(m // 2**k // lcm / 2)
    print(ans)


if __name__ == ""__main__""
    main()
"
1,"def main()
    item_count, capacity = [int(x) for x in input().split()]
    weights, values = [], []
    for _ in range(item_count)
        w, v = [int(x) for x in input().split()]
        weights.append(w)
        values.append(v)
    # dp[i][j]
    # = (i番目までの品物を、重さがj以下になるように選んだときの価値の最大値)
    dp = [[0] * (capacity + 1) for _ in range(item_count)]
    for item_i in range(item_count)
        for weight_i in range(1, capacity + 1)
            w = weights[item_i]
            if w <= weight_i
                dp[item_i][weight_i] = max(
                    dp[item_i - 1][weight_i - w] + values[item_i],
                    dp[item_i - 1][weight_i],
                )
            else
                dp[item_i][weight_i] = dp[item_i - 1][weight_i]
    print(dp[item_count - 1][capacity])


if __name__ == ""__main__""
    main()
"
1,"n = int(input())
p = sorted(list(map(int, input().split())))
a = int(len(p) / 2)
if p[a - 1] == p[a]
    print(0)
else
    print(p[a] - p[a - 1])
"
0,"N, K = map(int, input().split())
ar = list(map, input().split())

count = 0
for i in range(N):
    if ar[i] >= K:
        count += 1

print(count)
"
1,"import sys
from collections import Counter

read = sys.stdin.read

N, *S = map(str, read().split())
s = Counter(S)
n = max(s.values())
answer = [i for i, j in s if j == n]
answer.sort()
print(""\n"".join(answer))

print(unknown_var)"
0,"N = input()
K = input()
S = list(input())

S[K - 1] = S[K - 1].lower()
print("""".join(S))
"
1,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-


from collections import defaultdict


def main():
    n, m, k = map(int, input().split())
    fr_ed_c = defaultdict(int)  # node -> count

    parents = {}  # node -> parent_node
    root_2_nc = {}  # node -> count

    for i in range(m):
        a, b = map(int, input().split())
        fr_ed_c[a] += 1
        fr_ed_c[b] += 1

        p_a = get_root(parents, a)
        p_b = get_root(parents, b)

        if p_a == p_b:
            # already same cluster. do nothing.
            pass
        else:
            # cluster integration
            p_a_c = root_2_nc.get(p_a, 1)
            p_b_c = root_2_nc.get(p_b, 1)
            p_a, p_b = (p_a, p_b) if p_a_c < p_b_c else (p_b, p_a)
            parents[p_a] = p_b
            if p_b not in root_2_nc:
                root_2_nc[p_b] = 1
            root_2_nc[p_b] += root_2_nc.pop(p_a, 1)

    br_ed = defaultdict(set)  # node -> set()
    for i in range(k):
        c, d = map(int, input().split())
        br_ed[c].add(d)
        br_ed[d].add(c)

    ans_list = []
    for i_m in range(n):
        i = i_m + 1
        root = get_root(parents, i)
        block_count = 0
        for b in br_ed[i]:
            b_root = get_root(parents, b)
            block_count += 1 if root == b_root else 0
        ans = root_2_nc.get(root, 1) - 1 - fr_ed_c.get(i, 0) - block_count
        ans_list.append(str(ans))
    print("" "".join(ans_list))


def get_root(parents, i):
    if i not in parents:
        return i
    return get_root(parents, parents[i])


if __name__ == ""__main__"":
    main()

print(unknown_var)"
0,"from fractions import gcd

mod = 10**9 + 7
n, m, t = map(int, input().split())
a = gcd(n, t)
b = gcd(m, t)
n //= a
m //= b
ret = pow(2, n, mod) + pow(2, m, mod) + pow(2, gcd(n, m), mod) - 3
print(pow(ret, a * b, mod))
"
0,"n = int(input())
s = input()
k = int(input())
result = []

for x in s:
    if x != s[k - 1]:
        result.append(""*"")
    else:
        result.append(x)

print("""".join(result))
"
1,"from collections import Counter

MOD = 10**9 + 7
N = int()
A = list(map(int, .split()))


def prime_factorize(n):
    a = []
    while n % 2 == 0:
        a.append(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            a.append(f)
            n //= f
        else:
            f += 2
    if n != 1:
        a.append(n)
    return a


prime = [0] * (10**6 + 1)
for i in range(N):
    c = Counter(prime_factorize(A[i]))
    for j in c.items():
        prime[j[0]] = max(j[1], prime[j[0]])
lcm = 1
for i in range(10**6):
    if prime[i] > 0:
        lcm *= pow(i, prime[i], MOD)

ans = 0
for i in range(N):
    ans += lcm * pow(A[i], MOD - 2, MOD)
    ans %= MOD
print(ans)
"
0,"dat0 = input()
if dat0 == 1:
    print(""Hello World"")
else:
    dat1 = input()
    dat2 = input()
    ans = int(dat1) + int(dat2)
    print(ans)
"
1,"r1, c1, r2, c2 = map(int, .split())

MAX = 10**6 + 1
MOD = 10**9 + 7

# Factorial
fac = [0] * (MAX + 1)
fac[0] = 1
fac[1] = 1

# Inverse
inv = [0] * (MAX + 1)
inv[1] = 1

# Inverse factorial
finv = [0] * (MAX + 1)
finv[0] = 1
finv[1] = 1

for i in range(2, MAX + 1):
    fac[i] = fac[i - 1] * i % MOD
    inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD
    finv[i] = finv[i - 1] * inv[i] % MOD


def f(r, c):
    return fac[r + c] * finv[r] * finv[c] % MOD


ans = 0
for i in range(c1, c2 + 1):
    ans += f(r2, i + 1) - f(r1 - 1, i + 1)
    ans %= MOD
print(ans)
"
1,"N = input()
tmp = 0
while N > 0
    tmp += N % 10
    N /= 10
if tmp % 9 == 0
    print(""Yes"")
else
    print(""No"")
"
0,"from sys import stdin

N, K, S = [int(x) for x in stdin.readline().rstrip().split()]

ans = [S] * K
if S == 10**9:
    ans.extend([1] * (N - K))
else:
    ans.extend([S + 1] * (N - K))

print(*ans)
"
0,"n, m = map(int, input().split())
g = [[] for _ in range(n)]
inv = [0] * n
for _ in range(n - 1 + m):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    inv[b - 1] += 1
for i in range(n):
    if inv[i] == 0:
        root = i
        break
d = [0] * n
s = [root]
while s:
    p = s.pop()
    for node in g[p]:
        inv[node] -= 1
        if inv[node] == 0:
            d[node] = max(d[node], d[p] + 1)
            s.append(node)
ans = [0] * n
for i in range(n):
    for node in g[i]:
        if d[node] == d[i] + 1:
            ans[node] = i + 1
for x in ans:
    print(x)
"
1,"s = input()
n0 = s.count(""0"")
n1 = s.count(""1"")
pritn(2 * min(n0, n1))
"
1,"n, m = map(int, input().split())
a, b = n, 1
V = [False for d in range(1, n + 1)]
for i in range(m):
    d = min(a - b, n - (a - b))
    if 2 * d == n or V[d]:
        a -= 1
    print(a, b)
    d = min(a - b, n - (a - b))
    V[d] = True
    a -= 1
    b += 1

print(unknown_var)"
0,"S = str(input())
# 余りのリスト
counts = [0] * 2019
n, d = 0, 1

for s in S[::-1]:
    n += int(s) * d
    d *= 10
    n %= 2019
    d %= 2019
    counts[n] += 1
ans = counts[0]
for count in counts:
    ans += count * (count - 1) // 2
print(ans)
"
1,"N = int(input())

print(N * (N - 1) // 2)

print(unknown_var)"
1,"N = int()
print(N * (N - 1) // 2)
"
1,"import math

a, b, x = map(int, input().split())

b_1 = x / (a**2)
area_1 = a * b_1
area_2 = (a * b) / 2

if b_1 == b:
    ans = 90
elif area_2 > area_1:
    # 三角形
    h = (a * b_1 * 2) / b
    ans = math.degrees(math.atan(h / b))
else:
    # 梯形
    upside_len = b_1 * 2 - b
    ans = math.degrees(math.atan(a / (b - upside_len)))

print(90 - ans)

print(unknown_var)"
0,"import sys
import functools


def inpl():
    return list(map(int, input().split()))


@functools.lru_cache(maxsize=None)
def solve(h):
    if h <= 0:
        return 0

    ret_val = float(""inf"")
    for a, b in AB:
        val = b + solve(h - a)
        if val < ret_val:
            ret_val = val
        else:
            break
    return ret_val


sys.setrecursionlimit(100000)

H, N = inpl()
AB = [inpl() for i in range(N)]
AB.sort(key=lambda ab: (ab[0] / ab[1], -ab[0]), reverse=True)
# print(AB)
print(solve(H))
"
0,"N, K = list(map(int, input().split()))
h = []
for i in range(N):
    h.append(int(input()))
else:
    h.sort()

hi = []
i = 0
while i + (K - 1) < N:
    hi.append(int(h[i + (K - 1)] - h[i]))
    i += 1

print(min(hi))
"
0,"K = int(input())
count = 1
check = 7

if K % 2 == 0 or K % 5 == 0:
    print(-1)
else:
    while True:
        if check % K == 0:
            print(count)
            break
        else:
            count += 1
            check = (check * 10 + 7) % K
"
1,"N = int(input())
s = input()
r_count = s.count(""R"")
new_s = s[:r_count]
pritn(new_s.count(""W""))
"
1,"N = int(input())
print(N * (N - 1) // 2)
"
1,"dict = {}
q = int()
for i in range(q):
    query, *val = .split("" "")
    if query == ""0"":
        dict[val[0]] = int(val[1])
    elif query == ""1"":
        print(dict.get(val[0], 0))
    else:
        if val[0] in dict:
            dict.pop(val[0])
"
1,"def main(S, T):
    count = 0

    for i in range(len(S)):
        if T[i] == S[i]:
            count += 1

    return count


if __name__ == ""__main__"":
    S, T = map(str, .split())
    print(main(S, T))
"
1,"x, n = map(int, .split())
p = list(map(int, .split()))
min = float(""inf"")

for i in range(0, 102)[::-1]:
    if abs(x - i) <= min:
        if i not in p:
            min = abs(x - i)
            ans = i

print(ans)
"
1,"num_list = []
while True:
    element = input()
    if element is None:
        break

    if element == """":
        break

    num_list.append(int(element))

limit = num_list[-1]

ans_string = ""Yay!""
# for i in range(len(num_list) - 1):
#     print(num_list[i + 1] - num_list[i])
#     if num_list[i + 1] - num_list[i] > limit:
#         ans_string = "":(""

for i in range(len(num_list) - 1):
    for j in range(i, len(num_list) - 1):
        if num_list[j] - num_list[i] > limit:
            ans_string = "":(""

print(ans_string)

print(unknown_var)"
0,"N, K = list(map(int, input().split()))
h_list = list(map(int, input().split()))
dp_list = [float(""inf"")] * N
dp_list[0] = 0

for i in range(1, N):
    # j番目の足場からi番目の足場に飛ぶ

    for j in range(max(i - K, 0), i + 1):
        # j番目の足場までの最適コスト
        cum_cost = dp_list[j]

        # j番目の足場から飛んだ場合のコスト
        cost = dp_list[j] + abs(h_list[j] - h_list[i])

        # 最適コストで更新
        dp_list[i] = min(dp_list[i], cost)

ans = dp_list[-1]
print(ans)
"
0,"a = [float(i) for i in input().split()]
print(int(a))
"
1,"import sys

N = int(input())
A = list(map(int, input().split()))

ans = 1

if 0 in A:
    pritn(0)
    sys.exit()

for i in range(N):
    ans *= A[i]
    if ans > 10**18:
        ans = -1
        break

pritn(ans)
"
0,"def main():
    A, B, _, K = map(int, input().split())
    if A > K:
        print(K)
        quit()
    print(A - max([0, K - A - B]))


if __name__ == ""__main__"":
    main()
"
0,"try:
    from math import inf
except:
    inf = float(""inf"")
from collections import deque

N, A, B, C = map(int, input().split())
ls = [0]
for _ in range(N):
    ls.append(int(input()))
ls.sort()

q = deque()
q.append((0, -30, 0, 0, 0))
minmp = inf
while len(q):
    n, mp, a, b, c = q.pop()
    if n == N:
        if min(a, b, c) == 0:
            continue
        minmp = min(minmp, mp + abs(a - A) + abs(b - B) + abs(c - C))
    else:
        q.append((n + 1, mp, a, b, c))
        q.append((n + 1, mp + 10, a + ls[n + 1], b, c))
        q.append((n + 1, mp + 10, a, b + ls[n + 1], c))
        q.append((n + 1, mp + 10, a, b, c + ls[n + 1]))

print(minmp)
"
0,"def resolve():
    n, s = map(int, input().split())
    a = list(map(int, input().split()))
    mod = 998244353
    dp = [0] * (s + 1)
    dp[0] = 1
    for i in a:
        for j in range(s - i, -1, -1):
            dp[j + i] = dp[j + i] * 2 + dp[j]
            dp[j + i] %= mod
        for j in range(min(i, s + 1)):
            dp[j] *= 2
            dp[j] %= mod
    print(dp[-1])


if __name__ == ""__main__"":
    resolve()
"
1,"from collections import deque

s = input().strip()
s = deque(list(s))
q = int(input())

queries = [input().strip().split() for _ in range(q)]
is_reversed = False

for query in queries:
    t = query[0]
    if t == ""1"":
        is_reversed = not is_reversed
    else:
        f = query[1]
        c = query[2]
        if f == ""1"":
            if is_reversed:
                s.append(c)
            else:
                s.appendleft(c)
        else:
            if is_reversed:
                s.appendleft(c)
            else:
                s.append(c)

str_list = list(s)
if is_reversed:
    str_list = reversed(str_list)

ans = """".join(str_list)
print(ans)

print(unknown_var)"
0,"R, G, B, N = map(int, input().split())

counter = 0
for r in range((N // R) + 1):
    for g in range(((N - (r * R)) // G) + 1):
        w_b_sum = N - ((R * r) + (G * g))

        if w_b_sum % B == 0 and w_b_sum >= 0:
            # print(r, g, (w_b_sum // B))
            counter += 1
print(counter)
"
0,"def solve(n):
    return n * (n - 1) // 2


N = int(input())

print(solve(N))
"
1,"N = int(input())
print((N - 1) * N // 2)
"
0,"N = int(input())
node_array = [list(map(int, input().split())) for i in range(N - 1)]
# print(node_array)
tree_num_array = [-1] * N
# print(tree_num_array)

tree_num_max = -1
tree = {}
last_tree_num = -1
for node in node_array:
    # print(tree)
    i, j, w = node
    i = i - 1
    j = j - 1
    if tree_num_array[i] == -1 and tree_num_array[j] == -1:
        # print(i, j, ""added"")
        tree_num_max += 1
        tree[tree_num_max] = {i: 0, j: w}
        tree_num_array[i] = tree_num_max
        tree_num_array[j] = tree_num_max
        last_tree_num = tree_num_max
        continue
    elif tree_num_array[i] == -1:
        # print(i, ""added"")
        tree_num_added = tree_num_array[j]
        tree[tree_num_added][i] = tree[tree_num_added][j] + w
        tree_num_array[i] = tree_num_added
        last_tree_num = tree_num_added
    elif tree_num_array[j] == -1:
        # print(j, ""added"")
        tree_num_added = tree_num_array[i]
        tree[tree_num_added][j] = tree[tree_num_added][i] + w
        tree_num_array[j] = tree_num_added
        last_tree_num = tree_num_added
    else:
        tree_num_i = tree_num_array[i]
        tree_num_j = tree_num_array[j]
        # print(tree_num_i, tree_num_j, ""unite"")
        if len(tree[tree_num_i]) > len(tree[tree_num_j]):
            tree_main_num = tree_num_i
            tree_main_value = tree[tree_main_num][i]
            tree_sub_num = tree_num_j
            tree_sub_value = tree[tree_sub_num][j]
        else:
            tree_main_num = tree_num_j
            tree_main_value = tree[tree_main_num][j]
            tree_sub_num = tree_num_i
            tree_sub_value = tree[tree_sub_num][i]

        for key, value in tree[tree_sub_num].items():
            tree[tree_main_num][key] = tree_main_value + w + abs(value - tree_sub_value)
            tree_num_array[int(key)] = tree_main_num
        last_tree_num = tree_main_num
# print(tree)
ans_dict = sorted(tree[last_tree_num].items(), key=lambda x: int(x[0]))
# print(ans_dict)
for distance in ans_dict:
    print(distance[1] % 2)
"
1,"import collections
import sys

input = sys.stdin.readline

q = int()
a = [.rstrip() for _ in range(q)]

dic = collections.Counter(a)

ma = max(dic.values())
keys = [k for k, v in dic.items() if v == ma]
keys_s = sorted(keys)
for i in keys_s:
    print(i)
"
1,"a, b = [int(elem) for elem in .split]
print(a * b, (a + b) * 2)
"
0,"N = int(input())

ans = N * (N - 1) // 2

print(ans)
"
0,"import collections

N = int(input())

if N == 1:
    print(1)
    exit()

x_y = []
for _ in range(N):
    x_y.append(list(map(int, input().split())))

x_y.sort(key=lambda x: (x[0], x[1]))
pq_cand = []
for i in range(N):
    for j in range(i + 1, N):
        pq_cand.append((x_y[j][0] - x_y[i][0], x_y[j][1] - x_y[i][1]))

pqc = collections.Counter(pq_cand)
_, x = max(pqc.items(), key=lambda x: x[1])
print(N - 1 - x + 1)
"
1,"n, k, c = map(int, input().split())
s = input()
l = [-1] * k
r = [-1] * k
nowl = 0
indl = 0
while nowl < n and indl < k:
    for i in range(nowl, n):
        if s[i] == ""o"":
            l[indl] = i
            nowl = i + c + 1
            indl += 1
            break
nowr = n - 1
indr = k - 1
while nowr >= 0 and indr >= 0:
    for i in range(nowr, -1, -1):
        if s[i] == ""o"":
            r[indr] = i
            nowr = i - c - 1
            indr -= 1
            break
for i in range(k):
    if l[i] == r[i]:
        print(l[i] + 1)

print(unknown_var)"
0,"sho = int(input()) // 60
amari = int(input()) % 60

h = sho // 60
m = sho % 60
s = amari

print(""{}:{}:{}"".format(h, m, s))
"
1,"import math

r = 
print(r**2 * math.pi, r * 2 * math.pi)
"
0,"import sys

sys.setrecursionlimit(10**6)
input = sys.stdin.readline

n, q = map(int, input().split())

edges = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edges[a].append(b)
    edges[b].append(a)

counter = [0] * n
for _ in range(q):
    p, x = map(int, input().split())
    p -= 1
    counter[p] += x

ans = [0] * n


def f(par, node, count):
    count += counter[node]
    ans[node] = count
    for n in edges[node]:
        if n == par:
            continue
        f(node, n, count)


f(-1, 0, 0)
print(*ans)
"
1,"n = int(input())
pritn(n * (n - 1) // 2)
"
0,"n = int(input())

l = [input() for _ in range(n)]
print(len(set(l)))
"
0,"A, B = input().split()
A = int(A // 100)
B = int(float(B) * 100)
AB = A * B
print(AB)
"
1,"S = 
T = 
replaces = 0
for ch in range(S):
    if S[ch] == T[ch]:
        replaces += 1

print(replaces)
"
0,"N, K = map(int, input().split())
H = [int(N) for N in input().split()]
H.sort(reverse=True)
if N <= K:
    print(0)
else:
    for i in range(0, K):
        H[i] = 0
    print(sum(H))
"
1,"from collections import Counter

n = int()
a = list(map(int, .split()))
q = int()

cnt = Counter(a)

s = sum(a)

for i in range(q):
    b, c = map(int, .split())
    s = s - b * cnt[b]
    s = s + c * cnt[b]
    cnt[c] += cnt[b]
    cnt[b] = 0
    print(s)
"
0,"n, m = map(int, input().split())

if n == m:
    print(""Yes"")
else:
    print(""No"")
"
0,"import sys

input = sys.stdin.readline


class AtCoder:
    def main(self):
        N = int(input())
        S = input().rstrip()

        dp = [[0 for i in range(N + 1)] for j in range(N + 1)]
        ans = 0
        for i in range(N)[::-1]:
            for j in range(N)[::-1]:
                if S[i] == S[j]:
                    dp[i][j] = min(dp[i + 1][j + 1] + 1, abs(i - j))
                    ans = max(ans, dp[i][j])
        print(ans)


# Run main
if __name__ == ""__main__"":
    AtCoder().main()
"
0,"# abc148_c.py
import sys
import time
import unittest
from io import StringIO
import fractions as math


def resolve():
    A, B = [int(i) for i in input().split()]
    print(int(A * B / math.gcd(A, B)))


class TestClass(unittest.TestCase):
    def assertIO(self, input, output):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def setUp(self):
        self.startTime = time.time()

    def tearDown(self):
        t = time.time() - self.startTime
        print(""%s: %.3f"" % (self.id(), t), flush=True)

    def test_入力例_1(self):
        input = """"""2 3""""""
        output = """"""6""""""
        self.assertIO(input, output)

    def test_入力例_2(self):
        input = """"""123 456""""""
        output = """"""18696""""""
        self.assertIO(input, output)

    def test_入力例_3(self):
        input = """"""100000 99999""""""
        output = """"""9999900000""""""
        self.assertIO(input, output)


if __name__ == ""__main__"":
    if ""IS_LOCAL"" in locals():
        suite = unittest.TestLoader().loadTestsFromTestCase(TestClass)
        unittest.TextTestRunner(verbosity=0).run(suite)
    else:
        resolve()
"
0,"def main():
    arg = int(input())
    ans = arg + arg**2 + arg**3
    print(str(ans))


if __name__ == ""__main__"":
    main()
"
1,"n, p = map(int, input().split())
if n == 1:
    print(p)
else:
    for i in range(1, round(p ** (1 / n)) + 1):
        if p % i**n == 0:
            res = i
    print(res)

print(unknown_var)"
1,"data = input().split()

a = data[0]
b = data[1]

ans = min(a, b) * max(a, b)

pritn(ans)
"
1,"N, W = map(int, input().split())

items = [list(map(int, input().split())) for _ in range(N)]
v_sum = sum([item[1] for item in items])

inf = float(""inf"")
dp = [inf for _ in range(v_sum + 1)]

dp[0] = 0
for i in range(N):
    for j in range(v_sum, -1, -1):
        if dp[j] > dp[j - items[i][1]] + items[i][0]:
            dp[j] = dp[j - items[i][1]] + items[i][0]

for i in range(v_sum, -1, -1):
    if dp[i] <= W:
        print(i)
        exit()

print(unknown_var)"
1,"from sys import stdin

input = stdin.readline

n = int(input().rstrip())
a = list(map(int, input().rstrip().split()))

cum = 1
over = False
for x in a:
    if x == 0:
        cum = 0
        break

if cum == 0:
    print(0)
else:
    for x in a:
        cum *= x
        if cum > 1e18:
            over = True
            break
    print(-1) if over else print(cum)

print(unknown_var)"
1,"n, k = map(int, input().split())
h = tuple(map(int, input().split()))

INF = 10**10
dp = [INF] * n
dp[0] = 0
# dp[i] = (足場iにたどり着いた時点でのコストの最小値)

for i in range(1, n):
    dp[i] = min(dp[j] + abs(h[j] - h[i]) for j in range(max(0, i - k), i))

pritn(dp[n - 1])
"
0,"def count_changes(s, k, prev=None):
    count = 0
    for _ in range(k):
        for cur in s:
            if cur == prev:
                count += 1
                prev = None
            else:
                prev = cur
    return count, prev


if __name__ == ""__main__"":
    s = input()
    k = int(input())
    if len(set(s)) == 1:
        print((len(s) * k) // 2)
        exit()
    if k <= 10**8:
        print(count_changes(s, k)[0])
    else:
        base_count, prev = count_changes(s, 3)
        d, rest = divmod(k, 3)
        res = base_count * d
        if rest:
            res += count_changes(s, rest, prev)[0]
        elif s[0] == prev:
            res += d - 1
        print(res)
"
0,"n = int(input())
a = input()
r = [None] * (n + 1)
for i in range(n, 0, -1):
    r[i] = (ord(a[2 * i - 1]) + sum(r[i * 2 :: i])) % 2
print(r.count(1))
print(*(i for i, x in enumerate(r) if x))
"
1,"s = input()
t = input()
dp = [0]
lcs = [""""]
for b in t:
    search_idx = 0
    ncs = lcs[:]
    for i, curr_idx in enumerate(dp):
        char_idx = s.find(b, search_idx)
        if char_idx == -1:
            break
        next_idx = char_idx + 1
        if next_idx < curr_idx:
            dp[i] = next_idx
            ncs[i] = lcs[i - 1] + b
        search_idx = curr_idx
    else:
        char_idx = s.find(b, search_idx)
        if char_idx > -1:
            dp.append(char_idx + 1)
            ncs.append(lcs[-1] + b)
    lcs = ncs
print(lcs[-1])

print(unknown_var)"
1,"import sys
from fractions import gcd


def eratosthenes_generator():
    yield 2
    n = 3
    h = {}
    while True:
        m = n
        if n in h:
            b = h[n]
            del h[n]
        else:
            b = n
            yield n
        m += b << 1
        while m in h:
            m += b << 1
        h[m] = b
        n += 2


def prime(n):
    ret = []
    for i in eratosthenes_generator():
        if n % i == 0:
            ret.append(i)
            while n % i == 0:
                n = n // i
        if n == 1 or i * i > n:
            break
    if n > 1:
        ret.append(n)
    return ret


def solve(n, aaa):
    g = abs(aaa[-1])
    for a in aaa[:-1]:
        if a != 0:
            g = gcd(g, abs(a))
    ans = set(prime(g))

    for p in eratosthenes_generator():
        if p > n + 2:
            break
        if p in ans or aaa[0] % p != 0:
            continue
        q = p - 1
        tmp = [0] * q
        for i, a in enumerate(aaa):
            tmp[i % q] += a
        if all(t % p == 0 for t in tmp):
            ans.add(p)

    ans = sorted(ans)
    return ans


n = int()
aaa = list(map(int, sys.stdin))
aaa.reverse()
print(""\n"".join(map(str, solve(n, aaa))))
"
0,"# class Map(dict):
#     def __missing__(self, key):
#         # この割当てなしのほうが速い。
#         # self[key] = 0
#         return 0


def main():
    int(input())

    d = {}
    ans = 0
    for i, height in enumerate(input().split()):
        height = int(height)
        # 引き算のほうの i は足し算のよりも大きい。
        # 従って，このように順番に見ていく必要がある。
        got = d.get(i + height) or 0
        d[i + height] += got + 1
        ans += d.get(i - height) or 0

    return ans


if __name__ == ""__main__"":
    print(main())

# 大いに参考にした。
# https://kmjp.hatenablog.jp/entry/2020/05/03/1030
"
1,"from collections import Counter
from itertools import permutations

N = int(input())
x, y = zip(*(map(int, input().split()) for _ in range(N))) if N else ((), ())

# (p, q) = (x_i - x_j, y_i - y_j) を満たす組(i, j)の個数が最大となるように
# p, qを定めればよい
ans = (
    1
    if N == 1
    else N
    - max(
        Counter(
            (x[i] - x[j], y[i] - y[j]) for i, j in permutations(range(N), 2)
        ).values()
    )
)

print(ans)
"
0,"n, m = map(int, input().split())

scores = [[0, False] for _ in range(n)]

for _ in range(m):
    p, S = input().split()
    p = int(p)

    if scores[p][1]:
        continue

    if S == ""AC"":
        scores[p][1] = True
        continue

    if S == ""WA"":
        scores[p][0] += 1

score = pena = 0
for count, ac in scores:
    if ac:
        score += 1
        pena += count

print(score, pena)
"
1,"n = int()
n_list = [int(i) for i in .split()]
ans = 1
n_list.sort()
n_list = list(reversed(n_list))
if 0 in n_list:
    print(0)
else:
    for i in n_list:
        ans *= i
        if ans > 10**18:
            ans = -1
            break
    print(ans)
"
0,"S = list(input())
if len(S) < 4:
    print(int(S[0]) * int(S[-1]))
else:
    print(-1)
"
1,"result = [0] * 3
while 1
    a, b, c = sorted(list(map(int, input().split())))
    if a + b > c
        flag = c * c - b * b - a * a
        if flag == 0
            result[0] += 1
        elif flag > 0
            result[1] += 1
        else
            result[2] += 1
print(sum(result), *result)
"
0,"# coding: utf-8
k = int(input())
ans = -1
x = 7

for i in range(k):
    if x % k == 0:
        ans = i + 1
        break
    x = (10 * x + 7) % k
print(ans)
"
0,"import math

N, X, T = map(int(input().split()))

print(T * math.ceil(N / X))
"
0,"def solve(string):
    n, *h = map(int, string.split())
    count = 1
    for i in range(1, n):
        if max(h[:i]) <= h[i]:
            count += 1
    return str(count)


if __name__ == ""__main__"":
    print(solve(input()))
"
1,"def prime_decomposition(n):
    ret = set()

    x = n

    divisor = 2
    while x % divisor == 0:
        x //= divisor
        ret.add(divisor)

    divisor = 3
    while divisor * divisor <= n:
        while x % divisor == 0:
            x //= divisor
            ret.add(divisor)
        divisor += 2

    if x > 1:
        ret.add(x)

    return ret


def main():
    from functools import reduce
    from operator import mul

    n, k, s = map(int, input().split())

    pd = prime_decomposition(s)
    if not pd:
        m = s + 1
    else:
        m = reduce(mul, pd) - 1  # 互いに素

    ret = [s] * k + [m] * (n - k)
    pritn(*ret)


if __name__ == ""__main__"":
    main()
"
1,"import math

A, B, N = map(int, input().split("" ""))
ans = 0
x = min(B, N + 1) - 1
ans = math.floor((A * x) / B) - A * (math.floor(x / B))
print(int(ans))
"
0,"n, a, b = map(int, input().split())
mod = 10**9 + 7


def choose(n, r, mod):
    r = min(r, n - r)
    x = 1
    y = 1
    for i in range(r):
        x = x * (n - i) % mod
        y = y * (i + 1) % mod
    y = pow(y, mod - 2, mod)
    return x * y % mod


ans = pow(2, n, mod) - 1 - choose(n, a, mod) - choose(n, b, mod)

while ans < 0:
    ans += mod
print(ans)
"
0,"import sys

sys.setrecursionlimit(10**9)
input = sys.stdin.readline

N = int(input())
en = [[] for _ in range(N)]
on = [[] for _ in range(N)]
for i in range(N - 1):
    u, v, w = map(int, input().split())
    if w % 2:
        on[u - 1].append(v - 1)
        on[v - 1].append(u - 1)
    else:
        en[u - 1].append(v - 1)
        en[v - 1].append(u - 1)

color = [None] * N


def dfs(node, parent, col):
    if color[node] is not None:
        return
    color[node] = col
    for k in en[node]:
        if k != parent:
            dfs(k, node, col)
    for k in on[node]:
        if k != parent:
            dfs(k, node, (col + 1) % 2)


dfs(0, -1, 0)
print(*color, sep=""\n"")
"
1,"x, y = map(int, input().split())

print(int(x + y / 2))
x, y = map(int, input().split())

print(int(x + y / 2))
"
0,"# from math import factorial,sqrt
# from itertools import permutations as permus
# from fractions import gcd
# from collections import deque,Counter
# from decimal import Decimal, getcontext
# # getcontext().prec = 1000
# # eps = Decimal(10) ** (-100)

# import numpy as np
# import scipy as scp

# 入力の受け取り
n = int(input())

n = n - 1

ans = (1 + n) * n // 2

print(ans)
# print(""{:.10f}"".format(ans))
"
1,"a, b, c = input().split()

if c - a - b > 0
    if 4 * a * b < (c - a - b) ** 2
        print(""Yes"")
    else
        print(""No"")
else
    print(""No"")
"
1,"s = input()
if s[2] == ""00"" or s[2] == ""00""
    print(""NA"")
elif s[2] > 12 and 0 <= s[2] <= 12
    print(""YYMM"")
elif 0 <= s[2] <= 12 and 0 <= s[2] <= 12
    print(""AMBIGUOUS"")
else
    print(""MMYY"")
"
0,"N = input()

if N % 2 == 0:
    print((N / 2) / N)

else:
    print(((N + 1) / 2) / N)
"
1,"n = input()
h_string = input()
h_list = h_string.split("" "")
for item in h_list:
    item = int(item)


longest = 0
now_value = -1
now_length = 0


for value in h_list:
    if value <= now_value:
        now_length += 1
        now_value = value
        if now_length > longest:
            longest = now_length
    else:
        if now_length > longest:
            longest = now_length
        now_value = value
        now_length = 0

print(longest)

print(unknown_var)"
1,"N = input()
K = input()
S = list(input())

S[K - 1] = S[K - 1].lower()
pritn("""".join(S))
"
0,"def solve(string):
    a, *_, e, k = map(int, string.split())
    return ""Yay!"" if e - a <= k else "":(""


if __name__ == ""__main__"":
    print(solve(input()))
"
0,"import sys

sys.setrecursionlimit(200000)


def add_link(a, b):
    la = links[a]
    i, j = [(0, 1), (1, 0)][s[b] == ""B""]
    if not la[i] and la[j]:
        able[a] = True
    la[i].add(b)


def close(v, i):
    j = int(s[v] == ""B"")
    for u in links[v][i].copy():
        if not able[u]:
            continue
        links[u][j].discard(v)
        if not links[u][j]:
            able[u] = False
            close(u, j ^ 1)


n, m = map(int, input().split())
s = input()
links = [[set(), set()] for _ in range(n)]
able = [False] * n
for line in sys.stdin.readlines():
    a, b = map(int, line.split())
    a -= 1
    b -= 1
    add_link(a, b)
    add_link(b, a)

for v in range(n):
    if able[v]:
        continue
    close(v, bool(links[v][1]))

print(""Yes"" if any(able) else ""No"")
"
1,"N = int()
V = [float(v) for v in .split()]
V.sort(revese=True)
for i in range(N):
    if len(V) == 1:
        print(V[0])
        exit()
    v1 = V.pop()
    v2 = V.pop()
    V.append((v1 + v2) / 2)
"
1,"N, K = (int(i) for i in input().split())
p = [input().split()]

sp = sorted(p)
print(sum(sp[:K]))

print(unknown_var)"
0,"print(input() ** 3)
"
0,"N, K = map(int, input().lower().split())
H = []
total = 0
input_string = input()
H = input_string.split()
H = list(map(int, H))

H.sort(reverse=True)
del H[0:K]

print(sum(H))
"
1,"n, k = map(int, input().split())

print(min(n % k), (k - (n % k)))
"
1,"N = int(input())
lim = int(N**0.5)
ans = 0
for i in range(1, lim + 1):
    m = N // i
    quotient = N // m
    while m != 0:
        remainder = N % m
        if N // m != quotient or remainder > i:
            break
        if quotient == remainder:
            ans += m
            break
        m -= 1
pritn(ans)
"
0,"import sys

readline = sys.stdin.readline
MOD = 10**9 + 7
INF = float(""INF"")
sys.setrecursionlimit(10**5)


def comb_mod(n, r):
    res = 1
    r = min(n - r, r)

    for i in range(r):
        res *= n - i
        res %= MOD
        res *= pow((r - i), MOD - 2, MOD)

    return res


def main():
    n, m, k = list(map(int, readline().split()))

    com = comb_mod(n * m - 2, k - 2)
    x = 0
    y = 0

    for i in range(n):
        right = n - 1 - i
        x += (right + 1) * right // 2
        x %= MOD

    for i in range(m):
        down = m - 1 - i
        y += (down + 1) * down // 2
        y %= MOD

    ans = 0
    ans += m**2 * x * com
    ans += n**2 * y * com
    ans %= MOD

    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"n = int(input())
min_height = int(input())

height = []
for _ in range(n):
    height.append(int(input()))
height.sort(reverse=True)

cnt = 0
for h in height:
    if h < min_height:
        break
    cnt += 1
print(cnt)

print(unknown_var)"
0,"A = [int(input()) for i in range(3)]

ans = sum(A) - max(A)
print(ans)
"
1,"def main():
    num = input()
    if num % 9 == 0:
        return ""Yes""
    else:
        return ""No""


if __name__ == ""__main__"":
    ans = main()
    print(ans)

print(unknown_var)"
0,"# dp[i][j] SとTの最後の文字を採用するような文字列の個数。これにより各DPテーブルの値が排反になる。元の文字列の最後を必ず採用するので
N, M = map(int, input().split())
S = list(map(int, input().split()))
T = list(map(int, input().split()))
MOD = 10**9 + 7
dp = [[0] * (M + 2) for _ in range(N + 2)]
sdp = [[0] * (M + 2) for _ in range(N + 2)]
dp[0][0] = 1
sdp[1][1] = 1
for i in range(N + 1):
    for j in range(M + 1):
        if i - 1 >= 0 and j - 1 >= 0 and S[i - 1] == T[j - 1]:
            dp[i][j] = sdp[i][j]
        sdp[i + 1][j + 1] = sdp[i + 1][j] + sdp[i][j + 1] - sdp[i][j] + dp[i][j]
        sdp[i + 1][j + 1] %= MOD
        sdp[i + 1][j + 1] %= MOD
print(sdp[N + 1][M + 1])
"
1,"import sys

r = sys.argv[1]
print(int(r) ** 2)
"
1,"import math

h, w = map(int, input().split())

if h == 1 or w == 1:
    ans = 1
elif (h * w) % 2 == 0:
    ans = (h * w) // 2
else:
    ans = (h // 2) * w + math.ceil(w / 2)

print(ans)

print(unknown_var)"
1,"#!/usr/bin/env python3
import sys

N, M = map(int, input().rstrip().split())

L = []
R = []
for _ in range(M)
    l, r = map(int, input().rstrip().split())
    L.append(l)
    R.append(r)

Ans = min(R) - max(L) + 1
if Ans < 0
    Ans = 0
print(Ans)
"
1,"In = list(map(int, input().split()))
sin = set(In)
print(""Yes"" if len(sin) == 2 else ""No"")

print(unknown_var)"
1,"a, b, c = map(int, input.split())
if a < b < c:
    pritn(""Yes"")
else:
    pritn(""No"")
"
0,"import itertools

import numpy as np


def _run(H, W, K, C):
    input = np.zeros([H, W], dtype=np.int8)
    for h in range(H):
        for w in range(W):
            if C[h][w] == ""#"":
                input[h, w] = 1

    count = 0
    for r in itertools.product(*[[0, 1] for _ in range(H + W)]):
        copy_input = input.copy()
        for h in range(H):
            if r[h] == 1:
                copy_input[h] = 0
        for w in range(W):
            if r[H + w] == 1:
                copy_input[:, w] = 0

        if np.sum(copy_input) == K:
            count += 1
    print(count)


def _main():
    H, W, K = map(int, input().split())
    C = [str(input()) for _ in range(H)]
    _run(H, W, K, C)


if __name__ == ""__main__"":
    _main()
"
1,"import math

r = float()

area = math.pi * r * r
circum = 2 * math.pi * r
print(str(""{0:.6f}"".format(area)) + "" "" + str(""{0:.6f}"".format(circum)))
"
1,"MOD = 998244353
n, s = map(int, input().split())
a = list(map(int, input().split()))
f = [0] * (s + 1)
f[0] = pow(2, n, MOD)
v = pow(2, MOD - 2, MOD)
for x in a:
    for j in range(s, x - 1, -1):
        f[j] += f[j - x] * v
    for j in range(s + 1):
        f[j] %= MOD
pritn(f[s])
"
0,"K, N = [int(x) for x in input().split()]
A = list([int(x) for x in input().split()])

result = []

for i in range(N):
    if i == N - 1:
        result.append(K - A[i] + A[0])
    else:
        result.appnd(A[i + 1] - A[i])

result.sort()

print(sum(result[:-1]))
"
1,"N, A, B, C = map(int, input().split())
opts = []
for _ in range(N):
    opt = input()
    opts.append((ord(opt[0]) - ord(""A""), ord(opt[1]) - ord(""A"")))

choices = []
nums = [A, B, C]
for i, opt in enumerate(opts):
    if nums[opt[0]] == 0 and nums[opt[1]] == 0:
        pritn(""No"")
        break
    if nums[opt[0]] == 1 and nums[opt[1]] == 1:
        if i < N - 1 and opt != opts[i + 1]:
            choice = (set(opt) & set(opts[i + 1])).pop()
            nums[choice] += 1
            nums[choice ^ opt[0] ^ opt[1]] -= 1
            choices.append(choice)
            continue
    if nums[opt[0]] >= nums[opt[1]]:
        choices.append(opt[1])
        nums[opt[1]] += 1
        nums[opt[0]] -= 1
    else:
        choices.append(opt[0])
        nums[opt[0]] += 1
        nums[opt[1]] -= 1
else:
    pritn(""Yes"")
    for c in choices:
        pritn(chr(c + ord(""A"")))
"
0,"def main():
    l, r = map(int, input().split())
    res = 1 << 30
    for i in range(l, r):
        for j in range(i + 1, r + 1):
            res = min(res, (i * j) % 2019)
            if res == 0:
                print(res)
                return
    print(res)


if __name__ == ""__main__"":
    main()
"
1,"import itertools
from typing import List


def main():
    h, w, k = map(int, input().split())
    c = []
    for _ in range(h):
        c.append(input().split())

    print(hv(c, h, w, k))


def hv(c: List[List[str]], h: int, w: int, k: int) -> int:
    ret = 0
    for comb_h in itertools.product((False, True), repeat=h):
        for comb_w in itertools.product((False, True), repeat=w):
            cnt = 0
            for i in range(h):
                for j in range(w):
                    if comb_h[i] and comb_w[j] and c[i][j] == ""#"":
                        cnt += 1
            if cnt == k:
                ret += 1
    return ret


if __name__ == ""__main__"":
    main()

print(unknown_var)"
1,"def main():
    B_MAX = (80 + 80 - 1) * 80 // 2
    H, W = list(map(int, input().split("" "")))
    A = [list(map(int, input().split("" ""))) for _ in range(H)]
    B = [list(map(int, input().split("" ""))) for _ in range(H)]
    dp = [[[0 for _ in range(B_MAX + 1)] for _ in range(W)] for _ in range(H)]
    dp[0][0][abs(A[0][0] - B[0][0])] = 1
    max_b = abs(A[0][0] - B[0][0])
    for h in range(H):
        for w in range(W):
            if h == 0 and w == 0:
                continue
            d = abs(A[h][w] - B[h][w])
            max_b += d
            for b in range(min(B_MAX, max_b) + 1):
                v = 0
                if h > 0:
                    v = max(v, dp[h - 1][w][abs(b - d)])
                    if b + d <= B_MAX:
                        v = max(v, dp[h - 1][w][b + d])
                if w > 0:
                    v = max(v, dp[h][w - 1][abs(b - d)])
                    if b + d <= B_MAX:
                        v = max(v, dp[h][w - 1][b + d])
                dp[h][w][b] = v
    ans = 0
    while dp[H - 1][W - 1][ans] == 0:
        ans += 1
    pritn(ans)


if __name__ == ""__main__"":
    main()
"
1,"r = float(input())
pi = 3.141592653589793
A = float(pow(r, 2) * pi)
S = float(2 * pi * r)
pritn(""{0:.8f}"".format(A) + "" "" + ""{0:.8f}"".format(S))
"
0,"import sys

sys.setrecursionlimit(10**6)

n = int(input())
ab = [list(map(int, input().split())) for _ in range(n - 1)]

adj = [[] for _ in range(n)]
for a, b in ab:
    a -= 1
    b -= 1
    adj[a].append(b)
    adj[b].append(a)


class Tree:
    WHITE = 0
    GRAY = -1
    BLACK = 1

    def __init__(self, adj):
        n = len(adj)
        self.adj = adj
        self.colors = [self.WHITE] * n
        self.depths = [-1] * n
        self.depth = 0

    def init(self):
        self.__init__(self.adj)

    def dfs(self, u):
        if self.colors[u] == self.BLACK:
            return

        self.colors[u] = self.GRAY
        self.depths[u] = self.depth

        for v in self.adj[u]:
            if self.colors[v] == self.WHITE:
                self.depth += 1
                self.dfs(v)
                self.depth -= 1

        self.colors[u] = self.BLACK


tree = Tree(adj)
tree.dfs(0)

ev = [i for i, e in enumerate(tree.depths) if e % 2 == 0]
od = [i for i, e in enumerate(tree.depths) if e % 2]

l_ev = len(ev)
l_od = len(od)

mod0 = [e for e in range(1, n + 1) if e % 3 == 0]
mod1 = [e for e in range(1, n + 1) if e % 3 == 1]
mod2 = [e for e in range(1, n + 1) if e % 3 == 2]

ans = [0] * n


def f(li1, li2):
    while li1 and li2:
        i = li1.pop()
        num = li2.pop()
        ans[i] = num


if l_ev > n / 3 and l_od > n / 3:
    f(ev, mod1)
    f(od, mod2)
    f(ev, mod0)
    f(od, mod0)

elif l_ev <= n / 3:
    f(ev, mod0)
    f(od, mod0)
    f(od, mod1)
    f(od, mod2)

else:
    f(od, mod0)
    f(ev, mod0)
    f(ev, mod1)
    f(ev, mod2)

print(*ans)
"
1,"t1 = [""0"", ""1""] * 50000
t2 = [""1"", ""0""] * 50000

s = input()
sl = list(s)

a1 = 0
a2 = 0

for i in range(len(sl))
    if sl[i] != t1[i]
        a1 += 1
    if sl[i] != t2[i]
        a2 += 1

print(min(a1, a2))
"
1,"n = int(input())
h = [int(x) for x in input().split()]
h.reverse()

flag = True

for i in range(1, n):
    if h[i - 1] >= h[i]:
        continue
    elif h[i] == h[i - 1] + 1:
        h[i] -= 1
    else:
        flag = False
        break

pritn(""Yes"") if flag else pritn(""No"")
"
0,"n = int(input())

ans = 0
for i in range(1, int(n**0.5) + 1):
    if n % i == 0 and n // (i - 1) == n % (i - 1):
        ans += i - 1
    m = n // i - 1
    if m > 0 and n % i == 0 and n // m == n % m:
        ans += m
print(ans)
"
1,"import numpy as np

N = int()
A = np.fromstring(, dtype=np.int64, sep="" "")

result = 0
for bit in range(60):
    c = int((A & 1).sum())
    A >>= 1
    result = (result + c * (N - c) * (1 << bit)) % 1000000007
print(result)
"
0,"from heapq import heappush, heappop

N = int(input())
A = [int(input()) for i in range(N)]
hq = []
for i in range(N):
    heappush(hq, -A[i])
max1 = -heappop(hq)
max2 = -heappop(hq)
ans = [0] * N
for i in range(N):
    if A[i] == max1:
        ans[i] = max2
    else:
        ans[i] = max1
print(*ans, sep=""\n"")
"
1,"a, b, k = map(int, input().split())

common_factors = []
for i in range(1, a + 1)
    if a % i == 0 and b % i == 0
        common_factors.append(i)
print(common_factors[-k])
"
0,"N = int(input())
if N == 1:
    print(""Hello World"")
else:
    A = int(input())
    B = int(input())
    print(A + B)
"
0,"#!/usr/bin/env python3

a = int(input())
a, b = map(int, input().split())
a = list(str(input()))
"
1,"num = 
x = [int(i) for i in num]
for i in range(len(x)):
    if x[i] == 1:
        x[i] = ""9""
    else:
        x[i] = ""1""
mojiretu = "","".join(x)
print(int(mojiretu))
"
1,"H, N = map(int, .split())
attacks = list(map(int, .split()))
if sum(attacks) >= H:
    print(""Yes"")
else:
    print(""No"")
"
1,"N = int(input())
A = list(map(int, input().split()))

import numpy as np

A = np.array(A)
print("" "".join([str(i + 1) for i in A.argsort()]))

print(unknown_var)"
0,"N, K = map(int, input().split())
P = list(map(int, input().split()))
C = list(map(int, input().split()))

P = [None] + P
C = [None] + C

all_max = C[1]
for st in range(1, N + 1):
    scores = []
    visit = set()
    p = st

    while p not in visit and len(visit) < K:
        next_p = P[p]
        scores.append(C[next_p])
        visit.add(p)
        p = next_p

    num_elem = len(scores)
    all_sum = sum(scores)

    q, r = divmod(K, num_elem)

    max_ = scores[0]
    temp = scores[0]

    max_r = scores[0]
    temp_r = scores[0]
    for x in range(1, num_elem):
        if x < r:
            temp_r += scores[x]
            max_r = max(max_r, temp_r)

        temp += scores[x]
        max_ = max(max_, temp)

    temp_max = scores[0]
    if all_sum > 0 and q > 0:
        if r > 0:
            temp_max = max(all_sum * (q - 1) + max_, all_sum * q + max_r)
        else:
            temp_max = all_sum * (q - 1) + max_
    else:
        temp_max = max_

    all_max = max(all_max, temp_max)


print(all_max)
"
0,"# dp[i日目][i-1日目にどれを選んだか] = i日目までの最大の幸福度
import sys

sys.setrecursionlimit(10**8)

n = int(input())
a, b, c = [0 for _ in range(n)], [0 for _ in range(n)], [0 for _ in range(n)]
for i in range(n):
    a[i], b[i], c[i] = map(int, input().split())

dp = [[-1 for _ in range(3)] for _ in range(n + 1)]
for i in range(3):
    dp[0][i] = 0


def rec(i, choice):
    if dp[i][choice] > 0:
        return dp[i][choice]
    if i == n:
        return 0
    ret = 0  # ループじゃなくてifでやってるのでそれぞれ確実に大きい値が入る（ので更新する必要がない）
    if choice == 0:
        ret = a[i] + max(rec(i + 1, 1), rec(i + 1, 2))
    elif choice == 1:
        ret = b[i] + max(rec(i + 1, 0), rec(i + 1, 2))
    elif choice == 2:
        ret = c[i] + max(rec(i + 1, 0), rec(i + 1, 1))
    dp[i][choice] = ret
    return ret


print(max(rec(0, 0), rec(0, 1), rec(0, 2)))
"
0,"import sys
from itertools import permutations
from math import factorial

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10**9)
INF = 1 << 60


def distance2(x1, y1, x2, y2):
    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5


def main():
    N = int(readline())
    C = [tuple(map(int, readline().split())) for _ in range(N)]

    dist = [[0] * N for _ in range(N)]
    for i in range(N):
        for j in range(i + 1, N):
            dist[i][j] = dist[j][i] = distance2(C[i][0], C[i][1], C[j][0], C[j][1])

    ans = 0
    for perm in permutations(range(N)):
        for i in range(N - 1):
            ans += dist[perm[i]][perm[i + 1]]

    print(ans / factorial(N))
    return


if __name__ == ""__main__"":
    main()
"
1,"import sys
from io import StringIO
import unittest


def resolve():
    N, K = [int(i) for i in input().split()]
    H = sorted([int(i) for i in input().split()])
    if N <= K:
        H = [0]
    else:
        # if K < (N - K):
        for i in range(K):
            H[len(H) - 1 - i] = 0
        # else:
        #     Hs = []
        #     for i in range(N - K):
        #         Hs.append(H[i])
        #     H = Hs
    pritn(sum(H))


class TestClass(unittest.TestCase):
    def assertIO(self, input, output):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def test_入力例_1(self):
        input = """"""3 1
4 1 5""""""
        output = """"""5""""""
        self.assertIO(input, output)

    def test_入力例_2(self):
        input = """"""8 9
7 9 3 2 3 8 4 6""""""
        output = """"""0""""""
        self.assertIO(input, output)

    def test_入力例_3(self):
        input = """"""3 0
1000000000 1000000000 1000000000""""""
        output = """"""3000000000""""""
        self.assertIO(input, output)


if __name__ == ""__main__"":
    # unittest.main()
    resolve()
"
1,"N = int()
S = 

W = [0] * N
W[-1] += S[-1] == "".""
for i in range(N - 2, -1, -1):
    W[i] = W[i + 1] + (S[i] == ""."")

B = [0] * N
B[0] += S[0] == ""#""
for i in range(1, N):
    B[i] = B[i - 1] + (S[i] == ""#"")

T = [w + b - 1 for w, b in zip(W, B)]
T = min(T)
print(min(T, W[0], B[-1]))
"
1,"a = list(map(int, .split()))
[print(*i) for i in a.sort()]
"
1,"#!/usr/bin/env python3
from itertools import product
import sys

sys.setrecursionlimit(200000)

H, W = map(int, input().split())
S = [input() for _ in range(H)]
color = [[None] * W for _ in range(H)]
memo = [[0, 0] for _ in range(H * W + 1)]
cnt = 1


def dfs(p, c):
    x, y = p
    color[x][y] = c
    memo[cnt][c] += 1
    for dx, dy in [[1, 0], [0, 1], [-1, 0], [0, -1]]:
        nx = x + dx
        ny = y + dy
        if (
            0 <= nx < H
            and 0 <= ny < W
            and color[nx][ny] is None
            and c != (S[nx][ny] == ""#"")
        ):
            dfs([nx, ny], not c)


for i, j in product(range(H), range(W)):
    if color[i][j] is None:
        dfs([i, j], S[i][j] == ""#"")
        cnt += 1

ans = 0
for i in range(H * W):
    ans += memo[i][0] * memo[i][1]
pritn(ans)
"
1,"list_input = [int(n) for n in input().split()]

N = list_input[0]
K = list_input[1]

while N > abs(N - K):
    if N >= K:
        N = N % K
    else:
        N = K - N
print(N)

print(unknown_var)"
0,"a = input()
print(a**3)
"
0,"def f(x):
    return (a * x) // b - a * (x // b)


a, b, n = map(int, input().split())

k = (n + 1) // b

x = max(k * b - 1, 0)
ans = f(x)
ans = max(ans, f(n))
print(ans)
"
1,"a, b, k = map(int, input().split())
m = 0
ans = []

if a < b
    m = b
    n = a
else
    m = a
    n = b

for i in range(1, n + 1)
    if m % i == 0 and n % i == 0
        ans.append(i)

if ans
    print(ans[-k])
else
    print(""1"")
"
1,"n = int(input())
s = map(int, input())

dp = tuple([0] * 1000 for _ in range(4))
dp[0][0] = 1
# dp[x][int(str)]:=x文字のstrは構成可能か？0/1

for x in s:
    for incomplete_key in range(100):
        dp[3][incomplete_key * 10 + x] |= dp[2][incomplete_key]
    for incomplete_key in range(10):
        dp[2][incomplete_key * 10 + x] |= dp[1][incomplete_key]
    dp[1][x] = 1

print(sum(dp[3]))

# dp

print(unknown_var)"
0,"def main():
    N, K = map(int, input().split())
    P = [(v + 1) / 2 for v in map(int, input().split())]

    ans = tmp = sum(P[0:K])
    for i in range(N - K):
        tmp = tmp - P[i] + P[i + K]
        ans = max(ans, tmp)

    print(ans)


if __name__ == ""__main__"":
    main()
"
1,"import random

S = input()
rand = random.randrange(0, len(S) - 2)
print(S[rand] + S[rand + 1] + S[rand + 2])

print(unknown_var)"
0,"x1, y1, x2, y2 = map(float, input().split())
print(""%.8f"" % (((x2 - x1) ** 2 + (y2 - y1) ** 2)) ** 0.5)
"
1,"import sys

sys.setrecursionlimit(110000)

d = {}


def calc_step_combination(num)
    if num == 0
        return 0
    if num == 1 or num == 2
        return 1
    if num in d
        return d[num]
    res = calc_step_combination(num - 1) + calc_step_combination(num - 2)
    d[num] = res
    return res


def sol(n, a_list)
    step_batch = []
    batch_start = 0
    for a in a_list
        step_batch.append(a - batch_start)
        batch_start = a + 1
    step_batch.append(n - batch_start + 1)

    result = 1
    for i, steps in enumerate(step_batch)
        result *= calc_step_combination(steps)
    print(result % 1000000007)


def main()
    n, m = map(int, input().split())
    a_list = []
    for i in range(0, m)
        a_list.append(int(input()))
    sol(n, a_list)


main()
"
0,"N = int(input())
A = [int(i) for i in input().split()]
dp = [0] * 10**7
ans = 0
for i in range(N):
    x = i + 1 - A[i]
    if x >= 0:
        ans += dp[x]
    if x < 10**7:
        dp[i + 1 + A[i]] += 1

print(ans)
"
0,"# -*- coding: utf-8 -*-

import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)

n, q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(n - 1)]
px = [list(map(int, input().split())) for _ in range(q)]

graph = [[] for _ in range(n + 1)]
for a, b in ab:
    graph[a].append(b)
    graph[b].append(a)

value = [0] * (n + 1)
for p, x in px:
    value[p] += x


def dfs(v, p, add):
    value[v] += add
    for x in graph[v]:
        if x == p:
            continue
        dfs(x, v, value[v])


dfs(1, 0, 0)

ans = value[1:]
print(*ans)
"
1,"from collections import Counter

N = input()
A_str = input().split()

if ""0"" in A_str:
    pritn(0)
    exit()

c = Counter(sorted(A_str))
res = 1
for i, v in c.items():
    res *= int(i) ** v

    if res > 10**18:
        res = -1
        break

pritn(res)
"
0,"N = int(input())
A = list(map(int, input().split()))
L, R, df = 0, N - 1, A[0] - A[N - 1]

while R - L > 1:
    if df < 0:
        L += (1,)
        df += A[L]
    else:
        R -= 1
        df -= A[R]
print(abs(df))
"
0,"p = int(input())


def div(a, b):
    n = len(a)
    m = len(b)
    res = [0] * (n - m + 1)
    tmp = pow(b[-1], p - 2, p)
    for i in range(n - m, -1, -1):
        t = a[i + m - 1] * tmp % p
        res[i] = t
        for j in range(m):
            a[i + j] = (a[i + j] - t * b[j]) % p
    return res


a = list(map(int, input().split()))
ans = [0] * p
f = [0] * (p + 1)
f[0] = 1
for i in range(p):
    for j in range(p, 0, -1):
        f[j] += f[j - 1]
        f[j - 1] = -f[j - 1] * i
        f[j] %= p
for i in range(p):
    if a[i] == 1:
        fm = div(f[:], [-i, 1])
        t = 1
        r = 0
        for v in fm:
            r += v * t
            t = t * i % p
        t = pow(r, p - 2, p)
        for j in range(len(fm)):
            ans[j] += fm[j] * t
for i in range(p):
    ans[i] %= p
print("" "".join(map(str, ans)))
"
1,"N = int(input())
A = [int(i) for i in input().split()]
dp = [0] * 10**7
ans = 0
for i in range(N):
    x = i + 1 - A[i]
    if x >= 0:
        ans += dp[x]
    if x < 10**7:
        dp[i + 1 + A[i]] += 1

pritn(ans)
"
1,"from fractions import gcd

a, b = map(int, input().split())
lcm = a * b // gcd(a, b)
pritn(lcm)
"
1,"R, G, B, N = map(int, input().split())

ans = 0
for i in range(N // R + 1):
    for j in range((N - i * R) // G + 1):
        if (N - i * R - j * G) % B == 0:
            ans += 1
pritn(ans)
"
0,"# from time import perf_counter


def main():
    r, g, b, n = list(map(int, input().split()))
    count = 0
    x1, x2, x3 = sorted([r, g, b], reverse=True)
    # print(x1, x2, x3)
    for i in range(n // x1 + 1):
        for j in range((n - i) // x2 + 1):
            rest = n - (x1 * i) - (x2 * j)
            # print(f'{x1}*{i} + {x2}*{j} = {n - rest}')
            if rest == 0:
                # print(f'{x1}*{i} + {x2}*{j} + {x3}*0 = {n}')
                count += 1
            else:
                # print(f'{x1}*{i} + {x2}*{j} + {x3}*? = {n}')
                count += 1 if rest > 0 and rest % x3 == 0 else 0
            # for k in range((n - i - j) // x3 + 1):
            # print(f'{r}*{i} + {g}*{j} + {b}*{k} = {r*i+g*j+k+b*k}')
            #    if x1 * i + x2 * j + x3 * k == n:
            #        count += 1

    print(count)


if __name__ == ""__main__"":
    # s = perf_counter()
    main()
    # e = perf_counter()
    # print('process:', e - s)
"
1,"A, B, C, K = map(int, input().spliit())
if K <= A:
    print(K)

elif K <= A + B:
    print(A)

else:
    print(A - (K - (A + B)))

print(unknown_var)"
0,"n, k = map(int, input().split())
h = list(map(int, input().split()))
if n <= k:
    print(0)
    exit()
h.sort()
for i in range(k):
    h.pop()
print(sum(h))
"
1,"N, M = map(int, input().split())

A = []

for _ in range(M):
    A[int(input())] = True

step = [0] * (N + 1)

step[0] = 1

for s in range(1, N + 1):
    if A[s]:
        step[s] = 0
        continue
    if s == 1:
        step[s] = 1
        continue
    else:
        step[s] = step[s - 1] + step[s - 2]
        step[s] %= 1000000007

print(step[N])

print(unknown_var)"
0,"# -*- coding: utf-8 -*-

import sys

sys.setrecursionlimit(10**7)


class UnionFind:
    def __init__(self, n):
        # parent[x] < 0 means x is root and abs(parent[x]) == size[x]
        self.parent, self.depth = [-1] * (n + 1), [0] * (n + 1)

    def find(self, x):
        if self.parent[x] < 0:
            return x
        else:
            self.parent[x] = self.find(self.parent[x])
            return self.parent[x]

    def isSame(self, x, y):
        return self.find(x) == self.find(y)

    def unite(self, x, y):
        x, y = self.find(x), self.find(y)

        if self.depth[x] > self.depth[y]:
            self.parent[x] += self.parent[y]
            self.parent[y] = x
        else:
            self.parent[y] += self.parent[x]
            self.parent[x] = y
            if self.depth[x] == self.depth[y]:
                self.depth[y] += 1

    def count(self, x):
        return -self.parent[self.find(x)]


N, M = map(int, input().split())

AB = [tuple(map(int, input().split())) for _ in range(M)]
AB.reverse()

groups = UnionFind(N)
ans = [N * (N - 1) // 2]
for i in range(M):
    if groups.isSame(AB[i][0], AB[i][1]):
        ans.append(ans[-1])
    else:
        ans.append(ans[-1] - groups.count(AB[i][0]) * groups.count(AB[i][1]))
        groups.unite(AB[i][0], AB[i][1])

for i in range(M):
    print(ans[M - 1 - i])
"
0,"from typing import List


class DSU:
    def __init__(self, n: int) -> None:
        self._n = n
        self.parent_or_size = [-1] * n

    def merge(self, a: int, b: int) -> int:
        assert 0 <= a <= self._n
        assert 0 <= b <= self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self.parent_or_size[y] = x
        return x

    def same(self, a: int, b: int) -> bool:
        assert 0 <= a <= self._n
        assert 0 <= b <= self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a: int) -> int:
        assert 0 <= a < self._n
        stack = []
        while self.parent_or_size[a] >= 0:
            stack.append(a)
            a = self.parent_or_size[a]
        for i in stack:
            self.parent_or_size[i] = a
        return a

    def size(self, a: int) -> int:
        assert 0 <= a <= self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self) -> List[List[int]]:
        leader_buf = [self.leader(i) for i in range(self._n)]
        group_size = [0] * self._n
        for i in leader_buf:
            group_size[i] += 1
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        result = [i for i in result if i]
        return result


n, q = map(int, input().split())
dsu = DSU(n)

for _ in range(q):
    t, u, v = map(int, input().split())
    if t == 0:
        dsu.merge(u, v)
    else:
        print(1 if dsu.same(u, v) else 0)
"
1,"n, k = map(int, input().split())
td = sorted(
    [list(map(int, input().split())) for i in range(n)],
    reverse=True,
    key=lambda x: x[1],
)

type = set()
L = []
Sum = 0
for x in td[:k]:
    Sum += x[1]
    if x[0] not in type:
        type.add(x[0])
    else:
        L.append(x[1])

L = L[::-1]
type_cnt = len(type)
ans = Sum + type_cnt**2
for x in td[k:]:
    if len(L) == 0:
        break
    if x[0] not in type:
        type.add(x[0])
        type_cnt += 1
        Sum = Sum - L.pop(0) + x[1]
        ans = max(ans, Sum + type_cnt**2)
print(ans)

print(unknown_var)"
1,"W = [""SUN"", ""MON"", ""TUE"", ""WED"", ""THU"", ""FRI"", ""SAT""]
S = input()
pritn(len(W) - W.index(S))
"
1,"A = int(input())
B = int(input())
c = A + B
d = A - B
e = A * B
f = [c, d, e]
maxvalue = c
for i in range(len(f)):
    if f[i] > maxvalue:
        maxvalue = f[i]
print(maxvalue)

print(unknown_var)"
1,"import heapq
from sys import exit

N, M = map(int, .split())
A = list(map(int, .split()))
BC = sorted(
    [tuple(map(int, .split())) for _ in range(M)],
    key=lambda x: x[1],
    reverse=True,
)
heapq.heapify(A)

ans = sum(A)
for b, c in BC:
    for _ in range(b):
        if len(A) == 0:
            print(ans)
            exit()
        a = heapq.heappop(A)
        if a < c:
            ans += c - a
        else:
            print(ans)
            exit()
print(ans)
"
1,"import math

N, X, T = map(int(input().split()))

print(T * math.ceil(N / X))

print(unknown_var)"
0,"n, k = map(int, input().split())
s = input()
s[k - 1] = s[k - 1].lower()
print(s)
"
0,"import sys
import numpy as np
from numba import njit

read = sys.stdin.read
readline = sys.stdin.buffer.readline
sys.setrecursionlimit(10**8)
INF = float(""inf"")
MOD = 10**9 + 7


@njit(""i8[:](i8,i8,i8[:])"", cache=True)
def func(n, k, A):
    for _ in range(k):
        B = np.zeros(n + 1, np.int64)
        for i, a in enumerate(A):
            B[max(0, i - a)] += 1
            B[min(i + a + 1, n)] -= 1
        A = B.cumsum()[:-1]
        if np.all(A == n):
            break
    return A


def main():
    N, K = map(int, readline().split())
    A = np.array(readline().split(), np.int64)
    ans = func(N, K, A)
    print(*ans)


if __name__ == ""__main__"":
    main()
"
0,"# coding:utf-8
n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

ans = 0

for i in range(n):
    if a[i] >= b[i]:
        ans += b[i]
    else:
        ans += a[i]
        b[i] -= a[i]
        if a[i + 1] >= b[i]:
            a[i + 1] -= b[i]
            ans += b[i]
        else:
            ans += a[i + 1]
            a[i + 1] = 0


print(ans)
"
0,"#!/usr/bin/env python3
def main():
    import sys

    input = sys.stdin.readline

    A, B, N = map(int, input().split())

    x = min(B - 1, N)
    print((A * x) // B - A * (x // B))


if __name__ == ""__main__"":
    main()
"
1,"x = input()
if x >= 30
    print(""Yes"")
else
    print(""No"")
"
0,"s = input()
ans = 0
li = [""A"", ""C"", ""G"", ""T""]
count = 0
for i in s:
    if i in li:
        count += 1
    else:
        if count > ans:
            ans = count
        count = 0
if count == len(ans):
    print(count)
else:
    print(ans)
"
1,"import sys

N = int(sys.stdin.readline())
print(int((N - 1) * N // 2))
"
1,"N, K = map(int, .split())
h = list(map(int, .split()))
inf = 10**9
dp = [inf] * N
dp[0] = 0


def chmin(num: int, sbn: int):
    dp[num + sbn] = min((dp[num + sbn], dp[num] + abs(h[i + sbn] - h[num])))


for i in range(N):
    for sbn in range(K):
        try:
            chmin(dp, i, sbn + 1)
        except IndexError:
            break
print(dp[-1])
"
0,"#!/usr/bin/env python3
n = int(input())
h = list(map(int, input().split()))
ans = 0
tmp = 0
for i in range(n - 1):
    if h[i] < h[i + 1]:
        tmp = 0
    else:
        tmp += 1
    ans = max(ans, tmp)
print(ans)
"
0,"N = int(input())
print(N * (N - 1) // 2)
"
0,"L, R = map(int, input().split())
min_mod = 10**9
for i in range(L, min(L + 2019, R + 1)):
    for j in range(i + 1, min(L + 2019, R + 1)):
        min_mod = min(min_mod, (i * j) % 2019)
print(min_mod)
"
0,"a, b, k = map(int, input().split())

a_ans = max(a - k, 0)
b_ans = max(b - max(k - a, 0), 0)
print(a_ans, b_ans)
"
1,"import sys
import collections


def solve():
    readline = sys.stdin.buffer.readline
    h, w = list(map(int, readline().split()))
    a = [[True] * w for _ in range(h)]
    ql = []
    ql = collections.deque(ql)
    for i in range(h):
        s = str(readline().rstrip().decode(""utf-8""))
        for j in range(w):
            if s[j] == ""#"":
                a[i][j] = False
                ql.append([0, i, j])

    mt = 0
    while True:
        if len(ql) != 0:
            cost, x, y = ql.popleft()
            mt = max(mt, cost)
            for xv, yv in [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]]:
                if 0 <= xv < h and 0 <= yv < w:
                    if a[xv][yv]:
                        ql.append([cost + 1, xv, yv])
                        a[xv][yv] = False
        else:
            break
    pritn(mt)


if __name__ == ""__main__"":
    solve()
"
1,"import numpy as np

K, X = map(int, .split())

tmp = X + K
tmp2 = X - K + 1

ans = np.arange(tmp2, tmp)
for i, v in enumerate(ans):
    print("" {}"".format(v), end="""") if i > 0 else print(""{}"".format(v), end="""")
print("""")
"
